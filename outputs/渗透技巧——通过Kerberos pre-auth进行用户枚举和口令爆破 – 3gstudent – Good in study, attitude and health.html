<article class="post">
  <h1>渗透技巧——通过Kerberos pre-auth进行用户枚举和口令爆破</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在之前的文章《渗透基础——通过LDAP协议暴力破解域用户的口令》介绍了通过LDAP协议暴力破解域用户口令的方法，最大的特点是会产生日志(4625 - An account failed to log on)</p>

<p>而使用<a href="https://github.com/ropnop/kerbrute">kerbrute</a>通过Kerberos pre-auth进行暴力破解时不会产生日志(4625 - An account failed to log on)，于是我对<a href="https://github.com/ropnop/kerbrute">kerbrute</a>做了进一步的研究，使用python实现了相同的功能，并且添加支持TCP协议和NTLM hash的验证。本文将要记录自己的研究过程和学习心得。</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<ul>
  <li>kerbrute的介绍</li>
  <li>kerbrute的原理</li>
  <li>使用python实现kerbrute的细节</li>
  <li>开源代码pyKerbrute</li>
  <li>Kerberos pre-auth bruteforcing的检测</li>
</ul>

<h2 id="0x02-kerbrute的适用场景">0x02 kerbrute的适用场景</h2>
<hr>

<p>适用场景:从域外对域用户进行用户枚举和口令暴力破解</p>

<p>由于没有域用户的口令，所以无法通过LDAP协议枚举出所有域用户，而且使用LDAP协议进行暴力破解时会产生日志(4625 - An account failed to log on)</p>

<p>使用kerbrute有如下优点：</p>

<ul>
  <li>使用Kerberos pre-auth bruteforcing的速度更快</li>
  <li>不会产生日志(4625 - An account failed to log on)</li>
</ul>

<p><strong>注：</strong></p>

<p>Kerberos pre-auth对应的端口默认为88</p>

<h2 id="0x03-kerbrute测试">0x03 kerbrute测试</h2>
<hr>

<p>测试环境如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-12-12/3-1.png" alt="Alt text"></p>

<p>kerbrute使用Go语言开发，github提供了编译好的文件，地址如下：</p>

<p>https://github.com/ropnop/kerbrute/releases</p>

<p>kerbrute主要包括以下两个功能：</p>

<h3 id="1用户枚举">1.用户枚举</h3>

<p>用来验证用户是否存在，命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kerbrute_windows_amd64.exe userenum --dc 192.168.1.1 -d test.com user.txt
</code></pre></div></div>

<p>测试结果如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2020-1-1/2-1.png" alt="Alt text"></p>

<p>适用场景:</p>

<p>不掌握域用户的口令，所以无法通过LDAP协议枚举出所有域用户，可以使用这种方式来验证用户是否存在</p>

<h3 id="2口令验证">2.口令验证</h3>

<p>在确定了用户存在以后，可以使用这个功能来验证口令是否正确，命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kerbrute_windows_amd64.exe passwordspray -d test.com user.txt DomainUser123!
</code></pre></div></div>

<p>测试结果如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2020-1-1/2-2.png" alt="Alt text"></p>

<p>如果登录成功，会产生日志(4768 - A Kerberos authentication ticket (TGT) was requested)，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2020-1-1/2-3.png" alt="Alt text"></p>

<h2 id="0x04-使用python实现kerbrute的细节">0x04 使用python实现kerbrute的细节</h2>
<hr>

<p>我的想法是实现kerbrute的两个主要功能：用户枚举和口令验证</p>

<p>通过python实现kerberos协议的部分我参考了<a href="https://github.com/mubix/pykek">pykek</a></p>

<p>接下来通过抓包的方式获得kerbrute的数据包内容，然后通过python构造相同的数据包</p>

<p>kerbrute使用UDP协议实现Kerberos pre-auth，用来对明文口令进行验证</p>

<p>我在研究的过程中，发现通过TCP协议也能实现相同的功能，而且能够对NTLM hash进行验证</p>

<h3 id="1使用python实现用户枚举">1.使用python实现用户枚举</h3>

<p>使用wireshark抓取kerbrute用户枚举功能产生的数据包</p>

<p>使用UDP协议，用户枚举时发送的数据包内容如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2020-1-1/3-1.png" alt="Alt text"></p>

<p>如果用户存在，返回的数据包内容如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2020-1-1/3-2.png" alt="Alt text"></p>

<p>判断标志：<code class="language-plaintext highlighter-rouge">error-code: eRR-PREAUTH-REQUIRED (25)</code></p>

<p>如果用户不存在，返回的数据包内容如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2020-1-1/3-3.png" alt="Alt text"></p>

<p>判断标志：<code class="language-plaintext highlighter-rouge">error-code: eRR-C-PRINCIPAL-UNKNOWN (6)</code></p>

<p>接下来就是使用python实现发送UDP数据，发送的内容同kerbrute用户枚举时的数据包相同；接收返回内容，通过标志位来判断用户是否存在</p>

<p>通过TCP协议也能实现相同的功能，只是数据包格式不一样</p>

<p>TCP数据包前面要加一段字符串<code class="language-plaintext highlighter-rouge">pack('&gt;I', len(data))</code></p>

<p>具体的代码如下：</p>

<p>TCP：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def send_req_tcp(req, kdc, port=88):
    data = encode(req)
    data = pack('&gt;I', len(data)) + data
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((kdc, port))
    sock.send(data)
    return sock

def recv_rep_tcp(sock):
    data = ''
    datalen = None
    while True:
        rep = sock.recv(8192)
        if not rep:
            sock.close()
            raise IOError('Connection error')
        data += rep
        if len(rep) &gt;= 4:
            if datalen is None:
                datalen = unpack('&gt;I', rep[:4])[0]
            if len(data) &gt;= 4 + datalen:
                sock.close()
                return data[4:4 + datalen]
</code></pre></div></div>

<p>UDP：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def send_req_udp(req, kdc, port=88):
    data = encode(req)
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.connect((kdc, port))
    sock.send(data)
    return sock

def recv_rep_udp(sock):
    data = ''
    datalen = None
    while True:
        rep = sock.recv(8192)
        if not rep:
            sock.close()
            raise IOError('Connection error')
        data += rep
        if len(rep) &gt;= 4:
            sock.close()
            return data
</code></pre></div></div>

<h3 id="2使用python实现口令验证">2.使用python实现口令验证</h3>

<p>使用wireshark抓取kerbrute口令验证功能产生的数据包</p>

<p>使用UDP协议，口令验证时发送的数据包内容如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2020-1-1/3-4.png" alt="Alt text"></p>

<p>相比用户枚举，在口令验证时多了一部分内容(padata)</p>

<p>具体差异如下：</p>

<p>用户枚举发送的数据包格式如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2020-1-1/3-5.png" alt="Alt text"></p>

<p>口令验证发送的数据包格式如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2020-1-1/3-6.png" alt="Alt text"></p>

<p>所以在实现上需要添加padata段的内容</p>

<p>如果口令正确，返回的数据包内容如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2020-1-1/3-7.png" alt="Alt text"></p>

<p>如果口令错误，返回的数据包内容如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2020-1-1/3-8.png" alt="Alt text"></p>

<p>具体的数据包结构可以参考RFC文档，地址如下：</p>

<p>https://tools.ietf.org/html/rfc1510#page-50</p>

<p>计算padata-value需要先将明文口令转换成NTLM hash再进行计算</p>

<p>所以说这个位置不仅可以使用明文口令，也可以使用NTLM hash</p>

<p>部分加密的python代码如下：</p>

<p>使用明文口令：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>clearpassword = DomainUser123!
user_key = (RC4_HMAC, ntlm_hash(clearpassword).digest())
pa_ts = build_pa_enc_timestamp(current_time, user_key)
as_req['padata'][0]['padata-value'] = encode(pa_ts)
</code></pre></div></div>

<p>使用NTLM hash：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ntlmhash = e00045bd566a1b74386f5c1e3612921b
user_key = (RC4_HMAC, ntlmhash.decode('hex'))
pa_ts = build_pa_enc_timestamp(current_time, user_key)
as_req['padata'][0]['padata-value'] = encode(pa_ts)
</code></pre></div></div>

<h2 id="0x05-开源代码pykerbrute">0x05 开源代码pyKerbrute</h2>
<hr>

<p>完整的实现代码已上传至github，地址如下：</p>

<p>https://github.com/3gstudent/pyKerbrute</p>

<p>pyKerbrute是对kerbrute的python实现，相比于kerbrute，多了以下两个功能：</p>

<ul>
  <li>增加对TCP协议的支持</li>
  <li>增加对NTLM hash的验证</li>
</ul>

<p>pyKerbrute分为用户枚举和口令验证两个功能</p>

<h3 id="1enumaduserpy">1.EnumADUser.py</h3>

<p>用户枚举功能，支持TCP和UDP协议</p>

<p>命令实例：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>EnumADUser.py 192.168.1.1 test.com user.txt tcp
</code></pre></div></div>

<p>结果输出如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2020-1-1/4-1.png" alt="Alt text"></p>

<h3 id="2adpwdspraypy">2.ADPwdSpray.py</h3>

<p>口令验证功能，支持TCP和UDP协议，支持明文口令和NTLM hash</p>

<p>命令实例1：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ADPwdSpray.py 192.168.1.1 test.com user.txt clearpassword DomainUser123! tcp
</code></pre></div></div>

<p>结果输出如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2020-1-1/4-2.png" alt="Alt text"></p>

<p>命令实例2：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ADPwdSpray.py 192.168.1.1 test.com user.txt ntlmhash e00045bd566a1b74386f5c1e3612921b udp
</code></pre></div></div>

<p>结果输出如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2020-1-1/4-3.png" alt="Alt text"></p>

<h2 id="0x06-kerberos-pre-auth-bruteforcing的检测">0x06 Kerberos pre-auth bruteforcing的检测</h2>
<hr>

<p>Kerbrute使用Kerberos pre-auth协议，不会产生日志(4625 - An account failed to log on)</p>

<p>但是会产生以下日志：</p>

<ul>
  <li>口令验证成功时产生日志(4768 - A Kerberos authentication ticket (TGT) was requested)</li>
  <li>口令验证失败时产生日志(4771 - Kerberos pre-authentication failed)</li>
</ul>

<h2 id="0x07-小结">0x07 小结</h2>
<hr>

<p>本文对kerbrute进行了测试分析，使用python实现了相同的功能，并且添加支持TCP协议和NTLM hash的验证，开源代码，介绍脚本编写的细节，给出Kerberos pre-auth bruteforcing的检测方法。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on January  1, 2020
  </div>

  
</article>